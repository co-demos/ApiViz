(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var inserted = exports.cache = {}

function noop () {}

exports.insert = function (css) {
  if (inserted[css]) return noop
  inserted[css] = true

  var elem = document.createElement('style')
  elem.setAttribute('type', 'text/css')

  if ('textContent' in elem) {
    elem.textContent = css
  } else {
    elem.styleSheet.cssText = css
  }

  document.getElementsByTagName('head')[0].appendChild(elem)
  return function () {
    document.getElementsByTagName('head')[0].removeChild(elem)
    inserted[css] = false
  }
}

},{}],2:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":4}],3:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var buildURL = require('./../helpers/buildURL');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || require('./../helpers/btoa');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = require('./../helpers/cookies');

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

}).call(this,require('_process'))

},{"../core/createError":10,"./../core/settle":13,"./../helpers/btoa":17,"./../helpers/buildURL":18,"./../helpers/cookies":20,"./../helpers/isURLSameOrigin":22,"./../helpers/parseHeaders":24,"./../utils":26,"_process":31}],4:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":5,"./cancel/CancelToken":6,"./cancel/isCancel":7,"./core/Axios":8,"./defaults":15,"./helpers/bind":16,"./helpers/spread":25,"./utils":26}],5:[function(require,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],6:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":5}],7:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],8:[function(require,module,exports){
'use strict';

var defaults = require('./../defaults');
var utils = require('./../utils');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"./../defaults":15,"./../utils":26,"./InterceptorManager":9,"./dispatchRequest":11}],9:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":26}],10:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":12}],11:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');
var isAbsoluteURL = require('./../helpers/isAbsoluteURL');
var combineURLs = require('./../helpers/combineURLs');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":7,"../defaults":15,"./../helpers/combineURLs":19,"./../helpers/isAbsoluteURL":21,"./../utils":26,"./transformData":14}],12:[function(require,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};

},{}],13:[function(require,module,exports){
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":10}],14:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

},{"./../utils":26}],15:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this,require('_process'))

},{"./adapters/http":3,"./adapters/xhr":3,"./helpers/normalizeHeaderName":23,"./utils":26,"_process":31}],16:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],17:[function(require,module,exports){
'use strict';

// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;

},{}],18:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":26}],19:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],20:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);

},{"./../utils":26}],21:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],22:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);

},{"./../utils":26}],23:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":26}],24:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":26}],25:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],26:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');
var isBuffer = require('is-buffer');

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

},{"./helpers/bind":16,"is-buffer":28}],27:[function(require,module,exports){
// https://d3js.org/d3-dsv/ Version 1.0.7. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

var dsv = function(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns;
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? ""
        : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\""
        : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
};

var csv = dsv(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;

var tsv = dsv("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;

exports.dsvFormat = dsv;
exports.csvParse = csvParse;
exports.csvParseRows = csvParseRows;
exports.csvFormat = csvFormat;
exports.csvFormatRows = csvFormatRows;
exports.tsvParse = tsvParse;
exports.tsvParseRows = tsvParseRows;
exports.tsvFormat = tsvFormat;
exports.tsvFormatRows = tsvFormatRows;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],28:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],29:[function(require,module,exports){
/*
 * Leaflet.markercluster 1.4.1+master.94f9815,
 * Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.
 * https://github.com/Leaflet/Leaflet.markercluster
 * (c) 2012-2017, Dave Leaver, smartrak
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.Leaflet = global.Leaflet || {}, global.Leaflet.markercluster = global.Leaflet.markercluster || {})));
}(this, (function (exports) { 'use strict';

/*
 * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within
 */

var MarkerClusterGroup = L.MarkerClusterGroup = L.FeatureGroup.extend({

	options: {
		maxClusterRadius: 80, //A cluster will cover at most this many pixels from its center
		iconCreateFunction: null,
		clusterPane: L.Marker.prototype.options.pane,

		spiderfyOnMaxZoom: true,
		showCoverageOnHover: true,
		zoomToBoundsOnClick: true,
		singleMarkerMode: false,

		disableClusteringAtZoom: null,

		// Setting this to false prevents the removal of any clusters outside of the viewpoint, which
		// is the default behaviour for performance reasons.
		removeOutsideVisibleBounds: true,

		// Set to false to disable all animations (zoom and spiderfy).
		// If false, option animateAddingMarkers below has no effect.
		// If L.DomUtil.TRANSITION is falsy, this option has no effect.
		animate: true,

		//Whether to animate adding markers after adding the MarkerClusterGroup to the map
		// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
		animateAddingMarkers: false,

		//Increase to increase the distance away that spiderfied markers appear from the center
		spiderfyDistanceMultiplier: 1,

		// Make it possible to specify a polyline options on a spider leg
		spiderLegPolylineOptions: { weight: 1.5, color: '#222', opacity: 0.5 },

		// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts
		chunkedLoading: false,
		chunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)
		chunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser
		chunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)

		//Options to pass to the L.Polygon constructor
		polygonOptions: {}
	},

	initialize: function (options) {
		L.Util.setOptions(this, options);
		if (!this.options.iconCreateFunction) {
			this.options.iconCreateFunction = this._defaultIconCreateFunction;
		}

		this._featureGroup = L.featureGroup();
		this._featureGroup.addEventParent(this);

		this._nonPointGroup = L.featureGroup();
		this._nonPointGroup.addEventParent(this);

		this._inZoomAnimation = 0;
		this._needsClustering = [];
		this._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of
		//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move
		this._currentShownBounds = null;

		this._queue = [];

		this._childMarkerEventHandlers = {
			'dragstart': this._childMarkerDragStart,
			'move': this._childMarkerMoved,
			'dragend': this._childMarkerDragEnd,
		};

		// Hook the appropriate animation methods.
		var animate = L.DomUtil.TRANSITION && this.options.animate;
		L.extend(this, animate ? this._withAnimation : this._noAnimation);
		// Remember which MarkerCluster class to instantiate (animated or not).
		this._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;
	},

	addLayer: function (layer) {

		if (layer instanceof L.LayerGroup) {
			return this.addLayers([layer]);
		}

		//Don't cluster non point data
		if (!layer.getLatLng) {
			this._nonPointGroup.addLayer(layer);
			this.fire('layeradd', { layer: layer });
			return this;
		}

		if (!this._map) {
			this._needsClustering.push(layer);
			this.fire('layeradd', { layer: layer });
			return this;
		}

		if (this.hasLayer(layer)) {
			return this;
		}


		//If we have already clustered we'll need to add this one to a cluster

		if (this._unspiderfy) {
			this._unspiderfy();
		}

		this._addLayer(layer, this._maxZoom);
		this.fire('layeradd', { layer: layer });

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		//Work out what is visible
		var visibleLayer = layer,
		    currentZoom = this._zoom;
		if (layer.__parent) {
			while (visibleLayer.__parent._zoom >= currentZoom) {
				visibleLayer = visibleLayer.__parent;
			}
		}

		if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {
			if (this.options.animateAddingMarkers) {
				this._animationAddLayer(layer, visibleLayer);
			} else {
				this._animationAddLayerNonAnimated(layer, visibleLayer);
			}
		}
		return this;
	},

	removeLayer: function (layer) {

		if (layer instanceof L.LayerGroup) {
			return this.removeLayers([layer]);
		}

		//Non point layers
		if (!layer.getLatLng) {
			this._nonPointGroup.removeLayer(layer);
			this.fire('layerremove', { layer: layer });
			return this;
		}

		if (!this._map) {
			if (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {
				this._needsRemoving.push({ layer: layer, latlng: layer._latlng });
			}
			this.fire('layerremove', { layer: layer });
			return this;
		}

		if (!layer.__parent) {
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();
			this._unspiderfyLayer(layer);
		}

		//Remove the marker from clusters
		this._removeLayer(layer, true);
		this.fire('layerremove', { layer: layer });

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		layer.off(this._childMarkerEventHandlers, this);

		if (this._featureGroup.hasLayer(layer)) {
			this._featureGroup.removeLayer(layer);
			if (layer.clusterShow) {
				layer.clusterShow();
			}
		}

		return this;
	},

	//Takes an array of markers and adds them in bulk
	addLayers: function (layersArray, skipLayerAddEvent) {
		if (!L.Util.isArray(layersArray)) {
			return this.addLayer(layersArray);
		}

		var fg = this._featureGroup,
		    npg = this._nonPointGroup,
		    chunked = this.options.chunkedLoading,
		    chunkInterval = this.options.chunkInterval,
		    chunkProgress = this.options.chunkProgress,
		    l = layersArray.length,
		    offset = 0,
		    originalArray = true,
		    m;

		if (this._map) {
			var started = (new Date()).getTime();
			var process = L.bind(function () {
				var start = (new Date()).getTime();
				for (; offset < l; offset++) {
					if (chunked && offset % 200 === 0) {
						// every couple hundred markers, instrument the time elapsed since processing started:
						var elapsed = (new Date()).getTime() - start;
						if (elapsed > chunkInterval) {
							break; // been working too hard, time to take a break :-)
						}
					}

					m = layersArray[offset];

					// Group of layers, append children to layersArray and skip.
					// Side effects:
					// - Total increases, so chunkProgress ratio jumps backward.
					// - Groups are not included in this group, only their non-group child layers (hasLayer).
					// Changing array length while looping does not affect performance in current browsers:
					// http://jsperf.com/for-loop-changing-length/6
					if (m instanceof L.LayerGroup) {
						if (originalArray) {
							layersArray = layersArray.slice();
							originalArray = false;
						}
						this._extractNonGroupLayers(m, layersArray);
						l = layersArray.length;
						continue;
					}

					//Not point data, can't be clustered
					if (!m.getLatLng) {
						npg.addLayer(m);
						if (!skipLayerAddEvent) {
							this.fire('layeradd', { layer: m });
						}
						continue;
					}

					if (this.hasLayer(m)) {
						continue;
					}

					this._addLayer(m, this._maxZoom);
					if (!skipLayerAddEvent) {
						this.fire('layeradd', { layer: m });
					}

					//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will
					if (m.__parent) {
						if (m.__parent.getChildCount() === 2) {
							var markers = m.__parent.getAllChildMarkers(),
							    otherMarker = markers[0] === m ? markers[1] : markers[0];
							fg.removeLayer(otherMarker);
						}
					}
				}

				if (chunkProgress) {
					// report progress and time elapsed:
					chunkProgress(offset, l, (new Date()).getTime() - started);
				}

				// Completed processing all markers.
				if (offset === l) {

					// Refresh bounds and weighted positions.
					this._topClusterLevel._recalculateBounds();

					this._refreshClustersIcons();

					this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
				} else {
					setTimeout(process, this.options.chunkDelay);
				}
			}, this);

			process();
		} else {
			var needsClustering = this._needsClustering;

			for (; offset < l; offset++) {
				m = layersArray[offset];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					if (originalArray) {
						layersArray = layersArray.slice();
						originalArray = false;
					}
					this._extractNonGroupLayers(m, layersArray);
					l = layersArray.length;
					continue;
				}

				//Not point data, can't be clustered
				if (!m.getLatLng) {
					npg.addLayer(m);
					continue;
				}

				if (this.hasLayer(m)) {
					continue;
				}

				needsClustering.push(m);
			}
		}
		return this;
	},

	//Takes an array of markers and removes them in bulk
	removeLayers: function (layersArray) {
		var i, m,
		    l = layersArray.length,
		    fg = this._featureGroup,
		    npg = this._nonPointGroup,
		    originalArray = true;

		if (!this._map) {
			for (i = 0; i < l; i++) {
				m = layersArray[i];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					if (originalArray) {
						layersArray = layersArray.slice();
						originalArray = false;
					}
					this._extractNonGroupLayers(m, layersArray);
					l = layersArray.length;
					continue;
				}

				this._arraySplice(this._needsClustering, m);
				npg.removeLayer(m);
				if (this.hasLayer(m)) {
					this._needsRemoving.push({ layer: m, latlng: m._latlng });
				}
				this.fire('layerremove', { layer: m });
			}
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();

			// Work on a copy of the array, so that next loop is not affected.
			var layersArray2 = layersArray.slice(),
			    l2 = l;
			for (i = 0; i < l2; i++) {
				m = layersArray2[i];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					this._extractNonGroupLayers(m, layersArray2);
					l2 = layersArray2.length;
					continue;
				}

				this._unspiderfyLayer(m);
			}
		}

		for (i = 0; i < l; i++) {
			m = layersArray[i];

			// Group of layers, append children to layersArray and skip.
			if (m instanceof L.LayerGroup) {
				if (originalArray) {
					layersArray = layersArray.slice();
					originalArray = false;
				}
				this._extractNonGroupLayers(m, layersArray);
				l = layersArray.length;
				continue;
			}

			if (!m.__parent) {
				npg.removeLayer(m);
				this.fire('layerremove', { layer: m });
				continue;
			}

			this._removeLayer(m, true, true);
			this.fire('layerremove', { layer: m });

			if (fg.hasLayer(m)) {
				fg.removeLayer(m);
				if (m.clusterShow) {
					m.clusterShow();
				}
			}
		}

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		//Fix up the clusters and markers on the map
		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);

		return this;
	},

	//Removes all layers from the MarkerClusterGroup
	clearLayers: function () {
		//Need our own special implementation as the LayerGroup one doesn't work for us

		//If we aren't on the map (yet), blow away the markers we know of
		if (!this._map) {
			this._needsClustering = [];
			this._needsRemoving = [];
			delete this._gridClusters;
			delete this._gridUnclustered;
		}

		if (this._noanimationUnspiderfy) {
			this._noanimationUnspiderfy();
		}

		//Remove all the visible layers
		this._featureGroup.clearLayers();
		this._nonPointGroup.clearLayers();

		this.eachLayer(function (marker) {
			marker.off(this._childMarkerEventHandlers, this);
			delete marker.__parent;
		}, this);

		if (this._map) {
			//Reset _topClusterLevel and the DistanceGrids
			this._generateInitialClusters();
		}

		return this;
	},

	//Override FeatureGroup.getBounds as it doesn't work
	getBounds: function () {
		var bounds = new L.LatLngBounds();

		if (this._topClusterLevel) {
			bounds.extend(this._topClusterLevel._bounds);
		}

		for (var i = this._needsClustering.length - 1; i >= 0; i--) {
			bounds.extend(this._needsClustering[i].getLatLng());
		}

		bounds.extend(this._nonPointGroup.getBounds());

		return bounds;
	},

	//Overrides LayerGroup.eachLayer
	eachLayer: function (method, context) {
		var markers = this._needsClustering.slice(),
			needsRemoving = this._needsRemoving,
			thisNeedsRemoving, i, j;

		if (this._topClusterLevel) {
			this._topClusterLevel.getAllChildMarkers(markers);
		}

		for (i = markers.length - 1; i >= 0; i--) {
			thisNeedsRemoving = true;

			for (j = needsRemoving.length - 1; j >= 0; j--) {
				if (needsRemoving[j].layer === markers[i]) {
					thisNeedsRemoving = false;
					break;
				}
			}

			if (thisNeedsRemoving) {
				method.call(context, markers[i]);
			}
		}

		this._nonPointGroup.eachLayer(method, context);
	},

	//Overrides LayerGroup.getLayers
	getLayers: function () {
		var layers = [];
		this.eachLayer(function (l) {
			layers.push(l);
		});
		return layers;
	},

	//Overrides LayerGroup.getLayer, WARNING: Really bad performance
	getLayer: function (id) {
		var result = null;

		id = parseInt(id, 10);

		this.eachLayer(function (l) {
			if (L.stamp(l) === id) {
				result = l;
			}
		});

		return result;
	},

	//Returns true if the given layer is in this MarkerClusterGroup
	hasLayer: function (layer) {
		if (!layer) {
			return false;
		}

		var i, anArray = this._needsClustering;

		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === layer) {
				return true;
			}
		}

		anArray = this._needsRemoving;
		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i].layer === layer) {
				return false;
			}
		}

		return !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);
	},

	//Zoom down to show the given layer (spiderfying if necessary) then calls the callback
	zoomToShowLayer: function (layer, callback) {

		if (typeof callback !== 'function') {
			callback = function () {};
		}

		var showMarker = function () {
			if ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {
				this._map.off('moveend', showMarker, this);
				this.off('animationend', showMarker, this);

				if (layer._icon) {
					callback();
				} else if (layer.__parent._icon) {
					this.once('spiderfied', callback, this);
					layer.__parent.spiderfy();
				}
			}
		};

		if (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {
			//Layer is visible ond on screen, immediate return
			callback();
		} else if (layer.__parent._zoom < Math.round(this._map._zoom)) {
			//Layer should be visible at this zoom level. It must not be on screen so just pan over to it
			this._map.on('moveend', showMarker, this);
			this._map.panTo(layer.getLatLng());
		} else {
			this._map.on('moveend', showMarker, this);
			this.on('animationend', showMarker, this);
			layer.__parent.zoomToBounds();
		}
	},

	//Overrides FeatureGroup.onAdd
	onAdd: function (map) {
		this._map = map;
		var i, l, layer;

		if (!isFinite(this._map.getMaxZoom())) {
			throw "Map has no maxZoom specified";
		}

		this._featureGroup.addTo(map);
		this._nonPointGroup.addTo(map);

		if (!this._gridClusters) {
			this._generateInitialClusters();
		}

		this._maxLat = map.options.crs.projection.MAX_LATITUDE;

		//Restore all the positions as they are in the MCG before removing them
		for (i = 0, l = this._needsRemoving.length; i < l; i++) {
			layer = this._needsRemoving[i];
			layer.newlatlng = layer.layer._latlng;
			layer.layer._latlng = layer.latlng;
		}
		//Remove them, then restore their new positions
		for (i = 0, l = this._needsRemoving.length; i < l; i++) {
			layer = this._needsRemoving[i];
			this._removeLayer(layer.layer, true);
			layer.layer._latlng = layer.newlatlng;
		}
		this._needsRemoving = [];

		//Remember the current zoom level and bounds
		this._zoom = Math.round(this._map._zoom);
		this._currentShownBounds = this._getExpandedVisibleBounds();

		this._map.on('zoomend', this._zoomEnd, this);
		this._map.on('moveend', this._moveEnd, this);

		if (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnAdd();
		}

		this._bindEvents();

		//Actually add our markers to the map:
		l = this._needsClustering;
		this._needsClustering = [];
		this.addLayers(l, true);
	},

	//Overrides FeatureGroup.onRemove
	onRemove: function (map) {
		map.off('zoomend', this._zoomEnd, this);
		map.off('moveend', this._moveEnd, this);

		this._unbindEvents();

		//In case we are in a cluster animation
		this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');

		if (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnRemove();
		}

		delete this._maxLat;

		//Clean up all the layers we added to the map
		this._hideCoverage();
		this._featureGroup.remove();
		this._nonPointGroup.remove();

		this._featureGroup.clearLayers();

		this._map = null;
	},

	getVisibleParent: function (marker) {
		var vMarker = marker;
		while (vMarker && !vMarker._icon) {
			vMarker = vMarker.__parent;
		}
		return vMarker || null;
	},

	//Remove the given object from the given array
	_arraySplice: function (anArray, obj) {
		for (var i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === obj) {
				anArray.splice(i, 1);
				return true;
			}
		}
	},

	/**
	 * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.
	 * @param marker to be removed from _gridUnclustered.
	 * @param z integer bottom start zoom level (included)
	 * @private
	 */
	_removeFromGridUnclustered: function (marker, z) {
		var map = this._map,
		    gridUnclustered = this._gridUnclustered,
			minZoom = Math.floor(this._map.getMinZoom());

		for (; z >= minZoom; z--) {
			if (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {
				break;
			}
		}
	},

	_childMarkerDragStart: function (e) {
		e.target.__dragStart = e.target._latlng;
	},

	_childMarkerMoved: function (e) {
		if (!this._ignoreMove && !e.target.__dragStart) {
			var isPopupOpen = e.target._popup && e.target._popup.isOpen();

			this._moveChild(e.target, e.oldLatLng, e.latlng);

			if (isPopupOpen) {
				e.target.openPopup();
			}
		}
	},

	_moveChild: function (layer, from, to) {
		layer._latlng = from;
		this.removeLayer(layer);

		layer._latlng = to;
		this.addLayer(layer);
	},

	_childMarkerDragEnd: function (e) {
		var dragStart = e.target.__dragStart;
		delete e.target.__dragStart;
		if (dragStart) {
			this._moveChild(e.target, dragStart, e.target._latlng);
		}		
	},


	//Internal function for removing a marker from everything.
	//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
	_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {
		var gridClusters = this._gridClusters,
			gridUnclustered = this._gridUnclustered,
			fg = this._featureGroup,
			map = this._map,
			minZoom = Math.floor(this._map.getMinZoom());

		//Remove the marker from distance clusters it might be in
		if (removeFromDistanceGrid) {
			this._removeFromGridUnclustered(marker, this._maxZoom);
		}

		//Work our way up the clusters removing them as we go if required
		var cluster = marker.__parent,
			markers = cluster._markers,
			otherMarker;

		//Remove the marker from the immediate parents marker list
		this._arraySplice(markers, marker);

		while (cluster) {
			cluster._childCount--;
			cluster._boundsNeedUpdate = true;

			if (cluster._zoom < minZoom) {
				//Top level, do nothing
				break;
			} else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required
				//We need to push the other marker up to the parent
				otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];

				//Update distance grid
				gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));
				gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));

				//Move otherMarker up to parent
				this._arraySplice(cluster.__parent._childClusters, cluster);
				cluster.__parent._markers.push(otherMarker);
				otherMarker.__parent = cluster.__parent;

				if (cluster._icon) {
					//Cluster is currently on the map, need to put the marker on the map instead
					fg.removeLayer(cluster);
					if (!dontUpdateMap) {
						fg.addLayer(otherMarker);
					}
				}
			} else {
				cluster._iconNeedsUpdate = true;
			}

			cluster = cluster.__parent;
		}

		delete marker.__parent;
	},

	_isOrIsParent: function (el, oel) {
		while (oel) {
			if (el === oel) {
				return true;
			}
			oel = oel.parentNode;
		}
		return false;
	},

	//Override L.Evented.fire
	fire: function (type, data, propagate) {
		if (data && data.layer instanceof L.MarkerCluster) {
			//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)
			if (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) {
				return;
			}
			type = 'cluster' + type;
		}

		L.FeatureGroup.prototype.fire.call(this, type, data, propagate);
	},

	//Override L.Evented.listens
	listens: function (type, propagate) {
		return L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, 'cluster' + type, propagate);
	},

	//Default functionality
	_defaultIconCreateFunction: function (cluster) {
		var childCount = cluster.getChildCount();

		var c = ' marker-cluster-';
		if (childCount < 10) {
			c += 'small';
		} else if (childCount < 100) {
			c += 'medium';
		} else {
			c += 'large';
		}

		return new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });
	},

	_bindEvents: function () {
		var map = this._map,
		    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
		    showCoverageOnHover = this.options.showCoverageOnHover,
		    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;

		//Zoom on cluster click or spiderfy if we are at the lowest level
		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.on('clusterclick', this._zoomOrSpiderfy, this);
		}

		//Show convex hull (boundary) polygon on mouse over
		if (showCoverageOnHover) {
			this.on('clustermouseover', this._showCoverage, this);
			this.on('clustermouseout', this._hideCoverage, this);
			map.on('zoomend', this._hideCoverage, this);
		}
	},

	_zoomOrSpiderfy: function (e) {
		var cluster = e.layer,
		    bottomCluster = cluster;

		while (bottomCluster._childClusters.length === 1) {
			bottomCluster = bottomCluster._childClusters[0];
		}

		if (bottomCluster._zoom === this._maxZoom &&
			bottomCluster._childCount === cluster._childCount &&
			this.options.spiderfyOnMaxZoom) {

			// All child markers are contained in a single cluster from this._maxZoom to this cluster.
			cluster.spiderfy();
		} else if (this.options.zoomToBoundsOnClick) {
			cluster.zoomToBounds();
		}

		// Focus the map again for keyboard users.
		if (e.originalEvent && e.originalEvent.keyCode === 13) {
			this._map._container.focus();
		}
	},

	_showCoverage: function (e) {
		var map = this._map;
		if (this._inZoomAnimation) {
			return;
		}
		if (this._shownPolygon) {
			map.removeLayer(this._shownPolygon);
		}
		if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {
			this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);
			map.addLayer(this._shownPolygon);
		}
	},

	_hideCoverage: function () {
		if (this._shownPolygon) {
			this._map.removeLayer(this._shownPolygon);
			this._shownPolygon = null;
		}
	},

	_unbindEvents: function () {
		var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
			showCoverageOnHover = this.options.showCoverageOnHover,
			zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,
			map = this._map;

		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.off('clusterclick', this._zoomOrSpiderfy, this);
		}
		if (showCoverageOnHover) {
			this.off('clustermouseover', this._showCoverage, this);
			this.off('clustermouseout', this._hideCoverage, this);
			map.off('zoomend', this._hideCoverage, this);
		}
	},

	_zoomEnd: function () {
		if (!this._map) { //May have been removed from the map by a zoomEnd handler
			return;
		}
		this._mergeSplitClusters();

		this._zoom = Math.round(this._map._zoom);
		this._currentShownBounds = this._getExpandedVisibleBounds();
	},

	_moveEnd: function () {
		if (this._inZoomAnimation) {
			return;
		}

		var newBounds = this._getExpandedVisibleBounds();

		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, newBounds);
		this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds);

		this._currentShownBounds = newBounds;
		return;
	},

	_generateInitialClusters: function () {
		var maxZoom = Math.ceil(this._map.getMaxZoom()),
			minZoom = Math.floor(this._map.getMinZoom()),
			radius = this.options.maxClusterRadius,
			radiusFn = radius;

		//If we just set maxClusterRadius to a single number, we need to create
		//a simple function to return that number. Otherwise, we just have to
		//use the function we've passed in.
		if (typeof radius !== "function") {
			radiusFn = function () { return radius; };
		}

		if (this.options.disableClusteringAtZoom !== null) {
			maxZoom = this.options.disableClusteringAtZoom - 1;
		}
		this._maxZoom = maxZoom;
		this._gridClusters = {};
		this._gridUnclustered = {};

		//Set up DistanceGrids for each zoom
		for (var zoom = maxZoom; zoom >= minZoom; zoom--) {
			this._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));
			this._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));
		}

		// Instantiate the appropriate L.MarkerCluster class (animated or not).
		this._topClusterLevel = new this._markerCluster(this, minZoom - 1);
	},

	//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
	_addLayer: function (layer, zoom) {
		var gridClusters = this._gridClusters,
		    gridUnclustered = this._gridUnclustered,
			minZoom = Math.floor(this._map.getMinZoom()),
		    markerPoint, z;

		if (this.options.singleMarkerMode) {
			this._overrideMarkerIcon(layer);
		}

		layer.on(this._childMarkerEventHandlers, this);

		//Find the lowest zoom level to slot this one in
		for (; zoom >= minZoom; zoom--) {
			markerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position

			//Try find a cluster close by
			var closest = gridClusters[zoom].getNearObject(markerPoint);
			if (closest) {
				closest._addChild(layer);
				layer.__parent = closest;
				return;
			}

			//Try find a marker close by to form a new cluster with
			closest = gridUnclustered[zoom].getNearObject(markerPoint);
			if (closest) {
				var parent = closest.__parent;
				if (parent) {
					this._removeLayer(closest, false);
				}

				//Create new cluster with these 2 in it

				var newCluster = new this._markerCluster(this, zoom, closest, layer);
				gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));
				closest.__parent = newCluster;
				layer.__parent = newCluster;

				//First create any new intermediate parent clusters that don't exist
				var lastParent = newCluster;
				for (z = zoom - 1; z > parent._zoom; z--) {
					lastParent = new this._markerCluster(this, z, lastParent);
					gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));
				}
				parent._addChild(lastParent);

				//Remove closest from this zoom level and any above that it is in, replace with newCluster
				this._removeFromGridUnclustered(closest, zoom);

				return;
			}

			//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards
			gridUnclustered[zoom].addObject(layer, markerPoint);
		}

		//Didn't get in anything, add us to the top
		this._topClusterLevel._addChild(layer);
		layer.__parent = this._topClusterLevel;
		return;
	},

	/**
	 * Refreshes the icon of all "dirty" visible clusters.
	 * Non-visible "dirty" clusters will be updated when they are added to the map.
	 * @private
	 */
	_refreshClustersIcons: function () {
		this._featureGroup.eachLayer(function (c) {
			if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
				c._updateIcon();
			}
		});
	},

	//Enqueue code to fire after the marker expand/contract has happened
	_enqueue: function (fn) {
		this._queue.push(fn);
		if (!this._queueTimeout) {
			this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);
		}
	},
	_processQueue: function () {
		for (var i = 0; i < this._queue.length; i++) {
			this._queue[i].call(this);
		}
		this._queue.length = 0;
		clearTimeout(this._queueTimeout);
		this._queueTimeout = null;
	},

	//Merge and split any existing clusters that are too big or small
	_mergeSplitClusters: function () {
		var mapZoom = Math.round(this._map._zoom);

		//In case we are starting to split before the animation finished
		this._processQueue();

		if (this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) { //Zoom in, split
			this._animationStart();
			//Remove clusters now off screen
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds());

			this._animationZoomIn(this._zoom, mapZoom);

		} else if (this._zoom > mapZoom) { //Zoom out, merge
			this._animationStart();

			this._animationZoomOut(this._zoom, mapZoom);
		} else {
			this._moveEnd();
		}
	},

	//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
	_getExpandedVisibleBounds: function () {
		if (!this.options.removeOutsideVisibleBounds) {
			return this._mapBoundsInfinite;
		} else if (L.Browser.mobile) {
			return this._checkBoundsMaxLat(this._map.getBounds());
		}

		return this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.
	},

	/**
	 * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude
	 * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).
	 * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without
	 * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,
	 * making the user think that MCG "eats" them and never displays them again.
	 * @param bounds L.LatLngBounds
	 * @returns {L.LatLngBounds}
	 * @private
	 */
	_checkBoundsMaxLat: function (bounds) {
		var maxLat = this._maxLat;

		if (maxLat !== undefined) {
			if (bounds.getNorth() >= maxLat) {
				bounds._northEast.lat = Infinity;
			}
			if (bounds.getSouth() <= -maxLat) {
				bounds._southWest.lat = -Infinity;
			}
		}

		return bounds;
	},

	//Shared animation code
	_animationAddLayerNonAnimated: function (layer, newCluster) {
		if (newCluster === layer) {
			this._featureGroup.addLayer(layer);
		} else if (newCluster._childCount === 2) {
			newCluster._addToMap();

			var markers = newCluster.getAllChildMarkers();
			this._featureGroup.removeLayer(markers[0]);
			this._featureGroup.removeLayer(markers[1]);
		} else {
			newCluster._updateIcon();
		}
	},

	/**
	 * Extracts individual (i.e. non-group) layers from a Layer Group.
	 * @param group to extract layers from.
	 * @param output {Array} in which to store the extracted layers.
	 * @returns {*|Array}
	 * @private
	 */
	_extractNonGroupLayers: function (group, output) {
		var layers = group.getLayers(),
		    i = 0,
		    layer;

		output = output || [];

		for (; i < layers.length; i++) {
			layer = layers[i];

			if (layer instanceof L.LayerGroup) {
				this._extractNonGroupLayers(layer, output);
				continue;
			}

			output.push(layer);
		}

		return output;
	},

	/**
	 * Implements the singleMarkerMode option.
	 * @param layer Marker to re-style using the Clusters iconCreateFunction.
	 * @returns {L.Icon} The newly created icon.
	 * @private
	 */
	_overrideMarkerIcon: function (layer) {
		var icon = layer.options.icon = this.options.iconCreateFunction({
			getChildCount: function () {
				return 1;
			},
			getAllChildMarkers: function () {
				return [layer];
			}
		});

		return icon;
	}
});

// Constant bounds used in case option "removeOutsideVisibleBounds" is set to false.
L.MarkerClusterGroup.include({
	_mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))
});

L.MarkerClusterGroup.include({
	_noAnimation: {
		//Non Animated versions of everything
		_animationStart: function () {
			//Do nothing...
		},
		_animationZoomIn: function (previousZoomLevel, newZoomLevel) {
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

			//We didn't actually animate, but we use this event to mean "clustering animations have finished"
			this.fire('animationend');
		},
		_animationZoomOut: function (previousZoomLevel, newZoomLevel) {
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

			//We didn't actually animate, but we use this event to mean "clustering animations have finished"
			this.fire('animationend');
		},
		_animationAddLayer: function (layer, newCluster) {
			this._animationAddLayerNonAnimated(layer, newCluster);
		}
	},

	_withAnimation: {
		//Animated versions here
		_animationStart: function () {
			this._map._mapPane.className += ' leaflet-cluster-anim';
			this._inZoomAnimation++;
		},

		_animationZoomIn: function (previousZoomLevel, newZoomLevel) {
			var bounds = this._getExpandedVisibleBounds(),
			    fg = this._featureGroup,
				minZoom = Math.floor(this._map.getMinZoom()),
			    i;

			this._ignoreMove = true;

			//Add all children of current clusters to map and remove those clusters from map
			this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {
				var startPos = c._latlng,
				    markers  = c._markers,
				    m;

				if (!bounds.contains(startPos)) {
					startPos = null;
				}

				if (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us
					fg.removeLayer(c);
					c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);
				} else {
					//Fade out old cluster
					c.clusterHide();
					c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);
				}

				//Remove all markers that aren't visible any more
				//TODO: Do we actually need to do this on the higher levels too?
				for (i = markers.length - 1; i >= 0; i--) {
					m = markers[i];
					if (!bounds.contains(m._latlng)) {
						fg.removeLayer(m);
					}
				}

			});

			this._forceLayout();

			//Update opacities
			this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);
			//TODO Maybe? Update markers in _recursivelyBecomeVisible
			fg.eachLayer(function (n) {
				if (!(n instanceof L.MarkerCluster) && n._icon) {
					n.clusterShow();
				}
			});

			//update the positions of the just added clusters/markers
			this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {
				c._recursivelyRestoreChildPositions(newZoomLevel);
			});

			this._ignoreMove = false;

			//Remove the old clusters and close the zoom animation
			this._enqueue(function () {
				//update the positions of the just added clusters/markers
				this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {
					fg.removeLayer(c);
					c.clusterShow();
				});

				this._animationEnd();
			});
		},

		_animationZoomOut: function (previousZoomLevel, newZoomLevel) {
			this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);

			//Need to add markers for those that weren't on the map before but are now
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
			//Remove markers that were on the map before but won't be now
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());
		},

		_animationAddLayer: function (layer, newCluster) {
			var me = this,
			    fg = this._featureGroup;

			fg.addLayer(layer);
			if (newCluster !== layer) {
				if (newCluster._childCount > 2) { //Was already a cluster

					newCluster._updateIcon();
					this._forceLayout();
					this._animationStart();

					layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));
					layer.clusterHide();

					this._enqueue(function () {
						fg.removeLayer(layer);
						layer.clusterShow();

						me._animationEnd();
					});

				} else { //Just became a cluster
					this._forceLayout();

					me._animationStart();
					me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom);
				}
			}
		}
	},

	// Private methods for animated versions.
	_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {
		var bounds = this._getExpandedVisibleBounds(),
			minZoom = Math.floor(this._map.getMinZoom());

		//Animate all of the markers in the clusters to move to their cluster center point
		cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);

		var me = this;

		//Update the opacity (If we immediately set it they won't animate)
		this._forceLayout();
		cluster._recursivelyBecomeVisible(bounds, newZoomLevel);

		//TODO: Maybe use the transition timing stuff to make this more reliable
		//When the animations are done, tidy up
		this._enqueue(function () {

			//This cluster stopped being a cluster before the timeout fired
			if (cluster._childCount === 1) {
				var m = cluster._markers[0];
				//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it
				this._ignoreMove = true;
				m.setLatLng(m.getLatLng());
				this._ignoreMove = false;
				if (m.clusterShow) {
					m.clusterShow();
				}
			} else {
				cluster._recursively(bounds, newZoomLevel, minZoom, function (c) {
					c._recursivelyRemoveChildrenFromMap(bounds, minZoom, previousZoomLevel + 1);
				});
			}
			me._animationEnd();
		});
	},

	_animationEnd: function () {
		if (this._map) {
			this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');
		}
		this._inZoomAnimation--;
		this.fire('animationend');
	},

	//Force a browser layout of stuff in the map
	// Should apply the current opacity and location to all elements so we can update them again for an animation
	_forceLayout: function () {
		//In my testing this works, infact offsetWidth of any element seems to work.
		//Could loop all this._layers and do this for each _icon if it stops working

		L.Util.falseFn(document.body.offsetWidth);
	}
});

L.markerClusterGroup = function (options) {
	return new L.MarkerClusterGroup(options);
};

var MarkerCluster = L.MarkerCluster = L.Marker.extend({
	options: L.Icon.prototype.options,

	initialize: function (group, zoom, a, b) {

		L.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0),
            { icon: this, pane: group.options.clusterPane });

		this._group = group;
		this._zoom = zoom;

		this._markers = [];
		this._childClusters = [];
		this._childCount = 0;
		this._iconNeedsUpdate = true;
		this._boundsNeedUpdate = true;

		this._bounds = new L.LatLngBounds();

		if (a) {
			this._addChild(a);
		}
		if (b) {
			this._addChild(b);
		}
	},

	//Recursively retrieve all child markers of this cluster
	getAllChildMarkers: function (storageArray, ignoreDraggedMarker) {
		storageArray = storageArray || [];

		for (var i = this._childClusters.length - 1; i >= 0; i--) {
			this._childClusters[i].getAllChildMarkers(storageArray);
		}

		for (var j = this._markers.length - 1; j >= 0; j--) {
			if (ignoreDraggedMarker && this._markers[j].__dragStart) {
				continue;
			}
			storageArray.push(this._markers[j]);
		}

		return storageArray;
	},

	//Returns the count of how many child markers we have
	getChildCount: function () {
		return this._childCount;
	},

	//Zoom to the minimum of showing all of the child markers, or the extents of this cluster
	zoomToBounds: function (fitBoundsOptions) {
		var childClusters = this._childClusters.slice(),
			map = this._group._map,
			boundsZoom = map.getBoundsZoom(this._bounds),
			zoom = this._zoom + 1,
			mapZoom = map.getZoom(),
			i;

		//calculate how far we need to zoom down to see all of the markers
		while (childClusters.length > 0 && boundsZoom > zoom) {
			zoom++;
			var newClusters = [];
			for (i = 0; i < childClusters.length; i++) {
				newClusters = newClusters.concat(childClusters[i]._childClusters);
			}
			childClusters = newClusters;
		}

		if (boundsZoom > zoom) {
			this._group._map.setView(this._latlng, zoom);
		} else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead
			this._group._map.setView(this._latlng, mapZoom + 1);
		} else {
			this._group._map.fitBounds(this._bounds, fitBoundsOptions);
		}
	},

	getBounds: function () {
		var bounds = new L.LatLngBounds();
		bounds.extend(this._bounds);
		return bounds;
	},

	_updateIcon: function () {
		this._iconNeedsUpdate = true;
		if (this._icon) {
			this.setIcon(this);
		}
	},

	//Cludge for Icon, we pretend to be an icon for performance
	createIcon: function () {
		if (this._iconNeedsUpdate) {
			this._iconObj = this._group.options.iconCreateFunction(this);
			this._iconNeedsUpdate = false;
		}
		return this._iconObj.createIcon();
	},
	createShadow: function () {
		return this._iconObj.createShadow();
	},


	_addChild: function (new1, isNotificationFromChild) {

		this._iconNeedsUpdate = true;

		this._boundsNeedUpdate = true;
		this._setClusterCenter(new1);

		if (new1 instanceof L.MarkerCluster) {
			if (!isNotificationFromChild) {
				this._childClusters.push(new1);
				new1.__parent = this;
			}
			this._childCount += new1._childCount;
		} else {
			if (!isNotificationFromChild) {
				this._markers.push(new1);
			}
			this._childCount++;
		}

		if (this.__parent) {
			this.__parent._addChild(new1, true);
		}
	},

	/**
	 * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.
	 * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
	 * @private
	 */
	_setClusterCenter: function (child) {
		if (!this._cLatLng) {
			// when clustering, take position of the first point as the cluster center
			this._cLatLng = child._cLatLng || child._latlng;
		}
	},

	/**
	 * Assigns impossible bounding values so that the next extend entirely determines the new bounds.
	 * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
	 * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
	 * @private
	 */
	_resetBounds: function () {
		var bounds = this._bounds;

		if (bounds._southWest) {
			bounds._southWest.lat = Infinity;
			bounds._southWest.lng = Infinity;
		}
		if (bounds._northEast) {
			bounds._northEast.lat = -Infinity;
			bounds._northEast.lng = -Infinity;
		}
	},

	_recalculateBounds: function () {
		var markers = this._markers,
		    childClusters = this._childClusters,
		    latSum = 0,
		    lngSum = 0,
		    totalCount = this._childCount,
		    i, child, childLatLng, childCount;

		// Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.
		if (totalCount === 0) {
			return;
		}

		// Reset rather than creating a new object, for performance.
		this._resetBounds();

		// Child markers.
		for (i = 0; i < markers.length; i++) {
			childLatLng = markers[i]._latlng;

			this._bounds.extend(childLatLng);

			latSum += childLatLng.lat;
			lngSum += childLatLng.lng;
		}

		// Child clusters.
		for (i = 0; i < childClusters.length; i++) {
			child = childClusters[i];

			// Re-compute child bounds and weighted position first if necessary.
			if (child._boundsNeedUpdate) {
				child._recalculateBounds();
			}

			this._bounds.extend(child._bounds);

			childLatLng = child._wLatLng;
			childCount = child._childCount;

			latSum += childLatLng.lat * childCount;
			lngSum += childLatLng.lng * childCount;
		}

		this._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);

		// Reset dirty flag.
		this._boundsNeedUpdate = false;
	},

	//Set our markers position as given and add it to the map
	_addToMap: function (startPos) {
		if (startPos) {
			this._backupLatlng = this._latlng;
			this.setLatLng(startPos);
		}
		this._group._featureGroup.addLayer(this);
	},

	_recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {
		this._recursively(bounds, this._group._map.getMinZoom(), maxZoom - 1,
			function (c) {
				var markers = c._markers,
					i, m;
				for (i = markers.length - 1; i >= 0; i--) {
					m = markers[i];

					//Only do it if the icon is still on the map
					if (m._icon) {
						m._setPos(center);
						m.clusterHide();
					}
				}
			},
			function (c) {
				var childClusters = c._childClusters,
					j, cm;
				for (j = childClusters.length - 1; j >= 0; j--) {
					cm = childClusters[j];
					if (cm._icon) {
						cm._setPos(center);
						cm.clusterHide();
					}
				}
			}
		);
	},

	_recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, mapMinZoom, previousZoomLevel, newZoomLevel) {
		this._recursively(bounds, newZoomLevel, mapMinZoom,
			function (c) {
				c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);

				//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.
				//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate
				if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {
					c.clusterShow();
					c._recursivelyRemoveChildrenFromMap(bounds, mapMinZoom, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds
				} else {
					c.clusterHide();
				}

				c._addToMap();
			}
		);
	},

	_recursivelyBecomeVisible: function (bounds, zoomLevel) {
		this._recursively(bounds, this._group._map.getMinZoom(), zoomLevel, null, function (c) {
			c.clusterShow();
		});
	},

	_recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {
		this._recursively(bounds, this._group._map.getMinZoom() - 1, zoomLevel,
			function (c) {
				if (zoomLevel === c._zoom) {
					return;
				}

				//Add our child markers at startPos (so they can be animated out)
				for (var i = c._markers.length - 1; i >= 0; i--) {
					var nm = c._markers[i];

					if (!bounds.contains(nm._latlng)) {
						continue;
					}

					if (startPos) {
						nm._backupLatlng = nm.getLatLng();

						nm.setLatLng(startPos);
						if (nm.clusterHide) {
							nm.clusterHide();
						}
					}

					c._group._featureGroup.addLayer(nm);
				}
			},
			function (c) {
				c._addToMap(startPos);
			}
		);
	},

	_recursivelyRestoreChildPositions: function (zoomLevel) {
		//Fix positions of child markers
		for (var i = this._markers.length - 1; i >= 0; i--) {
			var nm = this._markers[i];
			if (nm._backupLatlng) {
				nm.setLatLng(nm._backupLatlng);
				delete nm._backupLatlng;
			}
		}

		if (zoomLevel - 1 === this._zoom) {
			//Reposition child clusters
			for (var j = this._childClusters.length - 1; j >= 0; j--) {
				this._childClusters[j]._restorePosition();
			}
		} else {
			for (var k = this._childClusters.length - 1; k >= 0; k--) {
				this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
			}
		}
	},

	_restorePosition: function () {
		if (this._backupLatlng) {
			this.setLatLng(this._backupLatlng);
			delete this._backupLatlng;
		}
	},

	//exceptBounds: If set, don't remove any markers/clusters in it
	_recursivelyRemoveChildrenFromMap: function (previousBounds, mapMinZoom, zoomLevel, exceptBounds) {
		var m, i;
		this._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1,
			function (c) {
				//Remove markers at every level
				for (i = c._markers.length - 1; i >= 0; i--) {
					m = c._markers[i];
					if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
						c._group._featureGroup.removeLayer(m);
						if (m.clusterShow) {
							m.clusterShow();
						}
					}
				}
			},
			function (c) {
				//Remove child clusters at just the bottom level
				for (i = c._childClusters.length - 1; i >= 0; i--) {
					m = c._childClusters[i];
					if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
						c._group._featureGroup.removeLayer(m);
						if (m.clusterShow) {
							m.clusterShow();
						}
					}
				}
			}
		);
	},

	//Run the given functions recursively to this and child clusters
	// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
	// zoomLevelToStart: zoom level to start running functions (inclusive)
	// zoomLevelToStop: zoom level to stop running functions (inclusive)
	// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
	// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
	_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
		var childClusters = this._childClusters,
		    zoom = this._zoom,
		    i, c;

		if (zoomLevelToStart <= zoom) {
			if (runAtEveryLevel) {
				runAtEveryLevel(this);
			}
			if (runAtBottomLevel && zoom === zoomLevelToStop) {
				runAtBottomLevel(this);
			}
		}

		if (zoom < zoomLevelToStart || zoom < zoomLevelToStop) {
			for (i = childClusters.length - 1; i >= 0; i--) {
				c = childClusters[i];
				if (c._boundsNeedUpdate) {
					c._recalculateBounds();
				}
				if (boundsToApplyTo.intersects(c._bounds)) {
					c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
				}
			}
		}
	},

	//Returns true if we are the parent of only one cluster and that cluster is the same as us
	_isSingleParent: function () {
		//Don't need to check this._markers as the rest won't work if there are any
		return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
	}
});

/*
* Extends L.Marker to include two extra methods: clusterHide and clusterShow.
* 
* They work as setOpacity(0) and setOpacity(1) respectively, but
* don't overwrite the options.opacity
* 
*/

L.Marker.include({
	clusterHide: function () {
		var backup = this.options.opacity;
		this.setOpacity(0);
		this.options.opacity = backup;
		return this;
	},
	
	clusterShow: function () {
		return this.setOpacity(this.options.opacity);
	}
});

L.DistanceGrid = function (cellSize) {
	this._cellSize = cellSize;
	this._sqCellSize = cellSize * cellSize;
	this._grid = {};
	this._objectPoint = { };
};

L.DistanceGrid.prototype = {

	addObject: function (obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    stamp = L.Util.stamp(obj);

		this._objectPoint[stamp] = point;

		cell.push(obj);
	},

	updateObject: function (obj, point) {
		this.removeObject(obj);
		this.addObject(obj, point);
	},

	//Returns true if the object was found
	removeObject: function (obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    i, len;

		delete this._objectPoint[L.Util.stamp(obj)];

		for (i = 0, len = cell.length; i < len; i++) {
			if (cell[i] === obj) {

				cell.splice(i, 1);

				if (len === 1) {
					delete row[x];
				}

				return true;
			}
		}

	},

	eachObject: function (fn, context) {
		var i, j, k, len, row, cell, removed,
		    grid = this._grid;

		for (i in grid) {
			row = grid[i];

			for (j in row) {
				cell = row[j];

				for (k = 0, len = cell.length; k < len; k++) {
					removed = fn.call(context, cell[k]);
					if (removed) {
						k--;
						len--;
					}
				}
			}
		}
	},

	getNearObject: function (point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    i, j, k, row, cell, len, obj, dist,
		    objectPoint = this._objectPoint,
		    closestDistSq = this._sqCellSize,
		    closest = null;

		for (i = y - 1; i <= y + 1; i++) {
			row = this._grid[i];
			if (row) {

				for (j = x - 1; j <= x + 1; j++) {
					cell = row[j];
					if (cell) {

						for (k = 0, len = cell.length; k < len; k++) {
							obj = cell[k];
							dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);
							if (dist < closestDistSq ||
								dist <= closestDistSq && closest === null) {
								closestDistSq = dist;
								closest = obj;
							}
						}
					}
				}
			}
		}
		return closest;
	},

	_getCoord: function (x) {
		var coord = Math.floor(x / this._cellSize);
		return isFinite(coord) ? coord : x;
	},

	_sqDist: function (p, p2) {
		var dx = p2.x - p.x,
		    dy = p2.y - p.y;
		return dx * dx + dy * dy;
	}
};

/* Copyright (c) 2012 the authors listed at the following URL, and/or
the authors of referenced articles or incorporated external code:
http://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Retrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434
*/

(function () {
	L.QuickHull = {

		/*
		 * @param {Object} cpt a point to be measured from the baseline
		 * @param {Array} bl the baseline, as represented by a two-element
		 *   array of latlng objects.
		 * @returns {Number} an approximate distance measure
		 */
		getDistant: function (cpt, bl) {
			var vY = bl[1].lat - bl[0].lat,
				vX = bl[0].lng - bl[1].lng;
			return (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));
		},

		/*
		 * @param {Array} baseLine a two-element array of latlng objects
		 *   representing the baseline to project from
		 * @param {Array} latLngs an array of latlng objects
		 * @returns {Object} the maximum point and all new points to stay
		 *   in consideration for the hull.
		 */
		findMostDistantPointFromBaseLine: function (baseLine, latLngs) {
			var maxD = 0,
				maxPt = null,
				newPoints = [],
				i, pt, d;

			for (i = latLngs.length - 1; i >= 0; i--) {
				pt = latLngs[i];
				d = this.getDistant(pt, baseLine);

				if (d > 0) {
					newPoints.push(pt);
				} else {
					continue;
				}

				if (d > maxD) {
					maxD = d;
					maxPt = pt;
				}
			}

			return { maxPoint: maxPt, newPoints: newPoints };
		},


		/*
		 * Given a baseline, compute the convex hull of latLngs as an array
		 * of latLngs.
		 *
		 * @param {Array} latLngs
		 * @returns {Array}
		 */
		buildConvexHull: function (baseLine, latLngs) {
			var convexHullBaseLines = [],
				t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);

			if (t.maxPoint) { // if there is still a point "outside" the base line
				convexHullBaseLines =
					convexHullBaseLines.concat(
						this.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)
					);
				convexHullBaseLines =
					convexHullBaseLines.concat(
						this.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)
					);
				return convexHullBaseLines;
			} else {  // if there is no more point "outside" the base line, the current base line is part of the convex hull
				return [baseLine[0]];
			}
		},

		/*
		 * Given an array of latlngs, compute a convex hull as an array
		 * of latlngs
		 *
		 * @param {Array} latLngs
		 * @returns {Array}
		 */
		getConvexHull: function (latLngs) {
			// find first baseline
			var maxLat = false, minLat = false,
				maxLng = false, minLng = false,
				maxLatPt = null, minLatPt = null,
				maxLngPt = null, minLngPt = null,
				maxPt = null, minPt = null,
				i;

			for (i = latLngs.length - 1; i >= 0; i--) {
				var pt = latLngs[i];
				if (maxLat === false || pt.lat > maxLat) {
					maxLatPt = pt;
					maxLat = pt.lat;
				}
				if (minLat === false || pt.lat < minLat) {
					minLatPt = pt;
					minLat = pt.lat;
				}
				if (maxLng === false || pt.lng > maxLng) {
					maxLngPt = pt;
					maxLng = pt.lng;
				}
				if (minLng === false || pt.lng < minLng) {
					minLngPt = pt;
					minLng = pt.lng;
				}
			}
			
			if (minLat !== maxLat) {
				minPt = minLatPt;
				maxPt = maxLatPt;
			} else {
				minPt = minLngPt;
				maxPt = maxLngPt;
			}

			var ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),
								this.buildConvexHull([maxPt, minPt], latLngs));
			return ch;
		}
	};
}());

L.MarkerCluster.include({
	getConvexHull: function () {
		var childMarkers = this.getAllChildMarkers(),
			points = [],
			p, i;

		for (i = childMarkers.length - 1; i >= 0; i--) {
			p = childMarkers[i].getLatLng();
			points.push(p);
		}

		return L.QuickHull.getConvexHull(points);
	}
});

//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet
//Huge thanks to jawj for implementing it first to make my job easy :-)

L.MarkerCluster.include({

	_2PI: Math.PI * 2,
	_circleFootSeparation: 25, //related to circumference of circle
	_circleStartAngle: 0,

	_spiralFootSeparation:  28, //related to size of spiral (experiment!)
	_spiralLengthStart: 11,
	_spiralLengthFactor: 5,

	_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.
								// 0 -> always spiral; Infinity -> always circle

	spiderfy: function () {
		if (this._group._spiderfied === this || this._group._inZoomAnimation) {
			return;
		}

		var childMarkers = this.getAllChildMarkers(null, true),
			group = this._group,
			map = group._map,
			center = map.latLngToLayerPoint(this._latlng),
			positions;

		this._group._unspiderfy();
		this._group._spiderfied = this;

		//TODO Maybe: childMarkers order by distance to center

		if (childMarkers.length >= this._circleSpiralSwitchover) {
			positions = this._generatePointsSpiral(childMarkers.length, center);
		} else {
			center.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.
			positions = this._generatePointsCircle(childMarkers.length, center);
		}

		this._animationSpiderfy(childMarkers, positions);
	},

	unspiderfy: function (zoomDetails) {
		/// <param Name="zoomDetails">Argument from zoomanim if being called in a zoom animation or null otherwise</param>
		if (this._group._inZoomAnimation) {
			return;
		}
		this._animationUnspiderfy(zoomDetails);

		this._group._spiderfied = null;
	},

	_generatePointsCircle: function (count, centerPt) {
		var circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),
			legLength = circumference / this._2PI,  //radius from circumference
			angleStep = this._2PI / count,
			res = [],
			i, angle;

		legLength = Math.max(legLength, 35); // Minimum distance to get outside the cluster icon.

		res.length = count;

		for (i = 0; i < count; i++) { // Clockwise, like spiral.
			angle = this._circleStartAngle + i * angleStep;
			res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
		}

		return res;
	},

	_generatePointsSpiral: function (count, centerPt) {
		var spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier,
			legLength = spiderfyDistanceMultiplier * this._spiralLengthStart,
			separation = spiderfyDistanceMultiplier * this._spiralFootSeparation,
			lengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,
			angle = 0,
			res = [],
			i;

		res.length = count;

		// Higher index, closer position to cluster center.
		for (i = count; i >= 0; i--) {
			// Skip the first position, so that we are already farther from center and we avoid
			// being under the default cluster icon (especially important for Circle Markers).
			if (i < count) {
				res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
			}
			angle += separation / legLength + i * 0.0005;
			legLength += lengthFactor / angle;
		}
		return res;
	},

	_noanimationUnspiderfy: function () {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			childMarkers = this.getAllChildMarkers(null, true),
			m, i;

		group._ignoreMove = true;

		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			fg.removeLayer(m);

			if (m._preSpiderfyLatlng) {
				m.setLatLng(m._preSpiderfyLatlng);
				delete m._preSpiderfyLatlng;
			}
			if (m.setZIndexOffset) {
				m.setZIndexOffset(0);
			}

			if (m._spiderLeg) {
				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
		}

		group.fire('unspiderfied', {
			cluster: this,
			markers: childMarkers
		});
		group._ignoreMove = false;
		group._spiderfied = null;
	}
});

//Non Animated versions of everything
L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
	_animationSpiderfy: function (childMarkers, positions) {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			legOptions = this._group.options.spiderLegPolylineOptions,
			i, m, leg, newPos;

		group._ignoreMove = true;

		// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
		// The reverse order trick no longer improves performance on modern browsers.
		for (i = 0; i < childMarkers.length; i++) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
			leg = new L.Polyline([this._latlng, newPos], legOptions);
			map.addLayer(leg);
			m._spiderLeg = leg;

			// Now add the marker.
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING
			}

			fg.addLayer(m);
		}
		this.setOpacity(0.3);

		group._ignoreMove = false;
		group.fire('spiderfied', {
			cluster: this,
			markers: childMarkers
		});
	},

	_animationUnspiderfy: function () {
		this._noanimationUnspiderfy();
	}
});

//Animated versions here
L.MarkerCluster.include({

	_animationSpiderfy: function (childMarkers, positions) {
		var me = this,
			group = this._group,
			map = group._map,
			fg = group._featureGroup,
			thisLayerLatLng = this._latlng,
			thisLayerPos = map.latLngToLayerPoint(thisLayerLatLng),
			svg = L.Path.SVG,
			legOptions = L.extend({}, this._group.options.spiderLegPolylineOptions), // Copy the options so that we can modify them for animation.
			finalLegOpacity = legOptions.opacity,
			i, m, leg, legPath, legLength, newPos;

		if (finalLegOpacity === undefined) {
			finalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;
		}

		if (svg) {
			// If the initial opacity of the spider leg is not 0 then it appears before the animation starts.
			legOptions.opacity = 0;

			// Add the class for CSS transitions.
			legOptions.className = (legOptions.className || '') + ' leaflet-cluster-spider-leg';
		} else {
			// Make sure we have a defined opacity.
			legOptions.opacity = finalLegOpacity;
		}

		group._ignoreMove = true;

		// Add markers and spider legs to map, hidden at our center point.
		// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
		// The reverse order trick no longer improves performance on modern browsers.
		for (i = 0; i < childMarkers.length; i++) {
			m = childMarkers[i];

			newPos = map.layerPointToLatLng(positions[i]);

			// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
			leg = new L.Polyline([thisLayerLatLng, newPos], legOptions);
			map.addLayer(leg);
			m._spiderLeg = leg;

			// Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/
			// In our case the transition property is declared in the CSS file.
			if (svg) {
				legPath = leg._path;
				legLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.
				legPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.
				legPath.style.strokeDashoffset = legLength;
			}

			// If it is a marker, add it now and we'll animate it out
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING
			}
			if (m.clusterHide) {
				m.clusterHide();
			}
			
			// Vectors just get immediately added
			fg.addLayer(m);

			if (m._setPos) {
				m._setPos(thisLayerPos);
			}
		}

		group._forceLayout();
		group._animationStart();

		// Reveal markers and spider legs.
		for (i = childMarkers.length - 1; i >= 0; i--) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			//Move marker to new position
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);
			
			if (m.clusterShow) {
				m.clusterShow();
			}

			// Animate leg (animation is actually delegated to CSS transition).
			if (svg) {
				leg = m._spiderLeg;
				legPath = leg._path;
				legPath.style.strokeDashoffset = 0;
				//legPath.style.strokeOpacity = finalLegOpacity;
				leg.setStyle({opacity: finalLegOpacity});
			}
		}
		this.setOpacity(0.3);

		group._ignoreMove = false;

		setTimeout(function () {
			group._animationEnd();
			group.fire('spiderfied', {
				cluster: me,
				markers: childMarkers
			});
		}, 200);
	},

	_animationUnspiderfy: function (zoomDetails) {
		var me = this,
			group = this._group,
			map = group._map,
			fg = group._featureGroup,
			thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),
			childMarkers = this.getAllChildMarkers(null, true),
			svg = L.Path.SVG,
			m, i, leg, legPath, legLength, nonAnimatable;

		group._ignoreMove = true;
		group._animationStart();

		//Make us visible and bring the child markers back in
		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			//Marker was added to us after we were spiderfied
			if (!m._preSpiderfyLatlng) {
				continue;
			}

			//Close any popup on the marker first, otherwise setting the location of the marker will make the map scroll
			m.closePopup();

			//Fix up the location to the real one
			m.setLatLng(m._preSpiderfyLatlng);
			delete m._preSpiderfyLatlng;

			//Hack override the location to be our center
			nonAnimatable = true;
			if (m._setPos) {
				m._setPos(thisLayerPos);
				nonAnimatable = false;
			}
			if (m.clusterHide) {
				m.clusterHide();
				nonAnimatable = false;
			}
			if (nonAnimatable) {
				fg.removeLayer(m);
			}

			// Animate the spider leg back in (animation is actually delegated to CSS transition).
			if (svg) {
				leg = m._spiderLeg;
				legPath = leg._path;
				legLength = legPath.getTotalLength() + 0.1;
				legPath.style.strokeDashoffset = legLength;
				leg.setStyle({opacity: 0});
			}
		}

		group._ignoreMove = false;

		setTimeout(function () {
			//If we have only <= one child left then that marker will be shown on the map so don't remove it!
			var stillThereChildCount = 0;
			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];
				if (m._spiderLeg) {
					stillThereChildCount++;
				}
			}


			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];

				if (!m._spiderLeg) { //Has already been unspiderfied
					continue;
				}

				if (m.clusterShow) {
					m.clusterShow();
				}
				if (m.setZIndexOffset) {
					m.setZIndexOffset(0);
				}

				if (stillThereChildCount > 1) {
					fg.removeLayer(m);
				}

				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
			group._animationEnd();
			group.fire('unspiderfied', {
				cluster: me,
				markers: childMarkers
			});
		}, 200);
	}
});


L.MarkerClusterGroup.include({
	//The MarkerCluster currently spiderfied (if any)
	_spiderfied: null,

	unspiderfy: function () {
		this._unspiderfy.apply(this, arguments);
	},

	_spiderfierOnAdd: function () {
		this._map.on('click', this._unspiderfyWrapper, this);

		if (this._map.options.zoomAnimation) {
			this._map.on('zoomstart', this._unspiderfyZoomStart, this);
		}
		//Browsers without zoomAnimation or a big zoom don't fire zoomstart
		this._map.on('zoomend', this._noanimationUnspiderfy, this);

		if (!L.Browser.touch) {
			this._map.getRenderer(this);
			//Needs to happen in the pageload, not after, or animations don't work in webkit
			//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements
			//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable
		}
	},

	_spiderfierOnRemove: function () {
		this._map.off('click', this._unspiderfyWrapper, this);
		this._map.off('zoomstart', this._unspiderfyZoomStart, this);
		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._map.off('zoomend', this._noanimationUnspiderfy, this);

		//Ensure that markers are back where they should be
		// Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane
		this._noanimationUnspiderfy();
	},

	//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
	//This means we can define the animation they do rather than Markers doing an animation to their actual location
	_unspiderfyZoomStart: function () {
		if (!this._map) { //May have been removed from the map by a zoomEnd handler
			return;
		}

		this._map.on('zoomanim', this._unspiderfyZoomAnim, this);
	},

	_unspiderfyZoomAnim: function (zoomDetails) {
		//Wait until the first zoomanim after the user has finished touch-zooming before running the animation
		if (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {
			return;
		}

		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._unspiderfy(zoomDetails);
	},

	_unspiderfyWrapper: function () {
		/// <summary>_unspiderfy but passes no arguments</summary>
		this._unspiderfy();
	},

	_unspiderfy: function (zoomDetails) {
		if (this._spiderfied) {
			this._spiderfied.unspiderfy(zoomDetails);
		}
	},

	_noanimationUnspiderfy: function () {
		if (this._spiderfied) {
			this._spiderfied._noanimationUnspiderfy();
		}
	},

	//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
	_unspiderfyLayer: function (layer) {
		if (layer._spiderLeg) {
			this._featureGroup.removeLayer(layer);

			if (layer.clusterShow) {
				layer.clusterShow();
			}
				//Position will be fixed up immediately in _animationUnspiderfy
			if (layer.setZIndexOffset) {
				layer.setZIndexOffset(0);
			}

			this._map.removeLayer(layer._spiderLeg);
			delete layer._spiderLeg;
		}
	}
});

/**
 * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing
 * markers' icon options and refreshing their icon and their parent clusters
 * accordingly (case where their iconCreateFunction uses data of childMarkers
 * to make up the cluster icon).
 */


L.MarkerClusterGroup.include({
	/**
	 * Updates the icon of all clusters which are parents of the given marker(s).
	 * In singleMarkerMode, also updates the given marker(s) icon.
	 * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|
	 * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent
	 * clusters need to be updated. If not provided, retrieves all child markers of this.
	 * @returns {L.MarkerClusterGroup}
	 */
	refreshClusters: function (layers) {
		if (!layers) {
			layers = this._topClusterLevel.getAllChildMarkers();
		} else if (layers instanceof L.MarkerClusterGroup) {
			layers = layers._topClusterLevel.getAllChildMarkers();
		} else if (layers instanceof L.LayerGroup) {
			layers = layers._layers;
		} else if (layers instanceof L.MarkerCluster) {
			layers = layers.getAllChildMarkers();
		} else if (layers instanceof L.Marker) {
			layers = [layers];
		} // else: must be an Array(L.Marker)|Map(L.Marker)
		this._flagParentsIconsNeedUpdate(layers);
		this._refreshClustersIcons();

		// In case of singleMarkerMode, also re-draw the markers.
		if (this.options.singleMarkerMode) {
			this._refreshSingleMarkerModeMarkers(layers);
		}

		return this;
	},

	/**
	 * Simply flags all parent clusters of the given markers as having a "dirty" icon.
	 * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
	 * @private
	 */
	_flagParentsIconsNeedUpdate: function (layers) {
		var id, parent;

		// Assumes layers is an Array or an Object whose prototype is non-enumerable.
		for (id in layers) {
			// Flag parent clusters' icon as "dirty", all the way up.
			// Dumb process that flags multiple times upper parents, but still
			// much more efficient than trying to be smart and make short lists,
			// at least in the case of a hierarchy following a power law:
			// http://jsperf.com/flag-nodes-in-power-hierarchy/2
			parent = layers[id].__parent;
			while (parent) {
				parent._iconNeedsUpdate = true;
				parent = parent.__parent;
			}
		}
	},

	/**
	 * Re-draws the icon of the supplied markers.
	 * To be used in singleMarkerMode only.
	 * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
	 * @private
	 */
	_refreshSingleMarkerModeMarkers: function (layers) {
		var id, layer;

		for (id in layers) {
			layer = layers[id];

			// Make sure we do not override markers that do not belong to THIS group.
			if (this.hasLayer(layer)) {
				// Need to re-create the icon first, then re-draw the marker.
				layer.setIcon(this._overrideMarkerIcon(layer));
			}
		}
	}
});

L.Marker.include({
	/**
	 * Updates the given options in the marker's icon and refreshes the marker.
	 * @param options map object of icon options.
	 * @param directlyRefreshClusters boolean (optional) true to trigger
	 * MCG.refreshClustersOf() right away with this single marker.
	 * @returns {L.Marker}
	 */
	refreshIconOptions: function (options, directlyRefreshClusters) {
		var icon = this.options.icon;

		L.setOptions(icon, options);

		this.setIcon(icon);

		// Shortcut to refresh the associated MCG clusters right away.
		// To be used when refreshing a single marker.
		// Otherwise, better use MCG.refreshClusters() once at the end with
		// the list of modified markers.
		if (directlyRefreshClusters && this.__parent) {
			this.__parent._group.refreshClusters(this);
		}

		return this;
	}
});

exports.MarkerClusterGroup = MarkerClusterGroup;
exports.MarkerCluster = MarkerCluster;

})));


},{}],30:[function(require,module,exports){
/* @preserve
 * Leaflet 1.3.1, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2017 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.L = {})));
}(this, (function (exports) { 'use strict';

var version = "1.3.1";

/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

var freeze = Object.freeze;
Object.freeze = function (obj) { return obj; };

// @function extend(dest: Object, src?: Object): Object
// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
function extend(dest) {
	var i, j, len, src;

	for (j = 1, len = arguments.length; j < len; j++) {
		src = arguments[j];
		for (i in src) {
			dest[i] = src[i];
		}
	}
	return dest;
}

// @function create(proto: Object, properties?: Object): Object
// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
var create = Object.create || (function () {
	function F() {}
	return function (proto) {
		F.prototype = proto;
		return new F();
	};
})();

// @function bind(fn: Function, …): Function
// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
// Has a `L.bind()` shortcut.
function bind(fn, obj) {
	var slice = Array.prototype.slice;

	if (fn.bind) {
		return fn.bind.apply(fn, slice.call(arguments, 1));
	}

	var args = slice.call(arguments, 2);

	return function () {
		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
	};
}

// @property lastId: Number
// Last unique ID used by [`stamp()`](#util-stamp)
var lastId = 0;

// @function stamp(obj: Object): Number
// Returns the unique ID of an object, assigning it one if it doesn't have it.
function stamp(obj) {
	/*eslint-disable */
	obj._leaflet_id = obj._leaflet_id || ++lastId;
	return obj._leaflet_id;
	/* eslint-enable */
}

// @function throttle(fn: Function, time: Number, context: Object): Function
// Returns a function which executes function `fn` with the given scope `context`
// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
// `fn` will be called no more than one time per given amount of `time`. The arguments
// received by the bound function will be any arguments passed when binding the
// function, followed by any arguments passed when invoking the bound function.
// Has an `L.throttle` shortcut.
function throttle(fn, time, context) {
	var lock, args, wrapperFn, later;

	later = function () {
		// reset lock and call if queued
		lock = false;
		if (args) {
			wrapperFn.apply(context, args);
			args = false;
		}
	};

	wrapperFn = function () {
		if (lock) {
			// called too soon, queue to call later
			args = arguments;

		} else {
			// call and lock until later
			fn.apply(context, arguments);
			setTimeout(later, time);
			lock = true;
		}
	};

	return wrapperFn;
}

// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
// Returns the number `num` modulo `range` in such a way so it lies within
// `range[0]` and `range[1]`. The returned value will be always smaller than
// `range[1]` unless `includeMax` is set to `true`.
function wrapNum(x, range, includeMax) {
	var max = range[1],
	    min = range[0],
	    d = max - min;
	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
}

// @function falseFn(): Function
// Returns a function which always returns `false`.
function falseFn() { return false; }

// @function formatNum(num: Number, digits?: Number): Number
// Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
function formatNum(num, digits) {
	var pow = Math.pow(10, (digits === undefined ? 6 : digits));
	return Math.round(num * pow) / pow;
}

// @function trim(str: String): String
// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
function trim(str) {
	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
function splitWords(str) {
	return trim(str).split(/\s+/);
}

// @function setOptions(obj: Object, options: Object): Object
// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
function setOptions(obj, options) {
	if (!obj.hasOwnProperty('options')) {
		obj.options = obj.options ? create(obj.options) : {};
	}
	for (var i in options) {
		obj.options[i] = options[i];
	}
	return obj.options;
}

// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
// be appended at the end. If `uppercase` is `true`, the parameter names will
// be uppercased (e.g. `'?A=foo&B=bar'`)
function getParamString(obj, existingUrl, uppercase) {
	var params = [];
	for (var i in obj) {
		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
	}
	return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
}

var templateRe = /\{ *([\w_-]+) *\}/g;

// @function template(str: String, data: Object): String
// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
// `('Hello foo, bar')`. You can also specify functions instead of strings for
// data values — they will be evaluated passing `data` as an argument.
function template(str, data) {
	return str.replace(templateRe, function (str, key) {
		var value = data[key];

		if (value === undefined) {
			throw new Error('No value provided for variable ' + str);

		} else if (typeof value === 'function') {
			value = value(data);
		}
		return value;
	});
}

// @function isArray(obj): Boolean
// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
var isArray = Array.isArray || function (obj) {
	return (Object.prototype.toString.call(obj) === '[object Array]');
};

// @function indexOf(array: Array, el: Object): Number
// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
function indexOf(array, el) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] === el) { return i; }
	}
	return -1;
}

// @property emptyImageUrl: String
// Data URI string containing a base64-encoded empty GIF image.
// Used as a hack to free memory from unused images on WebKit-powered
// mobile devices (by setting image `src` to this string).
var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

function getPrefixed(name) {
	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
}

var lastTime = 0;

// fallback for IE 7-8
function timeoutDefer(fn) {
	var time = +new Date(),
	    timeToCall = Math.max(0, 16 - (time - lastTime));

	lastTime = time + timeToCall;
	return window.setTimeout(fn, timeToCall);
}

var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
		getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
// `context` if given. When `immediate` is set, `fn` is called immediately if
// the browser doesn't have native support for
// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
function requestAnimFrame(fn, context, immediate) {
	if (immediate && requestFn === timeoutDefer) {
		fn.call(context);
	} else {
		return requestFn.call(window, bind(fn, context));
	}
}

// @function cancelAnimFrame(id: Number): undefined
// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
function cancelAnimFrame(id) {
	if (id) {
		cancelFn.call(window, id);
	}
}


var Util = (Object.freeze || Object)({
	freeze: freeze,
	extend: extend,
	create: create,
	bind: bind,
	lastId: lastId,
	stamp: stamp,
	throttle: throttle,
	wrapNum: wrapNum,
	falseFn: falseFn,
	formatNum: formatNum,
	trim: trim,
	splitWords: splitWords,
	setOptions: setOptions,
	getParamString: getParamString,
	template: template,
	isArray: isArray,
	indexOf: indexOf,
	emptyImageUrl: emptyImageUrl,
	requestFn: requestFn,
	cancelFn: cancelFn,
	requestAnimFrame: requestAnimFrame,
	cancelAnimFrame: cancelAnimFrame
});

// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

function Class() {}

Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		checkDeprecatedMixinEvents(props.includes);
		extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = extend(create(proto.options), props.options);
	}

	// mix given properties into the prototype
	extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
Class.include = function (props) {
	extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
Class.mergeOptions = function (options) {
	extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};

function checkDeprecatedMixinEvents(includes) {
	if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

	includes = isArray(includes) ? includes : [includes];

	for (var i = 0; i < includes.length; i++) {
		if (includes[i] === L.Mixin.Events) {
			console.warn('Deprecated include of L.Mixin.Events: ' +
				'this property will be removed in future releases, ' +
				'please inherit from L.Evented instead.', new Error().stack);
		}
	}
}

/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */

var Events = {
	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = {fn: fn, ctx: context},
		    listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
	},

	_off: function (type, fn, context) {
		var listeners,
		    i,
		    len;

		if (!this._events) { return; }

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) { continue; }
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object — the first argument of the listener function will contain its
	// properties. The event can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = extend({}, data, {
			type: type,
			target: this,
			sourceTarget: data && data.sourceTarget || this
		});

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = (this._firingCount + 1) || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(…): this
	// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, extend({
				layer: e.target,
				propagatedFrom: e.target
			}, e), true);
		}
	}
};

// aliases; we should ditch those eventually

// @method addEventListener(…): this
// Alias to [`on(…)`](#evented-on)
Events.addEventListener = Events.on;

// @method removeEventListener(…): this
// Alias to [`off(…)`](#evented-off)

// @method clearAllEventListeners(…): this
// Alias to [`off()`](#evented-off)
Events.removeEventListener = Events.clearAllEventListeners = Events.off;

// @method addOneTimeEventListener(…): this
// Alias to [`once(…)`](#evented-once)
Events.addOneTimeEventListener = Events.once;

// @method fireEvent(…): this
// Alias to [`fire(…)`](#evented-fire)
Events.fireEvent = Events.fire;

// @method hasEventListeners(…): Boolean
// Alias to [`listens(…)`](#evented-listens)
Events.hasEventListeners = Events.listens;

var Evented = Class.extend(Events);

/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 *
 * Note that `Point` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Point(x, y, round) {
	// @property x: Number; The `x` coordinate of the point
	this.x = (round ? Math.round(x) : x);
	// @property y: Number; The `y` coordinate of the point
	this.y = (round ? Math.round(y) : y);
}

var trunc = Math.trunc || function (v) {
	return v > 0 ? Math.floor(v) : Math.ceil(v);
};

Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(toPoint(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(toPoint(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method trunc(): Point
	// Returns a copy of the current point with truncated coordinates (rounded towards zero).
	trunc: function () {
		return this.clone()._trunc();
	},

	_trunc: function () {
		this.x = trunc(this.x);
		this.y = trunc(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = toPoint(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = toPoint(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = toPoint(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
		        formatNum(this.x) + ', ' +
		        formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
function toPoint(x, y, round) {
	if (x instanceof Point) {
		return x;
	}
	if (isArray(x)) {
		return new Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new Point(x.x, x.y);
	}
	return new Point(x, y, round);
}

/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 *
 * Note that `Bounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Bounds(a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
}

Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = toPoint(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new Point(this.max.x, this.min.y);
	},

	// @method getTopLeft(): Point
	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
	getTopLeft: function () {
		return this.min; // left, top
	},

	// @method getBottomRight(): Point
	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
	getBottomRight: function () {
		return this.max; // right, bottom
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof Point) {
			obj = toPoint(obj);
		} else {
			obj = toBounds(obj);
		}

		if (obj instanceof Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(corner1: Point, corner2: Point)
// Creates a Bounds object from two corners coordinate pairs.
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the given array of points.
function toBounds(a, b) {
	if (!a || a instanceof Bounds) {
		return a;
	}
	return new Bounds(a, b);
}

/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var corner1 = L.latLng(40.712, -74.227),
 * corner2 = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(corner1, corner2);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 *
 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
 *
 * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
	if (!corner1) { return; }

	var latlngs = corner2 ? [corner1, corner2] : corner1;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
}

LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new LatLng(sw2.lat, sw2.lng);
			this._northEast = new LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
	// Negative values will retract the bounds.
	pad: function (bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new LatLngBounds(
		        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
			obj = toLatLng(obj);
		} else {
			obj = toLatLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function (bounds, maxMargin) {
		if (!bounds) { return false; }

		bounds = toLatLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
		       this._northEast.equals(bounds.getNorthEast(), maxMargin);
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
function toLatLngBounds(a, b) {
	if (a instanceof LatLngBounds) {
		return a;
	}
	return new LatLngBounds(a, b);
}

/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 *
 * Note that `LatLng` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLng(lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
}

LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = toLatLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
		        formatNum(this.lat, precision) + ', ' +
		        formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
	distanceTo: function (other) {
		return Earth.distance(this, toLatLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return toLatLngBounds(
		        [this.lat - latAccuracy, this.lng - lngAccuracy],
		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

function toLatLng(a, b, c) {
	if (a instanceof LatLng) {
		return a;
	}
	if (isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new LatLng(a, b, c);
}

/*
 * @namespace CRS
 * @crs L.CRS.Base
 * Object that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 *
 * Note that the CRS instances do not inherit from Leafet's `Class` object,
 * and can't be instantiated. Also, new classes can't inherit from them,
 * and methods can't be added to them with the `include` function.
 */

var CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return new Bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return new LatLng(lat, lng, alt);
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring
	// that its center is within the CRS's bounds.
	// Only accepts actual `L.LatLngBounds` instances, not arrays.
	wrapLatLngBounds: function (bounds) {
		var center = bounds.getCenter(),
		    newCenter = this.wrapLatLng(center),
		    latShift = center.lat - newCenter.lat,
		    lngShift = center.lng - newCenter.lng;

		if (latShift === 0 && lngShift === 0) {
			return bounds;
		}

		var sw = bounds.getSouthWest(),
		    ne = bounds.getNorthEast(),
		    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
		    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

		return new LatLngBounds(newSw, newNe);
	}
};

/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

var Earth = extend({}, CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
		    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
		    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
		    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		return this.R * c;
	}
});

/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection — the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

var SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new Point(
			this.R * latlng.lng * d,
			this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return new Bounds([-d, -d], [d, d]);
	})()
};

/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = L.transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
function Transformation(a, b, c, d) {
	if (isArray(a)) {
		// use array properties
		this._a = a[0];
		this._b = a[1];
		this._c = a[2];
		this._d = a[3];
		return;
	}
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
}

Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts actual `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};

// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
// Instantiates a Transformation object with the given coefficients.

// @alternative
// @factory L.transformation(coefficients: Array): Transformation
// Expects an coefficients array of the form
// `[a: Number, b: Number, c: Number, d: Number]`.

function toTransformation(a, b, c, d) {
	return new Transformation(a, b, c, d);
}

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

var EPSG3857 = extend({}, Earth, {
	code: 'EPSG:3857',
	projection: SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * SphericalMercator.R);
		return toTransformation(scale, 0.5, -scale, 0.5);
	}())
});

var EPSG900913 = extend({}, EPSG3857, {
	code: 'EPSG:900913'
});

// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:

// @function create(name: String): SVGElement
// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
// corresponding to the class name passed. For example, using 'line' will return
// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
function svgCreate(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

// @function pointsToPath(rings: Point[], closed: Boolean): String
// Generates a SVG path string for multiple rings, with each ring turning
// into "M..L..L.." instructions
function pointsToPath(rings, closed) {
	var str = '',
	i, j, len, len2, points, p;

	for (i = 0, len = rings.length; i < len; i++) {
		points = rings[i];

		for (j = 0, len2 = points.length; j < len2; j++) {
			p = points[j];
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}

		// closes the ring for polygons; "x" is VML syntax
		str += closed ? (svg ? 'z' : 'x') : '';
	}

	// SVG complains about empty path strings
	return str || 'M0 0';
}

/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

var style$1 = document.documentElement.style;

// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
var ie = 'ActiveXObject' in window;

// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
var ielt9 = ie && !document.addEventListener;

// @property edge: Boolean; `true` for the Edge web browser.
var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

// @property webkit: Boolean;
// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
var webkit = userAgentContains('webkit');

// @property android: Boolean
// `true` for any browser running on an Android platform.
var android = userAgentContains('android');

// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
var android23 = userAgentContains('android 2') || userAgentContains('android 3');

/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
// @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)
var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

// @property opera: Boolean; `true` for the Opera browser
var opera = !!window.opera;

// @property chrome: Boolean; `true` for the Chrome browser.
var chrome = userAgentContains('chrome');

// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

// @property safari: Boolean; `true` for the Safari browser.
var safari = !chrome && userAgentContains('safari');

var phantom = userAgentContains('phantom');

// @property opera12: Boolean
// `true` for the Opera browser supporting CSS transforms (version 12 or later).
var opera12 = 'OTransition' in style$1;

// @property win: Boolean; `true` when the browser is running in a Windows platform
var win = navigator.platform.indexOf('Win') === 0;

// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
var ie3d = ie && ('transition' in style$1);

// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
var gecko3d = 'MozPerspective' in style$1;

// @property any3d: Boolean
// `true` for all browsers supporting CSS transforms.
var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

// @property mobile: Boolean; `true` for all browsers running in a mobile device.
var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
var mobileWebkit = mobile && webkit;

// @property mobileWebkit3d: Boolean
// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
var mobileWebkit3d = mobile && webkit3d;

// @property msPointer: Boolean
// `true` for browsers implementing the Microsoft touch events model (notably IE10).
var msPointer = !window.PointerEvent && window.MSPointerEvent;

// @property pointer: Boolean
// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
var pointer = !!(window.PointerEvent || msPointer);

// @property touch: Boolean
// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
// This does not necessarily mean that the browser is running in a computer with
// a touchscreen, it only means that the browser is capable of understanding
// touch events.
var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
		(window.DocumentTouch && document instanceof window.DocumentTouch));

// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
var mobileOpera = mobile && opera;

// @property mobileGecko: Boolean
// `true` for gecko-based browsers running in a mobile device.
var mobileGecko = mobile && gecko;

// @property retina: Boolean
// `true` for browsers on a high-resolution "retina" screen.
var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;


// @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
var canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect);

// @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
var vml = !svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());


function userAgentContains(str) {
	return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
}


var Browser = (Object.freeze || Object)({
	ie: ie,
	ielt9: ielt9,
	edge: edge,
	webkit: webkit,
	android: android,
	android23: android23,
	androidStock: androidStock,
	opera: opera,
	chrome: chrome,
	gecko: gecko,
	safari: safari,
	phantom: phantom,
	opera12: opera12,
	win: win,
	ie3d: ie3d,
	webkit3d: webkit3d,
	gecko3d: gecko3d,
	any3d: any3d,
	mobile: mobile,
	mobileWebkit: mobileWebkit,
	mobileWebkit3d: mobileWebkit3d,
	msPointer: msPointer,
	pointer: pointer,
	touch: touch,
	mobileOpera: mobileOpera,
	mobileGecko: mobileGecko,
	retina: retina,
	canvas: canvas,
	svg: svg,
	vml: vml
});

/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */


var POINTER_DOWN =   msPointer ? 'MSPointerDown'   : 'pointerdown';
var POINTER_MOVE =   msPointer ? 'MSPointerMove'   : 'pointermove';
var POINTER_UP =     msPointer ? 'MSPointerUp'     : 'pointerup';
var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];

var _pointers = {};
var _pointerDocListener = false;

// DomEvent.DoubleTap needs to know about this
var _pointersCount = 0;

// Provides a touch events wrapper for (ms)pointer events.
// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

function addPointerListener(obj, type, handler, id) {
	if (type === 'touchstart') {
		_addPointerStart(obj, handler, id);

	} else if (type === 'touchmove') {
		_addPointerMove(obj, handler, id);

	} else if (type === 'touchend') {
		_addPointerEnd(obj, handler, id);
	}

	return this;
}

function removePointerListener(obj, type, id) {
	var handler = obj['_leaflet_' + type + id];

	if (type === 'touchstart') {
		obj.removeEventListener(POINTER_DOWN, handler, false);

	} else if (type === 'touchmove') {
		obj.removeEventListener(POINTER_MOVE, handler, false);

	} else if (type === 'touchend') {
		obj.removeEventListener(POINTER_UP, handler, false);
		obj.removeEventListener(POINTER_CANCEL, handler, false);
	}

	return this;
}

function _addPointerStart(obj, handler, id) {
	var onDown = bind(function (e) {
		if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
			// In IE11, some touch events needs to fire for form controls, or
			// the controls will stop working. We keep a whitelist of tag names that
			// need these events. For other target tags, we prevent default on the event.
			if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
				preventDefault(e);
			} else {
				return;
			}
		}

		_handlePointer(e, handler);
	});

	obj['_leaflet_touchstart' + id] = onDown;
	obj.addEventListener(POINTER_DOWN, onDown, false);

	// need to keep track of what pointers and how many are active to provide e.touches emulation
	if (!_pointerDocListener) {
		// we listen documentElement as any drags that end by moving the touch off the screen get fired there
		document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
		document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
		document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
		document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

		_pointerDocListener = true;
	}
}

function _globalPointerDown(e) {
	_pointers[e.pointerId] = e;
	_pointersCount++;
}

function _globalPointerMove(e) {
	if (_pointers[e.pointerId]) {
		_pointers[e.pointerId] = e;
	}
}

function _globalPointerUp(e) {
	delete _pointers[e.pointerId];
	_pointersCount--;
}

function _handlePointer(e, handler) {
	e.touches = [];
	for (var i in _pointers) {
		e.touches.push(_pointers[i]);
	}
	e.changedTouches = [e];

	handler(e);
}

function _addPointerMove(obj, handler, id) {
	var onMove = function (e) {
		// don't fire touch moves when mouse isn't down
		if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

		_handlePointer(e, handler);
	};

	obj['_leaflet_touchmove' + id] = onMove;
	obj.addEventListener(POINTER_MOVE, onMove, false);
}

function _addPointerEnd(obj, handler, id) {
	var onUp = function (e) {
		_handlePointer(e, handler);
	};

	obj['_leaflet_touchend' + id] = onUp;
	obj.addEventListener(POINTER_UP, onUp, false);
	obj.addEventListener(POINTER_CANCEL, onUp, false);
}

/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';
var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';
var _pre = '_leaflet_';

// inspired by Zepto touch code by Thomas Fuchs
function addDoubleTapListener(obj, handler, id) {
	var last, touch$$1,
	    doubleTap = false,
	    delay = 250;

	function onTouchStart(e) {
		var count;

		if (pointer) {
			if ((!edge) || e.pointerType === 'mouse') { return; }
			count = _pointersCount;
		} else {
			count = e.touches.length;
		}

		if (count > 1) { return; }

		var now = Date.now(),
		    delta = now - (last || now);

		touch$$1 = e.touches ? e.touches[0] : e;
		doubleTap = (delta > 0 && delta <= delay);
		last = now;
	}

	function onTouchEnd(e) {
		if (doubleTap && !touch$$1.cancelBubble) {
			if (pointer) {
				if ((!edge) || e.pointerType === 'mouse') { return; }
				// work around .type being readonly with MSPointer* events
				var newTouch = {},
				    prop, i;

				for (i in touch$$1) {
					prop = touch$$1[i];
					newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
				}
				touch$$1 = newTouch;
			}
			touch$$1.type = 'dblclick';
			handler(touch$$1);
			last = null;
		}
	}

	obj[_pre + _touchstart + id] = onTouchStart;
	obj[_pre + _touchend + id] = onTouchEnd;
	obj[_pre + 'dblclick' + id] = handler;

	obj.addEventListener(_touchstart, onTouchStart, false);
	obj.addEventListener(_touchend, onTouchEnd, false);

	// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
	// the browser doesn't fire touchend/pointerup events but does fire
	// native dblclicks. See #4127.
	// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
	obj.addEventListener('dblclick', handler, false);

	return this;
}

function removeDoubleTapListener(obj, id) {
	var touchstart = obj[_pre + _touchstart + id],
	    touchend = obj[_pre + _touchend + id],
	    dblclick = obj[_pre + 'dblclick' + id];

	obj.removeEventListener(_touchstart, touchstart, false);
	obj.removeEventListener(_touchend, touchend, false);
	if (!edge) {
		obj.removeEventListener('dblclick', dblclick, false);
	}

	return this;
}

/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Adds a listener function (`fn`) to a particular DOM event type of the
// element `el`. You can optionally specify the context of the listener
// (object the `this` keyword will point to). You can also pass several
// space-separated types (e.g. `'click dblclick'`).

// @alternative
// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function on(obj, types, fn, context) {

	if (typeof types === 'object') {
		for (var type in types) {
			addOne(obj, type, types[type], fn);
		}
	} else {
		types = splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			addOne(obj, types[i], fn, context);
		}
	}

	return this;
}

var eventsKey = '_leaflet_events';

// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Removes a previously added listener function.
// Note that if you passed a custom context to on, you must pass the same
// context to `off` in order to remove the listener.

// @alternative
// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function off(obj, types, fn, context) {

	if (typeof types === 'object') {
		for (var type in types) {
			removeOne(obj, type, types[type], fn);
		}
	} else if (types) {
		types = splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			removeOne(obj, types[i], fn, context);
		}
	} else {
		for (var j in obj[eventsKey]) {
			removeOne(obj, j, obj[eventsKey][j]);
		}
		delete obj[eventsKey];
	}

	return this;
}

function addOne(obj, type, fn, context) {
	var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

	if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

	var handler = function (e) {
		return fn.call(context || obj, e || window.event);
	};

	var originalHandler = handler;

	if (pointer && type.indexOf('touch') === 0) {
		// Needs DomEvent.Pointer.js
		addPointerListener(obj, type, handler, id);

	} else if (touch && (type === 'dblclick') && addDoubleTapListener &&
	           !(pointer && chrome)) {
		// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
		// See #5180
		addDoubleTapListener(obj, handler, id);

	} else if ('addEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

		} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
			handler = function (e) {
				e = e || window.event;
				if (isExternalTarget(obj, e)) {
					originalHandler(e);
				}
			};
			obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

		} else {
			if (type === 'click' && android) {
				handler = function (e) {
					filterClick(e, originalHandler);
				};
			}
			obj.addEventListener(type, handler, false);
		}

	} else if ('attachEvent' in obj) {
		obj.attachEvent('on' + type, handler);
	}

	obj[eventsKey] = obj[eventsKey] || {};
	obj[eventsKey][id] = handler;
}

function removeOne(obj, type, fn, context) {

	var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
	    handler = obj[eventsKey] && obj[eventsKey][id];

	if (!handler) { return this; }

	if (pointer && type.indexOf('touch') === 0) {
		removePointerListener(obj, type, id);

	} else if (touch && (type === 'dblclick') && removeDoubleTapListener &&
	           !(pointer && chrome)) {
		removeDoubleTapListener(obj, id);

	} else if ('removeEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

		} else {
			obj.removeEventListener(
				type === 'mouseenter' ? 'mouseover' :
				type === 'mouseleave' ? 'mouseout' : type, handler, false);
		}

	} else if ('detachEvent' in obj) {
		obj.detachEvent('on' + type, handler);
	}

	obj[eventsKey][id] = null;
}

// @function stopPropagation(ev: DOMEvent): this
// Stop the given event from propagation to parent elements. Used inside the listener functions:
// ```js
// L.DomEvent.on(div, 'click', function (ev) {
// 	L.DomEvent.stopPropagation(ev);
// });
// ```
function stopPropagation(e) {

	if (e.stopPropagation) {
		e.stopPropagation();
	} else if (e.originalEvent) {  // In case of Leaflet event.
		e.originalEvent._stopped = true;
	} else {
		e.cancelBubble = true;
	}
	skipped(e);

	return this;
}

// @function disableScrollPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
function disableScrollPropagation(el) {
	addOne(el, 'mousewheel', stopPropagation);
	return this;
}

// @function disableClickPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
// `'mousedown'` and `'touchstart'` events (plus browser variants).
function disableClickPropagation(el) {
	on(el, 'mousedown touchstart dblclick', stopPropagation);
	addOne(el, 'click', fakeStop);
	return this;
}

// @function preventDefault(ev: DOMEvent): this
// Prevents the default action of the DOM Event `ev` from happening (such as
// following a link in the href of the a element, or doing a POST request
// with page reload when a `<form>` is submitted).
// Use it inside listener functions.
function preventDefault(e) {
	if (e.preventDefault) {
		e.preventDefault();
	} else {
		e.returnValue = false;
	}
	return this;
}

// @function stop(ev: DOMEvent): this
// Does `stopPropagation` and `preventDefault` at the same time.
function stop(e) {
	preventDefault(e);
	stopPropagation(e);
	return this;
}

// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
// Gets normalized mouse position from a DOM event relative to the
// `container` or to the whole page if not specified.
function getMousePosition(e, container) {
	if (!container) {
		return new Point(e.clientX, e.clientY);
	}

	var rect = container.getBoundingClientRect();

	var scaleX = rect.width / container.offsetWidth || 1;
	var scaleY = rect.height / container.offsetHeight || 1;
	return new Point(
		e.clientX / scaleX - rect.left - container.clientLeft,
		e.clientY / scaleY - rect.top - container.clientTop);
}

// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
// and Firefox scrolls device pixels, not CSS pixels
var wheelPxFactor =
	(win && chrome) ? 2 * window.devicePixelRatio :
	gecko ? window.devicePixelRatio : 1;

// @function getWheelDelta(ev: DOMEvent): Number
// Gets normalized wheel delta from a mousewheel DOM event, in vertical
// pixels scrolled (negative if scrolling down).
// Events from pointing devices without precise scrolling are mapped to
// a best guess of 60 pixels.
function getWheelDelta(e) {
	return (edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
	       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
	       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
	       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
	       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
	       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
	       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
	       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
	       0;
}

var skipEvents = {};

function fakeStop(e) {
	// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
	skipEvents[e.type] = true;
}

function skipped(e) {
	var events = skipEvents[e.type];
	// reset when checking, as it's only used in map container and propagates outside of the map
	skipEvents[e.type] = false;
	return events;
}

// check if element really left/entered the event target (for mouseenter/mouseleave)
function isExternalTarget(el, e) {

	var related = e.relatedTarget;

	if (!related) { return true; }

	try {
		while (related && (related !== el)) {
			related = related.parentNode;
		}
	} catch (err) {
		return false;
	}
	return (related !== el);
}

var lastClick;

// this is a horrible workaround for a bug in Android where a single touch triggers two click events
function filterClick(e, handler) {
	var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
	    elapsed = lastClick && (timeStamp - lastClick);

	// are they closer together than 500ms yet more than 100ms?
	// Android typically triggers them ~300ms apart while multiple listeners
	// on the same event should be triggered far faster;
	// or check if click is simulated on the element, and if it is, reject any non-simulated events

	if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
		stop(e);
		return;
	}
	lastClick = timeStamp;

	handler(e);
}




var DomEvent = (Object.freeze || Object)({
	on: on,
	off: off,
	stopPropagation: stopPropagation,
	disableScrollPropagation: disableScrollPropagation,
	disableClickPropagation: disableClickPropagation,
	preventDefault: preventDefault,
	stop: stop,
	getMousePosition: getMousePosition,
	getWheelDelta: getWheelDelta,
	fakeStop: fakeStop,
	skipped: skipped,
	isExternalTarget: isExternalTarget,
	addListener: on,
	removeListener: off
});

/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */


// @property TRANSFORM: String
// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
var TRANSFORM = testProp(
	['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

// @property TRANSITION: String
// Vendor-prefixed transition style name.
var TRANSITION = testProp(
	['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

// @property TRANSITION_END: String
// Vendor-prefixed transitionend event name.
var TRANSITION_END =
	TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


// @function get(id: String|HTMLElement): HTMLElement
// Returns an element given its DOM id, or returns the element itself
// if it was passed directly.
function get(id) {
	return typeof id === 'string' ? document.getElementById(id) : id;
}

// @function getStyle(el: HTMLElement, styleAttrib: String): String
// Returns the value for a certain style attribute on an element,
// including computed values or values set through CSS.
function getStyle(el, style) {
	var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

	if ((!value || value === 'auto') && document.defaultView) {
		var css = document.defaultView.getComputedStyle(el, null);
		value = css ? css[style] : null;
	}
	return value === 'auto' ? null : value;
}

// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
function create$1(tagName, className, container) {
	var el = document.createElement(tagName);
	el.className = className || '';

	if (container) {
		container.appendChild(el);
	}
	return el;
}

// @function remove(el: HTMLElement)
// Removes `el` from its parent element
function remove(el) {
	var parent = el.parentNode;
	if (parent) {
		parent.removeChild(el);
	}
}

// @function empty(el: HTMLElement)
// Removes all of `el`'s children elements from `el`
function empty(el) {
	while (el.firstChild) {
		el.removeChild(el.firstChild);
	}
}

// @function toFront(el: HTMLElement)
// Makes `el` the last child of its parent, so it renders in front of the other children.
function toFront(el) {
	var parent = el.parentNode;
	if (parent.lastChild !== el) {
		parent.appendChild(el);
	}
}

// @function toBack(el: HTMLElement)
// Makes `el` the first child of its parent, so it renders behind the other children.
function toBack(el) {
	var parent = el.parentNode;
	if (parent.firstChild !== el) {
		parent.insertBefore(el, parent.firstChild);
	}
}

// @function hasClass(el: HTMLElement, name: String): Boolean
// Returns `true` if the element's class attribute contains `name`.
function hasClass(el, name) {
	if (el.classList !== undefined) {
		return el.classList.contains(name);
	}
	var className = getClass(el);
	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
}

// @function addClass(el: HTMLElement, name: String)
// Adds `name` to the element's class attribute.
function addClass(el, name) {
	if (el.classList !== undefined) {
		var classes = splitWords(name);
		for (var i = 0, len = classes.length; i < len; i++) {
			el.classList.add(classes[i]);
		}
	} else if (!hasClass(el, name)) {
		var className = getClass(el);
		setClass(el, (className ? className + ' ' : '') + name);
	}
}

// @function removeClass(el: HTMLElement, name: String)
// Removes `name` from the element's class attribute.
function removeClass(el, name) {
	if (el.classList !== undefined) {
		el.classList.remove(name);
	} else {
		setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
	}
}

// @function setClass(el: HTMLElement, name: String)
// Sets the element's class.
function setClass(el, name) {
	if (el.className.baseVal === undefined) {
		el.className = name;
	} else {
		// in case of SVG element
		el.className.baseVal = name;
	}
}

// @function getClass(el: HTMLElement): String
// Returns the element's class.
function getClass(el) {
	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
}

// @function setOpacity(el: HTMLElement, opacity: Number)
// Set the opacity of an element (including old IE support).
// `opacity` must be a number from `0` to `1`.
function setOpacity(el, value) {
	if ('opacity' in el.style) {
		el.style.opacity = value;
	} else if ('filter' in el.style) {
		_setOpacityIE(el, value);
	}
}

function _setOpacityIE(el, value) {
	var filter = false,
	    filterName = 'DXImageTransform.Microsoft.Alpha';

	// filters collection throws an error if we try to retrieve a filter that doesn't exist
	try {
		filter = el.filters.item(filterName);
	} catch (e) {
		// don't set opacity to 1 if we haven't already set an opacity,
		// it isn't needed and breaks transparent pngs.
		if (value === 1) { return; }
	}

	value = Math.round(value * 100);

	if (filter) {
		filter.Enabled = (value !== 100);
		filter.Opacity = value;
	} else {
		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
	}
}

// @function testProp(props: String[]): String|false
// Goes through the array of style names and returns the first name
// that is a valid style name for an element. If no such name is found,
// it returns false. Useful for vendor-prefixed styles like `transform`.
function testProp(props) {
	var style = document.documentElement.style;

	for (var i = 0; i < props.length; i++) {
		if (props[i] in style) {
			return props[i];
		}
	}
	return false;
}

// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
// and optionally scaled by `scale`. Does not have an effect if the
// browser doesn't support 3D CSS transforms.
function setTransform(el, offset, scale) {
	var pos = offset || new Point(0, 0);

	el.style[TRANSFORM] =
		(ie3d ?
			'translate(' + pos.x + 'px,' + pos.y + 'px)' :
			'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
		(scale ? ' scale(' + scale + ')' : '');
}

// @function setPosition(el: HTMLElement, position: Point)
// Sets the position of `el` to coordinates specified by `position`,
// using CSS translate or top/left positioning depending on the browser
// (used by Leaflet internally to position its layers).
function setPosition(el, point) {

	/*eslint-disable */
	el._leaflet_pos = point;
	/* eslint-enable */

	if (any3d) {
		setTransform(el, point);
	} else {
		el.style.left = point.x + 'px';
		el.style.top = point.y + 'px';
	}
}

// @function getPosition(el: HTMLElement): Point
// Returns the coordinates of an element previously positioned with setPosition.
function getPosition(el) {
	// this method is only used for elements previously positioned using setPosition,
	// so it's safe to cache the position for performance

	return el._leaflet_pos || new Point(0, 0);
}

// @function disableTextSelection()
// Prevents the user from generating `selectstart` DOM events, usually generated
// when the user drags the mouse through a page with text. Used internally
// by Leaflet to override the behaviour of any click-and-drag interaction on
// the map. Affects drag interactions on the whole document.

// @function enableTextSelection()
// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
var disableTextSelection;
var enableTextSelection;
var _userSelect;
if ('onselectstart' in document) {
	disableTextSelection = function () {
		on(window, 'selectstart', preventDefault);
	};
	enableTextSelection = function () {
		off(window, 'selectstart', preventDefault);
	};
} else {
	var userSelectProperty = testProp(
		['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

	disableTextSelection = function () {
		if (userSelectProperty) {
			var style = document.documentElement.style;
			_userSelect = style[userSelectProperty];
			style[userSelectProperty] = 'none';
		}
	};
	enableTextSelection = function () {
		if (userSelectProperty) {
			document.documentElement.style[userSelectProperty] = _userSelect;
			_userSelect = undefined;
		}
	};
}

// @function disableImageDrag()
// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
// for `dragstart` DOM events, usually generated when the user drags an image.
function disableImageDrag() {
	on(window, 'dragstart', preventDefault);
}

// @function enableImageDrag()
// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
function enableImageDrag() {
	off(window, 'dragstart', preventDefault);
}

var _outlineElement;
var _outlineStyle;
// @function preventOutline(el: HTMLElement)
// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
// of the element `el` invisible. Used internally by Leaflet to prevent
// focusable elements from displaying an outline when the user performs a
// drag interaction on them.
function preventOutline(element) {
	while (element.tabIndex === -1) {
		element = element.parentNode;
	}
	if (!element.style) { return; }
	restoreOutline();
	_outlineElement = element;
	_outlineStyle = element.style.outline;
	element.style.outline = 'none';
	on(window, 'keydown', restoreOutline);
}

// @function restoreOutline()
// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
function restoreOutline() {
	if (!_outlineElement) { return; }
	_outlineElement.style.outline = _outlineStyle;
	_outlineElement = undefined;
	_outlineStyle = undefined;
	off(window, 'keydown', restoreOutline);
}


var DomUtil = (Object.freeze || Object)({
	TRANSFORM: TRANSFORM,
	TRANSITION: TRANSITION,
	TRANSITION_END: TRANSITION_END,
	get: get,
	getStyle: getStyle,
	create: create$1,
	remove: remove,
	empty: empty,
	toFront: toFront,
	toBack: toBack,
	hasClass: hasClass,
	addClass: addClass,
	removeClass: removeClass,
	setClass: setClass,
	getClass: getClass,
	setOpacity: setOpacity,
	testProp: testProp,
	setTransform: setTransform,
	setPosition: setPosition,
	getPosition: getPosition,
	disableTextSelection: disableTextSelection,
	enableTextSelection: enableTextSelection,
	disableImageDrag: disableImageDrag,
	enableImageDrag: enableImageDrag,
	preventOutline: preventOutline,
	restoreOutline: restoreOutline
});

/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

var PosAnimation = Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});

/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API — it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

var Map = Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = *
		// Minimum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the lowest of their `minZoom` options will be used instead.
		minZoom: undefined,

		// @option maxZoom: Number = *
		// Maximum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the highest of their `maxZoom` options will be used instead.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back if the user tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option zoomAnimation: Boolean = true
		// Whether the map zoom animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		zoomAnimation: true,

		// @option zoomAnimationThreshold: Number = 4
		// Won't animate zoom if the zoom difference exceeds this value.
		zoomAnimationThreshold: 4,

		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(toLatLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = TRANSITION && any3d && !mobileOpera &&
				this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			this._createAnimProxy();
			on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
		}

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = extend({animate: options.animate}, options.zoom);
				options.pan = extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		if (zoom === Infinity) {
			return {
				center: bounds.getCenter(),
				zoom: zoom
			};
		}

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = toLatLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point, options?: Pan options): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset, options) {
		offset = toPoint(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = toLatLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = (to.distanceTo(from)) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
			    // thus triggering an infinite loop in flyTo
			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true, options.noMoveStart);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = toLatLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		var oldZoom = this.options.minZoom;
		this.options.minZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() < this.options.minZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		var oldZoom = this.options.maxZoom;
		this.options.maxZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() > this.options.maxZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method invalidateSize(options: Zoom/pan options): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},

	// @section Geolocation methods
	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = extend({
			timeout: 10000,
			watch: false
			// setView: false
			// maxZoom: <Number>
			// maximumAge: 0
			// enableHighAccuracy: false
		}, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = bind(this._handleGeolocationResponse, this),
		    onError = bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	},

	// TODO Appropriate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/* eslint-enable */
			this._containerId = undefined;
		}

		if (this._locationWatchId !== undefined) {
			this.stopLocate();
		}

		this._stop();

		remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		var i;
		for (i in this._layers) {
			this._layers[i].remove();
		}
		for (i in this._panes) {
			remove(this._panes[i]);
		}

		this._layers = [];
		this._panes = [];
		delete this._mapPane;
		delete this._renderer;

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a child of `container`, or
	// as a child of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = create$1('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = toLatLngBounds(bounds);
		padding = toPoint(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
		    snap = any3d ? this.options.zoomSnap : 1,
		    scalex = size.x / boundsSize.x,
		    scaley = size.y / boundsSize.y,
		    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new Point(
				this._container.clientWidth || 0,
				this._container.clientHeight || 0);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(toPoint(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = toPoint(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(toLatLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(toLatLng(latlng));
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
	// its center is within the CRS's bounds.
	// By default this means the center longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees, and the majority of the bounds
	// overlaps the CRS's bounds.
	wrapLatLngBounds: function (latlng) {
		return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return toPoint(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return toPoint(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(toPoint(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		on(container, 'scroll', this._onScroll, this);
		this._containerId = stamp(container);
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && any3d;

		addClass(container, 'leaflet-container' +
			(touch ? ' leaflet-touch' : '') +
			(retina ? ' leaflet-retina' : '') +
			(ielt9 ? ' leaflet-oldie' : '') +
			(safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		setPosition(this._mapPane, new Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for `Tooltip`s.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			addClass(panes.markerPane, 'leaflet-zoom-hide');
			addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		setPosition(this._mapPane, new Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged, false)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged, noMoveStart) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		if (!noMoveStart) {
			this.fire('movestart');
		}
		return this;
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove$$1) {
		this._targets = {};
		this._targets[stamp(this._container)] = this;

		var onOff = remove$$1 ? off : on;

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused.
		onOff(this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			onOff(window, 'resize', this._onResize, this);
		}

		if (any3d && this.options.transform3DLimit) {
			(remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || skipped(e)) { return; }

		var type = e.type;

		if (type === 'mousedown' || type === 'keypress') {
			// prevents outline when clicking on keyboard-focusable element
			preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
			data.containerPoint = isMarker ?
				this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return getPosition(this._mapPane) || new Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return toBounds([
			this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
		]);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = toBounds(
		        this.project(maxBounds.getNorthEast(), zoom),
		        this.project(maxBounds.getSouthWest(), zoom)
		    ),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._trunc();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	},

	_createAnimProxy: function () {

		var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = TRANSFORM,
			    transform = this._proxy.style[prop];

			setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === this._proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);

		this._on('unload', this._destroyAnimProxy, this);
	},

	_destroyAnimProxy: function () {
		remove(this._proxy);
		delete this._proxy;
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		requestAnimFrame(function () {
			this
			    ._moveStart(true, false)
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (!this._mapPane) { return; }

		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired on every frame of a zoom animation
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		if (this._mapPane) {
			removeClass(this._mapPane, 'leaflet-zoom-anim');
		}

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
function createMap(id, options) {
	return new Map(id, options);
}

/*
 * @class Control
 * @aka L.Control
 * @inherits Class
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

var Control = Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

var control = function (options) {
	return new Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            create$1('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = create$1('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		for (var i in this._controlCorners) {
			remove(this._controlCorners[i]);
		}
		remove(this._controlContainer);
		delete this._controlCorners;
		delete this._controlContainer;
	}
});

/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */

var Layers = Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false,

		// @option sortLayers: Boolean = false
		// Whether to sort the layers. When `false`, layers will keep the order
		// in which they were added to the control.
		sortLayers: false,

		// @option sortFunction: Function = *
		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
		// that will be used for sorting the layers, when `sortLayers` is `true`.
		// The function receives both the `L.Layer` instances and their names, as in
		// `sortFunction(layerA, layerB, nameA, nameB)`.
		// By default, it sorts layers alphabetically by their name.
		sortFunction: function (layerA, layerB, nameA, nameB) {
			return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
		}
	},

	initialize: function (baseLayers, overlays, options) {
		setOptions(this, options);

		this._layerControlInputs = [];
		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.on('add remove', this._onLayerChange, this);
		}

		return this._container;
	},

	addTo: function (map) {
		Control.prototype.addTo.call(this, map);
		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
		return this._expandIfNotCollapsed();
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		addClass(this._container, 'leaflet-control-layers-expanded');
		this._form.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._form.clientHeight) {
			addClass(this._form, 'leaflet-control-layers-scrollbar');
			this._form.style.height = acceptableHeight + 'px';
		} else {
			removeClass(this._form, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = create$1('div', className),
		    collapsed = this.options.collapsed;

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		disableClickPropagation(container);
		disableScrollPropagation(container);

		var form = this._form = create$1('form', className + '-list');

		if (collapsed) {
			this._map.on('click', this.collapse, this);

			if (!android) {
				on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}
		}

		var link = this._layersLink = create$1('a', className + '-toggle', container);
		link.href = '#';
		link.title = 'Layers';

		if (touch) {
			on(link, 'click', stop);
			on(link, 'click', this.expand, this);
		} else {
			on(link, 'focus', this.expand, this);
		}

		if (!collapsed) {
			this.expand();
		}

		this._baseLayersList = create$1('div', className + '-base', form);
		this._separator = create$1('div', className + '-separator', form);
		this._overlaysList = create$1('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		if (this._map) {
			layer.on('add remove', this._onLayerChange, this);
		}

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.sortLayers) {
			this._layers.sort(bind(function (a, b) {
				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
			}, this));
		}

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}

		this._expandIfNotCollapsed();
	},

	_update: function () {
		if (!this._container) { return this; }

		empty(this._baseLayersList);
		empty(this._overlaysList);

		this._layerControlInputs = [];
		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		this._layerControlInputs.push(input);
		input.layerId = stamp(obj.layer);

		on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._layerControlInputs,
		    input, layer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;

			if (input.checked) {
				addedLayers.push(layer);
			} else if (!input.checked) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			if (this._map.hasLayer(removedLayers[i])) {
				this._map.removeLayer(removedLayers[i]);
			}
		}
		for (i = 0; i < addedLayers.length; i++) {
			if (!this._map.hasLayer(addedLayers[i])) {
				this._map.addLayer(addedLayers[i]);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._layerControlInputs,
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expandIfNotCollapsed: function () {
		if (this._map && !this.options.collapsed) {
			this.expand();
		}
		return this;
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
var layers = function (baseLayers, overlays, options) {
	return new Layers(baseLayers, overlays, options);
};

/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

var Zoom = Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '&#x2212;'
		// The text set on the 'zoom out' button.
		zoomOutText: '&#x2212;',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = create$1('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = create$1('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		/*
		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
		 */
		link.setAttribute('role', 'button');
		link.setAttribute('aria-label', title);

		disableClickPropagation(link);
		on(link, 'click', stop);
		on(link, 'click', fn, this);
		on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
		    className = 'leaflet-disabled';

		removeClass(this._zoomInButton, className);
		removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
Map.mergeOptions({
	zoomControl: true
});

Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
var zoom = function (options) {
	return new Zoom(options);
};

/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

var Scale = Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = create$1('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = create$1('div', className, container);
		}
		if (options.imperial) {
			this._iScale = create$1('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(
			map.containerPointToLatLng([0, y]),
			map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
var scale = function (options) {
	return new Scale(options);
};

/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

var Attribution = Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = create$1('div', 'leaflet-control-attribution');
		disableClickPropagation(this._container);

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
Map.mergeOptions({
	attributionControl: true
});

Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
var attribution = function (options) {
	return new Attribution(options);
};

Control.Layers = Layers;
Control.Zoom = Zoom;
Control.Scale = Scale;
Control.Attribution = Attribution;

control.layers = layers;
control.zoom = zoom;
control.scale = scale;
control.attribution = attribution;

/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

var Handler = Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});

// @section There is static function which can be called without instantiating L.Handler:
// @function addTo(map: Map, name: String): this
// Adds a new Handler to the given map with the given name.
Handler.addTo = function (map, name) {
	map.addHandler(name, this);
	return this;
};

var Mixin = {Events: Events};

/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

var START = touch ? 'touchstart mousedown' : 'mousedown';
var END = {
	mousedown: 'mouseup',
	touchstart: 'touchend',
	pointerdown: 'touchend',
	MSPointerDown: 'touchend'
};
var MOVE = {
	mousedown: 'mousemove',
	touchstart: 'touchmove',
	pointerdown: 'touchmove',
	MSPointerDown: 'touchmove'
};


var Draggable = Evented.extend({

	options: {
		// @section
		// @aka Draggable options
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline$$1, options) {
		setOptions(this, options);

		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline$$1;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		on(this._dragStartTarget, START, this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		// If we're currently dragging this draggable,
		// disabling it counts as first ending the drag.
		if (Draggable._dragging === this) {
			this.finishDrag();
		}

		off(this._dragStartTarget, START, this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
		Draggable._dragging = this;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			preventOutline(this._element);
		}

		disableImageDrag();
		disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new Point(first.clientX, first.clientY);

		on(document, MOVE[e.type], this._onMove, this);
		on(document, END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = getPosition(this._element).subtract(offset);

			addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }
		this.finishDrag();
	},

	finishDrag: function () {
		removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in MOVE) {
			off(document, MOVE[i], this._onMove, this);
			off(document, END[i], this._onUp, this);
		}

		enableImageDrag();
		enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		Draggable._dragging = false;
	}

});

/*
 * @namespace LineUtil
 *
 * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
 */

// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
// Improves rendering performance dramatically by lessening the number of points to draw.

// @function simplify(points: Point[], tolerance: Number): Point[]
// Dramatically reduces the number of points in a polyline while retaining
// its shape and returns a new array of simplified points, using the
// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
// Used for a huge performance boost when processing/displaying Leaflet polylines for
// each zoom level and also reducing visual noise. tolerance affects the amount of
// simplification (lesser value means higher quality but slower and with more points).
// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
function simplify(points, tolerance) {
	if (!tolerance || !points.length) {
		return points.slice();
	}

	var sqTolerance = tolerance * tolerance;

	    // stage 1: vertex reduction
	    points = _reducePoints(points, sqTolerance);

	    // stage 2: Douglas-Peucker simplification
	    points = _simplifyDP(points, sqTolerance);

	return points;
}

// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
// Returns the distance between point `p` and segment `p1` to `p2`.
function pointToSegmentDistance(p, p1, p2) {
	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
}

// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
// Returns the closest point from a point `p` on a segment `p1` to `p2`.
function closestPointOnSegment(p, p1, p2) {
	return _sqClosestPointOnSegment(p, p1, p2);
}

// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
function _simplifyDP(points, sqTolerance) {

	var len = points.length,
	    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
	    markers = new ArrayConstructor(len);

	    markers[0] = markers[len - 1] = 1;

	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

	var i,
	    newPoints = [];

	for (i = 0; i < len; i++) {
		if (markers[i]) {
			newPoints.push(points[i]);
		}
	}

	return newPoints;
}

function _simplifyDPStep(points, markers, sqTolerance, first, last) {

	var maxSqDist = 0,
	index, i, sqDist;

	for (i = first + 1; i <= last - 1; i++) {
		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

		if (sqDist > maxSqDist) {
			index = i;
			maxSqDist = sqDist;
		}
	}

	if (maxSqDist > sqTolerance) {
		markers[index] = 1;

		_simplifyDPStep(points, markers, sqTolerance, first, index);
		_simplifyDPStep(points, markers, sqTolerance, index, last);
	}
}

// reduce points that are too close to each other to a single point
function _reducePoints(points, sqTolerance) {
	var reducedPoints = [points[0]];

	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
		if (_sqDist(points[i], points[prev]) > sqTolerance) {
			reducedPoints.push(points[i]);
			prev = i;
		}
	}
	if (prev < len - 1) {
		reducedPoints.push(points[len - 1]);
	}
	return reducedPoints;
}

var _lastCode;

// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
// Clips the segment a to b by rectangular bounds with the
// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
// (modifying the segment points directly!). Used by Leaflet to only show polyline
// points that are on the screen or near, increasing performance.
function clipSegment(a, b, bounds, useLastCode, round) {
	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
	    codeB = _getBitCode(b, bounds),

	    codeOut, p, newCode;

	    // save 2nd code to avoid calculating it on the next segment
	    _lastCode = codeB;

	while (true) {
		// if a,b is inside the clip window (trivial accept)
		if (!(codeA | codeB)) {
			return [a, b];
		}

		// if a,b is outside the clip window (trivial reject)
		if (codeA & codeB) {
			return false;
		}

		// other cases
		codeOut = codeA || codeB;
		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
		newCode = _getBitCode(p, bounds);

		if (codeOut === codeA) {
			a = p;
			codeA = newCode;
		} else {
			b = p;
			codeB = newCode;
		}
	}
}

function _getEdgeIntersection(a, b, code, bounds, round) {
	var dx = b.x - a.x,
	    dy = b.y - a.y,
	    min = bounds.min,
	    max = bounds.max,
	    x, y;

	if (code & 8) { // top
		x = a.x + dx * (max.y - a.y) / dy;
		y = max.y;

	} else if (code & 4) { // bottom
		x = a.x + dx * (min.y - a.y) / dy;
		y = min.y;

	} else if (code & 2) { // right
		x = max.x;
		y = a.y + dy * (max.x - a.x) / dx;

	} else if (code & 1) { // left
		x = min.x;
		y = a.y + dy * (min.x - a.x) / dx;
	}

	return new Point(x, y, round);
}

function _getBitCode(p, bounds) {
	var code = 0;

	if (p.x < bounds.min.x) { // left
		code |= 1;
	} else if (p.x > bounds.max.x) { // right
		code |= 2;
	}

	if (p.y < bounds.min.y) { // bottom
		code |= 4;
	} else if (p.y > bounds.max.y) { // top
		code |= 8;
	}

	return code;
}

// square distance (to avoid unnecessary Math.sqrt calls)
function _sqDist(p1, p2) {
	var dx = p2.x - p1.x,
	    dy = p2.y - p1.y;
	return dx * dx + dy * dy;
}

// return closest point on segment or distance to that point
function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
	var x = p1.x,
	    y = p1.y,
	    dx = p2.x - x,
	    dy = p2.y - y,
	    dot = dx * dx + dy * dy,
	    t;

	if (dot > 0) {
		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

		if (t > 1) {
			x = p2.x;
			y = p2.y;
		} else if (t > 0) {
			x += dx * t;
			y += dy * t;
		}
	}

	dx = p.x - x;
	dy = p.y - y;

	return sqDist ? dx * dx + dy * dy : new Point(x, y);
}


// @function isFlat(latlngs: LatLng[]): Boolean
// Returns true if `latlngs` is a flat array, false is nested.
function isFlat(latlngs) {
	return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
}

function _flat(latlngs) {
	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
	return isFlat(latlngs);
}


var LineUtil = (Object.freeze || Object)({
	simplify: simplify,
	pointToSegmentDistance: pointToSegmentDistance,
	closestPointOnSegment: closestPointOnSegment,
	clipSegment: clipSegment,
	_getEdgeIntersection: _getEdgeIntersection,
	_getBitCode: _getBitCode,
	_sqClosestPointOnSegment: _sqClosestPointOnSegment,
	isFlat: isFlat,
	_flat: _flat
});

/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a separate method for it.
 */
function clipPolygon(points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = _getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = _getEdgeIntersection(b, a, edge, bounds, round);
					p._code = _getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = _getEdgeIntersection(b, a, edge, bounds, round);
				p._code = _getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
}


var PolyUtil = (Object.freeze || Object)({
	clipPolygon: clipPolygon
});

/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection — the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:4326` and `Simple` CRS.
 */

var LonLat = {
	project: function (latlng) {
		return new Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new LatLng(point.y, point.x);
	},

	bounds: new Bounds([-180, -90], [180, 90])
};

/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

var Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new LatLng(phi * d, point.x * d / r);
	}
};

/*
 * @class Projection

 * An object with methods for projecting geographical coordinates of the world onto
 * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).

 * @property bounds: Bounds
 * The bounds (specified in CRS units) where the projection is valid

 * @method project(latlng: LatLng): Point
 * Projects geographical coordinates into a 2D point.
 * Only accepts actual `L.LatLng` instances, not arrays.

 * @method unproject(point: Point): LatLng
 * The inverse of `project`. Projects a 2D point into a geographical location.
 * Only accepts actual `L.Point` instances, not arrays.

 * Note that the projection instances do not inherit from Leafet's `Class` object,
 * and can't be instantiated. Also, new classes can't inherit from them,
 * and methods can't be added to them with the `include` function.

 */




var index = (Object.freeze || Object)({
	LonLat: LonLat,
	Mercator: Mercator,
	SphericalMercator: SphericalMercator
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */
var EPSG3395 = extend({}, Earth, {
	code: 'EPSG:3395',
	projection: Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * Mercator.R);
		return toTransformation(scale, 0.5, -scale, 0.5);
	}())
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 *
 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
 */

var EPSG4326 = extend({}, Earth, {
	code: 'EPSG:4326',
	projection: LonLat,
	transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
});

/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

var Simple = extend({}, CRS, {
	projection: LonLat,
	transformation: toTransformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});

CRS.Earth = Earth;
CRS.EPSG3395 = EPSG3395;
CRS.EPSG3857 = EPSG3857;
CRS.EPSG900913 = EPSG900913;
CRS.EPSG4326 = EPSG4326;
CRS.Simple = Simple;

/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


var Layer = Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',

		// @option attribution: String = null
		// String to be shown in the attribution control, describes the layer data, e.g. "© Mapbox".
		attribution: null,

		bubblingMouseEvents: true
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map|LayerGroup): this
	 * Adds the layer to the given map or layer group.
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[stamp(targetEl)];
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && map.attributionControl) {
			map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		if (!layer._layerAdd) {
			throw new Error('The provided object is not a Layer.');
		}

		var id = stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}

		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
			this.setZoom(this._layersMaxZoom);
		}
		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
			this.setZoom(this._layersMinZoom);
		}
	}
});

/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

var LayerGroup = Layer.extend({

	initialize: function (layers, options) {
		setOptions(this, options);

		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	// @alternative
	// @method hasLayer(id: Number): Boolean
	// Returns `true` if the given internal ID is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		return this.eachLayer(this.removeLayer, this);
	},

	// @method invoke(methodName: String, …): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		this.eachLayer(map.addLayer, map);
	},

	onRemove: function (map) {
		this.eachLayer(map.removeLayer, map);
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];
		this.eachLayer(layers.push, layers);
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return stamp(layer);
	}
});


// @factory L.layerGroup(layers?: Layer[], options?: Object)
// Create a layer group, optionally given an initial set of layers and an `options` object.
var layerGroup = function (layers, options) {
	return new LayerGroup(layers, options);
};

/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

var FeatureGroup = LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the back of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
var featureGroup = function (layers) {
	return new FeatureGroup(layers);
};

/*
 * @class Icon
 * @aka L.Icon
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

var Icon = Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = [0, 0]
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option tooltipAnchor: Point = [0, 0]
	 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	options: {
		popupAnchor: [0, 0],
		tooltipAnchor: [0, 0],
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = toPoint(sizeOption),
		    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
function icon(options) {
	return new Icon(options);
}

/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 *
 * If you want to _completely_ replace the default icon, override the
 * `L.Marker.prototype.options.icon` with your own icon instead.
 */

var IconDefault = Icon.extend({

	options: {
		iconUrl:       'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl:     'marker-shadow.png',
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		if (!IconDefault.imagePath) {	// Deprecated, backwards-compatibility only
			IconDefault.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `Icon.Default` will try to auto-detect the location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right path.
		return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function () {
		var el = create$1('div',  'leaflet-default-icon-path', document.body);
		var path = getStyle(el, 'background-image') ||
		           getStyle(el, 'backgroundImage');	// IE8

		document.body.removeChild(el);

		if (path === null || path.indexOf('url') !== 0) {
			path = '';
		} else {
			path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
		}

		return path;
	}
});

/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
 */

var MarkerDrag = Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_adjustPan: function (e) {
		var marker = this._marker,
		    map = marker._map,
		    speed = this._marker.options.autoPanSpeed,
		    padding = this._marker.options.autoPanPadding,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    bounds = map.getPixelBounds(),
		    origin = map.getPixelOrigin();

		var panBounds = toBounds(
			bounds.min._subtract(origin).add(padding),
			bounds.max._subtract(origin).subtract(padding)
		);

		if (!panBounds.contains(iconPos)) {
			// Compute incremental movement
			var movement = toPoint(
				(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
				(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

				(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
				(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
			).multiplyBy(speed);

			map.panBy(movement, {animate: false});

			this._draggable._newPos._add(movement);
			this._draggable._startPos._add(movement);

			L.DomUtil.setPosition(marker._icon, this._draggable._newPos);
			this._onDrag(e);

			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
		}
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onPreDrag: function (e) {
		if (this._marker.options.autoPan) {
			cancelAnimFrame(this._panRequest);
			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
		}
	},

	_onDrag: function (e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		iconPos = getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		 cancelAnimFrame(this._panRequest);

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});

/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

var Marker = Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon instance to use for rendering the marker.
		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
		// If not specified, a common instance of `L.Icon.Default` is used.
		icon: new IconDefault(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option autoPan: Boolean = false
		// Set it to `true` if you want the map to do panning animation when marker hits the edges.
		autoPan: false,

		// @option autoPanPadding: Point = Point(50, 50)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [50, 50],

		// @option autoPanSpeed: Number = 10
		// Number of pixels the map should move by.
		autoPanSpeed: 10,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// @option bubblingMouseEvents: Boolean = false
		// When `true`, a mouse event on this marker will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: false
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		setOptions(this, options);
		this._latlng = toLatLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}
		delete this.dragging;

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = toLatLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon && this._map) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}

			if (icon.tagName === 'IMG') {
				icon.alt = options.alt || '';
			}
		}

		addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			addClass(newShadow, classToAdd);
			newShadow.alt = '';
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		setPosition(this._icon, pos);

		if (this._shadow) {
			setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		setOpacity(this._icon, opacity);

		if (this._shadow) {
			setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	},

	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor;
	},

	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor;
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
function marker(latlng, options) {
	return new Marker(latlng, options);
}

/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

var Path = Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option bubblingMouseEvents: Boolean = true
		// When `true`, a mouse event on this path will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in child classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
	}
});

/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

var CircleMarker = Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		setOptions(this, options);
		this._latlng = toLatLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		this._latlng = toLatLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p) {
		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
function circleMarker(latlng, options) {
	return new CircleMarker(latlng, options);
}

/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

var Circle = CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = extend({}, legacyOptions, {radius: options});
		}
		setOptions(this, options);
		this._latlng = toLatLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
			this._radiusY = p.y - top.y;

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
function circle(latlng, options, legacyOptions) {
	return new Circle(latlng, options, legacyOptions);
}

/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[45.51, -122.68],
 * 	[37.77, -122.43],
 * 	[34.04, -118.2]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[45.51, -122.68],
 * 	 [37.77, -122.43],
 * 	 [34.04, -118.2]],
 * 	[[40.78, -73.91],
 * 	 [41.83, -87.62],
 * 	 [32.76, -96.72]]
 * ];
 * ```
 */


var Polyline = Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	// @method closestLayerPoint: Point
	// Returns the point closest to `p` on the Polyline.
	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = _sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = toLatLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = isFlat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = toLatLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
		    p = new Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p, closed) {
		var i, j, k, len, len2, part,
		    w = this._clickTolerance();

		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

		// hit detection for polylines
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && (j === 0)) { continue; }

				if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
					return true;
				}
			}
		}
		return false;
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
function polyline(latlngs, options) {
	return new Polyline(latlngs, options);
}

// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
Polyline._flat = _flat;

/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 *   ],
 *   [ // second polygon
 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
 *   ]
 * ];
 * ```
 */

var Polygon = Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, j, p1, p2, f, area, x, y, center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		Polyline.prototype._setLatLngs.call(this, latlngs);
		if (isFlat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p) {
		var inside = false,
		    part, p1, p2, i, j, k, len, len2;

		if (!this._pxBounds.contains(p)) { return false; }

		// ray casting algorithm for detecting if point is in polygon
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
					inside = !inside;
				}
			}
		}

		// also check if it's on polygon stroke
		return inside || Polyline.prototype._containsPoint.call(this, p, true);
	}

});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
function polygon(latlngs, options) {
	return new Polygon(latlngs, options);
}

/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

var GeoJSON = FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to include a feature or not.
	 * The default is to include all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 * Note: dynamically changing the `filter` option will have effect only on newly
	 * added data. It will _not_ re-evaluate already included features.
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 */

	initialize: function (geojson, options) {
		setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): this
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer ): this
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): this
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:

// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
// Creates a `Layer` from a given GeoJSON feature. Can use a custom
// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
// functions if provided as options.
function geometryToLayer(geojson, options) {

	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
	    coords = geometry ? geometry.coordinates : null,
	    layers = [],
	    pointToLayer = options && options.pointToLayer,
	    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
	    latlng, latlngs, i, len;

	if (!coords && !geometry) {
		return null;
	}

	switch (geometry.type) {
	case 'Point':
		latlng = _coordsToLatLng(coords);
		return pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng);

	case 'MultiPoint':
		for (i = 0, len = coords.length; i < len; i++) {
			latlng = _coordsToLatLng(coords[i]);
			layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng));
		}
		return new FeatureGroup(layers);

	case 'LineString':
	case 'MultiLineString':
		latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
		return new Polyline(latlngs, options);

	case 'Polygon':
	case 'MultiPolygon':
		latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
		return new Polygon(latlngs, options);

	case 'GeometryCollection':
		for (i = 0, len = geometry.geometries.length; i < len; i++) {
			var layer = geometryToLayer({
				geometry: geometry.geometries[i],
				type: 'Feature',
				properties: geojson.properties
			}, options);

			if (layer) {
				layers.push(layer);
			}
		}
		return new FeatureGroup(layers);

	default:
		throw new Error('Invalid GeoJSON object.');
	}
}

// @function coordsToLatLng(coords: Array): LatLng
// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
function coordsToLatLng(coords) {
	return new LatLng(coords[1], coords[0], coords[2]);
}

// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
	var latlngs = [];

	for (var i = 0, len = coords.length, latlng; i < len; i++) {
		latlng = levelsDeep ?
			coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
			(_coordsToLatLng || coordsToLatLng)(coords[i]);

		latlngs.push(latlng);
	}

	return latlngs;
}

// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
function latLngToCoords(latlng, precision) {
	precision = typeof precision === 'number' ? precision : 6;
	return latlng.alt !== undefined ?
		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
}

// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
	var coords = [];

	for (var i = 0, len = latlngs.length; i < len; i++) {
		coords.push(levelsDeep ?
			latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) :
			latLngToCoords(latlngs[i], precision));
	}

	if (!levelsDeep && closed) {
		coords.push(coords[0]);
	}

	return coords;
}

function getFeature(layer, newGeometry) {
	return layer.feature ?
		extend({}, layer.feature, {geometry: newGeometry}) :
		asFeature(newGeometry);
}

// @function asFeature(geojson: Object): Object
// Normalize GeoJSON geometries/features into GeoJSON features.
function asFeature(geojson) {
	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
		return geojson;
	}

	return {
		type: 'Feature',
		properties: {},
		geometry: geojson
	};
}

var PointToGeoJSON = {
	toGeoJSON: function (precision) {
		return getFeature(this, {
			type: 'Point',
			coordinates: latLngToCoords(this.getLatLng(), precision)
		});
	}
};

// @namespace Marker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
Circle.include(PointToGeoJSON);
CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
Polyline.include({
	toGeoJSON: function (precision) {
		var multi = !isFlat(this._latlngs);

		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'LineString',
			coordinates: coords
		});
	}
});

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
Polygon.include({
	toGeoJSON: function (precision) {
		var holes = !isFlat(this._latlngs),
		    multi = holes && !isFlat(this._latlngs[0]);

		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

		if (!holes) {
			coords = [coords];
		}

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'Polygon',
			coordinates: coords
		});
	}
});


// @namespace LayerGroup
LayerGroup.include({
	toMultiPoint: function (precision) {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
		});

		return getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
	toGeoJSON: function (precision) {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint(precision);
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON(precision);
				if (isGeometryCollection) {
					jsons.push(json.geometry);
				} else {
					var feature = asFeature(json);
					// Squash nested feature collections
					if (feature.type === 'FeatureCollection') {
						jsons.push.apply(jsons, feature.features);
					} else {
						jsons.push(feature);
					}
				}
			}
		});

		if (isGeometryCollection) {
			return getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
function geoJSON(geojson, options) {
	return new GeoJSON(geojson, options);
}

// Backward compatibility.
var geoJson = geoJSON;

/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

var ImageOverlay = Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option crossOrigin: Boolean = false
		// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
		crossOrigin: false,

		// @option errorOverlayUrl: String = ''
		// URL to the overlay image to show in place of the overlay that failed to load.
		errorOverlayUrl: '',

		// @option zIndex: Number = 1
		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the tile layer.
		zIndex: 1,

		// @option className: String = ''
		// A custom class name to assign to the image. Empty by default.
		className: '',
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = toLatLngBounds(bounds);

		setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	// @method setBounds(bounds: LatLngBounds): this
	// Update the bounds that this ImageOverlay covers
	setBounds: function (bounds) {
		this._bounds = toLatLngBounds(bounds);

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @method: setZIndex(value: Number) : this
	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
	setZIndex: function (value) {
		this.options.zIndex = value;
		this._updateZIndex();
		return this;
	},

	// @method getBounds(): LatLngBounds
	// Get the bounds that this ImageOverlay covers
	getBounds: function () {
		return this._bounds;
	},

	// @method getElement(): HTMLElement
	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
	// used by this overlay.
	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var wasElementSupplied = this._url.tagName === 'IMG';
		var img = this._image = wasElementSupplied ? this._url : create$1('img');

		addClass(img, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
		if (this.options.className) { addClass(img, this.options.className); }

		img.onselectstart = falseFn;
		img.onmousemove = falseFn;

		// @event load: Event
		// Fired when the ImageOverlay layer has loaded its image
		img.onload = bind(this.fire, this, 'load');
		img.onerror = bind(this._overlayOnError, this, 'error');

		if (this.options.crossOrigin) {
			img.crossOrigin = '';
		}

		if (this.options.zIndex) {
			this._updateZIndex();
		}

		if (wasElementSupplied) {
			this._url = img.src;
			return;
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

		setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		setOpacity(this._image, this.options.opacity);
	},

	_updateZIndex: function () {
		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._image.style.zIndex = this.options.zIndex;
		}
	},

	_overlayOnError: function () {
		// @event error: Event
		// Fired when the ImageOverlay layer has loaded its image
		this.fire('error');

		var errorUrl = this.options.errorOverlayUrl;
		if (errorUrl && this._url !== errorUrl) {
			this._url = errorUrl;
			this._image.src = errorUrl;
		}
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
var imageOverlay = function (url, bounds, options) {
	return new ImageOverlay(url, bounds, options);
};

/*
 * @class VideoOverlay
 * @aka L.VideoOverlay
 * @inherits ImageOverlay
 *
 * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
 *
 * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
 * HTML5 element.
 *
 * @example
 *
 * ```js
 * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
 * 	videoBounds = [[ 32, -130], [ 13, -100]];
 * L.VideoOverlay(videoUrl, videoBounds ).addTo(map);
 * ```
 */

var VideoOverlay = ImageOverlay.extend({

	// @section
	// @aka VideoOverlay options
	options: {
		// @option autoplay: Boolean = true
		// Whether the video starts playing automatically when loaded.
		autoplay: true,

		// @option loop: Boolean = true
		// Whether the video will loop back to the beginning when played.
		loop: true
	},

	_initImage: function () {
		var wasElementSupplied = this._url.tagName === 'VIDEO';
		var vid = this._image = wasElementSupplied ? this._url : create$1('video');

		addClass(vid, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }

		vid.onselectstart = falseFn;
		vid.onmousemove = falseFn;

		// @event load: Event
		// Fired when the video has finished loading the first frame
		vid.onloadeddata = bind(this.fire, this, 'load');

		if (wasElementSupplied) {
			var sourceElements = vid.getElementsByTagName('source');
			var sources = [];
			for (var j = 0; j < sourceElements.length; j++) {
				sources.push(sourceElements[j].src);
			}

			this._url = (sourceElements.length > 0) ? sources : [vid.src];
			return;
		}

		if (!isArray(this._url)) { this._url = [this._url]; }

		vid.autoplay = !!this.options.autoplay;
		vid.loop = !!this.options.loop;
		for (var i = 0; i < this._url.length; i++) {
			var source = create$1('source');
			source.src = this._url[i];
			vid.appendChild(source);
		}
	}

	// @method getElement(): HTMLVideoElement
	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
	// used by this overlay.
});


// @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
// Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
// geographical bounds it is tied to.

function videoOverlay(video, bounds, options) {
	return new VideoOverlay(video, bounds, options);
}

/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
var DivOverlay = Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
		} else {
			remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = toLatLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			toBack(this._container);
		}
		return this;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = toPoint(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});

/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
var Popup = DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when another popup is opened.
		autoClose: true,

		// @option closeOnEscapeKey: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the ESC key for closing of the popup.
		closeOnEscapeKey: true,

		// @option closeOnClick: Boolean = *
		// Set it if you want to override the default behavior of the popup closing when user clicks
		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof Path)) {
				this._source.on('preclick', stopPropagation);
			}
		}
	},

	onRemove: function (map) {
		DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			if (!(this._source instanceof Path)) {
				this._source.off('preclick', stopPropagation);
			}
		}
	},

	getEvents: function () {
		var events = DivOverlay.prototype.getEvents.call(this);

		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = create$1('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-animated');

		var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
		this._contentNode = create$1('div', prefix + '-content', wrapper);

		disableClickPropagation(wrapper);
		disableScrollPropagation(this._contentNode);
		on(wrapper, 'contextmenu', stopPropagation);

		this._tipContainer = create$1('div', prefix + '-tip-container', container);
		this._tip = create$1('div', prefix + '-tip', this._tipContainer);

		if (this.options.closeButton) {
			var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			on(closeButton, 'click', this._onCloseButtonClick, this);
		}
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			addClass(container, scrolledClass);
		} else {
			removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }

		var map = this._map,
		    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
		    containerHeight = this._container.offsetHeight + marginBottom,
		    containerWidth = this._containerWidth,
		    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = toPoint(this.options.autoPanPadding),
		    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
var popup = function (options, source) {
	return new Popup(options, source);
};


/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
Map.mergeOptions({
	closePopupOnClick: true
});


// @namespace Map
// @section Methods for Layers and Controls
Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof Popup)) {
			popup = new Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof Popup) {
			setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (!(layer instanceof Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return (this._popup ? this._popup.isOpen() : false);
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	},

	_onKeyPress: function (e) {
		if (e.originalEvent.keyCode === 13) {
			this._openPopup(e);
		}
	}
});

/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offsetting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
var Tooltip = DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamically switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	getEvents: function () {
		var events = DivOverlay.prototype.getEvents.call(this);

		if (touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = create$1('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_setPosition: function (pos) {
		var map = this._map,
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = toPoint(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
		} else if (direction === 'bottom') {
			pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));
		} else if (direction === 'center') {
			pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
		} else {
			direction = 'left';
			pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
		}

		removeClass(container, 'leaflet-tooltip-right');
		removeClass(container, 'leaflet-tooltip-left');
		removeClass(container, 'leaflet-tooltip-top');
		removeClass(container, 'leaflet-tooltip-bottom');
		addClass(container, 'leaflet-tooltip-' + direction);
		setPosition(container, pos);
	},

	_updatePosition: function () {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
var tooltip = function (options, source) {
	return new Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof Tooltip)) {
			tooltip = new Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof Tooltip) {
			setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = new Tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove$$1) {
		if (!remove$$1 && this._tooltipHandlersAdded) { return; }
		var onOff = remove$$1 ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		    };
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove$$1;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (!(layer instanceof Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});

/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

var DivIcon = Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = toPoint(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
function divIcon(options) {
	return new DivIcon(options);
}

Icon.Default = IconDefault;

/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


var GridLayer = Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = (depends)
		// Load new tiles only when panning ends.
		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
		updateWhenIdle: mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: undefined,

		// @option maxNativeZoom: Number = undefined
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: undefined,

		// @option minNativeZoom: Number = undefined
		// Minimum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
		// from `minNativeZoom` level and auto-scaled.
		minNativeZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
		// tiles outside the CRS limits.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = undefined;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overridden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof Point ? s : new Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (ielt9) { return; }

		setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) {
					willPrune = true;
				} else {
					this._onOpaqueTile(tile);
				}
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
		}
	},

	_onOpaqueTile: falseFn,

	_initContainer: function () {
		if (this._container) { return; }

		this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
				this._onUpdateLevel(z);
			} else {
				remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				this._onRemoveLevel(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			falseFn(level.el.offsetWidth);

			this._onCreateLevel(level);
		}

		this._level = level;

		return level;
	},

	_onUpdateLevel: falseFn,

	_onRemoveLevel: falseFn,

	_onCreateLevel: falseFn,

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			remove(this._levels[z].el);
			this._onRemoveLevel(z);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = undefined;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_clampZoom: function (zoom) {
		var options = this.options;

		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
			return options.minNativeZoom;
		}

		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
			return options.maxNativeZoom;
		}

		return zoom;
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = this._clampZoom(Math.round(zoom));
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale)
		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (any3d) {
			setTransform(level.el, translate, scale);
		} else {
			setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = this._clampZoom(map.getZoom());

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
		                              tileRange.getTopRight().add([margin, -margin]));

		// Sanity check: panic if the tile range contains Infinity somewhere.
		if (!(isFinite(tileRange.min.x) &&
		      isFinite(tileRange.min.y) &&
		      isFinite(tileRange.max.x) &&
		      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	_tileCoordsToNwSe: function (coords) {
		var map = this._map,
		    tileSize = this.getTileSize(),
		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),
		    nw = map.unproject(nwPoint, coords.z),
		    se = map.unproject(sePoint, coords.z);
		return [nw, se];
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {
		var bp = this._tileCoordsToNwSe(coords),
		    bounds = new LatLngBounds(bp[0], bp[1]);

		if (!this.options.noWrap) {
			bounds = this._map.wrapLatLngBounds(bounds);
		}
		return bounds;
	},
	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
		    coords = new Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		// Cancels any pending http requests associated with the tile
		// unless we're on Android's stock browser,
		// see https://github.com/Leaflet/Leaflet/issues/137
		if (!androidStock) {
			tile.el.setAttribute('src', emptyImageUrl);
		}
		remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = falseFn;
		tile.onmousemove = falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (ielt9 && this.options.opacity < 1) {
			setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (android && !android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
		}

		setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map) { return; }

		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			setOpacity(tile.el, 0);
			cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (ielt9 || !this._map._fadeAnimated) {
				requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new Point(
			this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
function gridLayer(options) {
	return new GridLayer(options);
}

/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


var TileLayer = GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = 18
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: 18,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean = false
		// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
		on(tile, 'error', bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		/*
		 Set role="presentation" to force screen readers to ignore this
		 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
		*/
		tile.setAttribute('role', 'presentation');

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return template(this._url, extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (ielt9) {
			setTimeout(bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl && tile.getAttribute('src') !== errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {
		var zoom = this._tileZoom,
		maxZoom = this.options.maxZoom,
		zoomReverse = this.options.zoomReverse,
		zoomOffset = this.options.zoomOffset;

		if (zoomReverse) {
			zoom = maxZoom - zoom;
		}

		return zoom + zoomOffset;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = falseFn;
				tile.onerror = falseFn;

				if (!tile.complete) {
					tile.src = emptyImageUrl;
					remove(tile);
					delete this._tiles[i];
				}
			}
		}
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

function tileLayer(url, options) {
	return new TileLayer(url, options);
}

/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data © 2012 IEM Nexrad"
 * });
 * ```
 */

var TileLayerWMS = TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = setOptions(this, options);

		var realRetina = options.detectRetina && retina ? 2 : 1;
		var tileSize = this.getTileSize();
		wmsParams.width = tileSize.x * realRetina;
		wmsParams.height = tileSize.y * realRetina;

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToNwSe(coords),
		    crs = this._crs,
		    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
		    min = bounds.min,
		    max = bounds.max,
		    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
		    [min.y, min.x, max.y, max.x] :
		    [min.x, min.y, max.x, max.y]).join(','),
		url = L.TileLayer.prototype.getTileUrl.call(this, coords);
		return url +
			getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
function tileLayerWMS(url, options) {
	return new TileLayerWMS(url, options);
}

TileLayer.WMS = TileLayerWMS;
tileLayer.wms = tileLayerWMS;

/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

var Renderer = Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1,

		// @option tolerance: Number = 0
		// How much to extend click tolerance round a path/object on the map
		tolerance : 0
	},

	initialize: function (options) {
		setOptions(this, options);
		stamp(this);
		this._layers = this._layers || {};
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
		this.on('update', this._updatePaths, this);
	},

	onRemove: function () {
		this.off('update', this._updatePaths, this);
		this._destroyContainer();
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update,
			zoomend: this._onZoomEnd
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),

		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (any3d) {
			setTransform(this._container, topLeftOffset, scale);
		} else {
			setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);

		for (var id in this._layers) {
			this._layers[id]._reset();
		}
	},

	_onZoomEnd: function () {
		for (var id in this._layers) {
			this._layers[id]._project();
		}
	},

	_updatePaths: function () {
		for (var id in this._layers) {
			this._layers[id]._update();
		}
	},

	_update: function () {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});

/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var Canvas = Renderer.extend({
	getEvents: function () {
		var events = Renderer.prototype.getEvents.call(this);
		events.viewprereset = this._onViewPreReset;
		return events;
	},

	_onViewPreReset: function () {
		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
		this._postponeUpdatePaths = true;
	},

	onAdd: function () {
		Renderer.prototype.onAdd.call(this);

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		on(container, 'mousemove', throttle(this._onMouseMove, 32, this), this);
		on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
		on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_destroyContainer: function () {
		delete this._ctx;
		remove(this._container);
		off(this._container);
		delete this._container;
	},

	_updatePaths: function () {
		if (this._postponeUpdatePaths) { return; }

		var layer;
		this._redrawBounds = null;
		for (var id in this._layers) {
			layer = this._layers[id];
			layer._update();
		}
		this._redraw();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		this._drawnLayers = {};

		Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = retina ? 2 : 1;

		setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_reset: function () {
		Renderer.prototype._reset.call(this);

		if (this._postponeUpdatePaths) {
			this._postponeUpdatePaths = false;
			this._updatePaths();
		}
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[stamp(layer)] = layer;

		var order = layer._order = {
			layer: layer,
			prev: this._drawLast,
			next: null
		};
		if (this._drawLast) { this._drawLast.next = order; }
		this._drawLast = order;
		this._drawFirst = this._drawFirst || this._drawLast;
	},

	_addPath: function (layer) {
		this._requestRedraw(layer);
	},

	_removePath: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			this._drawLast = prev;
		}
		if (prev) {
			prev.next = next;
		} else {
			this._drawFirst = next;
		}

		delete layer._order;

		delete this._layers[L.stamp(layer)];

		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		// Redraw the union of the layer's old pixel
		// bounds and the new pixel bounds.
		this._extendRedrawBounds(layer);
		layer._project();
		layer._update();
		// The redraw will extend the redraw bounds
		// with the new pixel bounds.
		this._requestRedraw(layer);
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (layer.options.dashArray) {
			var parts = layer.options.dashArray.split(','),
			    dashArray = [],
			    i;
			for (i = 0; i < parts.length; i++) {
				dashArray.push(Number(parts[i]));
			}
			layer.options._dashArray = dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		this._extendRedrawBounds(layer);
		this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
	},

	_extendRedrawBounds: function (layer) {
		if (layer._pxBounds) {
			var padding = (layer.options.weight || 0) + 1;
			this._redrawBounds = this._redrawBounds || new Bounds();
			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
		}
	},

	_redraw: function () {
		this._redrawRequest = null;

		if (this._redrawBounds) {
			this._redrawBounds.min._floor();
			this._redrawBounds.max._ceil();
		}

		this._clear(); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_clear: function () {
		var bounds = this._redrawBounds;
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
		} else {
			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
		}
	},

	_draw: function () {
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
			this._ctx.clip();
		}

		this._drawing = true;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
		}

		this._drawing = false;

		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {
		if (!this._drawing) { return; }

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) { return; }

		this._drawnLayers[layer._leaflet_id] = layer;

		ctx.beginPath();

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (!this._drawing || layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = Math.max(Math.round(layer._radius), 1),
		    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

		this._drawnLayers[layer._leaflet_id] = layer;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var options = layer.options;

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			if (ctx.setLineDash) {
				ctx.setLineDash(layer.options && layer.options._dashArray || []);
			}
			ctx.globalAlpha = options.opacity;
			ctx.lineWidth = options.weight;
			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer)  {
			fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e) {
		var layer = this._hoveredLayer;
		if (layer) {
			// if we're leaving the layer, fire mouseout
			removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function (e, point) {
		var layer, candidateHoveredLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point)) {
				candidateHoveredLayer = layer;
			}
		}

		if (candidateHoveredLayer !== this._hoveredLayer) {
			this._handleMouseOut(e);

			if (candidateHoveredLayer) {
				addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
				this._hoveredLayer = candidateHoveredLayer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	_bringToFront: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			// Already last
			return;
		}
		if (prev) {
			prev.next = next;
		} else if (next) {
			// Update first entry unless this is the
			// single entry
			this._drawFirst = next;
		}

		order.prev = this._drawLast;
		this._drawLast.next = order;

		order.next = null;
		this._drawLast = order;

		this._requestRedraw(layer);
	},

	_bringToBack: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (prev) {
			prev.next = next;
		} else {
			// Already first
			return;
		}
		if (next) {
			next.prev = prev;
		} else if (prev) {
			// Update last entry unless this is the
			// single entry
			this._drawLast = prev;
		}

		order.prev = null;

		order.next = this._drawFirst;
		this._drawFirst.prev = order;
		this._drawFirst = order;

		this._requestRedraw(layer);
	}
});

// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
function canvas$1(options) {
	return canvas ? new Canvas(options) : null;
}

/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */


var vmlCreate = (function () {
	try {
		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
		return function (name) {
			return document.createElement('<lvml:' + name + ' class="lvml">');
		};
	} catch (e) {
		return function (name) {
			return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
		};
	}
})();


/*
 * @class SVG
 *
 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
var vmlMixin = {

	_initContainer: function () {
		this._container = create$1('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function (layer) {
		var container = layer._container = vmlCreate('shape');

		addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = vmlCreate('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
		this._layers[stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		remove(container);
		layer.removeInteractiveTarget(container);
		delete this._layers[stamp(layer)];
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = vmlCreate('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = vmlCreate('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
			'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		toFront(layer._container);
	},

	_bringToBack: function (layer) {
		toBack(layer._container);
	}
};

var create$2 = vml ? vmlCreate : svgCreate;

/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var SVG = Renderer.extend({

	getEvents: function () {
		var events = Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = create$2('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = create$2('g');
		this._container.appendChild(this._rootGroup);
	},

	_destroyContainer: function () {
		remove(this._container);
		off(this._container);
		delete this._container;
		delete this._rootGroup;
		delete this._svgSize;
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = create$2('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
		this._layers[stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		if (!this._rootGroup) { this._initContainer(); }
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
		delete this._layers[stamp(layer)];
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = Math.max(Math.round(layer._radius), 1),
		    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
			'M' + (p.x - r) + ',' + p.y +
			arc + (r * 2) + ',0 ' +
			arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		toFront(layer._path);
	},

	_bringToBack: function (layer) {
		toBack(layer._path);
	}
});

if (vml) {
	SVG.include(vmlMixin);
}

// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
function svg$1(options) {
	return svg || vml ? new SVG(options) : null;
}

Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			renderer = this._renderer = (this.options.preferCanvas && canvas$1()) || svg$1();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = (SVG && svg$1({pane: name})) || (Canvas && canvas$1({pane: name}));
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});

/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Rectangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


var Rectangle = Polygon.extend({
	initialize: function (latLngBounds, options) {
		Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = toLatLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
function rectangle(latLngBounds, options) {
	return new Rectangle(latLngBounds, options);
}

SVG.create = create$2;
SVG.pointsToPath = pointsToPath;

GeoJSON.geometryToLayer = geometryToLayer;
GeoJSON.coordsToLatLng = coordsToLatLng;
GeoJSON.coordsToLatLngs = coordsToLatLngs;
GeoJSON.latLngToCoords = latLngToCoords;
GeoJSON.latLngsToCoords = latLngsToCoords;
GeoJSON.getFeature = getFeature;
GeoJSON.asFeature = asFeature;

/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

var BoxZoom = Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._resetStateTimeout = 0;
		map.on('unload', this._destroy, this);
	},

	addHooks: function () {
		on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_destroy: function () {
		remove(this._pane);
		delete this._pane;
	},

	_resetState: function () {
		this._resetStateTimeout = 0;
		this._moved = false;
	},

	_clearDeferredResetState: function () {
		if (this._resetStateTimeout !== 0) {
			clearTimeout(this._resetStateTimeout);
			this._resetStateTimeout = 0;
		}
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		// Clear the deferred resetState if it hasn't executed yet, otherwise it
		// will interrupt the interaction and orphan a box element in the container.
		this._clearDeferredResetState();
		this._resetState();

		disableTextSelection();
		disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		on(document, {
			contextmenu: stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = create$1('div', 'leaflet-zoom-box', this._container);
			addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			remove(this._box);
			removeClass(this._container, 'leaflet-crosshair');
		}

		enableTextSelection();
		enableImageDrag();

		off(document, {
			contextmenu: stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		this._clearDeferredResetState();
		this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

		var bounds = new LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

var DoubleClickZoom = Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second².
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

var Drag = Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new Draggable(map._mapPane, map._container);

			this._draggable.on({
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		removeClass(this._map._container, 'leaflet-grab');
		removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDragStart: function () {
		var map = this._map;

		map._stop();
		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = toLatLngBounds(this._map.options.maxBounds);

			this._offsetLimit = toBounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			this._prunePositions(time);
		}

		this._map
		    .fire('move', e)
		    .fire('drag', e);
	},

	_prunePositions: function (time) {
		while (this._positions.length > 1 && time - this._times[0] > 50) {
			this._positions.shift();
			this._times.shift();
		}
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,

		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {
			this._prunePositions(+new Date());

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
Map.addInitHook('addHandler', 'dragging', Drag);

/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

var Keyboard = Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			offset = this._panKeys[key];
			if (e.shiftKey) {
				offset = toPoint(offset).multiplyBy(3);
			}

			map.panBy(offset);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
			map.closePopup();

		} else {
			return;
		}

		stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
Map.addInitHook('addHandler', 'keyboard', Keyboard);

/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

var ScrollWheelZoom = Handler.extend({
	addHooks: function () {
		on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(bind(this._performZoom, this), left);

		stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

var Tap = Handler.extend({
	addHooks: function () {
		on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (touch && !pointer) {
	Map.addInitHook('addHandler', 'tap', Tap);
}

/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: touch && !android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

var TouchZoom = Handler.extend({
	addHooks: function () {
		addClass(this._map._container, 'leaflet-touch-zoom');
		on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		removeClass(this._map._container, 'leaflet-touch-zoom');
		off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		on(document, 'touchmove', this._onTouchMove, this);
		on(document, 'touchend', this._onTouchEnd, this);

		preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;

		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true, false);
			this._moved = true;
		}

		cancelAnimFrame(this._animRequest);

		var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = requestAnimFrame(moveFn, this, true);

		preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		cancelAnimFrame(this._animRequest);

		off(document, 'touchmove', this._onTouchMove);
		off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

Map.BoxZoom = BoxZoom;
Map.DoubleClickZoom = DoubleClickZoom;
Map.Drag = Drag;
Map.Keyboard = Keyboard;
Map.ScrollWheelZoom = ScrollWheelZoom;
Map.Tap = Tap;
Map.TouchZoom = TouchZoom;

// misc

var oldL = window.L;
function noConflict() {
	window.L = oldL;
	return this;
}

// Always export us to window global (see #2364)
window.L = exports;

Object.freeze = freeze;

exports.version = version;
exports.noConflict = noConflict;
exports.Control = Control;
exports.control = control;
exports.Browser = Browser;
exports.Evented = Evented;
exports.Mixin = Mixin;
exports.Util = Util;
exports.Class = Class;
exports.Handler = Handler;
exports.extend = extend;
exports.bind = bind;
exports.stamp = stamp;
exports.setOptions = setOptions;
exports.DomEvent = DomEvent;
exports.DomUtil = DomUtil;
exports.PosAnimation = PosAnimation;
exports.Draggable = Draggable;
exports.LineUtil = LineUtil;
exports.PolyUtil = PolyUtil;
exports.Point = Point;
exports.point = toPoint;
exports.Bounds = Bounds;
exports.bounds = toBounds;
exports.Transformation = Transformation;
exports.transformation = toTransformation;
exports.Projection = index;
exports.LatLng = LatLng;
exports.latLng = toLatLng;
exports.LatLngBounds = LatLngBounds;
exports.latLngBounds = toLatLngBounds;
exports.CRS = CRS;
exports.GeoJSON = GeoJSON;
exports.geoJSON = geoJSON;
exports.geoJson = geoJson;
exports.Layer = Layer;
exports.LayerGroup = LayerGroup;
exports.layerGroup = layerGroup;
exports.FeatureGroup = FeatureGroup;
exports.featureGroup = featureGroup;
exports.ImageOverlay = ImageOverlay;
exports.imageOverlay = imageOverlay;
exports.VideoOverlay = VideoOverlay;
exports.videoOverlay = videoOverlay;
exports.DivOverlay = DivOverlay;
exports.Popup = Popup;
exports.popup = popup;
exports.Tooltip = Tooltip;
exports.tooltip = tooltip;
exports.Icon = Icon;
exports.icon = icon;
exports.DivIcon = DivIcon;
exports.divIcon = divIcon;
exports.Marker = Marker;
exports.marker = marker;
exports.TileLayer = TileLayer;
exports.tileLayer = tileLayer;
exports.GridLayer = GridLayer;
exports.gridLayer = gridLayer;
exports.SVG = SVG;
exports.svg = svg$1;
exports.Renderer = Renderer;
exports.Canvas = Canvas;
exports.canvas = canvas$1;
exports.Path = Path;
exports.CircleMarker = CircleMarker;
exports.circleMarker = circleMarker;
exports.Circle = Circle;
exports.circle = circle;
exports.Polyline = Polyline;
exports.polyline = polyline;
exports.Polygon = Polygon;
exports.polygon = polygon;
exports.Rectangle = Rectangle;
exports.rectangle = rectangle;
exports.Map = Map;
exports.map = createMap;

})));


},{}],31:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],32:[function(require,module,exports){
/**
  * vee-validate v2.1.7
  * (c) 2019 Abdelrahman Awad
  * @license MIT
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.VeeValidate = factory());
}(this, function () { 'use strict';

  var MILLISECONDS_IN_HOUR = 3600000;
  var MILLISECONDS_IN_MINUTE = 60000;
  var DEFAULT_ADDITIONAL_DIGITS = 2;

  var patterns = {
    dateTimeDelimeter: /[T ]/,
    plainTime: /:/,

    // year tokens
    YY: /^(\d{2})$/,
    YYY: [
      /^([+-]\d{2})$/, // 0 additional digits
      /^([+-]\d{3})$/, // 1 additional digit
      /^([+-]\d{4})$/ // 2 additional digits
    ],
    YYYY: /^(\d{4})/,
    YYYYY: [
      /^([+-]\d{4})/, // 0 additional digits
      /^([+-]\d{5})/, // 1 additional digit
      /^([+-]\d{6})/ // 2 additional digits
    ],

    // date tokens
    MM: /^-(\d{2})$/,
    DDD: /^-?(\d{3})$/,
    MMDD: /^-?(\d{2})-?(\d{2})$/,
    Www: /^-?W(\d{2})$/,
    WwwD: /^-?W(\d{2})-?(\d{1})$/,

    HH: /^(\d{2}([.,]\d*)?)$/,
    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,

    // timezone tokens
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-])(\d{2})$/,
    timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
  };

  /**
   * @name toDate
   * @category Common Helpers
   * @summary Convert the given argument to an instance of Date.
   *
   * @description
   * Convert the given argument to an instance of Date.
   *
   * If the argument is an instance of Date, the function returns its clone.
   *
   * If the argument is a number, it is treated as a timestamp.
   *
   * If an argument is a string, the function tries to parse it.
   * Function accepts complete ISO 8601 formats as well as partial implementations.
   * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
   *
   * If the argument is null, it is treated as an invalid date.
   *
   * If all above fails, the function passes the given argument to Date constructor.
   *
   * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
   * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
   *
   * @param {*} argument - the value to convert
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Convert string '2014-02-11T11:30:30' to date:
   * var result = toDate('2014-02-11T11:30:30')
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert string '+02014101' to date,
   * // if the additional number of digits in the extended year format is 1:
   * var result = toDate('+02014101', {additionalDigits: 1})
   * //=> Fri Apr 11 2014 00:00:00
   */
  function toDate (argument, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present')
    }

    if (argument === null) {
      return new Date(NaN)
    }

    var options = dirtyOptions || {};

    var additionalDigits = options.additionalDigits === undefined ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);
    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError('additionalDigits must be 0, 1 or 2')
    }

    // Clone the date
    if (argument instanceof Date) {
      // Prevent the date to lose the milliseconds when passed to new Date() in IE10
      return new Date(argument.getTime())
    } else if (typeof argument !== 'string') {
      return new Date(argument)
    }

    var dateStrings = splitDateString(argument);

    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    var year = parseYearResult.year;
    var restDateString = parseYearResult.restDateString;

    var date = parseDate(restDateString, year);

    if (date) {
      var timestamp = date.getTime();
      var time = 0;
      var offset;

      if (dateStrings.time) {
        time = parseTime(dateStrings.time);
      }

      if (dateStrings.timezone) {
        offset = parseTimezone(dateStrings.timezone);
      } else {
        // get offset accurate to hour in timezones that change offset
        offset = new Date(timestamp + time).getTimezoneOffset();
        offset = new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE).getTimezoneOffset();
      }

      return new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE)
    } else {
      return new Date(argument)
    }
  }

  function splitDateString (dateString) {
    var dateStrings = {};
    var array = dateString.split(patterns.dateTimeDelimeter);
    var timeString;

    if (patterns.plainTime.test(array[0])) {
      dateStrings.date = null;
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];
    }

    if (timeString) {
      var token = patterns.timezone.exec(timeString);
      if (token) {
        dateStrings.time = timeString.replace(token[1], '');
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }

    return dateStrings
  }

  function parseYear (dateString, additionalDigits) {
    var patternYYY = patterns.YYY[additionalDigits];
    var patternYYYYY = patterns.YYYYY[additionalDigits];

    var token;

    // YYYY or ±YYYYY
    token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
    if (token) {
      var yearString = token[1];
      return {
        year: parseInt(yearString, 10),
        restDateString: dateString.slice(yearString.length)
      }
    }

    // YY or ±YYY
    token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
    if (token) {
      var centuryString = token[1];
      return {
        year: parseInt(centuryString, 10) * 100,
        restDateString: dateString.slice(centuryString.length)
      }
    }

    // Invalid ISO-formatted year
    return {
      year: null
    }
  }

  function parseDate (dateString, year) {
    // Invalid ISO-formatted year
    if (year === null) {
      return null
    }

    var token;
    var date;
    var month;
    var week;

    // YYYY
    if (dateString.length === 0) {
      date = new Date(0);
      date.setUTCFullYear(year);
      return date
    }

    // YYYY-MM
    token = patterns.MM.exec(dateString);
    if (token) {
      date = new Date(0);
      month = parseInt(token[1], 10) - 1;
      date.setUTCFullYear(year, month);
      return date
    }

    // YYYY-DDD or YYYYDDD
    token = patterns.DDD.exec(dateString);
    if (token) {
      date = new Date(0);
      var dayOfYear = parseInt(token[1], 10);
      date.setUTCFullYear(year, 0, dayOfYear);
      return date
    }

    // YYYY-MM-DD or YYYYMMDD
    token = patterns.MMDD.exec(dateString);
    if (token) {
      date = new Date(0);
      month = parseInt(token[1], 10) - 1;
      var day = parseInt(token[2], 10);
      date.setUTCFullYear(year, month, day);
      return date
    }

    // YYYY-Www or YYYYWww
    token = patterns.Www.exec(dateString);
    if (token) {
      week = parseInt(token[1], 10) - 1;
      return dayOfISOYear(year, week)
    }

    // YYYY-Www-D or YYYYWwwD
    token = patterns.WwwD.exec(dateString);
    if (token) {
      week = parseInt(token[1], 10) - 1;
      var dayOfWeek = parseInt(token[2], 10) - 1;
      return dayOfISOYear(year, week, dayOfWeek)
    }

    // Invalid ISO-formatted date
    return null
  }

  function parseTime (timeString) {
    var token;
    var hours;
    var minutes;

    // hh
    token = patterns.HH.exec(timeString);
    if (token) {
      hours = parseFloat(token[1].replace(',', '.'));
      return (hours % 24) * MILLISECONDS_IN_HOUR
    }

    // hh:mm or hhmm
    token = patterns.HHMM.exec(timeString);
    if (token) {
      hours = parseInt(token[1], 10);
      minutes = parseFloat(token[2].replace(',', '.'));
      return (hours % 24) * MILLISECONDS_IN_HOUR +
        minutes * MILLISECONDS_IN_MINUTE
    }

    // hh:mm:ss or hhmmss
    token = patterns.HHMMSS.exec(timeString);
    if (token) {
      hours = parseInt(token[1], 10);
      minutes = parseInt(token[2], 10);
      var seconds = parseFloat(token[3].replace(',', '.'));
      return (hours % 24) * MILLISECONDS_IN_HOUR +
        minutes * MILLISECONDS_IN_MINUTE +
        seconds * 1000
    }

    // Invalid ISO-formatted time
    return null
  }

  function parseTimezone (timezoneString) {
    var token;
    var absoluteOffset;

    // Z
    token = patterns.timezoneZ.exec(timezoneString);
    if (token) {
      return 0
    }

    // ±hh
    token = patterns.timezoneHH.exec(timezoneString);
    if (token) {
      absoluteOffset = parseInt(token[2], 10) * 60;
      return (token[1] === '+') ? -absoluteOffset : absoluteOffset
    }

    // ±hh:mm or ±hhmm
    token = patterns.timezoneHHMM.exec(timezoneString);
    if (token) {
      absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10);
      return (token[1] === '+') ? -absoluteOffset : absoluteOffset
    }

    return 0
  }

  function dayOfISOYear (isoYear, week, day) {
    week = week || 0;
    day = day || 0;
    var date = new Date(0);
    date.setUTCFullYear(isoYear, 0, 4);
    var fourthOfJanuaryDay = date.getUTCDay() || 7;
    var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date
  }

  /**
   * @name addMilliseconds
   * @category Millisecond Helpers
   * @summary Add the specified number of milliseconds to the given date.
   *
   * @description
   * Add the specified number of milliseconds to the given date.
   *
   * @param {Date|String|Number} date - the date to be changed
   * @param {Number} amount - the amount of milliseconds to be added
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Date} the new date with the milliseconds added
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
   * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:30.750
   */
  function addMilliseconds (dirtyDate, dirtyAmount, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var timestamp = toDate(dirtyDate, dirtyOptions).getTime();
    var amount = Number(dirtyAmount);
    return new Date(timestamp + amount)
  }

  function cloneObject (dirtyObject) {
    dirtyObject = dirtyObject || {};
    var object = {};

    for (var property in dirtyObject) {
      if (dirtyObject.hasOwnProperty(property)) {
        object[property] = dirtyObject[property];
      }
    }

    return object
  }

  var MILLISECONDS_IN_MINUTE$2 = 60000;

  /**
   * @name addMinutes
   * @category Minute Helpers
   * @summary Add the specified number of minutes to the given date.
   *
   * @description
   * Add the specified number of minutes to the given date.
   *
   * @param {Date|String|Number} date - the date to be changed
   * @param {Number} amount - the amount of minutes to be added
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Date} the new date with the minutes added
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Add 30 minutes to 10 July 2014 12:00:00:
   * var result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
   * //=> Thu Jul 10 2014 12:30:00
   */
  function addMinutes (dirtyDate, dirtyAmount, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var amount = Number(dirtyAmount);
    return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE$2, dirtyOptions)
  }

  /**
   * @name isValid
   * @category Common Helpers
   * @summary Is the given date valid?
   *
   * @description
   * Returns false if argument is Invalid Date and true otherwise.
   * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * Invalid Date is a Date, whose time value is NaN.
   *
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * @param {*} date - the date to check
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Boolean} the date is valid
   * @throws {TypeError} 1 argument required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // For the valid date:
   * var result = isValid(new Date(2014, 1, 31))
   * //=> true
   *
   * @example
   * // For the value, convertable into a date:
   * var result = isValid('2014-02-31')
   * //=> true
   *
   * @example
   * // For the invalid date:
   * var result = isValid(new Date(''))
   * //=> false
   */
  function isValid (dirtyDate, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present')
    }

    var date = toDate(dirtyDate, dirtyOptions);
    return !isNaN(date)
  }

  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: 'less than a second',
      other: 'less than {{count}} seconds'
    },

    xSeconds: {
      one: '1 second',
      other: '{{count}} seconds'
    },

    halfAMinute: 'half a minute',

    lessThanXMinutes: {
      one: 'less than a minute',
      other: 'less than {{count}} minutes'
    },

    xMinutes: {
      one: '1 minute',
      other: '{{count}} minutes'
    },

    aboutXHours: {
      one: 'about 1 hour',
      other: 'about {{count}} hours'
    },

    xHours: {
      one: '1 hour',
      other: '{{count}} hours'
    },

    xDays: {
      one: '1 day',
      other: '{{count}} days'
    },

    aboutXMonths: {
      one: 'about 1 month',
      other: 'about {{count}} months'
    },

    xMonths: {
      one: '1 month',
      other: '{{count}} months'
    },

    aboutXYears: {
      one: 'about 1 year',
      other: 'about {{count}} years'
    },

    xYears: {
      one: '1 year',
      other: '{{count}} years'
    },

    overXYears: {
      one: 'over 1 year',
      other: 'over {{count}} years'
    },

    almostXYears: {
      one: 'almost 1 year',
      other: 'almost {{count}} years'
    }
  };

  function formatDistance (token, count, options) {
    options = options || {};

    var result;
    if (typeof formatDistanceLocale[token] === 'string') {
      result = formatDistanceLocale[token];
    } else if (count === 1) {
      result = formatDistanceLocale[token].one;
    } else {
      result = formatDistanceLocale[token].other.replace('{{count}}', count);
    }

    if (options.addSuffix) {
      if (options.comparison > 0) {
        return 'in ' + result
      } else {
        return result + ' ago'
      }
    }

    return result
  }

  var tokensToBeShortedPattern = /MMMM|MM|DD|dddd/g;

  function buildShortLongFormat (format) {
    return format.replace(tokensToBeShortedPattern, function (token) {
      return token.slice(1)
    })
  }

  /**
   * @name buildFormatLongFn
   * @category Locale Helpers
   * @summary Build `formatLong` property for locale used by `format`, `formatRelative` and `parse` functions.
   *
   * @description
   * Build `formatLong` property for locale used by `format`, `formatRelative` and `parse` functions.
   * Returns a function which takes one of the following tokens as the argument:
   * `'LTS'`, `'LT'`, `'L'`, `'LL'`, `'LLL'`, `'l'`, `'ll'`, `'lll'`, `'llll'`
   * and returns a long format string written as `format` token strings.
   * See [format]{@link https://date-fns.org/docs/format}
   *
   * `'l'`, `'ll'`, `'lll'` and `'llll'` formats are built automatically
   * by shortening some of the tokens from corresponding unshortened formats
   * (e.g., if `LL` is `'MMMM DD YYYY'` then `ll` will be `MMM D YYYY`)
   *
   * @param {Object} obj - the object with long formats written as `format` token strings
   * @param {String} obj.LT - time format: hours and minutes
   * @param {String} obj.LTS - time format: hours, minutes and seconds
   * @param {String} obj.L - short date format: numeric day, month and year
   * @param {String} [obj.l] - short date format: numeric day, month and year (shortened)
   * @param {String} obj.LL - long date format: day, month in words, and year
   * @param {String} [obj.ll] - long date format: day, month in words, and year (shortened)
   * @param {String} obj.LLL - long date and time format
   * @param {String} [obj.lll] - long date and time format (shortened)
   * @param {String} obj.LLLL - long date, time and weekday format
   * @param {String} [obj.llll] - long date, time and weekday format (shortened)
   * @returns {Function} `formatLong` property of the locale
   *
   * @example
   * // For `en-US` locale:
   * locale.formatLong = buildFormatLongFn({
   *   LT: 'h:mm aa',
   *   LTS: 'h:mm:ss aa',
   *   L: 'MM/DD/YYYY',
   *   LL: 'MMMM D YYYY',
   *   LLL: 'MMMM D YYYY h:mm aa',
   *   LLLL: 'dddd, MMMM D YYYY h:mm aa'
   * })
   */
  function buildFormatLongFn (obj) {
    var formatLongLocale = {
      LTS: obj.LTS,
      LT: obj.LT,
      L: obj.L,
      LL: obj.LL,
      LLL: obj.LLL,
      LLLL: obj.LLLL,
      l: obj.l || buildShortLongFormat(obj.L),
      ll: obj.ll || buildShortLongFormat(obj.LL),
      lll: obj.lll || buildShortLongFormat(obj.LLL),
      llll: obj.llll || buildShortLongFormat(obj.LLLL)
    };

    return function (token) {
      return formatLongLocale[token]
    }
  }

  var formatLong = buildFormatLongFn({
    LT: 'h:mm aa',
    LTS: 'h:mm:ss aa',
    L: 'MM/DD/YYYY',
    LL: 'MMMM D YYYY',
    LLL: 'MMMM D YYYY h:mm aa',
    LLLL: 'dddd, MMMM D YYYY h:mm aa'
  });

  var formatRelativeLocale = {
    lastWeek: '[last] dddd [at] LT',
    yesterday: '[yesterday at] LT',
    today: '[today at] LT',
    tomorrow: '[tomorrow at] LT',
    nextWeek: 'dddd [at] LT',
    other: 'L'
  };

  function formatRelative (token, date, baseDate, options) {
    return formatRelativeLocale[token]
  }

  /**
   * @name buildLocalizeFn
   * @category Locale Helpers
   * @summary Build `localize.weekday`, `localize.month` and `localize.timeOfDay` properties for the locale.
   *
   * @description
   * Build `localize.weekday`, `localize.month` and `localize.timeOfDay` properties for the locale
   * used by `format` function.
   * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
   *
   * `localize.weekday` function takes the weekday index as argument (0 - Sunday).
   * `localize.month` takes the month index (0 - January).
   * `localize.timeOfDay` takes the hours. Use `indexCallback` to convert them to an array index (see example).
   *
   * @param {Object} values - the object with arrays of values
   * @param {String} defaultType - the default type for the localize function
   * @param {Function} [indexCallback] - the callback which takes the resulting function argument
   *   and converts it into value array index
   * @returns {Function} the resulting function
   *
   * @example
   * var timeOfDayValues = {
   *   uppercase: ['AM', 'PM'],
   *   lowercase: ['am', 'pm'],
   *   long: ['a.m.', 'p.m.']
   * }
   * locale.localize.timeOfDay = buildLocalizeFn(timeOfDayValues, 'long', function (hours) {
   *   // 0 is a.m. array index, 1 is p.m. array index
   *   return (hours / 12) >= 1 ? 1 : 0
   * })
   * locale.localize.timeOfDay(16, {type: 'uppercase'}) //=> 'PM'
   * locale.localize.timeOfDay(5) //=> 'a.m.'
   */
  function buildLocalizeFn (values, defaultType, indexCallback) {
    return function (dirtyIndex, dirtyOptions) {
      var options = dirtyOptions || {};
      var type = options.type ? String(options.type) : defaultType;
      var valuesArray = values[type] || values[defaultType];
      var index = indexCallback ? indexCallback(Number(dirtyIndex)) : Number(dirtyIndex);
      return valuesArray[index]
    }
  }

  /**
   * @name buildLocalizeArrayFn
   * @category Locale Helpers
   * @summary Build `localize.weekdays`, `localize.months` and `localize.timesOfDay` properties for the locale.
   *
   * @description
   * Build `localize.weekdays`, `localize.months` and `localize.timesOfDay` properties for the locale.
   * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
   *
   * @param {Object} values - the object with arrays of values
   * @param {String} defaultType - the default type for the localize function
   * @returns {Function} the resulting function
   *
   * @example
   * var weekdayValues = {
   *   narrow: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
   *   short: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
   *   long: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
   * }
   * locale.localize.weekdays = buildLocalizeArrayFn(weekdayValues, 'long')
   * locale.localize.weekdays({type: 'narrow'}) //=> ['Su', 'Mo', ...]
   * locale.localize.weekdays() //=> ['Sunday', 'Monday', ...]
   */
  function buildLocalizeArrayFn (values, defaultType) {
    return function (dirtyOptions) {
      var options = dirtyOptions || {};
      var type = options.type ? String(options.type) : defaultType;
      return values[type] || values[defaultType]
    }
  }

  // Note: in English, the names of days of the week and months are capitalized.
  // If you are making a new locale based on this one, check if the same is true for the language you're working on.
  // Generally, formatted dates should look like they are in the middle of a sentence,
  // e.g. in Spanish language the weekdays and months should be in the lowercase.
  var weekdayValues = {
    narrow: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    short: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    long: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
  };

  var monthValues = {
    short: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    long: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  };

  // `timeOfDay` is used to designate which part of the day it is, when used with 12-hour clock.
  // Use the system which is used the most commonly in the locale.
  // For example, if the country doesn't use a.m./p.m., you can use `night`/`morning`/`afternoon`/`evening`:
  //
  //   var timeOfDayValues = {
  //     any: ['in the night', 'in the morning', 'in the afternoon', 'in the evening']
  //   }
  //
  // And later:
  //
  //   var localize = {
  //     // The callback takes the hours as the argument and returns the array index
  //     timeOfDay: buildLocalizeFn(timeOfDayValues, 'any', function (hours) {
  //       if (hours >= 17) {
  //         return 3
  //       } else if (hours >= 12) {
  //         return 2
  //       } else if (hours >= 4) {
  //         return 1
  //       } else {
  //         return 0
  //       }
  //     }),
  //     timesOfDay: buildLocalizeArrayFn(timeOfDayValues, 'any')
  //   }
  var timeOfDayValues = {
    uppercase: ['AM', 'PM'],
    lowercase: ['am', 'pm'],
    long: ['a.m.', 'p.m.']
  };

  function ordinalNumber (dirtyNumber, dirtyOptions) {
    var number = Number(dirtyNumber);

    // If ordinal numbers depend on context, for example,
    // if they are different for different grammatical genders,
    // use `options.unit`:
    //
    //   var options = dirtyOptions || {}
    //   var unit = String(options.unit)
    //
    // where `unit` can be 'month', 'quarter', 'week', 'isoWeek', 'dayOfYear',
    // 'dayOfMonth' or 'dayOfWeek'

    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + 'st'
        case 2:
          return number + 'nd'
        case 3:
          return number + 'rd'
      }
    }
    return number + 'th'
  }

  var localize = {
    ordinalNumber: ordinalNumber,
    weekday: buildLocalizeFn(weekdayValues, 'long'),
    weekdays: buildLocalizeArrayFn(weekdayValues, 'long'),
    month: buildLocalizeFn(monthValues, 'long'),
    months: buildLocalizeArrayFn(monthValues, 'long'),
    timeOfDay: buildLocalizeFn(timeOfDayValues, 'long', function (hours) {
      return (hours / 12) >= 1 ? 1 : 0
    }),
    timesOfDay: buildLocalizeArrayFn(timeOfDayValues, 'long')
  };

  /**
   * @name buildMatchFn
   * @category Locale Helpers
   * @summary Build `match.weekdays`, `match.months` and `match.timesOfDay` properties for the locale.
   *
   * @description
   * Build `match.weekdays`, `match.months` and `match.timesOfDay` properties for the locale used by `parse` function.
   * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
   * The result of the match function will be passed into corresponding parser function
   * (`match.weekday`, `match.month` or `match.timeOfDay` respectively. See `buildParseFn`).
   *
   * @param {Object} values - the object with RegExps
   * @param {String} defaultType - the default type for the match function
   * @returns {Function} the resulting function
   *
   * @example
   * var matchWeekdaysPatterns = {
   *   narrow: /^(su|mo|tu|we|th|fr|sa)/i,
   *   short: /^(sun|mon|tue|wed|thu|fri|sat)/i,
   *   long: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
   * }
   * locale.match.weekdays = buildMatchFn(matchWeekdaysPatterns, 'long')
   * locale.match.weekdays('Sunday', {type: 'narrow'}) //=> ['Su', 'Su', ...]
   * locale.match.weekdays('Sunday') //=> ['Sunday', 'Sunday', ...]
   */
  function buildMatchFn (patterns, defaultType) {
    return function (dirtyString, dirtyOptions) {
      var options = dirtyOptions || {};
      var type = options.type ? String(options.type) : defaultType;
      var pattern = patterns[type] || patterns[defaultType];
      var string = String(dirtyString);
      return string.match(pattern)
    }
  }

  /**
   * @name buildParseFn
   * @category Locale Helpers
   * @summary Build `match.weekday`, `match.month` and `match.timeOfDay` properties for the locale.
   *
   * @description
   * Build `match.weekday`, `match.month` and `match.timeOfDay` properties for the locale used by `parse` function.
   * The argument of the resulting function is the result of the corresponding match function
   * (`match.weekdays`, `match.months` or `match.timesOfDay` respectively. See `buildMatchFn`).
   *
   * @param {Object} values - the object with arrays of RegExps
   * @param {String} defaultType - the default type for the parser function
   * @returns {Function} the resulting function
   *
   * @example
   * var parseWeekdayPatterns = {
   *   any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
   * }
   * locale.match.weekday = buildParseFn(matchWeekdaysPatterns, 'long')
   * var matchResult = locale.match.weekdays('Friday')
   * locale.match.weekday(matchResult) //=> 5
   */
  function buildParseFn (patterns, defaultType) {
    return function (matchResult, dirtyOptions) {
      var options = dirtyOptions || {};
      var type = options.type ? String(options.type) : defaultType;
      var patternsArray = patterns[type] || patterns[defaultType];
      var string = matchResult[1];

      return patternsArray.findIndex(function (pattern) {
        return pattern.test(string)
      })
    }
  }

  /**
   * @name buildMatchPatternFn
   * @category Locale Helpers
   * @summary Build match function from a single RegExp.
   *
   * @description
   * Build match function from a single RegExp.
   * Usually used for building `match.ordinalNumbers` property of the locale.
   *
   * @param {Object} pattern - the RegExp
   * @returns {Function} the resulting function
   *
   * @example
   * locale.match.ordinalNumbers = buildMatchPatternFn(/^(\d+)(th|st|nd|rd)?/i)
   * locale.match.ordinalNumbers('3rd') //=> ['3rd', '3', 'rd', ...]
   */
  function buildMatchPatternFn (pattern) {
    return function (dirtyString) {
      var string = String(dirtyString);
      return string.match(pattern)
    }
  }

  /**
   * @name parseDecimal
   * @category Locale Helpers
   * @summary Parses the match result into decimal number.
   *
   * @description
   * Parses the match result into decimal number.
   * Uses the string matched with the first set of parentheses of match RegExp.
   *
   * @param {Array} matchResult - the object returned by matching function
   * @returns {Number} the parsed value
   *
   * @example
   * locale.match = {
   *   ordinalNumbers: (dirtyString) {
   *     return String(dirtyString).match(/^(\d+)(th|st|nd|rd)?/i)
   *   },
   *   ordinalNumber: parseDecimal
   * }
   */
  function parseDecimal (matchResult) {
    return parseInt(matchResult[1], 10)
  }

  var matchOrdinalNumbersPattern = /^(\d+)(th|st|nd|rd)?/i;

  var matchWeekdaysPatterns = {
    narrow: /^(su|mo|tu|we|th|fr|sa)/i,
    short: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    long: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };

  var parseWeekdayPatterns = {
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };

  var matchMonthsPatterns = {
    short: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    long: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };

  var parseMonthPatterns = {
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };

  // `timeOfDay` is used to designate which part of the day it is, when used with 12-hour clock.
  // Use the system which is used the most commonly in the locale.
  // For example, if the country doesn't use a.m./p.m., you can use `night`/`morning`/`afternoon`/`evening`:
  //
  //   var matchTimesOfDayPatterns = {
  //     long: /^((in the)? (night|morning|afternoon|evening?))/i
  //   }
  //
  //   var parseTimeOfDayPatterns = {
  //     any: [/(night|morning)/i, /(afternoon|evening)/i]
  //   }
  var matchTimesOfDayPatterns = {
    short: /^(am|pm)/i,
    long: /^([ap]\.?\s?m\.?)/i
  };

  var parseTimeOfDayPatterns = {
    any: [/^a/i, /^p/i]
  };

  var match = {
    ordinalNumbers: buildMatchPatternFn(matchOrdinalNumbersPattern),
    ordinalNumber: parseDecimal,
    weekdays: buildMatchFn(matchWeekdaysPatterns, 'long'),
    weekday: buildParseFn(parseWeekdayPatterns, 'any'),
    months: buildMatchFn(matchMonthsPatterns, 'long'),
    month: buildParseFn(parseMonthPatterns, 'any'),
    timesOfDay: buildMatchFn(matchTimesOfDayPatterns, 'long'),
    timeOfDay: buildParseFn(parseTimeOfDayPatterns, 'any')
  };

  /**
   * @type {Locale}
   * @category Locales
   * @summary English locale (United States).
   * @language English
   * @iso-639-2 eng
   */
  var locale = {
    formatDistance: formatDistance,
    formatLong: formatLong,
    formatRelative: formatRelative,
    localize: localize,
    match: match,
    options: {
      weekStartsOn: 0 /* Sunday */,
      firstWeekContainsDate: 1
    }
  };

  var MILLISECONDS_IN_DAY$1 = 86400000;

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function getUTCDayOfYear (dirtyDate, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var timestamp = date.getTime();
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
    var startOfYearTimestamp = date.getTime();
    var difference = timestamp - startOfYearTimestamp;
    return Math.floor(difference / MILLISECONDS_IN_DAY$1) + 1
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function startOfUTCISOWeek (dirtyDate, dirtyOptions) {
    var weekStartsOn = 1;

    var date = toDate(dirtyDate, dirtyOptions);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;

    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function getUTCISOWeekYear (dirtyDate, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var year = date.getUTCFullYear();

    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear, dirtyOptions);

    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear, dirtyOptions);

    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year
    } else {
      return year - 1
    }
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function startOfUTCISOWeekYear (dirtyDate, dirtyOptions) {
    var year = getUTCISOWeekYear(dirtyDate, dirtyOptions);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCISOWeek(fourthOfJanuary, dirtyOptions);
    return date
  }

  var MILLISECONDS_IN_WEEK$2 = 604800000;

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function getUTCISOWeek (dirtyDate, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var diff = startOfUTCISOWeek(date, dirtyOptions).getTime() - startOfUTCISOWeekYear(date, dirtyOptions).getTime();

    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1
  }

  var formatters = {
    // Month: 1, 2, ..., 12
    'M': function (date) {
      return date.getUTCMonth() + 1
    },

    // Month: 1st, 2nd, ..., 12th
    'Mo': function (date, options) {
      var month = date.getUTCMonth() + 1;
      return options.locale.localize.ordinalNumber(month, {unit: 'month'})
    },

    // Month: 01, 02, ..., 12
    'MM': function (date) {
      return addLeadingZeros(date.getUTCMonth() + 1, 2)
    },

    // Month: Jan, Feb, ..., Dec
    'MMM': function (date, options) {
      return options.locale.localize.month(date.getUTCMonth(), {type: 'short'})
    },

    // Month: January, February, ..., December
    'MMMM': function (date, options) {
      return options.locale.localize.month(date.getUTCMonth(), {type: 'long'})
    },

    // Quarter: 1, 2, 3, 4
    'Q': function (date) {
      return Math.ceil((date.getUTCMonth() + 1) / 3)
    },

    // Quarter: 1st, 2nd, 3rd, 4th
    'Qo': function (date, options) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
      return options.locale.localize.ordinalNumber(quarter, {unit: 'quarter'})
    },

    // Day of month: 1, 2, ..., 31
    'D': function (date) {
      return date.getUTCDate()
    },

    // Day of month: 1st, 2nd, ..., 31st
    'Do': function (date, options) {
      return options.locale.localize.ordinalNumber(date.getUTCDate(), {unit: 'dayOfMonth'})
    },

    // Day of month: 01, 02, ..., 31
    'DD': function (date) {
      return addLeadingZeros(date.getUTCDate(), 2)
    },

    // Day of year: 1, 2, ..., 366
    'DDD': function (date) {
      return getUTCDayOfYear(date)
    },

    // Day of year: 1st, 2nd, ..., 366th
    'DDDo': function (date, options) {
      return options.locale.localize.ordinalNumber(getUTCDayOfYear(date), {unit: 'dayOfYear'})
    },

    // Day of year: 001, 002, ..., 366
    'DDDD': function (date) {
      return addLeadingZeros(getUTCDayOfYear(date), 3)
    },

    // Day of week: Su, Mo, ..., Sa
    'dd': function (date, options) {
      return options.locale.localize.weekday(date.getUTCDay(), {type: 'narrow'})
    },

    // Day of week: Sun, Mon, ..., Sat
    'ddd': function (date, options) {
      return options.locale.localize.weekday(date.getUTCDay(), {type: 'short'})
    },

    // Day of week: Sunday, Monday, ..., Saturday
    'dddd': function (date, options) {
      return options.locale.localize.weekday(date.getUTCDay(), {type: 'long'})
    },

    // Day of week: 0, 1, ..., 6
    'd': function (date) {
      return date.getUTCDay()
    },

    // Day of week: 0th, 1st, 2nd, ..., 6th
    'do': function (date, options) {
      return options.locale.localize.ordinalNumber(date.getUTCDay(), {unit: 'dayOfWeek'})
    },

    // Day of ISO week: 1, 2, ..., 7
    'E': function (date) {
      return date.getUTCDay() || 7
    },

    // ISO week: 1, 2, ..., 53
    'W': function (date) {
      return getUTCISOWeek(date)
    },

    // ISO week: 1st, 2nd, ..., 53th
    'Wo': function (date, options) {
      return options.locale.localize.ordinalNumber(getUTCISOWeek(date), {unit: 'isoWeek'})
    },

    // ISO week: 01, 02, ..., 53
    'WW': function (date) {
      return addLeadingZeros(getUTCISOWeek(date), 2)
    },

    // Year: 00, 01, ..., 99
    'YY': function (date) {
      return addLeadingZeros(date.getUTCFullYear(), 4).substr(2)
    },

    // Year: 1900, 1901, ..., 2099
    'YYYY': function (date) {
      return addLeadingZeros(date.getUTCFullYear(), 4)
    },

    // ISO week-numbering year: 00, 01, ..., 99
    'GG': function (date) {
      return String(getUTCISOWeekYear(date)).substr(2)
    },

    // ISO week-numbering year: 1900, 1901, ..., 2099
    'GGGG': function (date) {
      return getUTCISOWeekYear(date)
    },

    // Hour: 0, 1, ... 23
    'H': function (date) {
      return date.getUTCHours()
    },

    // Hour: 00, 01, ..., 23
    'HH': function (date) {
      return addLeadingZeros(date.getUTCHours(), 2)
    },

    // Hour: 1, 2, ..., 12
    'h': function (date) {
      var hours = date.getUTCHours();
      if (hours === 0) {
        return 12
      } else if (hours > 12) {
        return hours % 12
      } else {
        return hours
      }
    },

    // Hour: 01, 02, ..., 12
    'hh': function (date) {
      return addLeadingZeros(formatters['h'](date), 2)
    },

    // Minute: 0, 1, ..., 59
    'm': function (date) {
      return date.getUTCMinutes()
    },

    // Minute: 00, 01, ..., 59
    'mm': function (date) {
      return addLeadingZeros(date.getUTCMinutes(), 2)
    },

    // Second: 0, 1, ..., 59
    's': function (date) {
      return date.getUTCSeconds()
    },

    // Second: 00, 01, ..., 59
    'ss': function (date) {
      return addLeadingZeros(date.getUTCSeconds(), 2)
    },

    // 1/10 of second: 0, 1, ..., 9
    'S': function (date) {
      return Math.floor(date.getUTCMilliseconds() / 100)
    },

    // 1/100 of second: 00, 01, ..., 99
    'SS': function (date) {
      return addLeadingZeros(Math.floor(date.getUTCMilliseconds() / 10), 2)
    },

    // Millisecond: 000, 001, ..., 999
    'SSS': function (date) {
      return addLeadingZeros(date.getUTCMilliseconds(), 3)
    },

    // Timezone: -01:00, +00:00, ... +12:00
    'Z': function (date, options) {
      var originalDate = options._originalDate || date;
      return formatTimezone(originalDate.getTimezoneOffset(), ':')
    },

    // Timezone: -0100, +0000, ... +1200
    'ZZ': function (date, options) {
      var originalDate = options._originalDate || date;
      return formatTimezone(originalDate.getTimezoneOffset())
    },

    // Seconds timestamp: 512969520
    'X': function (date, options) {
      var originalDate = options._originalDate || date;
      return Math.floor(originalDate.getTime() / 1000)
    },

    // Milliseconds timestamp: 512969520900
    'x': function (date, options) {
      var originalDate = options._originalDate || date;
      return originalDate.getTime()
    },

    // AM, PM
    'A': function (date, options) {
      return options.locale.localize.timeOfDay(date.getUTCHours(), {type: 'uppercase'})
    },

    // am, pm
    'a': function (date, options) {
      return options.locale.localize.timeOfDay(date.getUTCHours(), {type: 'lowercase'})
    },

    // a.m., p.m.
    'aa': function (date, options) {
      return options.locale.localize.timeOfDay(date.getUTCHours(), {type: 'long'})
    }
  };

  function formatTimezone (offset, delimeter) {
    delimeter = delimeter || '';
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;
    return sign + addLeadingZeros(hours, 2) + delimeter + addLeadingZeros(minutes, 2)
  }

  function addLeadingZeros (number, targetLength) {
    var output = Math.abs(number).toString();
    while (output.length < targetLength) {
      output = '0' + output;
    }
    return output
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function addUTCMinutes (dirtyDate, dirtyAmount, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var amount = Number(dirtyAmount);
    date.setUTCMinutes(date.getUTCMinutes() + amount);
    return date
  }

  var longFormattingTokensRegExp = /(\[[^[]*])|(\\)?(LTS|LT|LLLL|LLL|LL|L|llll|lll|ll|l)/g;
  var defaultFormattingTokensRegExp = /(\[[^[]*])|(\\)?(x|ss|s|mm|m|hh|h|do|dddd|ddd|dd|d|aa|a|ZZ|Z|YYYY|YY|X|Wo|WW|W|SSS|SS|S|Qo|Q|Mo|MMMM|MMM|MM|M|HH|H|GGGG|GG|E|Do|DDDo|DDDD|DDD|DD|D|A|.)/g;

  /**
   * @name format
   * @category Common Helpers
   * @summary Format the date.
   *
   * @description
   * Return the formatted date string in the given format.
   *
   * Accepted tokens:
   * | Unit                    | Token | Result examples                  |
   * |-------------------------|-------|----------------------------------|
   * | Month                   | M     | 1, 2, ..., 12                    |
   * |                         | Mo    | 1st, 2nd, ..., 12th              |
   * |                         | MM    | 01, 02, ..., 12                  |
   * |                         | MMM   | Jan, Feb, ..., Dec               |
   * |                         | MMMM  | January, February, ..., December |
   * | Quarter                 | Q     | 1, 2, 3, 4                       |
   * |                         | Qo    | 1st, 2nd, 3rd, 4th               |
   * | Day of month            | D     | 1, 2, ..., 31                    |
   * |                         | Do    | 1st, 2nd, ..., 31st              |
   * |                         | DD    | 01, 02, ..., 31                  |
   * | Day of year             | DDD   | 1, 2, ..., 366                   |
   * |                         | DDDo  | 1st, 2nd, ..., 366th             |
   * |                         | DDDD  | 001, 002, ..., 366               |
   * | Day of week             | d     | 0, 1, ..., 6                     |
   * |                         | do    | 0th, 1st, ..., 6th               |
   * |                         | dd    | Su, Mo, ..., Sa                  |
   * |                         | ddd   | Sun, Mon, ..., Sat               |
   * |                         | dddd  | Sunday, Monday, ..., Saturday    |
   * | Day of ISO week         | E     | 1, 2, ..., 7                     |
   * | ISO week                | W     | 1, 2, ..., 53                    |
   * |                         | Wo    | 1st, 2nd, ..., 53rd              |
   * |                         | WW    | 01, 02, ..., 53                  |
   * | Year                    | YY    | 00, 01, ..., 99                  |
   * |                         | YYYY  | 1900, 1901, ..., 2099            |
   * | ISO week-numbering year | GG    | 00, 01, ..., 99                  |
   * |                         | GGGG  | 1900, 1901, ..., 2099            |
   * | AM/PM                   | A     | AM, PM                           |
   * |                         | a     | am, pm                           |
   * |                         | aa    | a.m., p.m.                       |
   * | Hour                    | H     | 0, 1, ... 23                     |
   * |                         | HH    | 00, 01, ... 23                   |
   * |                         | h     | 1, 2, ..., 12                    |
   * |                         | hh    | 01, 02, ..., 12                  |
   * | Minute                  | m     | 0, 1, ..., 59                    |
   * |                         | mm    | 00, 01, ..., 59                  |
   * | Second                  | s     | 0, 1, ..., 59                    |
   * |                         | ss    | 00, 01, ..., 59                  |
   * | 1/10 of second          | S     | 0, 1, ..., 9                     |
   * | 1/100 of second         | SS    | 00, 01, ..., 99                  |
   * | Millisecond             | SSS   | 000, 001, ..., 999               |
   * | Timezone                | Z     | -01:00, +00:00, ... +12:00       |
   * |                         | ZZ    | -0100, +0000, ..., +1200         |
   * | Seconds timestamp       | X     | 512969520                        |
   * | Milliseconds timestamp  | x     | 512969520900                     |
   * | Long format             | LT    | 05:30 a.m.                       |
   * |                         | LTS   | 05:30:15 a.m.                    |
   * |                         | L     | 07/02/1995                       |
   * |                         | l     | 7/2/1995                         |
   * |                         | LL    | July 2 1995                      |
   * |                         | ll    | Jul 2 1995                       |
   * |                         | LLL   | July 2 1995 05:30 a.m.           |
   * |                         | lll   | Jul 2 1995 05:30 a.m.            |
   * |                         | LLLL  | Sunday, July 2 1995 05:30 a.m.   |
   * |                         | llll  | Sun, Jul 2 1995 05:30 a.m.       |
   *
   * The characters wrapped in square brackets are escaped.
   *
   * The result may vary by locale.
   *
   * @param {Date|String|Number} date - the original date
   * @param {String} format - the string of tokens
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @returns {String} the formatted date string
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   * @throws {RangeError} `options.locale` must contain `localize` property
   * @throws {RangeError} `options.locale` must contain `formatLong` property
   *
   * @example
   * // Represent 11 February 2014 in middle-endian format:
   * var result = format(
   *   new Date(2014, 1, 11),
   *   'MM/DD/YYYY'
   * )
   * //=> '02/11/2014'
   *
   * @example
   * // Represent 2 July 2014 in Esperanto:
   * import { eoLocale } from 'date-fns/locale/eo'
   * var result = format(
   *   new Date(2014, 6, 2),
   *   'Do [de] MMMM YYYY',
   *   {locale: eoLocale}
   * )
   * //=> '2-a de julio 2014'
   */
  function format (dirtyDate, dirtyFormatStr, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var formatStr = String(dirtyFormatStr);
    var options = dirtyOptions || {};

    var locale$$1 = options.locale || locale;

    if (!locale$$1.localize) {
      throw new RangeError('locale must contain localize property')
    }

    if (!locale$$1.formatLong) {
      throw new RangeError('locale must contain formatLong property')
    }

    var localeFormatters = locale$$1.formatters || {};
    var formattingTokensRegExp = locale$$1.formattingTokensRegExp || defaultFormattingTokensRegExp;
    var formatLong = locale$$1.formatLong;

    var originalDate = toDate(dirtyDate, options);

    if (!isValid(originalDate, options)) {
      return 'Invalid Date'
    }

    // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
    var timezoneOffset = originalDate.getTimezoneOffset();
    var utcDate = addUTCMinutes(originalDate, -timezoneOffset, options);

    var formatterOptions = cloneObject(options);
    formatterOptions.locale = locale$$1;
    formatterOptions.formatters = formatters;

    // When UTC functions will be implemented, options._originalDate will likely be a part of public API.
    // Right now, please don't use it in locales. If you have to use an original date,
    // please restore it from `date`, adding a timezone offset to it.
    formatterOptions._originalDate = originalDate;

    var result = formatStr
      .replace(longFormattingTokensRegExp, function (substring) {
        if (substring[0] === '[') {
          return substring
        }

        if (substring[0] === '\\') {
          return cleanEscapedString(substring)
        }

        return formatLong(substring)
      })
      .replace(formattingTokensRegExp, function (substring) {
        var formatter = localeFormatters[substring] || formatters[substring];

        if (formatter) {
          return formatter(utcDate, formatterOptions)
        } else {
          return cleanEscapedString(substring)
        }
      });

    return result
  }

  function cleanEscapedString (input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|]$/g, '')
    }
    return input.replace(/\\/g, '')
  }

  /**
   * @name subMinutes
   * @category Minute Helpers
   * @summary Subtract the specified number of minutes from the given date.
   *
   * @description
   * Subtract the specified number of minutes from the given date.
   *
   * @param {Date|String|Number} date - the date to be changed
   * @param {Number} amount - the amount of minutes to be subtracted
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Date} the new date with the mintues subtracted
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Subtract 30 minutes from 10 July 2014 12:00:00:
   * var result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
   * //=> Thu Jul 10 2014 11:30:00
   */
  function subMinutes (dirtyDate, dirtyAmount, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var amount = Number(dirtyAmount);
    return addMinutes(dirtyDate, -amount, dirtyOptions)
  }

  /**
   * @name isAfter
   * @category Common Helpers
   * @summary Is the first date after the second one?
   *
   * @description
   * Is the first date after the second one?
   *
   * @param {Date|String|Number} date - the date that should be after the other one to return true
   * @param {Date|String|Number} dateToCompare - the date to compare with
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Boolean} the first date is after the second date
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Is 10 July 1989 after 11 February 1987?
   * var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> true
   */
  function isAfter (dirtyDate, dirtyDateToCompare, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var date = toDate(dirtyDate, dirtyOptions);
    var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);
    return date.getTime() > dateToCompare.getTime()
  }

  /**
   * @name isBefore
   * @category Common Helpers
   * @summary Is the first date before the second one?
   *
   * @description
   * Is the first date before the second one?
   *
   * @param {Date|String|Number} date - the date that should be before the other one to return true
   * @param {Date|String|Number} dateToCompare - the date to compare with
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Boolean} the first date is before the second date
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Is 10 July 1989 before 11 February 1987?
   * var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> false
   */
  function isBefore (dirtyDate, dirtyDateToCompare, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var date = toDate(dirtyDate, dirtyOptions);
    var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);
    return date.getTime() < dateToCompare.getTime()
  }

  /**
   * @name isEqual
   * @category Common Helpers
   * @summary Are the given dates equal?
   *
   * @description
   * Are the given dates equal?
   *
   * @param {Date|String|Number} dateLeft - the first date to compare
   * @param {Date|String|Number} dateRight - the second date to compare
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Boolean} the dates are equal
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
   * var result = isEqual(
   *   new Date(2014, 6, 2, 6, 30, 45, 0)
   *   new Date(2014, 6, 2, 6, 30, 45, 500)
   * )
   * //=> false
   */
  function isEqual (dirtyLeftDate, dirtyRightDate, dirtyOptions) {
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')
    }

    var dateLeft = toDate(dirtyLeftDate, dirtyOptions);
    var dateRight = toDate(dirtyRightDate, dirtyOptions);
    return dateLeft.getTime() === dateRight.getTime()
  }

  var patterns$1 = {
    'M': /^(1[0-2]|0?\d)/, // 0 to 12
    'D': /^(3[0-1]|[0-2]?\d)/, // 0 to 31
    'DDD': /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/, // 0 to 366
    'W': /^(5[0-3]|[0-4]?\d)/, // 0 to 53
    'YYYY': /^(\d{1,4})/, // 0 to 9999
    'H': /^(2[0-3]|[0-1]?\d)/, // 0 to 23
    'm': /^([0-5]?\d)/, // 0 to 59
    'Z': /^([+-])(\d{2}):(\d{2})/,
    'ZZ': /^([+-])(\d{2})(\d{2})/,
    singleDigit: /^(\d)/,
    twoDigits: /^(\d{2})/,
    threeDigits: /^(\d{3})/,
    fourDigits: /^(\d{4})/,
    anyDigits: /^(\d+)/
  };

  function parseDecimal$1 (matchResult) {
    return parseInt(matchResult[1], 10)
  }

  var parsers = {
    // Year: 00, 01, ..., 99
    'YY': {
      unit: 'twoDigitYear',
      match: patterns$1.twoDigits,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult)
      }
    },

    // Year: 1900, 1901, ..., 2099
    'YYYY': {
      unit: 'year',
      match: patterns$1.YYYY,
      parse: parseDecimal$1
    },

    // ISO week-numbering year: 00, 01, ..., 99
    'GG': {
      unit: 'isoYear',
      match: patterns$1.twoDigits,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) + 1900
      }
    },

    // ISO week-numbering year: 1900, 1901, ..., 2099
    'GGGG': {
      unit: 'isoYear',
      match: patterns$1.YYYY,
      parse: parseDecimal$1
    },

    // Quarter: 1, 2, 3, 4
    'Q': {
      unit: 'quarter',
      match: patterns$1.singleDigit,
      parse: parseDecimal$1
    },

    // Ordinal quarter
    'Qo': {
      unit: 'quarter',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'quarter'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'quarter'})
      }
    },

    // Month: 1, 2, ..., 12
    'M': {
      unit: 'month',
      match: patterns$1.M,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) - 1
      }
    },

    // Ordinal month
    'Mo': {
      unit: 'month',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'month'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'month'}) - 1
      }
    },

    // Month: 01, 02, ..., 12
    'MM': {
      unit: 'month',
      match: patterns$1.twoDigits,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) - 1
      }
    },

    // Month: Jan, Feb, ..., Dec
    'MMM': {
      unit: 'month',
      match: function (string, options) {
        return options.locale.match.months(string, {type: 'short'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.month(matchResult, {type: 'short'})
      }
    },

    // Month: January, February, ..., December
    'MMMM': {
      unit: 'month',
      match: function (string, options) {
        return options.locale.match.months(string, {type: 'long'}) ||
          options.locale.match.months(string, {type: 'short'})
      },
      parse: function (matchResult, options) {
        var parseResult = options.locale.match.month(matchResult, {type: 'long'});

        if (parseResult == null) {
          parseResult = options.locale.match.month(matchResult, {type: 'short'});
        }

        return parseResult
      }
    },

    // ISO week: 1, 2, ..., 53
    'W': {
      unit: 'isoWeek',
      match: patterns$1.W,
      parse: parseDecimal$1
    },

    // Ordinal ISO week
    'Wo': {
      unit: 'isoWeek',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'isoWeek'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'isoWeek'})
      }
    },

    // ISO week: 01, 02, ..., 53
    'WW': {
      unit: 'isoWeek',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // Day of week: 0, 1, ..., 6
    'd': {
      unit: 'dayOfWeek',
      match: patterns$1.singleDigit,
      parse: parseDecimal$1
    },

    // Ordinal day of week
    'do': {
      unit: 'dayOfWeek',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'dayOfWeek'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'dayOfWeek'})
      }
    },

    // Day of week: Su, Mo, ..., Sa
    'dd': {
      unit: 'dayOfWeek',
      match: function (string, options) {
        return options.locale.match.weekdays(string, {type: 'narrow'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.weekday(matchResult, {type: 'narrow'})
      }
    },

    // Day of week: Sun, Mon, ..., Sat
    'ddd': {
      unit: 'dayOfWeek',
      match: function (string, options) {
        return options.locale.match.weekdays(string, {type: 'short'}) ||
          options.locale.match.weekdays(string, {type: 'narrow'})
      },
      parse: function (matchResult, options) {
        var parseResult = options.locale.match.weekday(matchResult, {type: 'short'});

        if (parseResult == null) {
          parseResult = options.locale.match.weekday(matchResult, {type: 'narrow'});
        }

        return parseResult
      }
    },

    // Day of week: Sunday, Monday, ..., Saturday
    'dddd': {
      unit: 'dayOfWeek',
      match: function (string, options) {
        return options.locale.match.weekdays(string, {type: 'long'}) ||
          options.locale.match.weekdays(string, {type: 'short'}) ||
          options.locale.match.weekdays(string, {type: 'narrow'})
      },
      parse: function (matchResult, options) {
        var parseResult = options.locale.match.weekday(matchResult, {type: 'long'});

        if (parseResult == null) {
          parseResult = options.locale.match.weekday(matchResult, {type: 'short'});

          if (parseResult == null) {
            parseResult = options.locale.match.weekday(matchResult, {type: 'narrow'});
          }
        }

        return parseResult
      }
    },

    // Day of ISO week: 1, 2, ..., 7
    'E': {
      unit: 'dayOfISOWeek',
      match: patterns$1.singleDigit,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult)
      }
    },

    // Day of month: 1, 2, ..., 31
    'D': {
      unit: 'dayOfMonth',
      match: patterns$1.D,
      parse: parseDecimal$1
    },

    // Ordinal day of month
    'Do': {
      unit: 'dayOfMonth',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'dayOfMonth'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'dayOfMonth'})
      }
    },

    // Day of month: 01, 02, ..., 31
    'DD': {
      unit: 'dayOfMonth',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // Day of year: 1, 2, ..., 366
    'DDD': {
      unit: 'dayOfYear',
      match: patterns$1.DDD,
      parse: parseDecimal$1
    },

    // Ordinal day of year
    'DDDo': {
      unit: 'dayOfYear',
      match: function (string, options) {
        return options.locale.match.ordinalNumbers(string, {unit: 'dayOfYear'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.ordinalNumber(matchResult, {unit: 'dayOfYear'})
      }
    },

    // Day of year: 001, 002, ..., 366
    'DDDD': {
      unit: 'dayOfYear',
      match: patterns$1.threeDigits,
      parse: parseDecimal$1
    },

    // AM, PM
    'A': {
      unit: 'timeOfDay',
      match: function (string, options) {
        return options.locale.match.timesOfDay(string, {type: 'short'})
      },
      parse: function (matchResult, options) {
        return options.locale.match.timeOfDay(matchResult, {type: 'short'})
      }
    },

    // a.m., p.m.
    'aa': {
      unit: 'timeOfDay',
      match: function (string, options) {
        return options.locale.match.timesOfDay(string, {type: 'long'}) ||
          options.locale.match.timesOfDay(string, {type: 'short'})
      },
      parse: function (matchResult, options) {
        var parseResult = options.locale.match.timeOfDay(matchResult, {type: 'long'});

        if (parseResult == null) {
          parseResult = options.locale.match.timeOfDay(matchResult, {type: 'short'});
        }

        return parseResult
      }
    },

    // Hour: 0, 1, ... 23
    'H': {
      unit: 'hours',
      match: patterns$1.H,
      parse: parseDecimal$1
    },

    // Hour: 00, 01, ..., 23
    'HH': {
      unit: 'hours',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // Hour: 1, 2, ..., 12
    'h': {
      unit: 'timeOfDayHours',
      match: patterns$1.M,
      parse: parseDecimal$1
    },

    // Hour: 01, 02, ..., 12
    'hh': {
      unit: 'timeOfDayHours',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // Minute: 0, 1, ..., 59
    'm': {
      unit: 'minutes',
      match: patterns$1.m,
      parse: parseDecimal$1
    },

    // Minute: 00, 01, ..., 59
    'mm': {
      unit: 'minutes',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // Second: 0, 1, ..., 59
    's': {
      unit: 'seconds',
      match: patterns$1.m,
      parse: parseDecimal$1
    },

    // Second: 00, 01, ..., 59
    'ss': {
      unit: 'seconds',
      match: patterns$1.twoDigits,
      parse: parseDecimal$1
    },

    // 1/10 of second: 0, 1, ..., 9
    'S': {
      unit: 'milliseconds',
      match: patterns$1.singleDigit,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) * 100
      }
    },

    // 1/100 of second: 00, 01, ..., 99
    'SS': {
      unit: 'milliseconds',
      match: patterns$1.twoDigits,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) * 10
      }
    },

    // Millisecond: 000, 001, ..., 999
    'SSS': {
      unit: 'milliseconds',
      match: patterns$1.threeDigits,
      parse: parseDecimal$1
    },

    // Timezone: -01:00, +00:00, ... +12:00
    'Z': {
      unit: 'timezone',
      match: patterns$1.Z,
      parse: function (matchResult) {
        var sign = matchResult[1];
        var hours = parseInt(matchResult[2], 10);
        var minutes = parseInt(matchResult[3], 10);
        var absoluteOffset = hours * 60 + minutes;
        return (sign === '+') ? absoluteOffset : -absoluteOffset
      }
    },

    // Timezone: -0100, +0000, ... +1200
    'ZZ': {
      unit: 'timezone',
      match: patterns$1.ZZ,
      parse: function (matchResult) {
        var sign = matchResult[1];
        var hours = parseInt(matchResult[2], 10);
        var minutes = parseInt(matchResult[3], 10);
        var absoluteOffset = hours * 60 + minutes;
        return (sign === '+') ? absoluteOffset : -absoluteOffset
      }
    },

    // Seconds timestamp: 512969520
    'X': {
      unit: 'timestamp',
      match: patterns$1.anyDigits,
      parse: function (matchResult) {
        return parseDecimal$1(matchResult) * 1000
      }
    },

    // Milliseconds timestamp: 512969520900
    'x': {
      unit: 'timestamp',
      match: patterns$1.anyDigits,
      parse: parseDecimal$1
    }
  };

  parsers['a'] = parsers['A'];

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function setUTCDay (dirtyDate, dirtyDay, dirtyOptions) {
    var options = dirtyOptions || {};
    var locale = options.locale;
    var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn === undefined ? 0 : Number(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn === undefined ? defaultWeekStartsOn : Number(options.weekStartsOn);

    // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively')
    }

    var date = toDate(dirtyDate, dirtyOptions);
    var day = Number(dirtyDay);

    var currentDay = date.getUTCDay();

    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;

    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;

    date.setUTCDate(date.getUTCDate() + diff);
    return date
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function setUTCISODay (dirtyDate, dirtyDay, dirtyOptions) {
    var day = Number(dirtyDay);

    if (day % 7 === 0) {
      day = day - 7;
    }

    var weekStartsOn = 1;
    var date = toDate(dirtyDate, dirtyOptions);
    var currentDay = date.getUTCDay();

    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;

    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;

    date.setUTCDate(date.getUTCDate() + diff);
    return date
  }

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function setUTCISOWeek (dirtyDate, dirtyISOWeek, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var isoWeek = Number(dirtyISOWeek);
    var diff = getUTCISOWeek(date, dirtyOptions) - isoWeek;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date
  }

  var MILLISECONDS_IN_DAY$3 = 86400000;

  // This function will be a part of public API when UTC function will be implemented.
  // See issue: https://github.com/date-fns/date-fns/issues/376
  function setUTCISOWeekYear (dirtyDate, dirtyISOYear, dirtyOptions) {
    var date = toDate(dirtyDate, dirtyOptions);
    var isoYear = Number(dirtyISOYear);
    var dateStartOfYear = startOfUTCISOWeekYear(date, dirtyOptions);
    var diff = Math.floor((date.getTime() - dateStartOfYear.getTime()) / MILLISECONDS_IN_DAY$3);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(isoYear, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    date = startOfUTCISOWeekYear(fourthOfJanuary, dirtyOptions);
    date.setUTCDate(date.getUTCDate() + diff);
    return date
  }

  var MILLISECONDS_IN_MINUTE$6 = 60000;

  function setTimeOfDay (hours, timeOfDay) {
    var isAM = timeOfDay === 0;

    if (isAM) {
      if (hours === 12) {
        return 0
      }
    } else {
      if (hours !== 12) {
        return 12 + hours
      }
    }

    return hours
  }

  var units = {
    twoDigitYear: {
      priority: 10,
      set: function (dateValues, value) {
        var century = Math.floor(dateValues.date.getUTCFullYear() / 100);
        var year = century * 100 + value;
        dateValues.date.setUTCFullYear(year, 0, 1);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    year: {
      priority: 10,
      set: function (dateValues, value) {
        dateValues.date.setUTCFullYear(value, 0, 1);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    isoYear: {
      priority: 10,
      set: function (dateValues, value, options) {
        dateValues.date = startOfUTCISOWeekYear(setUTCISOWeekYear(dateValues.date, value, options), options);
        return dateValues
      }
    },

    quarter: {
      priority: 20,
      set: function (dateValues, value) {
        dateValues.date.setUTCMonth((value - 1) * 3, 1);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    month: {
      priority: 30,
      set: function (dateValues, value) {
        dateValues.date.setUTCMonth(value, 1);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    isoWeek: {
      priority: 40,
      set: function (dateValues, value, options) {
        dateValues.date = startOfUTCISOWeek(setUTCISOWeek(dateValues.date, value, options), options);
        return dateValues
      }
    },

    dayOfWeek: {
      priority: 50,
      set: function (dateValues, value, options) {
        dateValues.date = setUTCDay(dateValues.date, value, options);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    dayOfISOWeek: {
      priority: 50,
      set: function (dateValues, value, options) {
        dateValues.date = setUTCISODay(dateValues.date, value, options);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    dayOfMonth: {
      priority: 50,
      set: function (dateValues, value) {
        dateValues.date.setUTCDate(value);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    dayOfYear: {
      priority: 50,
      set: function (dateValues, value) {
        dateValues.date.setUTCMonth(0, value);
        dateValues.date.setUTCHours(0, 0, 0, 0);
        return dateValues
      }
    },

    timeOfDay: {
      priority: 60,
      set: function (dateValues, value, options) {
        dateValues.timeOfDay = value;
        return dateValues
      }
    },

    hours: {
      priority: 70,
      set: function (dateValues, value, options) {
        dateValues.date.setUTCHours(value, 0, 0, 0);
        return dateValues
      }
    },

    timeOfDayHours: {
      priority: 70,
      set: function (dateValues, value, options) {
        var timeOfDay = dateValues.timeOfDay;
        if (timeOfDay != null) {
          value = setTimeOfDay(value, timeOfDay);
        }
        dateValues.date.setUTCHours(value, 0, 0, 0);
        return dateValues
      }
    },

    minutes: {
      priority: 80,
      set: function (dateValues, value) {
        dateValues.date.setUTCMinutes(value, 0, 0);
        return dateValues
      }
    },

    seconds: {
      priority: 90,
      set: function (dateValues, value) {
        dateValues.date.setUTCSeconds(value, 0);
        return dateValues
      }
    },

    milliseconds: {
      priority: 100,
      set: function (dateValues, value) {
        dateValues.date.setUTCMilliseconds(value);
        return dateValues
      }
    },

    timezone: {
      priority: 110,
      set: function (dateValues, value) {
        dateValues.date = new Date(dateValues.date.getTime() - value * MILLISECONDS_IN_MINUTE$6);
        return dateValues
      }
    },

    timestamp: {
      priority: 120,
      set: function (dateValues, value) {
        dateValues.date = new Date(value);
        return dateValues
      }
    }
  };

  var TIMEZONE_UNIT_PRIORITY = 110;
  var MILLISECONDS_IN_MINUTE$7 = 60000;

  var longFormattingTokensRegExp$1 = /(\[[^[]*])|(\\)?(LTS|LT|LLLL|LLL|LL|L|llll|lll|ll|l)/g;
  var defaultParsingTokensRegExp = /(\[[^[]*])|(\\)?(x|ss|s|mm|m|hh|h|do|dddd|ddd|dd|d|aa|a|ZZ|Z|YYYY|YY|X|Wo|WW|W|SSS|SS|S|Qo|Q|Mo|MMMM|MMM|MM|M|HH|H|GGGG|GG|E|Do|DDDo|DDDD|DDD|DD|D|A|.)/g;

  /**
   * @name parse
   * @category Common Helpers
   * @summary Parse the date.
   *
   * @description
   * Return the date parsed from string using the given format.
   *
   * Accepted format tokens:
   * | Unit                    | Priority | Token | Input examples                   |
   * |-------------------------|----------|-------|----------------------------------|
   * | Year                    | 10       | YY    | 00, 01, ..., 99                  |
   * |                         |          | YYYY  | 1900, 1901, ..., 2099            |
   * | ISO week-numbering year | 10       | GG    | 00, 01, ..., 99                  |
   * |                         |          | GGGG  | 1900, 1901, ..., 2099            |
   * | Quarter                 | 20       | Q     | 1, 2, 3, 4                       |
   * |                         |          | Qo    | 1st, 2nd, 3rd, 4th               |
   * | Month                   | 30       | M     | 1, 2, ..., 12                    |
   * |                         |          | Mo    | 1st, 2nd, ..., 12th              |
   * |                         |          | MM    | 01, 02, ..., 12                  |
   * |                         |          | MMM   | Jan, Feb, ..., Dec               |
   * |                         |          | MMMM  | January, February, ..., December |
   * | ISO week                | 40       | W     | 1, 2, ..., 53                    |
   * |                         |          | Wo    | 1st, 2nd, ..., 53rd              |
   * |                         |          | WW    | 01, 02, ..., 53                  |
   * | Day of week             | 50       | d     | 0, 1, ..., 6                     |
   * |                         |          | do    | 0th, 1st, ..., 6th               |
   * |                         |          | dd    | Su, Mo, ..., Sa                  |
   * |                         |          | ddd   | Sun, Mon, ..., Sat               |
   * |                         |          | dddd  | Sunday, Monday, ..., Saturday    |
   * | Day of ISO week         | 50       | E     | 1, 2, ..., 7                     |
   * | Day of month            | 50       | D     | 1, 2, ..., 31                    |
   * |                         |          | Do    | 1st, 2nd, ..., 31st              |
   * |                         |          | DD    | 01, 02, ..., 31                  |
   * | Day of year             | 50       | DDD   | 1, 2, ..., 366                   |
   * |                         |          | DDDo  | 1st, 2nd, ..., 366th             |
   * |                         |          | DDDD  | 001, 002, ..., 366               |
   * | Time of day             | 60       | A     | AM, PM                           |
   * |                         |          | a     | am, pm                           |
   * |                         |          | aa    | a.m., p.m.                       |
   * | Hour                    | 70       | H     | 0, 1, ... 23                     |
   * |                         |          | HH    | 00, 01, ... 23                   |
   * | Time of day hour        | 70       | h     | 1, 2, ..., 12                    |
   * |                         |          | hh    | 01, 02, ..., 12                  |
   * | Minute                  | 80       | m     | 0, 1, ..., 59                    |
   * |                         |          | mm    | 00, 01, ..., 59                  |
   * | Second                  | 90       | s     | 0, 1, ..., 59                    |
   * |                         |          | ss    | 00, 01, ..., 59                  |
   * | 1/10 of second          | 100      | S     | 0, 1, ..., 9                     |
   * | 1/100 of second         | 100      | SS    | 00, 01, ..., 99                  |
   * | Millisecond             | 100      | SSS   | 000, 001, ..., 999               |
   * | Timezone                | 110      | Z     | -01:00, +00:00, ... +12:00       |
   * |                         |          | ZZ    | -0100, +0000, ..., +1200         |
   * | Seconds timestamp       | 120      | X     | 512969520                        |
   * | Milliseconds timestamp  | 120      | x     | 512969520900                     |
   *
   * Values will be assigned to the date in the ascending order of its unit's priority.
   * Units of an equal priority overwrite each other in the order of appearance.
   *
   * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
   * the values will be taken from 3rd argument `baseDate` which works as a context of parsing.
   *
   * `baseDate` must be passed for correct work of the function.
   * If you're not sure which `baseDate` to supply, create a new instance of Date:
   * `parse('02/11/2014', 'MM/DD/YYYY', new Date())`
   * In this case parsing will be done in the context of the current date.
   * If `baseDate` is `Invalid Date` or a value not convertible to valid `Date`,
   * then `Invalid Date` will be returned.
   *
   * Also, `parse` unfolds long formats like those in [format]{@link https://date-fns.org/docs/format}:
   * | Token | Input examples                 |
   * |-------|--------------------------------|
   * | LT    | 05:30 a.m.                     |
   * | LTS   | 05:30:15 a.m.                  |
   * | L     | 07/02/1995                     |
   * | l     | 7/2/1995                       |
   * | LL    | July 2 1995                    |
   * | ll    | Jul 2 1995                     |
   * | LLL   | July 2 1995 05:30 a.m.         |
   * | lll   | Jul 2 1995 05:30 a.m.          |
   * | LLLL  | Sunday, July 2 1995 05:30 a.m. |
   * | llll  | Sun, Jul 2 1995 05:30 a.m.     |
   *
   * The characters wrapped in square brackets in the format string are escaped.
   *
   * The result may vary by locale.
   *
   * If `formatString` matches with `dateString` but does not provides tokens, `baseDate` will be returned.
   *
   * If parsing failed, `Invalid Date` will be returned.
   * Invalid Date is a Date, whose time value is NaN.
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * @param {String} dateString - the string to parse
   * @param {String} formatString - the string of tokens
   * @param {Date|String|Number} baseDate - the date to took the missing higher priority values from
   * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @returns {Date} the parsed date
   * @throws {TypeError} 3 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
   * @throws {RangeError} `options.locale` must contain `match` property
   * @throws {RangeError} `options.locale` must contain `formatLong` property
   *
   * @example
   * // Parse 11 February 2014 from middle-endian format:
   * var result = parse(
   *   '02/11/2014',
   *   'MM/DD/YYYY',
   *   new Date()
   * )
   * //=> Tue Feb 11 2014 00:00:00
   *
   * @example
   * // Parse 28th of February in English locale in the context of 2010 year:
   * import eoLocale from 'date-fns/locale/eo'
   * var result = parse(
   *   '28-a de februaro',
   *   'Do [de] MMMM',
   *   new Date(2010, 0, 1)
   *   {locale: eoLocale}
   * )
   * //=> Sun Feb 28 2010 00:00:00
   */
  function parse (dirtyDateString, dirtyFormatString, dirtyBaseDate, dirtyOptions) {
    if (arguments.length < 3) {
      throw new TypeError('3 arguments required, but only ' + arguments.length + ' present')
    }

    var dateString = String(dirtyDateString);
    var options = dirtyOptions || {};

    var weekStartsOn = options.weekStartsOn === undefined ? 0 : Number(options.weekStartsOn);

    // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively')
    }

    var locale$$1 = options.locale || locale;
    var localeParsers = locale$$1.parsers || {};
    var localeUnits = locale$$1.units || {};

    if (!locale$$1.match) {
      throw new RangeError('locale must contain match property')
    }

    if (!locale$$1.formatLong) {
      throw new RangeError('locale must contain formatLong property')
    }

    var formatString = String(dirtyFormatString)
      .replace(longFormattingTokensRegExp$1, function (substring) {
        if (substring[0] === '[') {
          return substring
        }

        if (substring[0] === '\\') {
          return cleanEscapedString$1(substring)
        }

        return locale$$1.formatLong(substring)
      });

    if (formatString === '') {
      if (dateString === '') {
        return toDate(dirtyBaseDate, options)
      } else {
        return new Date(NaN)
      }
    }

    var subFnOptions = cloneObject(options);
    subFnOptions.locale = locale$$1;

    var tokens = formatString.match(locale$$1.parsingTokensRegExp || defaultParsingTokensRegExp);
    var tokensLength = tokens.length;

    // If timezone isn't specified, it will be set to the system timezone
    var setters = [{
      priority: TIMEZONE_UNIT_PRIORITY,
      set: dateToSystemTimezone,
      index: 0
    }];

    var i;
    for (i = 0; i < tokensLength; i++) {
      var token = tokens[i];
      var parser = localeParsers[token] || parsers[token];
      if (parser) {
        var matchResult;

        if (parser.match instanceof RegExp) {
          matchResult = parser.match.exec(dateString);
        } else {
          matchResult = parser.match(dateString, subFnOptions);
        }

        if (!matchResult) {
          return new Date(NaN)
        }

        var unitName = parser.unit;
        var unit = localeUnits[unitName] || units[unitName];

        setters.push({
          priority: unit.priority,
          set: unit.set,
          value: parser.parse(matchResult, subFnOptions),
          index: setters.length
        });

        var substring = matchResult[0];
        dateString = dateString.slice(substring.length);
      } else {
        var head = tokens[i].match(/^\[.*]$/) ? tokens[i].replace(/^\[|]$/g, '') : tokens[i];
        if (dateString.indexOf(head) === 0) {
          dateString = dateString.slice(head.length);
        } else {
          return new Date(NaN)
        }
      }
    }

    var uniquePrioritySetters = setters
      .map(function (setter) {
        return setter.priority
      })
      .sort(function (a, b) {
        return a - b
      })
      .filter(function (priority, index, array) {
        return array.indexOf(priority) === index
      })
      .map(function (priority) {
        return setters
          .filter(function (setter) {
            return setter.priority === priority
          })
          .reverse()
      })
      .map(function (setterArray) {
        return setterArray[0]
      });

    var date = toDate(dirtyBaseDate, options);

    if (isNaN(date)) {
      return new Date(NaN)
    }

    // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37
    var utcDate = subMinutes(date, date.getTimezoneOffset());

    var dateValues = {date: utcDate};

    var settersLength = uniquePrioritySetters.length;
    for (i = 0; i < settersLength; i++) {
      var setter = uniquePrioritySetters[i];
      dateValues = setter.set(dateValues, setter.value, subFnOptions);
    }

    return dateValues.date
  }

  function dateToSystemTimezone (dateValues) {
    var date = dateValues.date;
    var time = date.getTime();

    // Get the system timezone offset at (moment of time - offset)
    var offset = date.getTimezoneOffset();

    // Get the system timezone offset at the exact moment of time
    offset = new Date(time + offset * MILLISECONDS_IN_MINUTE$7).getTimezoneOffset();

    // Convert date in timezone "UTC+00:00" to the system timezone
    dateValues.date = new Date(time + offset * MILLISECONDS_IN_MINUTE$7);

    return dateValues
  }

  function cleanEscapedString$1 (input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|]$/g, '')
    }
    return input.replace(/\\/g, '')
  }

  // This file is generated automatically by `scripts/build/indices.js`. Please, don't change it.

  // 

  /**
   * Custom parse behavior on top of date-fns parse function.
   */
  function parseDate$1 (date, format$$1) {
    if (typeof date !== 'string') {
      return isValid(date) ? date : null;
    }

    var parsed = parse(date, format$$1, new Date());

    // if date is not valid or the formatted output after parsing does not match
    // the string value passed in (avoids overflows)
    if (!isValid(parsed) || format(parsed, format$$1) !== date) {
      return null;
    }

    return parsed;
  }

  var afterValidator = function (value, ref) {
    if ( ref === void 0 ) ref = {};
    var targetValue = ref.targetValue;
    var inclusion = ref.inclusion; if ( inclusion === void 0 ) inclusion = false;
    var format$$1 = ref.format;

    if (typeof format$$1 === 'undefined') {
      format$$1 = inclusion;
      inclusion = false;
    }

    value = parseDate$1(value, format$$1);
    targetValue = parseDate$1(targetValue, format$$1);

    // if either is not valid.
    if (!value || !targetValue) {
      return false;
    }

    return isAfter(value, targetValue) || (inclusion && isEqual(value, targetValue));
  };

  var options = {
    hasTarget: true,
    isDate: true
  };

  // required to convert from a list of array values to an object.
  var paramNames = ['targetValue', 'inclusion', 'format'];

  var after = {
    validate: afterValidator,
    options: options,
    paramNames: paramNames
  };

  /**
   * Some Alpha Regex helpers.
   * https://github.com/chriso/validator.js/blob/master/src/lib/alpha.js
   */

  var alpha = {
    en: /^[A-Z]*$/i,
    cs: /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]*$/i,
    da: /^[A-ZÆØÅ]*$/i,
    de: /^[A-ZÄÖÜß]*$/i,
    es: /^[A-ZÁÉÍÑÓÚÜ]*$/i,
    fr: /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]*$/i,
    lt: /^[A-ZĄČĘĖĮŠŲŪŽ]*$/i,
    nl: /^[A-ZÉËÏÓÖÜ]*$/i,
    hu: /^[A-ZÁÉÍÓÖŐÚÜŰ]*$/i,
    pl: /^[A-ZĄĆĘŚŁŃÓŻŹ]*$/i,
    pt: /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$/i,
    ru: /^[А-ЯЁ]*$/i,
    sk: /^[A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ]*$/i,
    sr: /^[A-ZČĆŽŠĐ]*$/i,
    sv: /^[A-ZÅÄÖ]*$/i,
    tr: /^[A-ZÇĞİıÖŞÜ]*$/i,
    uk: /^[А-ЩЬЮЯЄІЇҐ]*$/i,
    ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]*$/,
    az: /^[A-ZÇƏĞİıÖŞÜ]*$/i
  };

  var alphaSpaces = {
    en: /^[A-Z\s]*$/i,
    cs: /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ\s]*$/i,
    da: /^[A-ZÆØÅ\s]*$/i,
    de: /^[A-ZÄÖÜß\s]*$/i,
    es: /^[A-ZÁÉÍÑÓÚÜ\s]*$/i,
    fr: /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ\s]*$/i,
    lt: /^[A-ZĄČĘĖĮŠŲŪŽ\s]*$/i,
    nl: /^[A-ZÉËÏÓÖÜ\s]*$/i,
    hu: /^[A-ZÁÉÍÓÖŐÚÜŰ\s]*$/i,
    pl: /^[A-ZĄĆĘŚŁŃÓŻŹ\s]*$/i,
    pt: /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ\s]*$/i,
    ru: /^[А-ЯЁ\s]*$/i,
    sk: /^[A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ\s]*$/i,
    sr: /^[A-ZČĆŽŠĐ\s]*$/i,
    sv: /^[A-ZÅÄÖ\s]*$/i,
    tr: /^[A-ZÇĞİıÖŞÜ\s]*$/i,
    uk: /^[А-ЩЬЮЯЄІЇҐ\s]*$/i,
    ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ\s]*$/,
    az: /^[A-ZÇƏĞİıÖŞÜ\s]*$/i
  };

  var alphanumeric = {
    en: /^[0-9A-Z]*$/i,
    cs: /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]*$/i,
    da: /^[0-9A-ZÆØÅ]$/i,
    de: /^[0-9A-ZÄÖÜß]*$/i,
    es: /^[0-9A-ZÁÉÍÑÓÚÜ]*$/i,
    fr: /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]*$/i,
    lt: /^[0-9A-ZĄČĘĖĮŠŲŪŽ]*$/i,
    hu: /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]*$/i,
    nl: /^[0-9A-ZÉËÏÓÖÜ]*$/i,
    pl: /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]*$/i,
    pt: /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$/i,
    ru: /^[0-9А-ЯЁ]*$/i,
    sk: /^[0-9A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ]*$/i,
    sr: /^[0-9A-ZČĆŽŠĐ]*$/i,
    sv: /^[0-9A-ZÅÄÖ]*$/i,
    tr: /^[0-9A-ZÇĞİıÖŞÜ]*$/i,
    uk: /^[0-9А-ЩЬЮЯЄІЇҐ]*$/i,
    ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]*$/,
    az: /^[0-9A-ZÇƏĞİıÖŞÜ]*$/i
  };

  var alphaDash = {
    en: /^[0-9A-Z_-]*$/i,
    cs: /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ_-]*$/i,
    da: /^[0-9A-ZÆØÅ_-]*$/i,
    de: /^[0-9A-ZÄÖÜß_-]*$/i,
    es: /^[0-9A-ZÁÉÍÑÓÚÜ_-]*$/i,
    fr: /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ_-]*$/i,
    lt: /^[0-9A-ZĄČĘĖĮŠŲŪŽ_-]*$/i,
    nl: /^[0-9A-ZÉËÏÓÖÜ_-]*$/i,
    hu: /^[0-9A-ZÁÉÍÓÖŐÚÜŰ_-]*$/i,
    pl: /^[0-9A-ZĄĆĘŚŁŃÓŻŹ_-]*$/i,
    pt: /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ_-]*$/i,
    ru: /^[0-9А-ЯЁ_-]*$/i,
    sk: /^[0-9A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ_-]*$/i,
    sr: /^[0-9A-ZČĆŽŠĐ_-]*$/i,
    sv: /^[0-9A-ZÅÄÖ_-]*$/i,
    tr: /^[0-9A-ZÇĞİıÖŞÜ_-]*$/i,
    uk: /^[0-9А-ЩЬЮЯЄІЇҐ_-]*$/i,
    ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ_-]*$/,
    az: /^[0-9A-ZÇƏĞİıÖŞÜ_-]*$/i
  };

  var validate = function (value, ref) {
    if ( ref === void 0 ) ref = {};
    var locale = ref.locale;

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate(val, [locale]); });
    }

    // Match at least one locale.
    if (! locale) {
      return Object.keys(alpha).some(function (loc) { return alpha[loc].test(value); });
    }

    return (alpha[locale] || alpha.en).test(value);
  };

  var paramNames$1 = ['locale'];

  var alpha$1 = {
    validate: validate,
    paramNames: paramNames$1
  };

  var validate$1 = function (value, ref) {
    if ( ref === void 0 ) ref = {};
    var locale = ref.locale;

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$1(val, [locale]); });
    }

    // Match at least one locale.
    if (! locale) {
      return Object.keys(alphaDash).some(function (loc) { return alphaDash[loc].test(value); });
    }

    return (alphaDash[locale] || alphaDash.en).test(value);
  };

  var paramNames$2 = ['locale'];

  var alpha_dash = {
    validate: validate$1,
    paramNames: paramNames$2
  };

  var validate$2 = function (value, ref) {
    if ( ref === void 0 ) ref = {};
    var locale = ref.locale;

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$2(val, [locale]); });
    }

    // Match at least one locale.
    if (! locale) {
      return Object.keys(alphanumeric).some(function (loc) { return alphanumeric[loc].test(value); });
    }

    return (alphanumeric[locale] || alphanumeric.en).test(value);
  };

  var paramNames$3 = ['locale'];

  var alpha_num = {
    validate: validate$2,
    paramNames: paramNames$3
  };

  var validate$3 = function (value, ref) {
    if ( ref === void 0 ) ref = {};
    var locale = ref.locale;

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$3(val, [locale]); });
    }

    // Match at least one locale.
    if (! locale) {
      return Object.keys(alphaSpaces).some(function (loc) { return alphaSpaces[loc].test(value); });
    }

    return (alphaSpaces[locale] || alphaSpaces.en).test(value);
  };

  var paramNames$4 = ['locale'];

  var alpha_spaces = {
    validate: validate$3,
    paramNames: paramNames$4
  };

  var validate$4 = function (value, ref) {
    if ( ref === void 0 ) ref = {};
    var targetValue = ref.targetValue;
    var inclusion = ref.inclusion; if ( inclusion === void 0 ) inclusion = false;
    var format$$1 = ref.format;

    if (typeof format$$1 === 'undefined') {
      format$$1 = inclusion;
      inclusion = false;
    }

    value = parseDate$1(value, format$$1);
    targetValue = parseDate$1(targetValue, format$$1);

    // if either is not valid.
    if (!value || !targetValue) {
      return false;
    }

    return isBefore(value, targetValue) || (inclusion && isEqual(value, targetValue));
  };

  var options$1 = {
    hasTarget: true,
    isDate: true
  };

  var paramNames$5 = ['targetValue', 'inclusion', 'format'];

  var before = {
    validate: validate$4,
    options: options$1,
    paramNames: paramNames$5
  };

  var validate$5 = function (value, ref) {
    if ( ref === void 0 ) ref = {};
    var min = ref.min;
    var max = ref.max;

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$5(val, { min: min, max: max }); });
    }

    return Number(min) <= value && Number(max) >= value;
  };

  var paramNames$6 = ['min', 'max'];

  var between = {
    validate: validate$5,
    paramNames: paramNames$6
  };

  var validate$6 = function (value, ref) {
    var targetValue = ref.targetValue;

    return String(value) === String(targetValue);
  };
  var options$2 = {
    hasTarget: true
  };

  var paramNames$7 = ['targetValue'];

  var confirmed = {
    validate: validate$6,
    options: options$2,
    paramNames: paramNames$7
  };

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var assertString_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.default = assertString;
  function assertString(input) {
    var isString = typeof input === 'string' || input instanceof String;

    if (!isString) {
      var invalidType = void 0;
      if (input === null) {
        invalidType = 'null';
      } else {
        invalidType = typeof input === 'undefined' ? 'undefined' : _typeof(input);
        if (invalidType === 'object' && input.constructor && input.constructor.hasOwnProperty('name')) {
          invalidType = input.constructor.name;
        } else {
          invalidType = 'a ' + invalidType;
        }
      }
      throw new TypeError('Expected string but received ' + invalidType + '.');
    }
  }
  module.exports = exports['default'];
  });

  unwrapExports(assertString_1);

  var isCreditCard_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCreditCard;



  var _assertString2 = _interopRequireDefault(assertString_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /* eslint-disable max-len */
  var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14})$/;
  /* eslint-enable max-len */

  function isCreditCard(str) {
    (0, _assertString2.default)(str);
    var sanitized = str.replace(/[- ]+/g, '');
    if (!creditCard.test(sanitized)) {
      return false;
    }
    var sum = 0;
    var digit = void 0;
    var tmpNum = void 0;
    var shouldDouble = void 0;
    for (var i = sanitized.length - 1; i >= 0; i--) {
      digit = sanitized.substring(i, i + 1);
      tmpNum = parseInt(digit, 10);
      if (shouldDouble) {
        tmpNum *= 2;
        if (tmpNum >= 10) {
          sum += tmpNum % 10 + 1;
        } else {
          sum += tmpNum;
        }
      } else {
        sum += tmpNum;
      }
      shouldDouble = !shouldDouble;
    }
    return !!(sum % 10 === 0 ? sanitized : false);
  }
  module.exports = exports['default'];
  });

  var isCreditCard = unwrapExports(isCreditCard_1);

  var validate$7 = function (value) { return isCreditCard(String(value)); };

  var credit_card = {
    validate: validate$7
  };

  var validate$8 = function (value, ref) {
    if ( ref === void 0 ) ref = {};
    var min$$1 = ref.min;
    var max$$1 = ref.max;
    var inclusivity = ref.inclusivity; if ( inclusivity === void 0 ) inclusivity = '()';
    var format$$1 = ref.format;

    if (typeof format$$1 === 'undefined') {
      format$$1 = inclusivity;
      inclusivity = '()';
    }

    var minDate = parseDate$1(String(min$$1), format$$1);
    var maxDate = parseDate$1(String(max$$1), format$$1);
    var dateVal = parseDate$1(String(value), format$$1);

    if (!minDate || !maxDate || !dateVal) {
      return false;
    }

    if (inclusivity === '()') {
      return isAfter(dateVal, minDate) && isBefore(dateVal, maxDate);
    }

    if (inclusivity === '(]') {
      return isAfter(dateVal, minDate) && (isEqual(dateVal, maxDate) || isBefore(dateVal, maxDate));
    }

    if (inclusivity === '[)') {
      return isBefore(dateVal, maxDate) && (isEqual(dateVal, minDate) || isAfter(dateVal, minDate));
    }

    return isEqual(dateVal, maxDate) || isEqual(dateVal, minDate) ||
      (isBefore(dateVal, maxDate) && isAfter(dateVal, minDate));
  };

  var options$3 = {
    isDate: true
  };

  var paramNames$8 = ['min', 'max', 'inclusivity', 'format'];

  var date_between = {
    validate: validate$8,
    options: options$3,
    paramNames: paramNames$8
  };

  var validate$9 = function (value, ref) {
    var format = ref.format;

    return !!parseDate$1(value, format);
  };

  var options$4 = {
    isDate: true
  };

  var paramNames$9 = ['format'];

  var date_format = {
    validate: validate$9,
    options: options$4,
    paramNames: paramNames$9
  };

  var validate$a = function (value, ref) {
    if ( ref === void 0 ) ref = {};
    var decimals = ref.decimals; if ( decimals === void 0 ) decimals = '*';
    var separator = ref.separator; if ( separator === void 0 ) separator = '.';

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$a(val, { decimals: decimals, separator: separator }); });
    }

    if (value === null || value === undefined || value === '') {
      return false;
    }

    // if is 0.
    if (Number(decimals) === 0) {
      return /^-?\d*$/.test(value);
    }

    var regexPart = decimals === '*' ? '+' : ("{1," + decimals + "}");
    var regex = new RegExp(("^[-+]?\\d*(\\" + separator + "\\d" + regexPart + ")?$"));

    if (! regex.test(value)) {
      return false;
    }

    var parsedValue = parseFloat(value);

    // eslint-disable-next-line
      return parsedValue === parsedValue;
  };

  var paramNames$a = ['decimals', 'separator'];

  var decimal = {
    validate: validate$a,
    paramNames: paramNames$a
  };

  var validate$b = function (value, ref) {
    var length = ref[0];

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$b(val, [length]); });
    }
    var strVal = String(value);

    return /^[0-9]*$/.test(strVal) && strVal.length === Number(length);
  };

  var digits = {
    validate: validate$b
  };

  var validateImage = function (file, width, height) {
    var URL = window.URL || window.webkitURL;
    return new Promise(function (resolve) {
      var image = new Image();
      image.onerror = function () { return resolve({ valid: false }); };
      image.onload = function () { return resolve({
        valid: image.width === Number(width) && image.height === Number(height)
      }); };

      image.src = URL.createObjectURL(file);
    });
  };

  var validate$c = function (files, ref) {
    var width = ref[0];
    var height = ref[1];

    var list = [];
    for (var i = 0; i < files.length; i++) {
      // if file is not an image, reject.
      if (! /\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(files[i].name)) {
        return false;
      }

      list.push(files[i]);
    }

    return Promise.all(list.map(function (file) { return validateImage(file, width, height); }));
  };

  var dimensions = {
    validate: validate$c
  };

  var merge_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = merge;
  function merge() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var defaults = arguments[1];

    for (var key in defaults) {
      if (typeof obj[key] === 'undefined') {
        obj[key] = defaults[key];
      }
    }
    return obj;
  }
  module.exports = exports['default'];
  });

  unwrapExports(merge_1);

  var isByteLength_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.default = isByteLength;



  var _assertString2 = _interopRequireDefault(assertString_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /* eslint-disable prefer-rest-params */
  function isByteLength(str, options) {
    (0, _assertString2.default)(str);
    var min = void 0;
    var max = void 0;
    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
      min = options.min || 0;
      max = options.max;
    } else {
      // backwards compatibility: isByteLength(str, min [, max])
      min = arguments[1];
      max = arguments[2];
    }
    var len = encodeURI(str).split(/%..|./).length - 1;
    return len >= min && (typeof max === 'undefined' || len <= max);
  }
  module.exports = exports['default'];
  });

  unwrapExports(isByteLength_1);

  var isFQDN_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFQDN;



  var _assertString2 = _interopRequireDefault(assertString_1);



  var _merge2 = _interopRequireDefault(merge_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var default_fqdn_options = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false
  };

  function isFQDN(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge2.default)(options, default_fqdn_options);

    /* Remove the optional trailing dot before checking validity */
    if (options.allow_trailing_dot && str[str.length - 1] === '.') {
      str = str.substring(0, str.length - 1);
    }
    var parts = str.split('.');
    for (var i = 0; i < parts.length; i++) {
      if (parts[i].length > 63) {
        return false;
      }
    }
    if (options.require_tld) {
      var tld = parts.pop();
      if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      }
      // disallow spaces
      if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
        return false;
      }
    }
    for (var part, _i = 0; _i < parts.length; _i++) {
      part = parts[_i];
      if (options.allow_underscores) {
        part = part.replace(/_/g, '');
      }
      if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      }
      // disallow full-width chars
      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      }
      if (part[0] === '-' || part[part.length - 1] === '-') {
        return false;
      }
    }
    return true;
  }
  module.exports = exports['default'];
  });

  unwrapExports(isFQDN_1);

  var isIP_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIP;



  var _assertString2 = _interopRequireDefault(assertString_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
  var ipv6Block = /^[0-9A-F]{1,4}$/i;

  function isIP(str) {
    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    (0, _assertString2.default)(str);
    version = String(version);
    if (!version) {
      return isIP(str, 4) || isIP(str, 6);
    } else if (version === '4') {
      if (!ipv4Maybe.test(str)) {
        return false;
      }
      var parts = str.split('.').sort(function (a, b) {
        return a - b;
      });
      return parts[3] <= 255;
    } else if (version === '6') {
      var blocks = str.split(':');
      var foundOmissionBlock = false; // marker to indicate ::

      // At least some OS accept the last 32 bits of an IPv6 address
      // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
      // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
      // and '::a.b.c.d' is deprecated, but also valid.
      var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
      var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

      if (blocks.length > expectedNumberOfBlocks) {
        return false;
      }
      // initial or final ::
      if (str === '::') {
        return true;
      } else if (str.substr(0, 2) === '::') {
        blocks.shift();
        blocks.shift();
        foundOmissionBlock = true;
      } else if (str.substr(str.length - 2) === '::') {
        blocks.pop();
        blocks.pop();
        foundOmissionBlock = true;
      }

      for (var i = 0; i < blocks.length; ++i) {
        // test for a :: which can not be at the string start/end
        // since those cases have been handled above
        if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
          if (foundOmissionBlock) {
            return false; // multiple :: in address
          }
          foundOmissionBlock = true;
        } else if (foundIPv4TransitionBlock && i === blocks.length - 1) ; else if (!ipv6Block.test(blocks[i])) {
          return false;
        }
      }
      if (foundOmissionBlock) {
        return blocks.length >= 1;
      }
      return blocks.length === expectedNumberOfBlocks;
    }
    return false;
  }
  module.exports = exports['default'];
  });

  var isIP = unwrapExports(isIP_1);

  var isEmail_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmail;



  var _assertString2 = _interopRequireDefault(assertString_1);



  var _merge2 = _interopRequireDefault(merge_1);



  var _isByteLength2 = _interopRequireDefault(isByteLength_1);



  var _isFQDN2 = _interopRequireDefault(isFQDN_1);



  var _isIP2 = _interopRequireDefault(isIP_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var default_email_options = {
    allow_display_name: false,
    require_display_name: false,
    allow_utf8_local_part: true,
    require_tld: true
  };

  /* eslint-disable max-len */
  /* eslint-disable no-control-regex */
  var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
  var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
  var gmailUserPart = /^[a-z\d]+$/;
  var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
  var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
  var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
  /* eslint-enable max-len */
  /* eslint-enable no-control-regex */

  function isEmail(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge2.default)(options, default_email_options);

    if (options.require_display_name || options.allow_display_name) {
      var display_email = str.match(displayName);
      if (display_email) {
        str = display_email[1];
      } else if (options.require_display_name) {
        return false;
      }
    }

    var parts = str.split('@');
    var domain = parts.pop();
    var user = parts.join('@');

    var lower_domain = domain.toLowerCase();

    if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
      /*
        Previously we removed dots for gmail addresses before validating.
        This was removed because it allows `multiple..dots@gmail.com`
        to be reported as valid, but it is not.
        Gmail only normalizes single dots, removing them from here is pointless,
        should be done in normalizeEmail
      */
      user = user.toLowerCase();

      // Removing sub-address from username before gmail validation
      var username = user.split('+')[0];

      // Dots are not included in gmail length restriction
      if (!(0, _isByteLength2.default)(username.replace('.', ''), { min: 6, max: 30 })) {
        return false;
      }

      var _user_parts = username.split('.');
      for (var i = 0; i < _user_parts.length; i++) {
        if (!gmailUserPart.test(_user_parts[i])) {
          return false;
        }
      }
    }

    if (!(0, _isByteLength2.default)(user, { max: 64 }) || !(0, _isByteLength2.default)(domain, { max: 254 })) {
      return false;
    }

    if (!(0, _isFQDN2.default)(domain, { require_tld: options.require_tld })) {
      if (!options.allow_ip_domain) {
        return false;
      }

      if (!(0, _isIP2.default)(domain)) {
        if (!domain.startsWith('[') || !domain.endsWith(']')) {
          return false;
        }

        var noBracketdomain = domain.substr(1, domain.length - 2);

        if (noBracketdomain.length === 0 || !(0, _isIP2.default)(noBracketdomain)) {
          return false;
        }
      }
    }

    if (user[0] === '"') {
      user = user.slice(1, user.length - 1);
      return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
    }

    var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;

    var user_parts = user.split('.');
    for (var _i = 0; _i < user_parts.length; _i++) {
      if (!pattern.test(user_parts[_i])) {
        return false;
      }
    }

    return true;
  }
  module.exports = exports['default'];
  });

  var isEmail = unwrapExports(isEmail_1);

  var validate$d = function (value, options) {
    if ( options === void 0 ) options = {};

    if (options.multiple) {
      value = value.split(',').map(function (emailStr) { return emailStr.trim(); });
    }

    if (Array.isArray(value)) {
      return value.every(function (val) { return isEmail(String(val), options); });
    }

    return isEmail(String(value), options);
  };

  var email = {
    validate: validate$d
  };

  // 

  var isTextInput = function (el) {
    return includes(['text', 'password', 'search', 'email', 'tel', 'url', 'textarea', 'number'], el.type);
  };

  var isCheckboxOrRadioInput = function (el) {
    return includes(['radio', 'checkbox'], el.type);
  };

  var isDateInput = function (el) {
    return includes(['date', 'week', 'month', 'datetime-local', 'time'], el.type);
  };

  /**
   * Gets the data attribute. the name must be kebab-case.
   */
  var getDataAttribute = function (el, name) { return el.getAttribute(("data-vv-" + name)); };

  /**
   * Checks if the values are either null or undefined.
   */
  var isNullOrUndefined = function () {
    var values = [], len = arguments.length;
    while ( len-- ) values[ len ] = arguments[ len ];

    return values.every(function (value) {
      return value === null || value === undefined;
    });
  };

  /**
   * Creates the default flags object.
   */
  var createFlags = function () { return ({
    untouched: true,
    touched: false,
    dirty: false,
    pristine: true,
    valid: null,
    invalid: null,
    validated: false,
    pending: false,
    required: false,
    changed: false
  }); };

  /**
   * Shallow object comparison.
   */
  var isEqual$1 = function (lhs, rhs) {
    if (lhs instanceof RegExp && rhs instanceof RegExp) {
      return isEqual$1(lhs.source, rhs.source) && isEqual$1(lhs.flags, rhs.flags);
    }

    if (Array.isArray(lhs) && Array.isArray(rhs)) {
      if (lhs.length !== rhs.length) { return false; }

      for (var i = 0; i < lhs.length; i++) {
        if (!isEqual$1(lhs[i], rhs[i])) {
          return false;
        }
      }

      return true;
    }

    // if both are objects, compare each key recursively.
    if (isObject(lhs) && isObject(rhs)) {
      return Object.keys(lhs).every(function (key) {
        return isEqual$1(lhs[key], rhs[key]);
      }) && Object.keys(rhs).every(function (key) {
        return isEqual$1(lhs[key], rhs[key]);
      });
    }

    return lhs === rhs;
  };

  /**
   * Determines the input field scope.
   */
  var getScope = function (el) {
    var scope = getDataAttribute(el, 'scope');
    if (isNullOrUndefined(scope)) {
      var form = getForm(el);

      if (form) {
        scope = getDataAttribute(form, 'scope');
      }
    }

    return !isNullOrUndefined(scope) ? scope : null;
  };

  /**
   * Get the closest form element.
   */
  var getForm = function (el) {
    if (isNullOrUndefined(el)) { return null; }

    if (el.tagName === 'FORM') { return el; }

    if (!isNullOrUndefined(el.form)) { return el.form; }

    return !isNullOrUndefined(el.parentNode) ? getForm(el.parentNode) : null;
  };

  /**
   * Gets the value in an object safely.
   */
  var getPath = function (path, target, def) {
    if ( def === void 0 ) def = undefined;

    if (!path || !target) { return def; }

    var value = target;
    path.split('.').every(function (prop) {
      if (prop in value) {
        value = value[prop];

        return true;
      }

      value = def;

      return false;
    });

    return value;
  };

  /**
   * Checks if path exists within an object.
   */
  var hasPath = function (path, target) {
    var obj = target;
    return path.split('.').every(function (prop) {
      if (prop in obj) {
        obj = obj[prop];

        return true;
      }

      return false;
    });
  };

  /**
   * Parses a rule string expression.
   */
  var parseRule = function (rule) {
    var params = [];
    var name = rule.split(':')[0];

    if (includes(rule, ':')) {
      params = rule.split(':').slice(1).join(':').split(',');
    }

    return { name: name, params: params };
  };

  /**
   * Debounces a function.
   */
  var debounce = function (fn, wait, token) {
    if ( wait === void 0 ) wait = 0;
    if ( token === void 0 ) token = { cancelled: false };

    if (wait === 0) {
      return fn;
    }

    var timeout;

    return function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var later = function () {
        timeout = null;

        // check if the fn call was cancelled.
        if (!token.cancelled) { fn.apply(void 0, args); }
      };

      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (!timeout) { fn.apply(void 0, args); }
    };
  };

  /**
   * Appends a rule definition to a list of rules.
   */
  var appendRule = function (rule, rules) {
    if (!rules) {
      return normalizeRules(rule);
    }

    if (!rule) {
      return normalizeRules(rules);
    }

    if (typeof rules === 'string') {
      rules = normalizeRules(rules);
    }

    return assign({}, rules, normalizeRules(rule));
  };

  /**
   * Normalizes the given rules expression.
   */
  var normalizeRules = function (rules) {
    // if falsy value return an empty object.
    if (!rules) {
      return {};
    }

    if (isObject(rules)) {
      // $FlowFixMe
      return Object.keys(rules).reduce(function (prev, curr) {
        var params = [];
        // $FlowFixMe
        if (rules[curr] === true) {
          params = [];
        } else if (Array.isArray(rules[curr])) {
          params = rules[curr];
        } else if (isObject(rules[curr])) {
          params = rules[curr];
        } else {
          params = [rules[curr]];
        }

        // $FlowFixMe
        if (rules[curr] !== false) {
          prev[curr] = params;
        }

        return prev;
      }, {});
    }

    if (typeof rules !== 'string') {
      warn('rules must be either a string or an object.');
      return {};
    }

    return rules.split('|').reduce(function (prev, rule) {
      var parsedRule = parseRule(rule);
      if (!parsedRule.name) {
        return prev;
      }

      prev[parsedRule.name] = parsedRule.params;
      return prev;
    }, {});
  };

  /**
   * Emits a warning to the console.
   */
  var warn = function (message) {
    console.warn(("[vee-validate] " + message)); // eslint-disable-line
  };

  /**
   * Creates a branded error object.
   */
  var createError = function (message) { return new Error(("[vee-validate] " + message)); };

  /**
   * Checks if the value is an object.
   */
  var isObject = function (obj) { return obj !== null && obj && typeof obj === 'object' && ! Array.isArray(obj); };

  /**
   * Checks if a function is callable.
   */
  var isCallable = function (func) { return typeof func === 'function'; };

  /**
   * Check if element has the css class on it.
   */
  var hasClass = function (el, className) {
    if (el.classList) {
      return el.classList.contains(className);
    }

    return !!el.className.match(new RegExp(("(\\s|^)" + className + "(\\s|$)")));
  };

  /**
   * Adds the provided css className to the element.
   */
  var addClass = function (el, className) {
    if (el.classList) {
      el.classList.add(className);
      return;
    }

    if (!hasClass(el, className)) {
      el.className += " " + className;
    }
  };

  /**
   * Remove the provided css className from the element.
   */
  var removeClass = function (el, className) {
    if (el.classList) {
      el.classList.remove(className);
      return;
    }

    if (hasClass(el, className)) {
      var reg = new RegExp(("(\\s|^)" + className + "(\\s|$)"));
      el.className = el.className.replace(reg, ' ');
    }
  };

  /**
   * Adds or removes a class name on the input depending on the status flag.
   */
  var toggleClass = function (el, className, status) {
    if (!el || !className) { return; }

    if (Array.isArray(className)) {
      className.forEach(function (item) { return toggleClass(el, item, status); });
      return;
    }

    if (status) {
      return addClass(el, className);
    }

    removeClass(el, className);
  };

  /**
   * Converts an array-like object to array, provides a simple polyfill for Array.from
   */
  var toArray = function (arrayLike) {
    if (isCallable(Array.from)) {
      return Array.from(arrayLike);
    }

    var array = [];
    var length = arrayLike.length;
    /* istanbul ignore next */
    for (var i = 0; i < length; i++) {
      array.push(arrayLike[i]);
    }

    /* istanbul ignore next */
    return array;
  };

  /**
   * Assign polyfill from the mdn.
   */
  var assign = function (target) {
    var others = [], len = arguments.length - 1;
    while ( len-- > 0 ) others[ len ] = arguments[ len + 1 ];

    /* istanbul ignore else */
    if (isCallable(Object.assign)) {
      return Object.assign.apply(Object, [ target ].concat( others ));
    }

    /* istanbul ignore next */
    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    /* istanbul ignore next */
    var to = Object(target);
    /* istanbul ignore next */
    others.forEach(function (arg) {
      // Skip over if undefined or null
      if (arg != null) {
        Object.keys(arg).forEach(function (key) {
          to[key] = arg[key];
        });
      }
    });
    /* istanbul ignore next */
    return to;
  };

  var id = 0;
  var idTemplate = '{id}';

  /**
   * Generates a unique id.
   */
  var uniqId = function () {
    // handle too many uses of uniqId, although unlikely.
    if (id >= 9999) {
      id = 0;
      // shift the template.
      idTemplate = idTemplate.replace('{id}', '_{id}');
    }

    id++;
    var newId = idTemplate.replace('{id}', String(id));

    return newId;
  };

  /**
   * finds the first element that satisfies the predicate callback, polyfills array.find
   */
  var find = function (arrayLike, predicate) {
    var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);
    for (var i = 0; i < array.length; i++) {
      if (predicate(array[i])) {
        return array[i];
      }
    }

    return undefined;
  };

  var isBuiltInComponent = function (vnode) {
    if (!vnode) {
      return false;
    }

    var tag = vnode.componentOptions.tag;

    return /^(keep-alive|transition|transition-group)$/.test(tag);
  };

  var makeDelayObject = function (events, delay, delayConfig) {
    if (typeof delay === 'number') {
      return events.reduce(function (prev, e) {
        prev[e] = delay;
        return prev;
      }, {});
    }

    return events.reduce(function (prev, e) {
      if (typeof delay === 'object' && e in delay) {
        prev[e] = delay[e];
        return prev;
      }

      if (typeof delayConfig === 'number') {
        prev[e] = delayConfig;
        return prev;
      }

      prev[e] = (delayConfig && delayConfig[e]) || 0;

      return prev;
    }, {});
  };

  var deepParseInt = function (input) {
    if (typeof input === 'number') { return input; }

    if (typeof input === 'string') { return parseInt(input); }

    var map = {};
    for (var element in input) {
      map[element] = parseInt(input[element]);
    }

    return map;
  };

  var merge$1 = function (target, source) {
    if (! (isObject(target) && isObject(source))) {
      return target;
    }

    Object.keys(source).forEach(function (key) {
      var obj, obj$1;

      if (isObject(source[key])) {
        if (! target[key]) {
          assign(target, ( obj = {}, obj[key] = {}, obj ));
        }

        merge$1(target[key], source[key]);
        return;
      }

      assign(target, ( obj$1 = {}, obj$1[key] = source[key], obj$1 ));
    });

    return target;
  };

  var fillRulesFromElement = function (el, rules) {
    if (el.required) {
      rules = appendRule('required', rules);
    }

    if (isTextInput(el)) {
      if (el.type === 'email') {
        rules = appendRule(("email" + (el.multiple ? ':multiple' : '')), rules);
      }

      if (el.pattern) {
        rules = appendRule({ regex: el.pattern }, rules);
      }

      // 524288 is the max on some browsers and test environments.
      if (el.maxLength >= 0 && el.maxLength < 524288) {
        rules = appendRule(("max:" + (el.maxLength)), rules);
      }

      if (el.minLength > 0) {
        rules = appendRule(("min:" + (el.minLength)), rules);
      }

      if (el.type === 'number') {
        rules = appendRule('decimal', rules);
        if (el.min !== '') {
          rules = appendRule(("min_value:" + (el.min)), rules);
        }

        if (el.max !== '') {
          rules = appendRule(("max_value:" + (el.max)), rules);
        }
      }

      return rules;
    }

    if (isDateInput(el)) {
      var timeFormat = el.step && Number(el.step) < 60 ? 'HH:mm:ss' : 'HH:mm';

      if (el.type === 'date') {
        return appendRule('date_format:YYYY-MM-DD', rules);
      }

      if (el.type === 'datetime-local') {
        return appendRule(("date_format:YYYY-MM-DDT" + timeFormat), rules);
      }

      if (el.type === 'month') {
        return appendRule('date_format:YYYY-MM', rules);
      }

      if (el.type === 'week') {
        return appendRule('date_format:YYYY-[W]WW', rules);
      }

      if (el.type === 'time') {
        return appendRule(("date_format:" + timeFormat), rules);
      }
    }

    return rules;
  };

  var values = function (obj) {
    if (isCallable(Object.values)) {
      return Object.values(obj);
    }

    // fallback to keys()
    /* istanbul ignore next */
    return Object.keys(obj).map(function (k) { return obj[k]; });
  };

  var parseSelector = function (selector) {
    var rule = null;
    if (includes(selector, ':')) {
      rule = selector.split(':').pop();
      selector = selector.replace((":" + rule), '');
    }

    if (selector[0] === '#') {
      return {
        id: selector.slice(1),
        rule: rule,
        name: null,
        scope: null
      };
    }

    var scope = null;
    var name = selector;
    if (includes(selector, '.')) {
      var parts = selector.split('.');
      scope = parts[0];
      name = parts.slice(1).join('.');
    }

    return {
      id: null,
      scope: scope,
      name: name,
      rule: rule
    };
  };

  var includes = function (collection, item) {
    return collection.indexOf(item) !== -1;
  };

  var isEmptyArray = function (arr) {
    return Array.isArray(arr) && arr.length === 0;
  };

  var validate$e = function (value, options) {
    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$e(val, options); });
    }

    return toArray(options).some(function (item) {
      // eslint-disable-next-line
      return item == value;
    });
  };

  var included = {
    validate: validate$e
  };

  var validate$f = function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return !validate$e.apply(void 0, args);
  };

  var excluded = {
    validate: validate$f
  };

  var validate$g = function (files, extensions) {
    var regex = new RegExp((".(" + (extensions.join('|')) + ")$"), 'i');

    return files.every(function (file) { return regex.test(file.name); });
  };

  var ext = {
    validate: validate$g
  };

  var validate$h = function (files) { return files.every(function (file) { return /\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(file.name); }); };

  var image = {
    validate: validate$h
  };

  var validate$i = function (value) {
    if (Array.isArray(value)) {
      return value.every(function (val) { return /^-?[0-9]+$/.test(String(val)); });
    }

    return /^-?[0-9]+$/.test(String(value));
  };

  var integer = {
    validate: validate$i
  };

  var validate$j = function (value, ref) {
    if ( ref === void 0 ) ref = {};
    var version = ref.version; if ( version === void 0 ) version = 4;

    if (isNullOrUndefined(value)) {
      value = '';
    }

    if (Array.isArray(value)) {
      return value.every(function (val) { return isIP(val, version); });
    }

    return isIP(value, version);
  };

  var paramNames$b = ['version'];

  var ip = {
    validate: validate$j,
    paramNames: paramNames$b
  };

  var validate$k = function (value, ref) {
    if ( ref === void 0 ) ref = [];
    var other = ref[0];

    return value === other;
  };

  var is = {
    validate: validate$k
  };

  var validate$l = function (value, ref) {
    if ( ref === void 0 ) ref = [];
    var other = ref[0];

    return value !== other;
  };

  var is_not = {
    validate: validate$l
  };

  /**
   * @param {Array|String} value
   * @param {Number} length
   * @param {Number} max
   */
  var compare = function (value, length, max) {
    if (max === undefined) {
      return value.length === length;
    }

    // cast to number.
    max = Number(max);

    return value.length >= length && value.length <= max;
  };

  var validate$m = function (value, ref) {
    var length = ref[0];
    var max = ref[1]; if ( max === void 0 ) max = undefined;

    length = Number(length);
    if (value === undefined || value === null) {
      return false;
    }

    if (typeof value === 'number') {
      value = String(value);
    }

    if (!value.length) {
      value = toArray(value);
    }

    return compare(value, length, max);
  };

  var length = {
    validate: validate$m
  };

  var validate$n = function (value, ref) {
    var length = ref[0];

    if (value === undefined || value === null) {
      return length >= 0;
    }

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$n(val, [length]); });
    }

    return String(value).length <= length;
  };

  var max$1 = {
    validate: validate$n
  };

  var validate$o = function (value, ref) {
    var max = ref[0];

    if (value === null || value === undefined || value === '') {
      return false;
    }

    if (Array.isArray(value)) {
      return value.length > 0 && value.every(function (val) { return validate$o(val, [max]); });
    }

    return Number(value) <= max;
  };

  var max_value = {
    validate: validate$o
  };

  var validate$p = function (files, mimes) {
    var regex = new RegExp(((mimes.join('|').replace('*', '.+')) + "$"), 'i');

    return files.every(function (file) { return regex.test(file.type); });
  };

  var mimes = {
    validate: validate$p
  };

  var validate$q = function (value, ref) {
    var length = ref[0];

    if (value === undefined || value === null) {
      return false;
    }

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$q(val, [length]); });
    }

    return String(value).length >= length;
  };

  var min$1 = {
    validate: validate$q
  };

  var validate$r = function (value, ref) {
    var min = ref[0];

    if (value === null || value === undefined || value === '') {
      return false;
    }

    if (Array.isArray(value)) {
      return value.length > 0 && value.every(function (val) { return validate$r(val, [min]); });
    }

    return Number(value) >= min;
  };

  var min_value = {
    validate: validate$r
  };

  var validate$s = function (value) {
    if (Array.isArray(value)) {
      return value.every(function (val) { return /^[0-9]+$/.test(String(val)); });
    }

    return /^[0-9]+$/.test(String(value));
  };

  var numeric = {
    validate: validate$s
  };

  var validate$t = function (value, ref) {
    var expression = ref.expression;

    if (typeof expression === 'string') {
      expression = new RegExp(expression);
    }

    if (Array.isArray(value)) {
      return value.every(function (val) { return validate$t(val, { expression: expression }); });
    }

    return expression.test(String(value));
  };

  var paramNames$c = ['expression'];

  var regex = {
    validate: validate$t,
    paramNames: paramNames$c
  };

  var validate$u = function (value, ref) {
    if ( ref === void 0 ) ref = [];
    var invalidateFalse = ref[0]; if ( invalidateFalse === void 0 ) invalidateFalse = false;

    if (isEmptyArray(value)) {
      return false;
    }

    // incase a field considers `false` as an empty value like checkboxes.
    if (value === false && invalidateFalse) {
      return false;
    }

    if (value === undefined || value === null) {
      return false;
    }

    return !!String(value).trim().length;
  };

  var required = {
    validate: validate$u
  };

  var validate$v = function (value, ref) {
    if ( ref === void 0 ) ref = [];
    var otherFieldVal = ref[0];
    var possibleVals = ref.slice(1);

    var required = possibleVals.includes(String(otherFieldVal).trim());

    if (!required) {
      return {
        valid: true,
        data: {
          required: required
        }
      };
    }

    var invalid = (isEmptyArray(value) || [false, null, undefined].includes(value));

    invalid = invalid || !String(value).trim().length;

    return {
      valid: !invalid,
      data: {
        required: required
      }
    };
  };

  var options$5 = {
    hasTarget: true,
    computesRequired: true
  };

  var required_if = {
    validate: validate$v,
    options: options$5
  };

  var validate$w = function (files, ref) {
    var size = ref[0];

    if (isNaN(size)) {
      return false;
    }

    var nSize = Number(size) * 1024;
    for (var i = 0; i < files.length; i++) {
      if (files[i].size > nSize) {
        return false;
      }
    }

    return true;
  };

  var size = {
    validate: validate$w
  };

  var isURL_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isURL;



  var _assertString2 = _interopRequireDefault(assertString_1);



  var _isFQDN2 = _interopRequireDefault(isFQDN_1);



  var _isIP2 = _interopRequireDefault(isIP_1);



  var _merge2 = _interopRequireDefault(merge_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var default_url_options = {
    protocols: ['http', 'https', 'ftp'],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false
  };

  var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

  function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
  }

  function checkHost(host, matches) {
    for (var i = 0; i < matches.length; i++) {
      var match = matches[i];
      if (host === match || isRegExp(match) && match.test(host)) {
        return true;
      }
    }
    return false;
  }

  function isURL(url, options) {
    (0, _assertString2.default)(url);
    if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
      return false;
    }
    if (url.indexOf('mailto:') === 0) {
      return false;
    }
    options = (0, _merge2.default)(options, default_url_options);
    var protocol = void 0,
        auth = void 0,
        host = void 0,
        hostname = void 0,
        port = void 0,
        port_str = void 0,
        split = void 0,
        ipv6 = void 0;

    split = url.split('#');
    url = split.shift();

    split = url.split('?');
    url = split.shift();

    split = url.split('://');
    if (split.length > 1) {
      protocol = split.shift().toLowerCase();
      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options.require_protocol) {
      return false;
    } else if (url.substr(0, 2) === '//') {
      if (!options.allow_protocol_relative_urls) {
        return false;
      }
      split[0] = url.substr(2);
    }
    url = split.join('://');

    if (url === '') {
      return false;
    }

    split = url.split('/');
    url = split.shift();

    if (url === '' && !options.require_host) {
      return true;
    }

    split = url.split('@');
    if (split.length > 1) {
      auth = split.shift();
      if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
        return false;
      }
    }
    hostname = split.join('@');

    port_str = null;
    ipv6 = null;
    var ipv6_match = hostname.match(wrapped_ipv6);
    if (ipv6_match) {
      host = '';
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split = hostname.split(':');
      host = split.shift();
      if (split.length) {
        port_str = split.join(':');
      }
    }

    if (port_str !== null) {
      port = parseInt(port_str, 10);
      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    }

    if (!(0, _isIP2.default)(host) && !(0, _isFQDN2.default)(host, options) && (!ipv6 || !(0, _isIP2.default)(ipv6, 6))) {
      return false;
    }

    host = host || ipv6;

    if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
      return false;
    }
    if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
      return false;
    }

    return true;
  }
  module.exports = exports['default'];
  });

  var isURL = unwrapExports(isURL_1);

  var validate$x = function (value, options) {
    if ( options === void 0 ) options = {};

    if (isNullOrUndefined(value)) {
      value = '';
    }

    if (Array.isArray(value)) {
      return value.every(function (val) { return isURL(val, options); });
    }

    return isURL(value, options);
  };

  var url = {
    validate: validate$x
  };

  /* eslint-disable camelcase */

  var Rules = /*#__PURE__*/Object.freeze({
    after: after,
    alpha_dash: alpha_dash,
    alpha_num: alpha_num,
    alpha_spaces: alpha_spaces,
    alpha: alpha$1,
    before: before,
    between: between,
    confirmed: confirmed,
    credit_card: credit_card,
    date_between: date_between,
    date_format: date_format,
    decimal: decimal,
    digits: digits,
    dimensions: dimensions,
    email: email,
    ext: ext,
    image: image,
    included: included,
    integer: integer,
    length: length,
    ip: ip,
    is_not: is_not,
    is: is,
    max: max$1,
    max_value: max_value,
    mimes: mimes,
    min: min$1,
    min_value: min_value,
    excluded: excluded,
    numeric: numeric,
    regex: regex,
    required: required,
    required_if: required_if,
    size: size,
    url: url
  });

  // 

  var LOCALE = 'en';

  var Dictionary = function Dictionary (dictionary) {
    if ( dictionary === void 0 ) dictionary = {};

    this.container = {};
    this.merge(dictionary);
  };

  var prototypeAccessors = { locale: { configurable: true } };

  prototypeAccessors.locale.get = function () {
    return LOCALE;
  };

  prototypeAccessors.locale.set = function (value) {
    LOCALE = value || 'en';
  };

  Dictionary.prototype.hasLocale = function hasLocale (locale) {
    return !!this.container[locale];
  };

  Dictionary.prototype.setDateFormat = function setDateFormat (locale, format) {
    if (!this.container[locale]) {
      this.container[locale] = {};
    }

    this.container[locale].dateFormat = format;
  };

  Dictionary.prototype.getDateFormat = function getDateFormat (locale) {
    if (!this.container[locale] || !this.container[locale].dateFormat) {
      return null;
    }

    return this.container[locale].dateFormat;
  };

  Dictionary.prototype.getMessage = function getMessage (locale, key, data) {
    var message = null;
    if (!this.hasMessage(locale, key)) {
      message = this._getDefaultMessage(locale);
    } else {
      message = this.container[locale].messages[key];
    }

    return isCallable(message) ? message.apply(void 0, data) : message;
  };

  /**
   * Gets a specific message for field. falls back to the rule message.
   */
  Dictionary.prototype.getFieldMessage = function getFieldMessage (locale, field, key, data) {
    if (!this.hasLocale(locale)) {
      return this.getMessage(locale, key, data);
    }

    var dict = this.container[locale].custom && this.container[locale].custom[field];
    if (!dict || !dict[key]) {
      return this.getMessage(locale, key, data);
    }

    var message = dict[key];
    return isCallable(message) ? message.apply(void 0, data) : message;
  };

  Dictionary.prototype._getDefaultMessage = function _getDefaultMessage (locale) {
    if (this.hasMessage(locale, '_default')) {
      return this.container[locale].messages._default;
    }

    return this.container.en.messages._default;
  };

  Dictionary.prototype.getAttribute = function getAttribute (locale, key, fallback) {
      if ( fallback === void 0 ) fallback = '';

    if (!this.hasAttribute(locale, key)) {
      return fallback;
    }

    return this.container[locale].attributes[key];
  };

  Dictionary.prototype.hasMessage = function hasMessage (locale, key) {
    return !! (
      this.hasLocale(locale) &&
            this.container[locale].messages &&
            this.container[locale].messages[key]
    );
  };

  Dictionary.prototype.hasAttribute = function hasAttribute (locale, key) {
    return !! (
      this.hasLocale(locale) &&
            this.container[locale].attributes &&
            this.container[locale].attributes[key]
    );
  };

  Dictionary.prototype.merge = function merge$1$$1 (dictionary) {
    merge$1(this.container, dictionary);
  };

  Dictionary.prototype.setMessage = function setMessage (locale, key, message) {
    if (! this.hasLocale(locale)) {
      this.container[locale] = {
        messages: {},
        attributes: {}
      };
    }

    this.container[locale].messages[key] = message;
  };

  Dictionary.prototype.setAttribute = function setAttribute (locale, key, attribute) {
    if (! this.hasLocale(locale)) {
      this.container[locale] = {
        messages: {},
        attributes: {}
      };
    }

    this.container[locale].attributes[key] = attribute;
  };

  Object.defineProperties( Dictionary.prototype, prototypeAccessors );

  var drivers = {
    default: new Dictionary({
      en: {
        messages: {},
        attributes: {},
        custom: {}
      }
    })
  };

  var currentDriver = 'default';

  var DictionaryResolver = function DictionaryResolver () {};

  DictionaryResolver._checkDriverName = function _checkDriverName (driver) {
    if (!driver) {
      throw createError('you must provide a name to the dictionary driver');
    }
  };

  DictionaryResolver.setDriver = function setDriver (driver, implementation) {
      if ( implementation === void 0 ) implementation = null;

    this._checkDriverName(driver);
    if (implementation) {
      drivers[driver] = implementation;
    }

    currentDriver = driver;
  };

  DictionaryResolver.getDriver = function getDriver () {
    return drivers[currentDriver];
  };

  // 

  var ErrorBag = function ErrorBag (errorBag, id) {
    if ( errorBag === void 0 ) errorBag = null;
    if ( id === void 0 ) id = null;

    this.vmId = id || null;
    // make this bag a mirror of the provided one, sharing the same items reference.
    if (errorBag && errorBag instanceof ErrorBag) {
      this.items = errorBag.items;
    } else {
      this.items = [];
    }
  };

  ErrorBag.prototype[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator'] = function () {
      var this$1 = this;

    var index = 0;
    return {
      next: function () {
        return { value: this$1.items[index++], done: index > this$1.items.length };
      }
    };
  };

  /**
   * Adds an error to the internal array.
   */
  ErrorBag.prototype.add = function add (error) {
      var ref;

    (ref = this.items).push.apply(
      ref, this._normalizeError(error)
    );
  };

  /**
   * Normalizes passed errors to an error array.
   */
  ErrorBag.prototype._normalizeError = function _normalizeError (error) {
      var this$1 = this;

    if (Array.isArray(error)) {
      return error.map(function (e) {
        e.scope = !isNullOrUndefined(e.scope) ? e.scope : null;
        e.vmId = !isNullOrUndefined(e.vmId) ? e.vmId : (this$1.vmId || null);

        return e;
      });
    }

    error.scope = !isNullOrUndefined(error.scope) ? error.scope : null;
    error.vmId = !isNullOrUndefined(error.vmId) ? error.vmId : (this.vmId || null);

    return [error];
  };

  /**
   * Regenrates error messages if they have a generator function.
   */
  ErrorBag.prototype.regenerate = function regenerate () {
    this.items.forEach(function (i) {
      i.msg = isCallable(i.regenerate) ? i.regenerate() : i.msg;
    });
  };

  /**
   * Updates a field error with the new field scope.
   */
  ErrorBag.prototype.update = function update (id, error) {
    var item = find(this.items, function (i) { return i.id === id; });
    if (!item) {
      return;
    }

    var idx = this.items.indexOf(item);
    this.items.splice(idx, 1);
    item.scope = error.scope;
    this.items.push(item);
  };

  /**
   * Gets all error messages from the internal array.
   */
  ErrorBag.prototype.all = function all (scope) {
      var this$1 = this;

    var filterFn = function (item) {
      var matchesScope = true;
      var matchesVM = true;
      if (!isNullOrUndefined(scope)) {
        matchesScope = item.scope === scope;
      }

      if (!isNullOrUndefined(this$1.vmId)) {
        matchesVM = item.vmId === this$1.vmId;
      }

      return matchesVM && matchesScope;
    };

    return this.items.filter(filterFn).map(function (e) { return e.msg; });
  };

  /**
   * Checks if there are any errors in the internal array.
   */
  ErrorBag.prototype.any = function any (scope) {
      var this$1 = this;

    var filterFn = function (item) {
      var matchesScope = true;
      var matchesVM = true;
      if (!isNullOrUndefined(scope)) {
        matchesScope = item.scope === scope;
      }

      if (!isNullOrUndefined(this$1.vmId)) {
        matchesVM = item.vmId === this$1.vmId;
      }

      return matchesVM && matchesScope;
    };

    return !!this.items.filter(filterFn).length;
  };

  /**
   * Removes all items from the internal array.
   */
  ErrorBag.prototype.clear = function clear (scope) {
      var this$1 = this;

    var matchesVM = isNullOrUndefined(this.vmId) ? function () { return true; } : function (i) { return i.vmId === this$1.vmId; };
    if (isNullOrUndefined(scope)) {
      scope = null;
    }

    for (var i = 0; i < this.items.length; ++i) {
      if (matchesVM(this.items[i]) && this.items[i].scope === scope) {
        this.items.splice(i, 1);
        --i;
      }
    }
  };

  /**
   * Collects errors into groups or for a specific field.
   */
  ErrorBag.prototype.collect = function collect (field, scope, map) {
      var this$1 = this;
      if ( map === void 0 ) map = true;

    var isSingleField = !isNullOrUndefined(field) && !field.includes('*');
    var groupErrors = function (items) {
      var errors = items.reduce(function (collection, error) {
        if (!isNullOrUndefined(this$1.vmId) && error.vmId !== this$1.vmId) {
          return collection;
        }

        if (!collection[error.field]) {
          collection[error.field] = [];
        }

        collection[error.field].push(map ? error.msg : error);

        return collection;
      }, {});

      // reduce the collection to be a single array.
      if (isSingleField) {
        return values(errors)[0] || [];
      }

      return errors;
    };

    if (isNullOrUndefined(field)) {
      return groupErrors(this.items);
    }

    var selector = isNullOrUndefined(scope) ? String(field) : (scope + "." + field);
    var ref = this._makeCandidateFilters(selector);
      var isPrimary = ref.isPrimary;
      var isAlt = ref.isAlt;

    var collected = this.items.reduce(function (prev, curr) {
      if (isPrimary(curr)) {
        prev.primary.push(curr);
      }

      if (isAlt(curr)) {
        prev.alt.push(curr);
      }

      return prev;
    }, { primary: [], alt: [] });

    collected = collected.primary.length ? collected.primary : collected.alt;

    return groupErrors(collected);
  };

  /**
   * Gets the internal array length.
   */
  ErrorBag.prototype.count = function count () {
      var this$1 = this;

    if (this.vmId) {
      return this.items.filter(function (e) { return e.vmId === this$1.vmId; }).length;
    }

    return this.items.length;
  };

  /**
   * Finds and fetches the first error message for the specified field id.
   */
  ErrorBag.prototype.firstById = function firstById (id) {
    var error = find(this.items, function (i) { return i.id === id; });

    return error ? error.msg : undefined;
  };

  /**
   * Gets the first error message for a specific field.
   */
  ErrorBag.prototype.first = function first (field, scope) {
      if ( scope === void 0 ) scope = null;

    var selector = isNullOrUndefined(scope) ? field : (scope + "." + field);
    var match = this._match(selector);

    return match && match.msg;
  };

  /**
   * Returns the first error rule for the specified field
   */
  ErrorBag.prototype.firstRule = function firstRule (field, scope) {
    var errors = this.collect(field, scope, false);

    return (errors.length && errors[0].rule) || undefined;
  };

  /**
   * Checks if the internal array has at least one error for the specified field.
   */
  ErrorBag.prototype.has = function has (field, scope) {
      if ( scope === void 0 ) scope = null;

    return !!this.first(field, scope);
  };

  /**
   * Gets the first error message for a specific field and a rule.
   */
  ErrorBag.prototype.firstByRule = function firstByRule (name, rule, scope) {
      if ( scope === void 0 ) scope = null;

    var error = this.collect(name, scope, false).filter(function (e) { return e.rule === rule; })[0];

    return (error && error.msg) || undefined;
  };

  /**
   * Gets the first error message for a specific field that not match the rule.
   */
  ErrorBag.prototype.firstNot = function firstNot (name, rule, scope) {
      if ( rule === void 0 ) rule = 'required';
      if ( scope === void 0 ) scope = null;

    var error = this.collect(name, scope, false).filter(function (e) { return e.rule !== rule; })[0];

    return (error && error.msg) || undefined;
  };

  /**
   * Removes errors by matching against the id or ids.
   */
  ErrorBag.prototype.removeById = function removeById (id) {
    var condition = function (item) { return item.id === id; };
    if (Array.isArray(id)) {
      condition = function (item) { return id.indexOf(item.id) !== -1; };
    }

    for (var i = 0; i < this.items.length; ++i) {
      if (condition(this.items[i])) {
        this.items.splice(i, 1);
        --i;
      }
    }
  };

  /**
   * Removes all error messages associated with a specific field.
   */
  ErrorBag.prototype.remove = function remove (field, scope, vmId) {
    if (isNullOrUndefined(field)) {
      return;
    }

    var selector = isNullOrUndefined(scope) ? String(field) : (scope + "." + field);
    var ref = this._makeCandidateFilters(selector);
      var isPrimary = ref.isPrimary;
      var isAlt = ref.isAlt;
    var matches = function (item) { return isPrimary(item) || isAlt(item); };
    var shouldRemove = function (item) {
      if (isNullOrUndefined(vmId)) { return matches(item); }

      return matches(item) && item.vmId === vmId;
    };

    for (var i = 0; i < this.items.length; ++i) {
      if (shouldRemove(this.items[i])) {
        this.items.splice(i, 1);
        --i;
      }
    }
  };

  ErrorBag.prototype._makeCandidateFilters = function _makeCandidateFilters (selector) {
      var this$1 = this;

    var matchesRule = function () { return true; };
    var matchesScope = function () { return true; };
    var matchesName = function () { return true; };
    var matchesVM = function () { return true; };

    var ref = parseSelector(selector);
      var id = ref.id;
      var rule = ref.rule;
      var scope = ref.scope;
      var name = ref.name;

    if (rule) {
      matchesRule = function (item) { return item.rule === rule; };
    }

    // match by id, can be combined with rule selection.
    if (id) {
      return {
        isPrimary: function (item) { return matchesRule(item) && (function (item) { return id === item.id; }); },
        isAlt: function () { return false; }
      };
    }

    if (isNullOrUndefined(scope)) {
      // if no scope specified, make sure the found error has no scope.
      matchesScope = function (item) { return isNullOrUndefined(item.scope); };
    } else {
      matchesScope = function (item) { return item.scope === scope; };
    }

    if (!isNullOrUndefined(name) && name !== '*') {
      matchesName = function (item) { return item.field === name; };
    }

    if (!isNullOrUndefined(this.vmId)) {
      matchesVM = function (item) { return item.vmId === this$1.vmId; };
    }

    // matches the first candidate.
    var isPrimary = function (item) {
      return matchesVM(item) && matchesName(item) && matchesRule(item) && matchesScope(item);
    };

    // matches a second candidate, which is a field with a name containing the '.' character.
    var isAlt = function (item) {
      return matchesVM(item) && matchesRule(item) && item.field === (scope + "." + name);
    };

    return {
      isPrimary: isPrimary,
      isAlt: isAlt
    };
  };

  ErrorBag.prototype._match = function _match (selector) {
    if (isNullOrUndefined(selector)) {
      return undefined;
    }

    var ref = this._makeCandidateFilters(selector);
      var isPrimary = ref.isPrimary;
      var isAlt = ref.isAlt;

    return this.items.reduce(function (prev, item, idx, arr) {
      var isLast = idx === arr.length - 1;
      if (prev.primary) {
        return isLast ? prev.primary : prev;
      }

      if (isPrimary(item)) {
        prev.primary = item;
      }

      if (isAlt(item)) {
        prev.alt = item;
      }

      // keep going.
      if (!isLast) {
        return prev;
      }

      return prev.primary || prev.alt;
    }, {});
  };

  // VNode Utils

  // Gets the model object on the vnode.
  function findModel (vnode) {
    if (!vnode.data) {
      return null;
    }

    // Component Model
    if (vnode.data.model) {
      return vnode.data.model;
    }

    return !!(vnode.data.directives) && find(vnode.data.directives, function (d) { return d.name === 'model'; });
  }

  function extractChildren (vnode) {
    if (Array.isArray(vnode)) {
      return vnode;
    }

    if (Array.isArray(vnode.children)) {
      return vnode.children;
    }

    if (vnode.componentOptions && Array.isArray(vnode.componentOptions.children)) {
      return vnode.componentOptions.children;
    }

    return [];
  }

  function extractVNodes (vnode) {
    if (findModel(vnode)) {
      return [vnode];
    }

    var children = extractChildren(vnode);

    return children.reduce(function (nodes, node) {
      var candidates = extractVNodes(node);
      if (candidates.length) {
        nodes.push.apply(nodes, candidates);
      }

      return nodes;
    }, []);
  }

  // Resolves v-model config if exists.
  function findModelConfig (vnode) {
    if (!vnode.componentOptions) { return null; }

    return vnode.componentOptions.Ctor.options.model;
  }
  // Adds a listener to vnode listener object.
  function mergeVNodeListeners (obj, eventName, handler) {
    // Has a single listener.
    if (isCallable(obj[eventName])) {
      var prevHandler = obj[eventName];
      obj[eventName] = [prevHandler];
    }

    // has other listeners.
    if (Array.isArray(obj[eventName])) {
      obj[eventName].push(handler);
      return;
    }

    // no listener at all.
    if (isNullOrUndefined(obj[eventName])) {
      obj[eventName] = [handler];
    }
  }

  // Adds a listener to a native HTML vnode.
  function addNativeNodeListener (node, eventName, handler) {
    if (isNullOrUndefined(node.data.on)) {
      node.data.on = {};
    }

    mergeVNodeListeners(node.data.on, eventName, handler);
  }

  // Adds a listener to a Vue component vnode.
  function addComponentNodeListener (node, eventName, handler) {
    /* istanbul ignore next */
    if (!node.componentOptions.listeners) {
      node.componentOptions.listeners = {};
    }

    mergeVNodeListeners(node.componentOptions.listeners, eventName, handler);
  }
  function addVNodeListener (vnode, eventName, handler) {
    if (vnode.componentOptions) {
      addComponentNodeListener(vnode, eventName, handler);
    }

    addNativeNodeListener(vnode, eventName, handler);
  }
  // Determines if `change` should be used over `input` for listeners.
  function getInputEventName (vnode, model) {
    // Is a component.
    if (vnode.componentOptions) {
      var ref = findModelConfig(vnode) || { event: 'input' };
      var event = ref.event;

      return event;
    }

    // Lazy Models typically use change event
    if (model && model.modifiers && model.modifiers.lazy) {
      return 'change';
    }

    // is a textual-type input.
    if (vnode.data.attrs && isTextInput({ type: vnode.data.attrs.type || 'text' })) {
      return 'input';
    }

    return 'change';
  }

  function normalizeSlots (slots, ctx) {
    return Object.keys(slots).reduce(function (arr, key) {
      slots[key].forEach(function (vnode) {
        if (!vnode.context) {
          slots[key].context = ctx;
          if (!vnode.data) {
            vnode.data = {};
          }
          vnode.data.slot = key;
        }
      });

      return arr.concat(slots[key]);
    }, []);
  }

  function createRenderless (h, vnode) {
    // a single-root slot yay!
    if (!Array.isArray(vnode)) {
      return vnode;
    }

    if (vnode.length === 1) {
      return vnode[0];
    }

    {
      warn('Your slot should have one root element. Rendering a span as the root.');
    }

    // Renders a multi-root node, should throw a Vue error.
    return vnode;
  }

  /**
   * Generates the options required to construct a field.
   */
  var Resolver = function Resolver () {};

  Resolver.generate = function generate (el, binding, vnode) {
    var model = Resolver.resolveModel(binding, vnode);
    var options = pluginInstance.resolveConfig(vnode.context);

    return {
      name: Resolver.resolveName(el, vnode),
      el: el,
      listen: !binding.modifiers.disable,
      bails: binding.modifiers.bails ? true : (binding.modifiers.continues === true ? false : undefined),
      scope: Resolver.resolveScope(el, binding, vnode),
      vm: Resolver.makeVM(vnode.context),
      expression: binding.value,
      component: vnode.componentInstance,
      classes: options.classes,
      classNames: options.classNames,
      getter: Resolver.resolveGetter(el, vnode, model),
      events: Resolver.resolveEvents(el, vnode) || options.events,
      model: model,
      delay: Resolver.resolveDelay(el, vnode, options),
      rules: Resolver.resolveRules(el, binding, vnode),
      immediate: !!binding.modifiers.initial || !!binding.modifiers.immediate,
      persist: !!binding.modifiers.persist,
      validity: options.validity,
      aria: options.aria,
      initialValue: Resolver.resolveInitialValue(vnode)
    };
  };

  Resolver.getCtorConfig = function getCtorConfig (vnode) {
    if (!vnode.componentInstance) { return null; }

    var config = getPath('componentInstance.$options.$_veeValidate', vnode);

    return config;
  };

  /**
   * Resolves the rules defined on an element.
   */
  Resolver.resolveRules = function resolveRules (el, binding, vnode) {
    var rules = '';
    if (!binding.value && (!binding || !binding.expression)) {
      rules = getDataAttribute(el, 'rules');
    }

    if (binding.value && includes(['string', 'object'], typeof binding.value.rules)) {
      rules = binding.value.rules;
    } else if (binding.value) {
      rules = binding.value;
    }

    if (vnode.componentInstance) {
      return rules;
    }

    // If validity is disabled, ignore field rules.
    var normalized = normalizeRules(rules);
    if (!pluginInstance.config.useConstraintAttrs) {
      return normalized;
    }

    return assign({}, fillRulesFromElement(el, {}), normalized);
  };

  /**
   * @param {*} vnode
   */
  Resolver.resolveInitialValue = function resolveInitialValue (vnode) {
    var model = vnode.data.model || find(vnode.data.directives, function (d) { return d.name === 'model'; });

    return model && model.value;
  };

  /**
   * Creates a non-circular partial VM instance from a Vue instance.
   * @param {*} vm
   */
  Resolver.makeVM = function makeVM (vm) {
    return {
      get $el () {
        return vm.$el;
      },
      get $refs () {
        return vm.$refs;
      },
      $watch: vm.$watch ? vm.$watch.bind(vm) : function () {},
      $validator: vm.$validator ? {
        errors: vm.$validator.errors,
        validate: vm.$validator.validate.bind(vm.$validator),
        update: vm.$validator.update.bind(vm.$validator)
      } : null
    };
  };

  /**
   * Resolves the delay value.
   * @param {*} el
   * @param {*} vnode
   * @param {Object} options
   */
  Resolver.resolveDelay = function resolveDelay (el, vnode, options) {
    var delay = getDataAttribute(el, 'delay');
    var globalDelay = (options && 'delay' in options) ? options.delay : 0;

    if (!delay && vnode.componentInstance && vnode.componentInstance.$attrs) {
      delay = vnode.componentInstance.$attrs['data-vv-delay'];
    }

    if (!isObject(globalDelay)) {
      return deepParseInt(delay || globalDelay);
    }

    if (!isNullOrUndefined(delay)) {
      globalDelay.input = delay;
    }

    return deepParseInt(globalDelay);
  };

  /**
   * Resolves the events to validate in response to.
   * @param {*} el
   * @param {*} vnode
   */
  Resolver.resolveEvents = function resolveEvents (el, vnode) {
    // resolve it from the root element.
    var events = getDataAttribute(el, 'validate-on');

    // resolve from data-vv-validate-on if its a vue component.
    if (!events && vnode.componentInstance && vnode.componentInstance.$attrs) {
      events = vnode.componentInstance.$attrs['data-vv-validate-on'];
    }

    // resolve it from $_veeValidate options.
    if (!events && vnode.componentInstance) {
      var config = Resolver.getCtorConfig(vnode);
      events = config && config.events;
    }

    if (!events && pluginInstance.config.events) {
      events = pluginInstance.config.events;
    }

    // resolve the model event if its configured for custom components.
    if (events && vnode.componentInstance && includes(events, 'input')) {
      var ref = vnode.componentInstance.$options.model || { event: 'input' };
        var event = ref.event;
      // if the prop was configured but not the model.
      if (!event) {
        return events;
      }

      events = events.replace('input', event);
    }

    return events;
  };

  /**
   * Resolves the scope for the field.
   * @param {*} el
   * @param {*} binding
   */
  Resolver.resolveScope = function resolveScope (el, binding, vnode) {
      if ( vnode === void 0 ) vnode = {};

    var scope = null;
    if (vnode.componentInstance && isNullOrUndefined(scope)) {
      scope = vnode.componentInstance.$attrs && vnode.componentInstance.$attrs['data-vv-scope'];
    }

    return !isNullOrUndefined(scope) ? scope : getScope(el);
  };

  /**
   * Checks if the node directives contains a v-model or a specified arg.
   * Args take priority over models.
   *
   * @return {Object}
   */
  Resolver.resolveModel = function resolveModel (binding, vnode) {
    if (binding.arg) {
      return { expression: binding.arg };
    }

    var model = findModel(vnode);
    if (!model) {
      return null;
    }

    // https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L26
    var watchable = !/[^\w.$]/.test(model.expression) && hasPath(model.expression, vnode.context);
    var lazy = !!(model.modifiers && model.modifiers.lazy);

    if (!watchable) {
      return { expression: null, lazy: lazy };
    }

    return { expression: model.expression, lazy: lazy };
  };

  /**
   * Resolves the field name to trigger validations.
   * @return {String} The field name.
   */
  Resolver.resolveName = function resolveName (el, vnode) {
    var name = getDataAttribute(el, 'name');

    if (!name && !vnode.componentInstance) {
      return el.name;
    }

    if (!name && vnode.componentInstance && vnode.componentInstance.$attrs) {
      name = vnode.componentInstance.$attrs['data-vv-name'] || vnode.componentInstance.$attrs['name'];
    }

    if (!name && vnode.componentInstance) {
      var config = Resolver.getCtorConfig(vnode);
      if (config && isCallable(config.name)) {
        var boundGetter = config.name.bind(vnode.componentInstance);

        return boundGetter();
      }

      return vnode.componentInstance.name;
    }

    return name;
  };

  /**
   * Returns a value getter input type.
   */
  Resolver.resolveGetter = function resolveGetter (el, vnode, model) {
    if (model && model.expression) {
      return function () {
        return getPath(model.expression, vnode.context);
      };
    }

    if (vnode.componentInstance) {
      var path = getDataAttribute(el, 'value-path') || (vnode.componentInstance.$attrs && vnode.componentInstance.$attrs['data-vv-value-path']);
      if (path) {
        return function () {
          return getPath(path, vnode.componentInstance);
        };
      }

      var config = Resolver.getCtorConfig(vnode);
      if (config && isCallable(config.value)) {
        var boundGetter = config.value.bind(vnode.componentInstance);

        return function () {
          return boundGetter();
        };
      }

      var ref = vnode.componentInstance.$options.model || { prop: 'value' };
        var prop = ref.prop;

      return function () {
        return vnode.componentInstance[prop];
      };
    }

    switch (el.type) {
    case 'checkbox': return function () {
      var els = document.querySelectorAll(("input[name=\"" + (el.name) + "\"]"));

      els = toArray(els).filter(function (el) { return el.checked; });
      if (!els.length) { return undefined; }

      return els.map(function (checkbox) { return checkbox.value; });
    };
    case 'radio': return function () {
      var els = document.querySelectorAll(("input[name=\"" + (el.name) + "\"]"));
      var elm = find(els, function (el) { return el.checked; });

      return elm && elm.value;
    };
    case 'file': return function (context) {
      return toArray(el.files);
    };
    case 'select-multiple': return function () {
      return toArray(el.options).filter(function (opt) { return opt.selected; }).map(function (opt) { return opt.value; });
    };
    default: return function () {
      return el && el.value;
    };
    }
  };

  var RULES = {};

  var RuleContainer = function RuleContainer () {};

  var staticAccessors = { rules: { configurable: true } };

  RuleContainer.add = function add (name, ref) {
      var validate = ref.validate;
      var options = ref.options;
      var paramNames = ref.paramNames;

    RULES[name] = {
      validate: validate,
      options: options,
      paramNames: paramNames
    };
  };

  staticAccessors.rules.get = function () {
    return RULES;
  };

  RuleContainer.has = function has (name) {
    return !!RULES[name];
  };

  RuleContainer.isImmediate = function isImmediate (name) {
    return !!(RULES[name] && RULES[name].options.immediate);
  };

  RuleContainer.isRequireRule = function isRequireRule (name) {
    return !!(RULES[name] && RULES[name].options.computesRequired);
  };

  RuleContainer.isTargetRule = function isTargetRule (name) {
    return !!(RULES[name] && RULES[name].options.hasTarget);
  };

  RuleContainer.remove = function remove (ruleName) {
    delete RULES[ruleName];
  };

  RuleContainer.getParamNames = function getParamNames (ruleName) {
    return RULES[ruleName] && RULES[ruleName].paramNames;
  };

  RuleContainer.getOptions = function getOptions (ruleName) {
    return RULES[ruleName] && RULES[ruleName].options;
  };

  RuleContainer.getValidatorMethod = function getValidatorMethod (ruleName) {
    return RULES[ruleName] ? RULES[ruleName].validate : null;
  };

  Object.defineProperties( RuleContainer, staticAccessors );

  // 

  var isEvent = function (evt) {
    return (typeof Event !== 'undefined' && isCallable(Event) && evt instanceof Event) || (evt && evt.srcElement);
  };

  var normalizeEvents = function (evts) {
    if (!evts) { return []; }

    return (typeof evts === 'string' ? evts.split('|') : evts);
  };

  var supportsPassive = true;

  var detectPassiveSupport = function () {
    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get () {
          supportsPassive = true;
        }
      });
      window.addEventListener('testPassive', null, opts);
      window.removeEventListener('testPassive', null, opts);
    } catch (e) {
      supportsPassive = false;
    }
    return supportsPassive;
  };

  var addEventListener = function (el, eventName, cb) {
    el.addEventListener(eventName, cb, supportsPassive ? { passive: true } : false);
  };

  // 

  var DEFAULT_OPTIONS = {
    targetOf: null,
    immediate: false,
    persist: false,
    scope: null,
    listen: true,
    name: null,
    rules: {},
    vm: null,
    classes: false,
    validity: true,
    aria: true,
    events: 'input|blur',
    delay: 0,
    classNames: {
      touched: 'touched', // the control has been blurred
      untouched: 'untouched', // the control hasn't been blurred
      valid: 'valid', // model is valid
      invalid: 'invalid', // model is invalid
      pristine: 'pristine', // control has not been interacted with
      dirty: 'dirty' // control has been interacted with
    }
  };

  var Field = function Field (options) {
    if ( options === void 0 ) options = {};

    this.id = uniqId();
    this.el = options.el;
    this.updated = false;
    this.dependencies = [];
    this.vmId = options.vmId;
    this.watchers = [];
    this.events = [];
    this.delay = 0;
    this.rules = {};
    this.forceRequired = false;
    this._cacheId(options);
    this.classNames = assign({}, DEFAULT_OPTIONS.classNames);
    options = assign({}, DEFAULT_OPTIONS, options);
    this._delay = !isNullOrUndefined(options.delay) ? options.delay : 0; // cache initial delay
    this.validity = options.validity;
    this.aria = options.aria;
    this.flags = options.flags || createFlags();
    this.vm = options.vm;
    this.componentInstance = options.component;
    this.ctorConfig = this.componentInstance ? getPath('$options.$_veeValidate', this.componentInstance) : undefined;
    this.update(options);
    // set initial value.
    this.initialValue = this.value;
    this.updated = false;
  };

  var prototypeAccessors$1 = { validator: { configurable: true },isRequired: { configurable: true },isDisabled: { configurable: true },alias: { configurable: true },value: { configurable: true },bails: { configurable: true },rejectsFalse: { configurable: true } };

  prototypeAccessors$1.validator.get = function () {
    if (!this.vm || !this.vm.$validator) {
      return { validate: function () {} };
    }

    return this.vm.$validator;
  };

  prototypeAccessors$1.isRequired.get = function () {
    return !!this.rules.required || this.forceRequired;
  };

  prototypeAccessors$1.isDisabled.get = function () {
    return !!(this.componentInstance && this.componentInstance.disabled) || !!(this.el && this.el.disabled);
  };

  /**
   * Gets the display name (user-friendly name).
   */
  prototypeAccessors$1.alias.get = function () {
    if (this._alias) {
      return this._alias;
    }

    var alias = null;
    if (this.ctorConfig && this.ctorConfig.alias) {
      alias = isCallable(this.ctorConfig.alias) ? this.ctorConfig.alias.call(this.componentInstance) : this.ctorConfig.alias;
    }

    if (!alias && this.el) {
      alias = getDataAttribute(this.el, 'as');
    }

    if (!alias && this.componentInstance) {
      return this.componentInstance.$attrs && this.componentInstance.$attrs['data-vv-as'];
    }

    return alias;
  };

  /**
   * Gets the input value.
   */

  prototypeAccessors$1.value.get = function () {
    if (!isCallable(this.getter)) {
      return undefined;
    }

    return this.getter();
  };

  prototypeAccessors$1.bails.get = function () {
    return this._bails;
  };

  /**
   * If the field rejects false as a valid value for the required rule.
   */

  prototypeAccessors$1.rejectsFalse.get = function () {
    if (this.componentInstance && this.ctorConfig) {
      return !!this.ctorConfig.rejectsFalse;
    }

    if (!this.el) {
      return false;
    }

    return this.el.type === 'checkbox';
  };

  /**
   * Determines if the instance matches the options provided.
   */
  Field.prototype.matches = function matches (options) {
      var this$1 = this;

    if (!options) {
      return true;
    }

    if (options.id) {
      return this.id === options.id;
    }

    var matchesComponentId = isNullOrUndefined(options.vmId) ? function () { return true; } : function (id) { return id === this$1.vmId; };
    if (!matchesComponentId(options.vmId)) {
      return false;
    }

    if (options.name === undefined && options.scope === undefined) {
      return true;
    }

    if (options.scope === undefined) {
      return this.name === options.name;
    }

    if (options.name === undefined) {
      return this.scope === options.scope;
    }

    return options.name === this.name && options.scope === this.scope;
  };

  /**
   * Caches the field id.
   */
  Field.prototype._cacheId = function _cacheId (options) {
    if (this.el && !options.targetOf) {
      this.el._veeValidateId = this.id;
    }
  };

  /**
   * Keeps a reference of the most current validation run.
   */
  Field.prototype.waitFor = function waitFor (pendingPromise) {
    this._waitingFor = pendingPromise;
  };

  Field.prototype.isWaitingFor = function isWaitingFor (promise) {
    return this._waitingFor === promise;
  };

  /**
   * Updates the field with changed data.
   */
  Field.prototype.update = function update (options) {
    this.targetOf = options.targetOf || null;
    this.immediate = options.immediate || this.immediate || false;
    this.persist = options.persist || this.persist || false;

    // update errors scope if the field scope was changed.
    if (!isNullOrUndefined(options.scope) && options.scope !== this.scope && isCallable(this.validator.update)) {
      this.validator.update(this.id, { scope: options.scope });
    }
    this.scope = !isNullOrUndefined(options.scope) ? options.scope
      : !isNullOrUndefined(this.scope) ? this.scope : null;
    this.name = (!isNullOrUndefined(options.name) ? String(options.name) : options.name) || this.name || null;
    this.rules = options.rules !== undefined ? normalizeRules(options.rules) : this.rules;
    this._bails = options.bails !== undefined ? options.bails : this._bails;
    this.model = options.model || this.model;
    this.listen = options.listen !== undefined ? options.listen : this.listen;
    this.classes = (options.classes || this.classes || false) && !this.componentInstance;
    this.classNames = isObject(options.classNames) ? merge$1(this.classNames, options.classNames) : this.classNames;
    this.getter = isCallable(options.getter) ? options.getter : this.getter;
    this._alias = options.alias || this._alias;
    this.events = (options.events) ? normalizeEvents(options.events) : this.events;
    this.delay = makeDelayObject(this.events, options.delay || this.delay, this._delay);
    this.updateDependencies();
    this.addActionListeners();

    if (!this.name && !this.targetOf) {
      warn('A field is missing a "name" or "data-vv-name" attribute');
    }

    // update required flag flags
    if (options.rules !== undefined) {
      this.flags.required = this.isRequired;
    }

    // validate if it was validated before and field was updated and there was a rules mutation.
    if (this.flags.validated && options.rules !== undefined && this.updated) {
      this.validator.validate(("#" + (this.id)));
    }

    this.updated = true;
    this.addValueListeners();

    // no need to continue.
    if (!this.el) {
      return;
    }
    this.updateClasses();
    this.updateAriaAttrs();
  };

  /**
   * Resets field flags and errors.
   */
  Field.prototype.reset = function reset () {
      var this$1 = this;

    if (this._cancellationToken) {
      this._cancellationToken.cancelled = true;
      delete this._cancellationToken;
    }

    var defaults = createFlags();
    Object.keys(this.flags).filter(function (flag) { return flag !== 'required'; }).forEach(function (flag) {
      this$1.flags[flag] = defaults[flag];
    });

    this.addValueListeners();
    this.addActionListeners();
    this.updateClasses(true);
    this.updateAriaAttrs();
    this.updateCustomValidity();
  };

  /**
   * Sets the flags and their negated counterparts, and updates the classes and re-adds action listeners.
   */
  Field.prototype.setFlags = function setFlags (flags) {
      var this$1 = this;

    var negated = {
      pristine: 'dirty',
      dirty: 'pristine',
      valid: 'invalid',
      invalid: 'valid',
      touched: 'untouched',
      untouched: 'touched'
    };

    Object.keys(flags).forEach(function (flag) {
      this$1.flags[flag] = flags[flag];
      // if it has a negation and was not specified, set it as well.
      if (negated[flag] && flags[negated[flag]] === undefined) {
        this$1.flags[negated[flag]] = !flags[flag];
      }
    });

    if (
      flags.untouched !== undefined ||
      flags.touched !== undefined ||
      flags.dirty !== undefined ||
      flags.pristine !== undefined
    ) {
      this.addActionListeners();
    }
    this.updateClasses();
    this.updateAriaAttrs();
    this.updateCustomValidity();
  };

  /**
   * Determines if the field requires references to target fields.
  */
  Field.prototype.updateDependencies = function updateDependencies () {
      var this$1 = this;

    // reset dependencies.
    this.dependencies.forEach(function (d) { return d.field.destroy(); });
    this.dependencies = [];

    // we get the selectors for each field.
    var fields = Object.keys(this.rules).reduce(function (prev, r) {
      if (RuleContainer.isTargetRule(r)) {
        prev.push({ selector: this$1.rules[r][0], name: r });
      }

      return prev;
    }, []);

    if (!fields.length || !this.vm || !this.vm.$el) { return; }

    // must be contained within the same component, so we use the vm root element constrain our dom search.
    fields.forEach(function (ref$1) {
        var selector = ref$1.selector;
        var name = ref$1.name;

      var ref = this$1.vm.$refs[selector];
      var el = Array.isArray(ref) ? ref[0] : ref;
      if (!el) {
        return;
      }

      var options = {
        vm: this$1.vm,
        classes: this$1.classes,
        classNames: this$1.classNames,
        delay: this$1.delay,
        scope: this$1.scope,
        events: this$1.events.join('|'),
        immediate: this$1.immediate,
        targetOf: this$1.id
      };

      // probably a component.
      if (isCallable(el.$watch)) {
        options.component = el;
        options.el = el.$el;
        options.getter = Resolver.resolveGetter(el.$el, el.$vnode);
      } else {
        options.el = el;
        options.getter = Resolver.resolveGetter(el, {});
      }

      this$1.dependencies.push({ name: name, field: new Field(options) });
    });
  };

  /**
   * Removes listeners.
   */
  Field.prototype.unwatch = function unwatch (tag) {
      if ( tag === void 0 ) tag = null;

    if (!tag) {
      this.watchers.forEach(function (w) { return w.unwatch(); });
      this.watchers = [];
      return;
    }

    this.watchers.filter(function (w) { return tag.test(w.tag); }).forEach(function (w) { return w.unwatch(); });
    this.watchers = this.watchers.filter(function (w) { return !tag.test(w.tag); });
  };

  /**
   * Updates the element classes depending on each field flag status.
   */
  Field.prototype.updateClasses = function updateClasses (isReset) {
      var this$1 = this;
      if ( isReset === void 0 ) isReset = false;

    if (!this.classes || this.isDisabled) { return; }
    var applyClasses = function (el) {
      toggleClass(el, this$1.classNames.dirty, this$1.flags.dirty);
      toggleClass(el, this$1.classNames.pristine, this$1.flags.pristine);
      toggleClass(el, this$1.classNames.touched, this$1.flags.touched);
      toggleClass(el, this$1.classNames.untouched, this$1.flags.untouched);

      // remove valid/invalid classes on reset.
      if (isReset) {
        toggleClass(el, this$1.classNames.valid, false);
        toggleClass(el, this$1.classNames.invalid, false);
      }

      // make sure we don't set any classes if the state is undetermined.
      if (!isNullOrUndefined(this$1.flags.valid) && this$1.flags.validated) {
        toggleClass(el, this$1.classNames.valid, this$1.flags.valid);
      }

      if (!isNullOrUndefined(this$1.flags.invalid) && this$1.flags.validated) {
        toggleClass(el, this$1.classNames.invalid, this$1.flags.invalid);
      }
    };

    if (!isCheckboxOrRadioInput(this.el)) {
      applyClasses(this.el);
      return;
    }

    var els = document.querySelectorAll(("input[name=\"" + (this.el.name) + "\"]"));
    toArray(els).forEach(applyClasses);
  };

  /**
   * Adds the listeners required for automatic classes and some flags.
   */
  Field.prototype.addActionListeners = function addActionListeners () {
      var this$1 = this;

    // remove previous listeners.
    this.unwatch(/class/);

    if (!this.el) { return; }

    var onBlur = function () {
      this$1.flags.touched = true;
      this$1.flags.untouched = false;
      if (this$1.classes) {
        toggleClass(this$1.el, this$1.classNames.touched, true);
        toggleClass(this$1.el, this$1.classNames.untouched, false);
      }

      // only needed once.
      this$1.unwatch(/^class_blur$/);
    };

    var inputEvent = isTextInput(this.el) ? 'input' : 'change';
    var onInput = function () {
      this$1.flags.dirty = true;
      this$1.flags.pristine = false;
      if (this$1.classes) {
        toggleClass(this$1.el, this$1.classNames.pristine, false);
        toggleClass(this$1.el, this$1.classNames.dirty, true);
      }

      // only needed once.
      this$1.unwatch(/^class_input$/);
    };

    if (this.componentInstance && isCallable(this.componentInstance.$once)) {
      this.componentInstance.$once('input', onInput);
      this.componentInstance.$once('blur', onBlur);
      this.watchers.push({
        tag: 'class_input',
        unwatch: function () {
          this$1.componentInstance.$off('input', onInput);
        }
      });
      this.watchers.push({
        tag: 'class_blur',
        unwatch: function () {
          this$1.componentInstance.$off('blur', onBlur);
        }
      });
      return;
    }

    if (!this.el) { return; }

    addEventListener(this.el, inputEvent, onInput);
    // Checkboxes and radio buttons on Mac don't emit blur naturally, so we listen on click instead.
    var blurEvent = isCheckboxOrRadioInput(this.el) ? 'change' : 'blur';
    addEventListener(this.el, blurEvent, onBlur);
    this.watchers.push({
      tag: 'class_input',
      unwatch: function () {
        this$1.el.removeEventListener(inputEvent, onInput);
      }
    });

    this.watchers.push({
      tag: 'class_blur',
      unwatch: function () {
        this$1.el.removeEventListener(blurEvent, onBlur);
      }
    });
  };

  Field.prototype.checkValueChanged = function checkValueChanged () {
    // handle some people initialize the value to null, since text inputs have empty string value.
    if (this.initialValue === null && this.value === '' && isTextInput(this.el)) {
      return false;
    }

    return this.value !== this.initialValue;
  };

  /**
   * Determines the suitable primary event to listen for.
   */
  Field.prototype._determineInputEvent = function _determineInputEvent () {
    // if its a custom component, use the customized model event or the input event.
    if (this.componentInstance) {
      return (this.componentInstance.$options.model && this.componentInstance.$options.model.event) || 'input';
    }

    if (this.model && this.model.lazy) {
      return 'change';
    }

    if (isTextInput(this.el)) {
      return 'input';
    }

    return 'change';
  };

  /**
   * Determines the list of events to listen to.
   */
  Field.prototype._determineEventList = function _determineEventList (defaultInputEvent) {
      var this$1 = this;

    // if no event is configured, or it is a component or a text input then respect the user choice.
    if (!this.events.length || this.componentInstance || isTextInput(this.el)) {
      return [].concat( this.events ).map(function (evt) {
        if (evt === 'input' && this$1.model && this$1.model.lazy) {
          return 'change';
        }

        return evt;
      });
    }

    // force suitable event for non-text type fields.
    return this.events.map(function (e) {
      if (e === 'input') {
        return defaultInputEvent;
      }

      return e;
    });
  };

  /**
   * Adds the listeners required for validation.
   */
  Field.prototype.addValueListeners = function addValueListeners () {
      var this$1 = this;

    this.unwatch(/^input_.+/);
    if (!this.listen || !this.el) { return; }

    var token = { cancelled: false };
    var fn = this.targetOf ? function () {
      this$1.flags.changed = this$1.checkValueChanged();    this$1.validator.validate(("#" + (this$1.targetOf)));
    } : function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

      // if its a DOM event, resolve the value, otherwise use the first parameter as the value.
      if (args.length === 0 || isEvent(args[0])) {
        args[0] = this$1.value;
      }

      this$1.flags.changed = this$1.checkValueChanged();
      this$1.validator.validate(("#" + (this$1.id)), args[0]);
    };

    var inputEvent = this._determineInputEvent();
    var events = this._determineEventList(inputEvent);

    // if there is a model and an on input validation is requested.
    if (this.model && includes(events, inputEvent)) {
      var ctx = null;
      var expression = this.model.expression;
      // if its watchable from the context vm.
      if (this.model.expression) {
        ctx = this.vm;
        expression = this.model.expression;
      }

      // watch it from the custom component vm instead.
      if (!expression && this.componentInstance && this.componentInstance.$options.model) {
        ctx = this.componentInstance;
        expression = this.componentInstance.$options.model.prop || 'value';
      }

      if (ctx && expression) {
        var debouncedFn = debounce(fn, this.delay[inputEvent], token);
        var unwatch = ctx.$watch(expression, function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

          this$1.flags.pending = true;
          this$1._cancellationToken = token;
          debouncedFn.apply(void 0, args);
        });
        this.watchers.push({
          tag: 'input_model',
          unwatch: unwatch
        });

        // filter out input event as it is already handled by the watcher API.
        events = events.filter(function (e) { return e !== inputEvent; });
      }
    }

    // Add events.
    events.forEach(function (e) {
      var debouncedFn = debounce(fn, this$1.delay[e], token);
      var validate = function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];

        this$1.flags.pending = true;
        this$1._cancellationToken = token;
        debouncedFn.apply(void 0, args);
      };

      this$1._addComponentEventListener(e, validate);
      this$1._addHTMLEventListener(e, validate);
    });
  };

  Field.prototype._addComponentEventListener = function _addComponentEventListener (evt, validate) {
      var this$1 = this;

    if (!this.componentInstance) { return; }

    this.componentInstance.$on(evt, validate);
    this.watchers.push({
      tag: 'input_vue',
      unwatch: function () {
        this$1.componentInstance.$off(evt, validate);
      }
    });
  };

  Field.prototype._addHTMLEventListener = function _addHTMLEventListener (evt, validate) {
      var this$1 = this;

    if (!this.el || this.componentInstance) { return; }

    // listen for the current element.
    var addListener = function (el) {
      addEventListener(el, evt, validate);
      this$1.watchers.push({
        tag: 'input_native',
        unwatch: function () {
          el.removeEventListener(evt, validate);
        }
      });
    };

    addListener(this.el);
    if (!isCheckboxOrRadioInput(this.el)) {
      return;
    }

    var els = document.querySelectorAll(("input[name=\"" + (this.el.name) + "\"]"));
    toArray(els).forEach(function (el) {
      // skip if it is added by v-validate and is not the current element.
      if (el._veeValidateId && el !== this$1.el) {
        return;
      }

      addListener(el);
    });
  };

  /**
   * Updates aria attributes on the element.
   */
  Field.prototype.updateAriaAttrs = function updateAriaAttrs () {
      var this$1 = this;

    if (!this.aria || !this.el || !isCallable(this.el.setAttribute)) { return; }

    var applyAriaAttrs = function (el) {
      el.setAttribute('aria-required', this$1.isRequired ? 'true' : 'false');
      el.setAttribute('aria-invalid', this$1.flags.invalid ? 'true' : 'false');
    };

    if (!isCheckboxOrRadioInput(this.el)) {
      applyAriaAttrs(this.el);
      return;
    }

    var els = document.querySelectorAll(("input[name=\"" + (this.el.name) + "\"]"));
    toArray(els).forEach(applyAriaAttrs);
  };

  /**
   * Updates the custom validity for the field.
   */
  Field.prototype.updateCustomValidity = function updateCustomValidity () {
    if (!this.validity || !this.el || !isCallable(this.el.setCustomValidity) || !this.validator.errors) { return; }

    this.el.setCustomValidity(this.flags.valid ? '' : (this.validator.errors.firstById(this.id) || ''));
  };

  /**
   * Removes all listeners.
   */
  Field.prototype.destroy = function destroy () {
    // ignore the result of any ongoing validation.
    if (this._cancellationToken) {
      this._cancellationToken.cancelled = true;
    }

    this.unwatch();
    this.dependencies.forEach(function (d) { return d.field.destroy(); });
    this.dependencies = [];
  };

  Object.defineProperties( Field.prototype, prototypeAccessors$1 );

  // 

  var FieldBag = function FieldBag (items) {
    if ( items === void 0 ) items = [];

    this.items = items || [];
  };

  var prototypeAccessors$2 = { length: { configurable: true } };

  FieldBag.prototype[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator'] = function () {
      var this$1 = this;

    var index = 0;
    return {
      next: function () {
        return { value: this$1.items[index++], done: index > this$1.items.length };
      }
    };
  };

  /**
   * Gets the current items length.
   */

  prototypeAccessors$2.length.get = function () {
    return this.items.length;
  };

  /**
   * Finds the first field that matches the provided matcher object.
   */
  FieldBag.prototype.find = function find$1 (matcher) {
    return find(this.items, function (item) { return item.matches(matcher); });
  };

  /**
   * Filters the items down to the matched fields.
   */
  FieldBag.prototype.filter = function filter (matcher) {
    // multiple matchers to be tried.
    if (Array.isArray(matcher)) {
      return this.items.filter(function (item) { return matcher.some(function (m) { return item.matches(m); }); });
    }

    return this.items.filter(function (item) { return item.matches(matcher); });
  };

  /**
   * Maps the field items using the mapping function.
   */
  FieldBag.prototype.map = function map (mapper) {
    return this.items.map(mapper);
  };

  /**
   * Finds and removes the first field that matches the provided matcher object, returns the removed item.
   */
  FieldBag.prototype.remove = function remove (matcher) {
    var item = null;
    if (matcher instanceof Field) {
      item = matcher;
    } else {
      item = this.find(matcher);
    }

    if (!item) { return null; }

    var index = this.items.indexOf(item);
    this.items.splice(index, 1);

    return item;
  };

  /**
   * Adds a field item to the list.
   */
  FieldBag.prototype.push = function push (item) {
    if (! (item instanceof Field)) {
      throw createError('FieldBag only accepts instances of Field that has an id defined.');
    }

    if (!item.id) {
      throw createError('Field id must be defined.');
    }

    if (this.find({ id: item.id })) {
      throw createError(("Field with id " + (item.id) + " is already added."));
    }

    this.items.push(item);
  };

  Object.defineProperties( FieldBag.prototype, prototypeAccessors$2 );

  var ScopedValidator = function ScopedValidator (base, vm) {
    this.id = vm._uid;
    this._base = base;
    this._paused = false;

    // create a mirror bag with limited component scope.
    this.errors = new ErrorBag(base.errors, this.id);
  };

  var prototypeAccessors$3 = { flags: { configurable: true },rules: { configurable: true },fields: { configurable: true },dictionary: { configurable: true },locale: { configurable: true } };

  prototypeAccessors$3.flags.get = function () {
      var this$1 = this;

    return this._base.fields.items.filter(function (f) { return f.vmId === this$1.id; }).reduce(function (acc, field) {
      if (field.scope) {
        if (!acc[("$" + (field.scope))]) {
          acc[("$" + (field.scope))] = {};
        }

        acc[("$" + (field.scope))][field.name] = field.flags;
      }

      acc[field.name] = field.flags;

      return acc;
    }, {});
  };

  prototypeAccessors$3.rules.get = function () {
    return this._base.rules;
  };

  prototypeAccessors$3.fields.get = function () {
    return new FieldBag(this._base.fields.filter({ vmId: this.id }));
  };

  prototypeAccessors$3.dictionary.get = function () {
    return this._base.dictionary;
  };

  prototypeAccessors$3.locale.get = function () {
    return this._base.locale;
  };

  prototypeAccessors$3.locale.set = function (val) {
    this._base.locale = val;
  };

  ScopedValidator.prototype.localize = function localize () {
      var ref;

      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];
    return (ref = this._base).localize.apply(ref, args);
  };

  ScopedValidator.prototype.update = function update () {
      var ref;

      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];
    return (ref = this._base).update.apply(ref, args);
  };

  ScopedValidator.prototype.attach = function attach (opts) {
    var attachOpts = assign({}, opts, { vmId: this.id });

    return this._base.attach(attachOpts);
  };

  ScopedValidator.prototype.pause = function pause () {
    this._paused = true;
  };

  ScopedValidator.prototype.resume = function resume () {
    this._paused = false;
  };

  ScopedValidator.prototype.remove = function remove (ruleName) {
    return this._base.remove(ruleName);
  };

  ScopedValidator.prototype.detach = function detach (name, scope) {
    return this._base.detach(name, scope, this.id);
  };

  ScopedValidator.prototype.extend = function extend () {
      var ref;

      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];
    return (ref = this._base).extend.apply(ref, args);
  };

  ScopedValidator.prototype.validate = function validate (descriptor, value, opts) {
      if ( opts === void 0 ) opts = {};

    if (this._paused) { return Promise.resolve(true); }

    return this._base.validate(descriptor, value, assign({}, { vmId: this.id }, opts || {}));
  };

  ScopedValidator.prototype.validateAll = function validateAll (values$$1, opts) {
      if ( opts === void 0 ) opts = {};

    if (this._paused) { return Promise.resolve(true); }

    return this._base.validateAll(values$$1, assign({}, { vmId: this.id }, opts || {}));
  };

  ScopedValidator.prototype.validateScopes = function validateScopes (opts) {
      if ( opts === void 0 ) opts = {};

    if (this._paused) { return Promise.resolve(true); }

    return this._base.validateScopes(assign({}, { vmId: this.id }, opts || {}));
  };

  ScopedValidator.prototype.destroy = function destroy () {
    delete this.id;
    delete this._base;
  };

  ScopedValidator.prototype.reset = function reset (matcher) {
    return this._base.reset(Object.assign({}, matcher || {}, { vmId: this.id }));
  };

  ScopedValidator.prototype.flag = function flag () {
      var ref;

      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];
    return (ref = this._base).flag.apply(ref, args.concat( [this.id] ));
  };

  Object.defineProperties( ScopedValidator.prototype, prototypeAccessors$3 );

  // 

  /**
   * Checks if a parent validator instance was requested.
   */
  var requestsValidator = function (injections) {
    if (isObject(injections) && injections.$validator) {
      return true;
    }

    return false;
  };

  var mixin = {
    provide: function provide () {
      if (this.$validator && !isBuiltInComponent(this.$vnode)) {
        return {
          $validator: this.$validator
        };
      }

      return {};
    },
    beforeCreate: function beforeCreate () {
      // if built in do nothing.
      if (isBuiltInComponent(this.$vnode) || this.$options.$__veeInject === false) {
        return;
      }

      // if its a root instance set the config if it exists.
      if (!this.$parent) {
        pluginInstance.configure(this.$options.$_veeValidate || {});
      }

      var options = pluginInstance.resolveConfig(this);

      // if its a root instance, inject anyways, or if it requested a new instance.
      if (!this.$parent || (this.$options.$_veeValidate && /new/.test(this.$options.$_veeValidate.validator))) {
        this.$validator = new ScopedValidator(pluginInstance._validator, this);
      }

      var requested = requestsValidator(this.$options.inject);

      // if automatic injection is enabled and no instance was requested.
      if (! this.$validator && options.inject && !requested) {
        this.$validator = new ScopedValidator(pluginInstance._validator, this);
      }

      // don't inject errors or fieldBag as no validator was resolved.
      if (! requested && ! this.$validator) {
        return;
      }

      // There is a validator but it isn't injected, mark as reactive.
      if (!requested && this.$validator) {
        var Vue = this.$options._base; // the vue constructor.
        Vue.util.defineReactive(this.$validator, 'errors', this.$validator.errors);
      }

      if (! this.$options.computed) {
        this.$options.computed = {};
      }

      this.$options.computed[options.errorBagName || 'errors'] = function errorBagGetter () {
        return this.$validator.errors;
      };
      this.$options.computed[options.fieldsBagName || 'fields'] = function fieldBagGetter () {
        return this.$validator.fields.items.reduce(function (acc, field) {
          if (field.scope) {
            if (!acc[("$" + (field.scope))]) {
              acc[("$" + (field.scope))] = {};
            }

            acc[("$" + (field.scope))][field.name] = field.flags;

            return acc;
          }

          acc[field.name] = field.flags;

          return acc;
        }, {});
      };
    },
    beforeDestroy: function beforeDestroy () {
      if (this.$validator && this._uid === this.$validator.id) {
        this.$validator.errors.clear(); // remove errors generated by this component.
      }
    }
  };

  // 

  /**
   * Finds the requested field by id from the context object.
   */
  function findField (el, context) {
    if (!context || !context.$validator) {
      return null;
    }

    return context.$validator.fields.find({ id: el._veeValidateId });
  }
  var directive = {
    bind: function bind (el, binding, vnode) {
      var validator = vnode.context.$validator;
      if (!validator) {
        {
          warn("No validator instance is present on vm, did you forget to inject '$validator'?");
        }

        return;
      }

      var fieldOptions = Resolver.generate(el, binding, vnode);
      validator.attach(fieldOptions);
    },
    inserted: function inserted (el, binding, vnode) {
      var field = findField(el, vnode.context);
      var scope = Resolver.resolveScope(el, binding, vnode);

      // skip if scope hasn't changed.
      if (!field || scope === field.scope) { return; }

      // only update scope.
      field.update({ scope: scope });

      // allows the field to re-evaluated once more in the update hook.
      field.updated = false;
    },
    update: function update (el, binding, vnode) {
      var field = findField(el, vnode.context);

      // make sure we don't do unneccasary work if no important change was done.
      if (!field || (field.updated && isEqual$1(binding.value, binding.oldValue))) { return; }
      var scope = Resolver.resolveScope(el, binding, vnode);
      var rules = Resolver.resolveRules(el, binding, vnode);

      field.update({
        scope: scope,
        rules: rules
      });
    },
    unbind: function unbind (el, binding, ref) {
      var context = ref.context;

      var field = findField(el, context);
      if (!field) { return; }

      context.$validator.detach(field);
    }
  };

  // 

  var Validator = function Validator (validations, options) {
    if ( options === void 0 ) options = { fastExit: true };

    this.errors = new ErrorBag();
    this.fields = new FieldBag();
    this._createFields(validations);
    this.paused = false;
    this.fastExit = !isNullOrUndefined(options && options.fastExit) ? options.fastExit : true;
  };

  var prototypeAccessors$4 = { rules: { configurable: true },dictionary: { configurable: true },flags: { configurable: true },locale: { configurable: true } };
  var staticAccessors$1 = { rules: { configurable: true },dictionary: { configurable: true },locale: { configurable: true } };

  staticAccessors$1.rules.get = function () {
    return RuleContainer.rules;
  };

  prototypeAccessors$4.rules.get = function () {
    return RuleContainer.rules;
  };

  prototypeAccessors$4.dictionary.get = function () {
    return VeeValidate$1.i18nDriver;
  };

  staticAccessors$1.dictionary.get = function () {
    return VeeValidate$1.i18nDriver;
  };

  prototypeAccessors$4.flags.get = function () {
    return this.fields.items.reduce(function (acc, field) {
        var obj;

      if (field.scope) {
        acc[("$" + (field.scope))] = ( obj = {}, obj[field.name] = field.flags, obj );

        return acc;
      }

      acc[field.name] = field.flags;

      return acc;
    }, {});
  };

  /**
   * Getter for the current locale.
   */
  prototypeAccessors$4.locale.get = function () {
    return Validator.locale;
  };

  /**
   * Setter for the validator locale.
   */
  prototypeAccessors$4.locale.set = function (value) {
    Validator.locale = value;
  };

  staticAccessors$1.locale.get = function () {
    return VeeValidate$1.i18nDriver.locale;
  };

  /**
   * Setter for the validator locale.
   */
  staticAccessors$1.locale.set = function (value) {
    var hasChanged = value !== VeeValidate$1.i18nDriver.locale;
    VeeValidate$1.i18nDriver.locale = value;
    if (hasChanged && VeeValidate$1.instance && VeeValidate$1.instance._vm) {
      VeeValidate$1.instance._vm.$emit('localeChanged');
    }
  };

  /**
   * Static constructor.
   */
  Validator.create = function create (validations, options) {
    return new Validator(validations, options);
  };

  /**
   * Adds a custom validator to the list of validation rules.
   */
  Validator.extend = function extend (name, validator, options) {
      if ( options === void 0 ) options = {};

    Validator._guardExtend(name, validator);
    Validator._merge(name, {
      validator: validator,
      paramNames: options && options.paramNames,
      options: assign({}, { hasTarget: false, immediate: true }, options || {})
    });
  };

  /**
   * Removes a rule from the list of validators.
   */
  Validator.remove = function remove (name) {
    RuleContainer.remove(name);
  };

  /**
   * Checks if the given rule name is a rule that targets other fields.
   */
  Validator.isTargetRule = function isTargetRule (name) {
    return RuleContainer.isTargetRule(name);
  };

  /**
   * Adds and sets the current locale for the validator.
   */
  Validator.prototype.localize = function localize (lang, dictionary) {
    Validator.localize(lang, dictionary);
  };

  /**
   * Adds and sets the current locale for the validator.
   */
  Validator.localize = function localize (lang, dictionary) {
      var obj;

    if (isObject(lang)) {
      VeeValidate$1.i18nDriver.merge(lang);
      return;
    }

    // merge the dictionary.
    if (dictionary) {
      var locale = lang || dictionary.name;
      dictionary = assign({}, dictionary);
      VeeValidate$1.i18nDriver.merge(( obj = {}, obj[locale] = dictionary, obj ));
    }

    if (lang) {
      // set the locale.
      Validator.locale = lang;
    }
  };

  /**
   * Registers a field to be validated.
   */
  Validator.prototype.attach = function attach (fieldOpts) {
      var this$1 = this;

    // We search for a field with the same name & scope, having persist enabled
    var oldFieldMatcher = { name: fieldOpts.name, scope: fieldOpts.scope, persist: true };
    var oldField = fieldOpts.persist ? this.fields.find(oldFieldMatcher) : null;

    if (oldField) {
      // We keep the flags of the old field, then we remove its instance
      fieldOpts.flags = oldField.flags;
      oldField.destroy();
      this.fields.remove(oldField);
    }

    // fixes initial value detection with v-model and select elements.
    var value = fieldOpts.initialValue;
    var field = new Field(fieldOpts);
    this.fields.push(field);

    // validate the field initially
    if (field.immediate) {
      VeeValidate$1.instance._vm.$nextTick(function () { return this$1.validate(("#" + (field.id)), value || field.value, { vmId: fieldOpts.vmId }); });
    } else {
      this._validate(field, value || field.value, { initial: true }).then(function (result) {
        field.flags.valid = result.valid;
        field.flags.invalid = !result.valid;
      });
    }

    return field;
  };

  /**
   * Sets the flags on a field.
   */
  Validator.prototype.flag = function flag (name, flags, uid) {
      if ( uid === void 0 ) uid = null;

    var field = this._resolveField(name, undefined, uid);
    if (!field || !flags) {
      return;
    }

    field.setFlags(flags);
  };

  /**
   * Removes a field from the validator.
   */
  Validator.prototype.detach = function detach (name, scope, uid) {
    var field = isCallable(name.destroy) ? name : this._resolveField(name, scope, uid);
    if (!field) { return; }

    // We destroy/remove the field & error instances if it's not a `persist` one
    if (!field.persist) {
      field.destroy();
      this.errors.remove(field.name, field.scope, field.vmId);
      this.fields.remove(field);
    }
  };

  /**
   * Adds a custom validator to the list of validation rules.
   */
  Validator.prototype.extend = function extend (name, validator, options) {
      if ( options === void 0 ) options = {};

    Validator.extend(name, validator, options);
  };

  Validator.prototype.reset = function reset (matcher) {
      var this$1 = this;

    // two ticks
    return VeeValidate$1.instance._vm.$nextTick().then(function () {
      return VeeValidate$1.instance._vm.$nextTick();
    }).then(function () {
      this$1.fields.filter(matcher).forEach(function (field) {
        field.waitFor(null);
        field.reset(); // reset field flags.
        this$1.errors.remove(field.name, field.scope, matcher && matcher.vmId);
      });
    });
  };

  /**
   * Updates a field, updating both errors and flags.
   */
  Validator.prototype.update = function update (id, ref) {
      var scope = ref.scope;

    var field = this._resolveField(("#" + id));
    if (!field) { return; }

    // remove old scope.
    this.errors.update(id, { scope: scope });
  };

  /**
   * Removes a rule from the list of validators.
   */
  Validator.prototype.remove = function remove (name) {
    Validator.remove(name);
  };

  /**
   * Validates a value against a registered field validations.
   */
  Validator.prototype.validate = function validate (fieldDescriptor, value, ref) {
      var this$1 = this;
      if ( ref === void 0 ) ref = {};
      var silent = ref.silent;
      var vmId = ref.vmId;

    if (this.paused) { return Promise.resolve(true); }

    // overload to validate all.
    if (isNullOrUndefined(fieldDescriptor)) {
      return this.validateScopes({ silent: silent, vmId: vmId });
    }

    // overload to validate scope-less fields.
    if (fieldDescriptor === '*') {
      return this.validateAll(undefined, { silent: silent, vmId: vmId });
    }

    // if scope validation was requested.
    if (/^(.+)\.\*$/.test(fieldDescriptor)) {
      var matched = fieldDescriptor.match(/^(.+)\.\*$/)[1];
      return this.validateAll(matched);
    }

    var field = this._resolveField(fieldDescriptor);
    if (!field) {
      return this._handleFieldNotFound(name);
    }

    if (!silent) { field.flags.pending = true; }
    if (value === undefined) {
      value = field.value;
    }

    var validationPromise = this._validate(field, value);
    field.waitFor(validationPromise);

    return validationPromise.then(function (result) {
      if (!silent && field.isWaitingFor(validationPromise)) {
        // allow next validation to mutate the state.
        field.waitFor(null);
        this$1._handleValidationResults([result], vmId);
      }

      return result.valid;
    });
  };

  /**
   * Pauses the validator.
   */
  Validator.prototype.pause = function pause () {
    this.paused = true;

    return this;
  };

  /**
   * Resumes the validator.
   */
  Validator.prototype.resume = function resume () {
    this.paused = false;

    return this;
  };

  /**
   * Validates each value against the corresponding field validations.
   */
  Validator.prototype.validateAll = function validateAll (values$$1, ref) {
      var this$1 = this;
      if ( ref === void 0 ) ref = {};
      var silent = ref.silent;
      var vmId = ref.vmId;

    if (this.paused) { return Promise.resolve(true); }

    var matcher = null;
    var providedValues = false;

    if (typeof values$$1 === 'string') {
      matcher = { scope: values$$1, vmId: vmId };
    } else if (isObject(values$$1)) {
      matcher = Object.keys(values$$1).map(function (key) {
        return { name: key, vmId: vmId, scope: null };
      });
      providedValues = true;
    } else if (Array.isArray(values$$1)) {
      matcher = values$$1.map(function (key) {
        return { name: key, vmId: vmId };
      });
    } else {
      matcher = { scope: null, vmId: vmId };
    }

    return Promise.all(
      this.fields.filter(matcher).map(function (field) { return this$1._validate(field, providedValues ? values$$1[field.name] : field.value); })
    ).then(function (results) {
      if (!silent) {
        this$1._handleValidationResults(results, vmId);
      }

      return results.every(function (t) { return t.valid; });
    });
  };

  /**
   * Validates all scopes.
   */
  Validator.prototype.validateScopes = function validateScopes (ref) {
      var this$1 = this;
      if ( ref === void 0 ) ref = {};
      var silent = ref.silent;
      var vmId = ref.vmId;

    if (this.paused) { return Promise.resolve(true); }

    return Promise.all(
      this.fields.filter({ vmId: vmId }).map(function (field) { return this$1._validate(field, field.value); })
    ).then(function (results) {
      if (!silent) {
        this$1._handleValidationResults(results, vmId);
      }

      return results.every(function (t) { return t.valid; });
    });
  };

  /**
   * Validates a value against the rules.
   */
  Validator.prototype.verify = function verify (value, rules, options) {
      if ( options === void 0 ) options = {};

    var field = {
      name: (options && options.name) || '{field}',
      rules: normalizeRules(rules),
      bails: getPath('bails', options, true),
      forceRequired: false,
      get isRequired () {
        return !!this.rules.required || this.forceRequired;
      }
    };

    var targetRules = Object.keys(field.rules).filter(Validator.isTargetRule);
    if (targetRules.length && options && isObject(options.values)) {
      field.dependencies = targetRules.map(function (rule) {
        var ref = field.rules[rule];
          var targetKey = ref[0];

        return {
          name: rule,
          field: { value: options.values[targetKey] }
        };
      });
    }

    return this._validate(field, value).then(function (result) {
      return { valid: result.valid, errors: result.errors.map(function (e) { return e.msg; }) };
    });
  };

  /**
   * Perform cleanup.
   */
  Validator.prototype.destroy = function destroy () {
    VeeValidate$1.instance._vm.$off('localeChanged');
  };

  /**
   * Creates the fields to be validated.
   */
  Validator.prototype._createFields = function _createFields (validations) {
      var this$1 = this;

    if (!validations) { return; }

    Object.keys(validations).forEach(function (field) {
      var options = assign({}, { name: field, rules: validations[field] });
      this$1.attach(options);
    });
  };

  /**
   * Date rules need the existence of a format, so date_format must be supplied.
   */
  Validator.prototype._getDateFormat = function _getDateFormat (validations) {
    var format = null;
    if (validations.date_format && Array.isArray(validations.date_format)) {
      format = validations.date_format[0];
    }

    return format || VeeValidate$1.i18nDriver.getDateFormat(this.locale);
  };

  /**
   * Formats an error message for field and a rule.
   */
  Validator.prototype._formatErrorMessage = function _formatErrorMessage (field, rule, data, targetName) {
      if ( data === void 0 ) data = {};
      if ( targetName === void 0 ) targetName = null;

    var name = this._getFieldDisplayName(field);
    var params = this._getLocalizedParams(rule, targetName);

    return VeeValidate$1.i18nDriver.getFieldMessage(this.locale, field.name, rule.name, [name, params, data]);
  };

  /**
   * We need to convert any object param to an array format since the locales do not handle params as objects yet.
   */
  Validator.prototype._convertParamObjectToArray = function _convertParamObjectToArray (obj, ruleName) {
    if (Array.isArray(obj)) {
      return obj;
    }

    var paramNames = RuleContainer.getParamNames(ruleName);
    if (!paramNames || !isObject(obj)) {
      return obj;
    }

    return paramNames.reduce(function (prev, paramName) {
      if (paramName in obj) {
        prev.push(obj[paramName]);
      }

      return prev;
    }, []);
  };

  /**
   * Translates the parameters passed to the rule (mainly for target fields).
   */
  Validator.prototype._getLocalizedParams = function _getLocalizedParams (rule, targetName) {
      if ( targetName === void 0 ) targetName = null;

    var params = this._convertParamObjectToArray(rule.params, rule.name);
    if (rule.options.hasTarget && params && params[0]) {
      var localizedName = targetName || VeeValidate$1.i18nDriver.getAttribute(this.locale, params[0], params[0]);
      return [localizedName].concat(params.slice(1));
    }

    return params;
  };

  /**
   * Resolves an appropriate display name, first checking 'data-as' or the registered 'prettyName'
   */
  Validator.prototype._getFieldDisplayName = function _getFieldDisplayName (field) {
    return field.alias || VeeValidate$1.i18nDriver.getAttribute(this.locale, field.name, field.name);
  };

  /**
   * Converts an array of params to an object with named properties.
   * Only works if the rule is configured with a paramNames array.
   * Returns the same params if it cannot convert it.
   */
  Validator.prototype._convertParamArrayToObj = function _convertParamArrayToObj (params, ruleName) {
    var paramNames = RuleContainer.getParamNames(ruleName);
    if (!paramNames) {
      return params;
    }

    if (isObject(params)) {
      // check if the object is either a config object or a single parameter that is an object.
      var hasKeys = paramNames.some(function (name) { return Object.keys(params).indexOf(name) !== -1; });
      // if it has some of the keys, return it as is.
      if (hasKeys) {
        return params;
      }
      // otherwise wrap the object in an array.
      params = [params];
    }

    // Reduce the paramsNames to a param object.
    return params.reduce(function (prev, value, idx) {
      prev[paramNames[idx]] = value;

      return prev;
    }, {});
  };

  /**
   * Tests a single input value against a rule.
   */
  Validator.prototype._test = function _test (field, value, rule) {
      var this$1 = this;

    var validator = RuleContainer.getValidatorMethod(rule.name);
    var params = Array.isArray(rule.params) ? toArray(rule.params) : rule.params;
    if (!params) {
      params = [];
    }

    var targetName = null;
    if (!validator || typeof validator !== 'function') {
      return Promise.reject(createError(("No such validator '" + (rule.name) + "' exists.")));
    }

    // has field dependencies.
    if (rule.options.hasTarget && field.dependencies) {
      var target = find(field.dependencies, function (d) { return d.name === rule.name; });
      if (target) {
        targetName = target.field.alias;
        params = [target.field.value].concat(params.slice(1));
      }
    } else if (rule.name === 'required' && field.rejectsFalse) {
      // invalidate false if no args were specified and the field rejects false by default.
      params = params.length ? params : [true];
    }

    if (rule.options.isDate) {
      var dateFormat = this._getDateFormat(field.rules);
      if (rule.name !== 'date_format') {
        params.push(dateFormat);
      }
    }

    var result = validator(value, this._convertParamArrayToObj(params, rule.name));

    // If it is a promise.
    if (isCallable(result.then)) {
      return result.then(function (values$$1) {
        var allValid = true;
        var data = {};
        if (Array.isArray(values$$1)) {
          allValid = values$$1.every(function (t) { return (isObject(t) ? t.valid : t); });
        } else { // Is a single object/boolean.
          allValid = isObject(values$$1) ? values$$1.valid : values$$1;
          data = values$$1.data;
        }

        return {
          valid: allValid,
          data: result.data,
          errors: allValid ? [] : [this$1._createFieldError(field, rule, data, targetName)]
        };
      });
    }

    if (!isObject(result)) {
      result = { valid: result, data: {} };
    }

    return {
      valid: result.valid,
      data: result.data,
      errors: result.valid ? [] : [this._createFieldError(field, rule, result.data, targetName)]
    };
  };

  /**
   * Merges a validator object into the RULES and Messages.
   */
  Validator._merge = function _merge (name, ref) {
      var validator = ref.validator;
      var options = ref.options;
      var paramNames = ref.paramNames;

    var validate = isCallable(validator) ? validator : validator.validate;
    if (validator.getMessage) {
      VeeValidate$1.i18nDriver.setMessage(Validator.locale, name, validator.getMessage);
    }

    RuleContainer.add(name, {
      validate: validate,
      options: options,
      paramNames: paramNames
    });
  };

  /**
   * Guards from extension violations.
   */
  Validator._guardExtend = function _guardExtend (name, validator) {
    if (isCallable(validator)) {
      return;
    }

    if (!isCallable(validator.validate)) {
      throw createError(
        ("Extension Error: The validator '" + name + "' must be a function or have a 'validate' method.")
      );
    }
  };

  /**
   * Creates a Field Error Object.
   */
  Validator.prototype._createFieldError = function _createFieldError (field, rule, data, targetName) {
      var this$1 = this;

    return {
      id: field.id,
      vmId: field.vmId,
      field: field.name,
      msg: this._formatErrorMessage(field, rule, data, targetName),
      rule: rule.name,
      scope: field.scope,
      regenerate: function () {
        return this$1._formatErrorMessage(field, rule, data, targetName);
      }
    };
  };

  /**
   * Tries different strategies to find a field.
   */
  Validator.prototype._resolveField = function _resolveField (name, scope, uid) {
    if (name[0] === '#') {
      return this.fields.find({ id: name.slice(1) });
    }

    if (!isNullOrUndefined(scope)) {
      return this.fields.find({ name: name, scope: scope, vmId: uid });
    }

    if (includes(name, '.')) {
      var ref = name.split('.');
        var fieldScope = ref[0];
        var fieldName = ref.slice(1);
      var field = this.fields.find({ name: fieldName.join('.'), scope: fieldScope, vmId: uid });
      if (field) {
        return field;
      }
    }

    return this.fields.find({ name: name, scope: null, vmId: uid });
  };

  /**
   * Handles when a field is not found.
   */
  Validator.prototype._handleFieldNotFound = function _handleFieldNotFound (name, scope) {
    var fullName = isNullOrUndefined(scope) ? name : ("" + (!isNullOrUndefined(scope) ? scope + '.' : '') + name);

    return Promise.reject(createError(
      ("Validating a non-existent field: \"" + fullName + "\". Use \"attach()\" first.")
    ));
  };

  /**
   * Handles validation results.
   */
  Validator.prototype._handleValidationResults = function _handleValidationResults (results, vmId) {
      var this$1 = this;

    var matchers = results.map(function (result) { return ({ id: result.id }); });
    this.errors.removeById(matchers.map(function (m) { return m.id; }));
    // remove by name and scope to remove any custom errors added.
    results.forEach(function (result) {
      this$1.errors.remove(result.field, result.scope, vmId);
    });
    var allErrors = results.reduce(function (prev, curr) {
      prev.push.apply(prev, curr.errors);

      return prev;
    }, []);

    this.errors.add(allErrors);

    // handle flags.
    this.fields.filter(matchers).forEach(function (field) {
      var result = find(results, function (r) { return r.id === field.id; });
      field.setFlags({
        pending: false,
        valid: result.valid,
        validated: true
      });
    });
  };

  Validator.prototype._shouldSkip = function _shouldSkip (field, value) {
    // field is configured to run through the pipeline regardless
    if (field.bails === false) {
      return false;
    }

    // disabled fields are skipped
    if (field.isDisabled) {
      return true;
    }

    // skip if the field is not required and has an empty value.
    return !field.isRequired && (isNullOrUndefined(value) || value === '' || isEmptyArray(value));
  };

  Validator.prototype._shouldBail = function _shouldBail (field) {
    // if the field was configured explicitly.
    if (field.bails !== undefined) {
      return field.bails;
    }

    return this.fastExit;
  };

  /**
   * Starts the validation process.
   */
  Validator.prototype._validate = function _validate (field, value, ref) {
      var this$1 = this;
      if ( ref === void 0 ) ref = {};
      var initial = ref.initial;

    var requireRules = Object.keys(field.rules).filter(RuleContainer.isRequireRule);

    field.forceRequired = false;
    requireRules.forEach(function (rule) {
      var ruleOptions = RuleContainer.getOptions(rule);
      var result = this$1._test(field, value, { name: rule, params: field.rules[rule], options: ruleOptions });

      if (isCallable(result.then)) { throw createError('Require rules cannot be async'); }
      if (!isObject(result)) { throw createError('Require rules has to return an object (see docs)'); }

      if (result.data.required === true) {
        field.forceRequired = true;
      }
    });

    if (this._shouldSkip(field, value)) {
      return Promise.resolve({ valid: true, id: field.id, field: field.name, scope: field.scope, errors: [] });
    }

    var promises = [];
    var errors = [];
    var isExitEarly = false;
    // use of '.some()' is to break iteration in middle by returning true
    Object.keys(field.rules).filter(function (rule) {
      if (!initial || !RuleContainer.has(rule)) { return true; }

      return RuleContainer.isImmediate(rule);
    }).some(function (rule) {
      var ruleOptions = RuleContainer.getOptions(rule);
      var result = this$1._test(field, value, { name: rule, params: field.rules[rule], options: ruleOptions });
      if (isCallable(result.then)) {
        promises.push(result);
      } else if (!result.valid && this$1._shouldBail(field)) {
        errors.push.apply(errors, result.errors);
        isExitEarly = true;
      } else {
        // promisify the result.
        promises.push(new Promise(function (resolve) { return resolve(result); }));
      }

      return isExitEarly;
    });

    if (isExitEarly) {
      return Promise.resolve({ valid: false, errors: errors, id: field.id, field: field.name, scope: field.scope });
    }

    return Promise.all(promises).then(function (results) {
      return results.reduce(function (prev, v) {
          var ref;

        if (!v.valid) {
          (ref = prev.errors).push.apply(ref, v.errors);
        }

        prev.valid = prev.valid && v.valid;

        return prev;
      }, { valid: true, errors: errors, id: field.id, field: field.name, scope: field.scope });
    });
  };

  Object.defineProperties( Validator.prototype, prototypeAccessors$4 );
  Object.defineProperties( Validator, staticAccessors$1 );

  // 

  var normalize = function (fields) {
    if (Array.isArray(fields)) {
      return fields.reduce(function (prev, curr) {
        if (includes(curr, '.')) {
          prev[curr.split('.')[1]] = curr;
        } else {
          prev[curr] = curr;
        }

        return prev;
      }, {});
    }

    return fields;
  };

  // Combines two flags using either AND or OR depending on the flag type.
  var combine = function (lhs, rhs) {
    var mapper = {
      pristine: function (lhs, rhs) { return lhs && rhs; },
      dirty: function (lhs, rhs) { return lhs || rhs; },
      touched: function (lhs, rhs) { return lhs || rhs; },
      untouched: function (lhs, rhs) { return lhs && rhs; },
      valid: function (lhs, rhs) { return lhs && rhs; },
      invalid: function (lhs, rhs) { return lhs || rhs; },
      pending: function (lhs, rhs) { return lhs || rhs; },
      required: function (lhs, rhs) { return lhs || rhs; },
      validated: function (lhs, rhs) { return lhs && rhs; }
    };

    return Object.keys(mapper).reduce(function (flags, flag) {
      flags[flag] = mapper[flag](lhs[flag], rhs[flag]);

      return flags;
    }, {});
  };

  var mapScope = function (scope, deep) {
    if ( deep === void 0 ) deep = true;

    return Object.keys(scope).reduce(function (flags, field) {
      if (!flags) {
        flags = assign({}, scope[field]);
        return flags;
      }

      // scope.
      var isScope = field.indexOf('$') === 0;
      if (deep && isScope) {
        return combine(mapScope(scope[field]), flags);
      } else if (!deep && isScope) {
        return flags;
      }

      flags = combine(flags, scope[field]);

      return flags;
    }, null);
  };

  /**
   * Maps fields to computed functions.
   */
  var mapFields = function (fields) {
    if (!fields) {
      return function () {
        return mapScope(this.$validator.flags);
      };
    }

    var normalized = normalize(fields);
    return Object.keys(normalized).reduce(function (prev, curr) {
      var field = normalized[curr];
      prev[curr] = function mappedField () {
        // if field exists
        if (this.$validator.flags[field]) {
          return this.$validator.flags[field];
        }

        // scopeless fields were selected.
        if (normalized[curr] === '*') {
          return mapScope(this.$validator.flags, false);
        }

        // if it has a scope defined
        var index = field.indexOf('.');
        if (index <= 0) {
          return {};
        }

        var ref = field.split('.');
        var scope = ref[0];
        var name = ref.slice(1);

        scope = this.$validator.flags[("$" + scope)];
        name = name.join('.');

        // an entire scope was selected: scope.*
        if (name === '*' && scope) {
          return mapScope(scope);
        }

        if (scope && scope[name]) {
          return scope[name];
        }

        return {};
      };

      return prev;
    }, {});
  };

  var $validator = null;

  var PROVIDER_COUNTER = 0;

  function createValidationCtx (ctx) {
    return {
      errors: ctx.messages,
      flags: ctx.flags,
      classes: ctx.classes,
      valid: ctx.isValid,
      reset: function () { return ctx.reset(); },
      validate: function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return ctx.validate.apply(ctx, args);
    },
      aria: {
        'aria-invalid': ctx.flags.invalid ? 'true' : 'false',
        'aria-required': ctx.isRequired ? 'true' : 'false'
      }
    };
  }

  /**
   * Determines if a provider needs to run validation.
   */
  function shouldValidate (ctx, model) {
    // when an immediate/initial validation is needed and wasn't done before.
    if (!ctx._ignoreImmediate && ctx.immediate) {
      return true;
    }

    // when the value changes for whatever reason.
    if (ctx.value !== model.value) {
      return true;
    }

    // when it needs validation due to props/cross-fields changes.
    if (ctx._needsValidation) {
      return true;
    }

    // when the initial value is undefined and the field wasn't rendered yet.
    if (!ctx.initialized && model.value === undefined) {
      return true;
    }

    return false;
  }

  function onRenderUpdate (model) {
    var this$1 = this;

    if (!this.initialized) {
      this.initialValue = model.value;
    }

    var validateNow = shouldValidate(this, model);
    this._needsValidation = false;
    this.value = model.value;
    this._ignoreImmediate = true;

    if (!validateNow) {
      return;
    }

    var silentHandler = function (ref) {
      var valid = ref.valid;

      // initially assign the valid/invalid flags.
      this$1.setFlags({
        valid: valid,
        invalid: !valid
      });
    };

    this.validateSilent().then(this.immediate || this.flags.validated ? this.applyResult : silentHandler);
  }

  // Creates the common handlers for a validatable context.
  function createCommonHandlers (ctx) {
    var onInput = function (e) {
      ctx.syncValue(e); // track and keep the value updated.
      ctx.setFlags({ dirty: true, pristine: false });
    };

    // Blur event listener.
    var onBlur = function () {
      ctx.setFlags({ touched: true, untouched: false });
    };

    var onValidate = debounce(
      function () {
        var pendingPromise = ctx.validate();
        // avoids race conditions between successive validations.
        ctx._pendingValidation = pendingPromise;
        pendingPromise.then(function (result) {
          if (pendingPromise === ctx._pendingValidation) {
            ctx.applyResult(result);
            ctx._pendingValidation = null;
          }
        });
      },
      ctx.debounce
    );

    return { onInput: onInput, onBlur: onBlur, onValidate: onValidate };
  }

  // Adds all plugin listeners to the vnode.
  function addListeners (node) {
    var model = findModel(node);
    // cache the input eventName.
    this._inputEventName = this._inputEventName || getInputEventName(node, model);

    onRenderUpdate.call(this, model);

    var ref = createCommonHandlers(this);
    var onInput = ref.onInput;
    var onBlur = ref.onBlur;
    var onValidate = ref.onValidate;
    addVNodeListener(node, this._inputEventName, onInput);
    addVNodeListener(node, 'blur', onBlur);

    // add the validation listeners.
    this.normalizedEvents.forEach(function (evt) {
      addVNodeListener(node, evt, onValidate);
    });

    this.initialized = true;
  }

  function createValuesLookup (ctx) {
    var providers = ctx.$_veeObserver.refs;

    return ctx.fieldDeps.reduce(function (acc, depName) {
      if (!providers[depName]) {
        return acc;
      }

      acc[depName] = providers[depName].value;

      return acc;
    }, {});
  }

  function updateRenderingContextRefs (ctx) {
    // IDs should not be nullable.
    if (isNullOrUndefined(ctx.id) && ctx.id === ctx.vid) {
      ctx.id = PROVIDER_COUNTER;
      PROVIDER_COUNTER++;
    }

    var id = ctx.id;
    var vid = ctx.vid;
    // Nothing has changed.
    if (id === vid && ctx.$_veeObserver.refs[id]) {
      return;
    }

    // vid was changed.
    if (id !== vid && ctx.$_veeObserver.refs[id] === ctx) {
      ctx.$_veeObserver.$unsubscribe(ctx);
    }

    ctx.$_veeObserver.$subscribe(ctx);
    ctx.id = vid;
  }

  function createObserver () {
    return {
      refs: {},
      $subscribe: function $subscribe (ctx) {
        this.refs[ctx.vid] = ctx;
      },
      $unsubscribe: function $unsubscribe (ctx) {
        delete this.refs[ctx.vid];
      }
    };
  }

  var ValidationProvider = {
    $__veeInject: false,
    inject: {
      $_veeObserver: {
        from: '$_veeObserver',
        default: function default$1 () {
          if (!this.$vnode.context.$_veeObserver) {
            this.$vnode.context.$_veeObserver = createObserver();
          }

          return this.$vnode.context.$_veeObserver;
        }
      }
    },
    props: {
      vid: {
        type: [String, Number],
        default: function () {
          PROVIDER_COUNTER++;

          return PROVIDER_COUNTER;
        }
      },
      name: {
        type: String,
        default: null
      },
      events: {
        type: [Array, String],
        default: function () { return ['input']; }
      },
      rules: {
        type: [Object, String],
        default: null
      },
      immediate: {
        type: Boolean,
        default: false
      },
      persist: {
        type: Boolean,
        default: false
      },
      bails: {
        type: Boolean,
        default: function () { return VeeValidate$1.config.fastExit; }
      },
      debounce: {
        type: Number,
        default: function () { return VeeValidate$1.config.delay || 0; }
      }
    },
    watch: {
      rules: {
        deep: true,
        handler: function handler () {
          this._needsValidation = true;
        }
      }
    },
    data: function () { return ({
      messages: [],
      value: undefined,
      initialized: false,
      initialValue: undefined,
      flags: createFlags(),
      forceRequired: false,
      id: null
    }); },
    methods: {
      setFlags: function setFlags (flags) {
        var this$1 = this;

        Object.keys(flags).forEach(function (flag) {
          this$1.flags[flag] = flags[flag];
        });
      },
      syncValue: function syncValue (e) {
        var value = isEvent(e) ? e.target.value : e;
        this.value = value;
        this.flags.changed = this.initialValue !== value;
      },
      reset: function reset () {
        this.messages = [];
        this._pendingValidation = null;
        this.initialValue = this.value;
        var flags = createFlags();
        this.setFlags(flags);
      },
      validate: function validate () {
        var this$1 = this;
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        if (args[0]) {
          this.syncValue(args[0]);
        }

        return this.validateSilent().then(function (result) {
          this$1.applyResult(result);

          return result;
        });
      },
      validateSilent: function validateSilent () {
        var this$1 = this;

        this.setFlags({ pending: true });

        return $validator.verify(this.value, this.rules, {
          name: this.name,
          values: createValuesLookup(this),
          bails: this.bails
        }).then(function (result) {
          this$1.setFlags({ pending: false });

          return result;
        });
      },
      applyResult: function applyResult (ref) {
        var errors = ref.errors;

        this.messages = errors;
        this.setFlags({
          valid: !errors.length,
          changed: this.value !== this.initialValue,
          invalid: !!errors.length,
          validated: true
        });
      },
      registerField: function registerField () {
        if (!$validator) {
          /* istanbul ignore next */
          {
            if (!VeeValidate$1.instance) {
              warn('You must install vee-validate first before using this component.');
            }
          }

          $validator = VeeValidate$1.instance._validator;
        }

        updateRenderingContextRefs(this);
      }
    },
    computed: {
      isValid: function isValid () {
        return this.flags.valid;
      },
      fieldDeps: function fieldDeps () {
        var this$1 = this;

        var rules = normalizeRules(this.rules);
        var providers = this.$_veeObserver.refs;

        return Object.keys(rules).filter(RuleContainer.isTargetRule).map(function (rule) {
          var depName = rules[rule][0];
          var watcherName = "$__" + depName;
          if (!isCallable(this$1[watcherName])) {
            this$1[watcherName] = providers[depName].$watch('value', function () {
              this$1._needsValidation = true;
              this$1.validate();
            });
          }

          return depName;
        });
      },
      normalizedEvents: function normalizedEvents () {
        var this$1 = this;

        return normalizeEvents(this.events).map(function (e) {
          if (e === 'input') {
            return this$1._inputEventName;
          }

          return e;
        });
      },
      isRequired: function isRequired () {
        var rules = normalizeRules(this.rules);
        var forceRequired = this.forceRequired;

        return !!rules.required || forceRequired;
      },
      classes: function classes () {
        var this$1 = this;

        var names = VeeValidate$1.config.classNames;
        return Object.keys(this.flags).reduce(function (classes, flag) {
          var className = (names && names[flag]) || flag;
          if (flag === 'invalid') {
            classes[className] = !!this$1.messages.length;

            return classes;
          }

          if (flag === 'valid') {
            classes[className] = !this$1.messages.length;

            return classes;
          }

          if (className) {
            classes[className] = this$1.flags[flag];
          }

          return classes;
        }, {});
      }
    },
    render: function render (h) {
      var this$1 = this;

      this.registerField();
      var ctx = createValidationCtx(this);

      // Gracefully handle non-existent scoped slots.
      var slot = this.$scopedSlots.default;
      if (!isCallable(slot)) {
        {
          warn('ValidationProvider expects a scoped slot. Did you forget to add "slot-scope" to your slot?');
        }

        return createRenderless(h, this.$slots.default);
      }

      var nodes = slot(ctx);
      // Handle single-root slot.
      extractVNodes(nodes).forEach(function (input) {
        addListeners.call(this$1, input);
      });

      return createRenderless(h, nodes);
    },
    beforeDestroy: function beforeDestroy () {
      // cleanup reference.
      this.$_veeObserver.$unsubscribe(this);
    }
  };

  var flagMergingStrategy = {
    pristine: 'every',
    dirty: 'some',
    touched: 'some',
    untouched: 'every',
    valid: 'every',
    invalid: 'some',
    pending: 'some',
    validated: 'every'
  };

  function mergeFlags (lhs, rhs, strategy) {
    var stratName = flagMergingStrategy[strategy];

    return [lhs, rhs][stratName](function (f) { return f; });
  }

  var ValidationObserver = {
    name: 'ValidationObserver',
    provide: function provide () {
      return {
        $_veeObserver: this
      };
    },
    data: function () { return ({
      refs: {}
    }); },
    methods: {
      $subscribe: function $subscribe (provider) {
        var obj;

        this.refs = Object.assign({}, this.refs, ( obj = {}, obj[provider.vid] = provider, obj ));
      },
      $unsubscribe: function $unsubscribe (ref) {
        var vid = ref.vid;

        delete this.refs[vid];
        this.refs = Object.assign({}, this.refs);
      },
      validate: function validate () {
        return Promise.all(
          values(this.refs).map(function (ref) { return ref.validate(); })
        ).then(function (results) { return results.every(function (r) { return r.valid; }); });
      },
      reset: function reset () {
        return values(this.refs).forEach(function (ref) { return ref.reset(); });
      }
    },
    computed: {
      ctx: function ctx () {
        var this$1 = this;

        var ctx = {
          errors: {},
          validate: function () {
            var promise = this$1.validate();

            return {
              then: function then (thenable) {
                promise.then(function (success) {
                  if (success && isCallable(thenable)) {
                    return Promise.resolve(thenable());
                  }

                  return Promise.resolve(success);
                });
              }
            };
          },
          reset: function () { return this$1.reset(); }
        };

        return values(this.refs).reduce(function (acc, provider) {
          Object.keys(flagMergingStrategy).forEach(function (flag) {
            if (!(flag in acc)) {
              acc[flag] = provider.flags[flag];
              return;
            }

            acc[flag] = mergeFlags(acc[flag], provider.flags[flag], flag);
          });

          acc.errors[provider.vid] = provider.messages;

          return acc;
        }, ctx);
      }
    },
    render: function render (h) {
      var slots = this.$scopedSlots.default;
      if (!isCallable(slots)) {
        return createRenderless(h, this.$slots.default);
      }

      return createRenderless(h, slots(this.ctx));
    }
  };

  function withValidation (component, ctxToProps) {
    if ( ctxToProps === void 0 ) ctxToProps = null;

    var options = isCallable(component) ? component.options : component;
    options.$__veeInject = false;
    var hoc = {
      name: ((options.name || 'AnonymousHoc') + "WithValidation"),
      props: assign({}, ValidationProvider.props),
      data: ValidationProvider.data,
      computed: assign({}, ValidationProvider.computed),
      methods: assign({}, ValidationProvider.methods),
      $__veeInject: false,
      beforeDestroy: ValidationProvider.beforeDestroy,
      inject: ValidationProvider.inject
    };

    // Default ctx converts ctx props to component props.
    if (!ctxToProps) {
      ctxToProps = function (ctx) { return ctx; };
    }

    var eventName = (options.model && options.model.event) || 'input';

    hoc.render = function (h) {
      var obj;

      this.registerField();
      var vctx = createValidationCtx(this);
      var listeners = assign({}, this.$listeners);

      var model = findModel(this.$vnode);
      this._inputEventName = this._inputEventName || getInputEventName(this.$vnode, model);
      onRenderUpdate.call(this, model);

      var ref = createCommonHandlers(this);
      var onInput = ref.onInput;
      var onBlur = ref.onBlur;
      var onValidate = ref.onValidate;

      mergeVNodeListeners(listeners, eventName, onInput);
      mergeVNodeListeners(listeners, 'blur', onBlur);
      this.normalizedEvents.forEach(function (evt, idx) {
        mergeVNodeListeners(listeners, evt, onValidate);
      });

      // Props are any attrs not associated with ValidationProvider Plus the model prop.
      // WARNING: Accidental prop overwrite will probably happen.
      var ref$1 = findModelConfig(this.$vnode) || { prop: 'value' };
      var prop = ref$1.prop;
      var props = assign({}, this.$attrs, ( obj = {}, obj[prop] = model.value, obj ), ctxToProps(vctx));

      return h(options, {
        attrs: this.$attrs,
        props: props,
        on: listeners
      }, normalizeSlots(this.$slots, this.$vnode.context));
    };

    return hoc;
  }

  // 

  var normalizeValue = function (value) {
    if (isObject(value)) {
      return Object.keys(value).reduce(function (prev, key) {
        prev[key] = normalizeValue(value[key]);

        return prev;
      }, {});
    }

    if (isCallable(value)) {
      return value('{0}', ['{1}', '{2}', '{3}']);
    }

    return value;
  };

  var normalizeFormat = function (locale) {
    // normalize messages
    var dictionary = {};
    if (locale.messages) {
      dictionary.messages = normalizeValue(locale.messages);
    }

    if (locale.custom) {
      dictionary.custom = normalizeValue(locale.custom);
    }

    if (locale.attributes) {
      dictionary.attributes = locale.attributes;
    }

    if (!isNullOrUndefined(locale.dateFormat)) {
      dictionary.dateFormat = locale.dateFormat;
    }

    return dictionary;
  };

  var I18nDictionary = function I18nDictionary (i18n, rootKey) {
    this.i18n = i18n;
    this.rootKey = rootKey;
  };

  var prototypeAccessors$5 = { locale: { configurable: true } };

  prototypeAccessors$5.locale.get = function () {
    return this.i18n.locale;
  };

  prototypeAccessors$5.locale.set = function (value) {
    warn('Cannot set locale from the validator when using vue-i18n, use i18n.locale setter instead');
  };

  I18nDictionary.prototype.getDateFormat = function getDateFormat (locale) {
    return this.i18n.getDateTimeFormat(locale || this.locale);
  };

  I18nDictionary.prototype.setDateFormat = function setDateFormat (locale, value) {
    this.i18n.setDateTimeFormat(locale || this.locale, value);
  };

  I18nDictionary.prototype.getMessage = function getMessage (_, key, data) {
    var path = (this.rootKey) + ".messages." + key;
    if (this.i18n.te(path)) {
      return this.i18n.t(path, data);
    }

    // fallback to the fallback message
    if (this.i18n.te(path, this.i18n.fallbackLocale)) {
      return this.i18n.t(path, this.i18n.fallbackLocale, data);
    }

    // fallback to the root message
    return this.i18n.t(((this.rootKey) + ".messages._default"), data);
  };

  I18nDictionary.prototype.getAttribute = function getAttribute (_, key, fallback) {
      if ( fallback === void 0 ) fallback = '';

    var path = (this.rootKey) + ".attributes." + key;
    if (this.i18n.te(path)) {
      return this.i18n.t(path);
    }

    return fallback;
  };

  I18nDictionary.prototype.getFieldMessage = function getFieldMessage (_, field, key, data) {
    var path = (this.rootKey) + ".custom." + field + "." + key;
    if (this.i18n.te(path)) {
      return this.i18n.t(path, data);
    }

    return this.getMessage(_, key, data);
  };

  I18nDictionary.prototype.merge = function merge$1$$1 (dictionary) {
      var this$1 = this;

    Object.keys(dictionary).forEach(function (localeKey) {
        var obj;

      // i18n doesn't deep merge
      // first clone the existing locale (avoid mutations to locale)
      var clone = merge$1({}, getPath((localeKey + "." + (this$1.rootKey)), this$1.i18n.messages, {}));
      // Merge cloned locale with new one
      var locale = merge$1(clone, normalizeFormat(dictionary[localeKey]));
      this$1.i18n.mergeLocaleMessage(localeKey, ( obj = {}, obj[this$1.rootKey] = locale, obj ));
      if (locale.dateFormat) {
        this$1.i18n.setDateTimeFormat(localeKey, locale.dateFormat);
      }
    });
  };

  I18nDictionary.prototype.setMessage = function setMessage (locale, key, value) {
      var obj, obj$1;

    this.merge(( obj$1 = {}, obj$1[locale] = {
        messages: ( obj = {}, obj[key] = value, obj )
      }, obj$1 ));
  };

  I18nDictionary.prototype.setAttribute = function setAttribute (locale, key, value) {
      var obj, obj$1;

    this.merge(( obj$1 = {}, obj$1[locale] = {
        attributes: ( obj = {}, obj[key] = value, obj )
      }, obj$1 ));
  };

  Object.defineProperties( I18nDictionary.prototype, prototypeAccessors$5 );

  // 

  var defaultConfig = {
    locale: 'en',
    delay: 0,
    errorBagName: 'errors',
    dictionary: null,
    fieldsBagName: 'fields',
    classes: false,
    classNames: null,
    events: 'input',
    inject: true,
    fastExit: true,
    aria: true,
    validity: false,
    useConstraintAttrs: true,
    i18n: null,
    i18nRootKey: 'validation'
  };

  var Vue;
  var pendingPlugins;
  var currentConfig = assign({}, defaultConfig);
  var pluginInstance;

  var VeeValidate$1 = function VeeValidate (config, _Vue) {
    this.configure(config);
    pluginInstance = this;
    if (_Vue) {
      Vue = _Vue;
    }
    this._validator = new Validator(null, { fastExit: config && config.fastExit });
    this._initVM(this.config);
    this._initI18n(this.config);
  };

  var prototypeAccessors$6 = { i18nDriver: { configurable: true },config: { configurable: true } };
  var staticAccessors$2 = { instance: { configurable: true },i18nDriver: { configurable: true },config: { configurable: true } };

  VeeValidate$1.setI18nDriver = function setI18nDriver (driver, instance) {
    DictionaryResolver.setDriver(driver, instance);
  };

  VeeValidate$1.configure = function configure (cfg) {
    currentConfig = assign({}, currentConfig, cfg);
  };

  VeeValidate$1.use = function use (plugin, options) {
      if ( options === void 0 ) options = {};

    if (!isCallable(plugin)) {
      return warn('The plugin must be a callable function');
    }

    // Don't install plugins until vee-validate is installed.
    if (!pluginInstance) {
      if (!pendingPlugins) {
        pendingPlugins = [];
      }
      pendingPlugins.push({ plugin: plugin, options: options });
      return;
    }

    plugin({ Validator: Validator, ErrorBag: ErrorBag, Rules: Validator.rules }, options);
  };
  VeeValidate$1.install = function install (_Vue, opts) {
    if (Vue && _Vue === Vue) {
      {
        warn('already installed, Vue.use(VeeValidate) should only be called once.');
      }
      return;
    }

    Vue = _Vue;
    pluginInstance = new VeeValidate$1(opts);

    detectPassiveSupport();

    Vue.mixin(mixin);
    Vue.directive('validate', directive);
    if (pendingPlugins) {
      pendingPlugins.forEach(function (ref) {
          var plugin = ref.plugin;
          var options = ref.options;

        VeeValidate$1.use(plugin, options);
      });
      pendingPlugins = null;
    }
  };

  staticAccessors$2.instance.get = function () {
    return pluginInstance;
  };

  prototypeAccessors$6.i18nDriver.get = function () {
    return DictionaryResolver.getDriver();
  };

  staticAccessors$2.i18nDriver.get = function () {
    return DictionaryResolver.getDriver();
  };

  prototypeAccessors$6.config.get = function () {
    return currentConfig;
  };

  staticAccessors$2.config.get = function () {
    return currentConfig;
  };

  VeeValidate$1.prototype._initVM = function _initVM (config) {
      var this$1 = this;

    this._vm = new Vue({
      data: function () { return ({
        errors: this$1._validator.errors,
        fields: this$1._validator.fields
      }); }
    });
  };

  VeeValidate$1.prototype._initI18n = function _initI18n (config) {
      var this$1 = this;

    var dictionary = config.dictionary;
      var i18n = config.i18n;
      var i18nRootKey = config.i18nRootKey;
      var locale = config.locale;
    var onLocaleChanged = function () {
      this$1._validator.errors.regenerate();
    };

    // i18 is being used for localization.
    if (i18n) {
      VeeValidate$1.setI18nDriver('i18n', new I18nDictionary(i18n, i18nRootKey));
      i18n._vm.$watch('locale', onLocaleChanged);
    } else if (typeof window !== 'undefined') {
      this._vm.$on('localeChanged', onLocaleChanged);
    }

    if (dictionary) {
      this.i18nDriver.merge(dictionary);
    }

    if (locale && !i18n) {
      this._validator.localize(locale);
    }
  };

  VeeValidate$1.prototype.configure = function configure (cfg) {
    VeeValidate$1.configure(cfg);
  };

  VeeValidate$1.prototype.resolveConfig = function resolveConfig (ctx) {
    var selfConfig = getPath('$options.$_veeValidate', ctx, {});

    return assign({}, this.config, selfConfig);
  };

  Object.defineProperties( VeeValidate$1.prototype, prototypeAccessors$6 );
  Object.defineProperties( VeeValidate$1, staticAccessors$2 );

  VeeValidate$1.version = '2.1.7';
  VeeValidate$1.mixin = mixin;
  VeeValidate$1.directive = directive;
  VeeValidate$1.Validator = Validator;
  VeeValidate$1.ErrorBag = ErrorBag;
  VeeValidate$1.mapFields = mapFields;
  VeeValidate$1.ValidationProvider = ValidationProvider;
  VeeValidate$1.ValidationObserver = ValidationObserver;
  VeeValidate$1.withValidation = withValidation;

  /**
   * Formates file size.
   *
   * @param {Number|String} size
   */
  var formatFileSize = function (size) {
    var units = ['Byte', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    var threshold = 1024;
    size = Number(size) * threshold;
    var i = size === 0 ? 0 : Math.floor(Math.log(size) / Math.log(threshold));
    return (((size / Math.pow(threshold, i)).toFixed(2) * 1) + " " + (units[i]));
  };

  /**
   * Checks if vee-validate is defined globally.
   */
  var isDefinedGlobally = function () {
    return typeof VeeValidate !== 'undefined';
  };

  var obj;

  var messages = {
    _default: function (field) { return ("The " + field + " value is not valid."); },
    after: function (field, ref) {
      var target = ref[0];
      var inclusion = ref[1];

      return ("The " + field + " must be after " + (inclusion ? 'or equal to ' : '') + target + ".");
  },
    alpha: function (field) { return ("The " + field + " field may only contain alphabetic characters."); },
    alpha_dash: function (field) { return ("The " + field + " field may contain alpha-numeric characters as well as dashes and underscores."); },
    alpha_num: function (field) { return ("The " + field + " field may only contain alpha-numeric characters."); },
    alpha_spaces: function (field) { return ("The " + field + " field may only contain alphabetic characters as well as spaces."); },
    before: function (field, ref) {
      var target = ref[0];
      var inclusion = ref[1];

      return ("The " + field + " must be before " + (inclusion ? 'or equal to ' : '') + target + ".");
  },
    between: function (field, ref) {
      var min = ref[0];
      var max = ref[1];

      return ("The " + field + " field must be between " + min + " and " + max + ".");
  },
    confirmed: function (field) { return ("The " + field + " confirmation does not match."); },
    credit_card: function (field) { return ("The " + field + " field is invalid."); },
    date_between: function (field, ref) {
      var min = ref[0];
      var max = ref[1];

      return ("The " + field + " must be between " + min + " and " + max + ".");
  },
    date_format: function (field, ref) {
      var format = ref[0];

      return ("The " + field + " must be in the format " + format + ".");
  },
    decimal: function (field, ref) {
      if ( ref === void 0 ) ref = [];
      var decimals = ref[0]; if ( decimals === void 0 ) decimals = '*';

      return ("The " + field + " field must be numeric and may contain " + (!decimals || decimals === '*' ? '' : decimals) + " decimal points.");
  },
    digits: function (field, ref) {
      var length = ref[0];

      return ("The " + field + " field must be numeric and exactly contain " + length + " digits.");
  },
    dimensions: function (field, ref) {
      var width = ref[0];
      var height = ref[1];

      return ("The " + field + " field must be " + width + " pixels by " + height + " pixels.");
  },
    email: function (field) { return ("The " + field + " field must be a valid email."); },
    excluded: function (field) { return ("The " + field + " field must be a valid value."); },
    ext: function (field) { return ("The " + field + " field must be a valid file."); },
    image: function (field) { return ("The " + field + " field must be an image."); },
    included: function (field) { return ("The " + field + " field must be a valid value."); },
    integer: function (field) { return ("The " + field + " field must be an integer."); },
    ip: function (field) { return ("The " + field + " field must be a valid ip address."); },
    length: function (field, ref) {
      var length = ref[0];
      var max = ref[1];

      if (max) {
        return ("The " + field + " length must be between " + length + " and " + max + ".");
      }

      return ("The " + field + " length must be " + length + ".");
    },
    max: function (field, ref) {
      var length = ref[0];

      return ("The " + field + " field may not be greater than " + length + " characters.");
  },
    max_value: function (field, ref) {
      var max = ref[0];

      return ("The " + field + " field must be " + max + " or less.");
  },
    mimes: function (field) { return ("The " + field + " field must have a valid file type."); },
    min: function (field, ref) {
      var length = ref[0];

      return ("The " + field + " field must be at least " + length + " characters.");
  },
    min_value: function (field, ref) {
      var min = ref[0];

      return ("The " + field + " field must be " + min + " or more.");
  },
    numeric: function (field) { return ("The " + field + " field may only contain numeric characters."); },
    regex: function (field) { return ("The " + field + " field format is invalid."); },
    required: function (field) { return ("The " + field + " field is required."); },
    required_if: function (field, ref) {
      var target = ref[0];

      return ("The " + field + " field is required when the " + target + " field has this value.");
  },
    size: function (field, ref) {
      var size = ref[0];

      return ("The " + field + " size must be less than " + (formatFileSize(size)) + ".");
  },
    url: function (field) { return ("The " + field + " field is not a valid URL."); }
  };

  var locale$1 = {
    name: 'en',
    messages: messages,
    attributes: {}
  };

  if (isDefinedGlobally()) {
    // eslint-disable-next-line
    VeeValidate.Validator.localize(( obj = {}, obj[locale$1.name] = locale$1, obj ));
  }

  // rules plugin definition.

  Object.keys(Rules).forEach(function (rule) {
    VeeValidate$1.Validator.extend(rule, Rules[rule].validate, assign({}, Rules[rule].options, { paramNames: Rules[rule].paramNames }));
  });

  // Merge the english messages.
  VeeValidate$1.Validator.localize({
    en: locale$1
  });

  VeeValidate$1.Rules = Rules;

  return VeeValidate$1;

}));

},{}],33:[function(require,module,exports){
(function (process){
/**
  * vue-router v3.0.1
  * (c) 2017 Evan You
  * @license MIT
  */
'use strict';

/*  */

function assert (condition, message) {
  if (!condition) {
    throw new Error(("[vue-router] " + message))
  }
}

function warn (condition, message) {
  if (process.env.NODE_ENV !== 'production' && !condition) {
    typeof console !== 'undefined' && console.warn(("[vue-router] " + message));
  }
}

function isError (err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render (_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children)
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h()
    }

    var component = cache[name] = matched.components[name];

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (
        (val && current !== vm) ||
        (!val && current === vm)
      ) {
        matched.instances[name] = val;
      }
    }

    // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // resolve props
    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);
    if (propsToPass) {
      // clone to prevent mutation
      propsToPass = data.props = extend({}, propsToPass);
      // pass non-declared props as attrs
      var attrs = data.attrs = data.attrs || {};
      for (var key in propsToPass) {
        if (!component.props || !(key in component.props)) {
          attrs[key] = propsToPass[key];
          delete propsToPass[key];
        }
      }
    }

    return h(component, data, children)
  }
};

function resolveProps (route, config) {
  switch (typeof config) {
    case 'undefined':
      return
    case 'object':
      return config
    case 'function':
      return config(route)
    case 'boolean':
      return config ? route.params : undefined
    default:
      if (process.env.NODE_ENV !== 'production') {
        warn(
          false,
          "props in \"" + (route.path) + "\" is a " + (typeof config) + ", " +
          "expecting an object, function or boolean."
        );
      }
  }
}

function extend (to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  return to
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) { return encodeURIComponent(str)
  .replace(encodeReserveRE, encodeReserveReplacer)
  .replace(commaRE, ','); };

var decode = decodeURIComponent;

function resolveQuery (
  query,
  extraQuery,
  _parseQuery
) {
  if ( extraQuery === void 0 ) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    process.env.NODE_ENV !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    parsedQuery[key] = extraQuery[key];
  }
  return parsedQuery
}

function parseQuery (query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0
      ? decode(parts.join('='))
      : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res
}

function stringifyQuery (obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return ''
    }

    if (val === null) {
      return encode(key)
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&')
    }

    return encode(key) + '=' + encode(val)
  }).filter(function (x) { return x.length > 0; }).join('&') : null;
  return res ? ("?" + res) : ''
}

/*  */


var trailingSlashRE = /\/?$/;

function createRoute (
  record,
  location,
  redirectedFrom,
  router
) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;

  var query = location.query || {};
  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || (record && record.name),
    meta: (record && record.meta) || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }
  return Object.freeze(route)
}

function clone (value) {
  if (Array.isArray(value)) {
    return value.map(clone)
  } else if (value && typeof value === 'object') {
    var res = {};
    for (var key in value) {
      res[key] = clone(value[key]);
    }
    return res
  } else {
    return value
  }
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch (record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res
}

function getFullPath (
  ref,
  _stringifyQuery
) {
  var path = ref.path;
  var query = ref.query; if ( query === void 0 ) query = {};
  var hash = ref.hash; if ( hash === void 0 ) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash
}

function isSameRoute (a, b) {
  if (b === START) {
    return a === b
  } else if (!b) {
    return false
  } else if (a.path && b.path) {
    return (
      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query)
    )
  } else if (a.name && b.name) {
    return (
      a.name === b.name &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query) &&
      isObjectEqual(a.params, b.params)
    )
  } else {
    return false
  }
}

function isObjectEqual (a, b) {
  if ( a === void 0 ) a = {};
  if ( b === void 0 ) b = {};

  // handle null value #1566
  if (!a || !b) { return a === b }
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal)
    }
    return String(aVal) === String(bVal)
  })
}

function isIncludedRoute (current, target) {
  return (
    current.path.replace(trailingSlashRE, '/').indexOf(
      target.path.replace(trailingSlashRE, '/')
    ) === 0 &&
    (!target.hash || current.hash === target.hash) &&
    queryIncludes(current.query, target.query)
  )
}

function queryIncludes (current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false
    }
  }
  return true
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render (h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback = globalActiveClass == null
            ? 'router-link-active'
            : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null
            ? 'router-link-exact-active'
            : globalExactActiveClass;
    var activeClass = this.activeClass == null
            ? activeClassFallback
            : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null
            ? exactActiveClassFallback
            : this.exactActiveClass;
    var compareTarget = location.path
      ? createRoute(null, location, null, router)
      : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact
      ? classes[exactActiveClass]
      : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) { on[e] = handler; });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default)
  }
};

function guardEvent (e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) { return }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) { return }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) { return }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true
}

function findAnchor (children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child
      }
    }
  }
}

var _Vue;

function install (Vue) {
  if (install.installed && _Vue === Vue) { return }
  install.installed = true;

  _Vue = Vue;

  var isDef = function (v) { return v !== undefined; };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate () {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed () {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get () { return this._routerRoot._router }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get () { return this._routerRoot._route }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath (
  relative,
  base,
  append
) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/')
}

function parsePath (path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  }
}

function cleanPath (path) {
  return path.replace(/\/\//g, '/')
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/*  */

// $flow-disable-line
var regexpCompileCache = Object.create(null);

function fillParams (
  path,
  params,
  routeMsg
) {
  try {
    var filler =
      regexpCompileCache[path] ||
      (regexpCompileCache[path] = pathToRegexp_1.compile(path));
    return filler(params || {}, { pretty: true })
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      warn(false, ("missing param for " + routeMsg + ": " + (e.message)));
    }
    return ''
  }
}

/*  */

function createRouteMap (
  routes,
  oldPathList,
  oldPathMap,
  oldNameMap
) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  // $flow-disable-line
  var pathMap = oldPathMap || Object.create(null);
  // $flow-disable-line
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  }
}

function addRouteRecord (
  pathList,
  pathMap,
  nameMap,
  route,
  parent,
  matchAs
) {
  var path = route.path;
  var name = route.name;
  if (process.env.NODE_ENV !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(
      typeof route.component !== 'string',
      "route config \"component\" for path: " + (String(path || name)) + " cannot be a " +
      "string id. Use an actual component instead."
    );
  }

  var pathToRegexpOptions = route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(
    path,
    parent,
    pathToRegexpOptions.strict
  );

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null
      ? {}
      : route.components
        ? route.props
        : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && !route.redirect && route.children.some(function (child) { return /^\/?$/.test(child.path); })) {
        warn(
          false,
          "Named Route '" + (route.name) + "' has a default child route. " +
          "When navigating to this named route (:to=\"{name: '" + (route.name) + "'\"), " +
          "the default child route will not be rendered. Remove the name from " +
          "this route and use the name of the default child route for named " +
          "links instead."
        );
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs
        ? cleanPath((matchAs + "/" + (child.path)))
        : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias)
      ? route.alias
      : [route.alias];

    aliases.forEach(function (alias) {
      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(
        pathList,
        pathMap,
        nameMap,
        aliasRoute,
        parent,
        record.path || '/' // matchAs
      );
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      warn(
        false,
        "Duplicate named routes definition: " +
        "{ name: \"" + name + "\", path: \"" + (record.path) + "\" }"
      );
    }
  }
}

function compileRouteRegex (path, pathToRegexpOptions) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);
  if (process.env.NODE_ENV !== 'production') {
    var keys = Object.create(null);
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], ("Duplicate param keys in route with path: \"" + path + "\""));
      keys[key.name] = true;
    });
  }
  return regex
}

function normalizePath (path, parent, strict) {
  if (!strict) { path = path.replace(/\/$/, ''); }
  if (path[0] === '/') { return path }
  if (parent == null) { return path }
  return cleanPath(((parent.path) + "/" + path))
}

/*  */


function normalizeLocation (
  raw,
  current,
  append,
  router
) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, ("path " + (current.path)));
    } else if (process.env.NODE_ENV !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }
    return next
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = (current && current.path) || '/';
  var path = parsedPath.path
    ? resolvePath(parsedPath.path, basePath, append || next.append)
    : basePath;

  var query = resolveQuery(
    parsedPath.query,
    next.query,
    router && router.options.parseQuery
  );

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  }
}

function assign (a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a
}

/*  */


function createMatcher (
  routes,
  router
) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes (routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match (
    raw,
    currentRoute,
    redirectedFrom
  ) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        warn(record, ("Route with name '" + name + "' does not exist"));
      }
      if (!record) { return _createRoute(null, location) }
      var paramNames = record.regex.keys
        .filter(function (key) { return !key.optional; })
        .map(function (key) { return key.name; });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, ("named route \"" + name + "\""));
        return _createRoute(record, location, redirectedFrom)
      }
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom)
        }
      }
    }
    // no match
    return _createRoute(null, location)
  }

  function redirect (
    record,
    location
  ) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function'
        ? originalRedirect(createRoute(record, location, null, router))
        : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      if (process.env.NODE_ENV !== 'production') {
        warn(
          false, ("invalid redirect option: " + (JSON.stringify(redirect)))
        );
      }
      return _createRoute(null, location)
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        assert(targetRecord, ("redirect failed: named route \"" + name + "\" not found."));
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location)
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, ("redirect route with path \"" + rawPath + "\""));
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location)
    } else {
      if (process.env.NODE_ENV !== 'production') {
        warn(false, ("invalid redirect option: " + (JSON.stringify(redirect))));
      }
      return _createRoute(null, location)
    }
  }

  function alias (
    record,
    location,
    matchAs
  ) {
    var aliasedPath = fillParams(matchAs, location.params, ("aliased route with path \"" + matchAs + "\""));
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location)
    }
    return _createRoute(null, location)
  }

  function _createRoute (
    record,
    location,
    redirectedFrom
  ) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location)
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs)
    }
    return createRoute(record, location, redirectedFrom, router)
  }

  return {
    match: match,
    addRoutes: addRoutes
  }
}

function matchRoute (
  regex,
  path,
  params
) {
  var m = path.match(regex);

  if (!m) {
    return false
  } else if (!params) {
    return true
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true
}

function resolveRecordPath (path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true)
}

/*  */


var positionStore = Object.create(null);

function setupScroll () {
  // Fix for #1585 for Firefox
  window.history.replaceState({ key: getStateKey() }, '');
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll (
  router,
  to,
  from,
  isPop
) {
  if (!router.app) {
    return
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);

    if (!shouldScroll) {
      return
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll.then(function (shouldScroll) {
        scrollToPosition((shouldScroll), position);
      }).catch(function (err) {
        if (process.env.NODE_ENV !== 'production') {
          assert(false, err.toString());
        }
      });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition () {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition () {
  var key = getStateKey();
  if (key) {
    return positionStore[key]
  }
}

function getElementPosition (el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  }
}

function isValidPosition (obj) {
  return isNumber(obj.x) || isNumber(obj.y)
}

function normalizePosition (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  }
}

function normalizeOffset (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  }
}

function isNumber (v) {
  return typeof v === 'number'
}

function scrollToPosition (shouldScroll, position) {
  var isObject = typeof shouldScroll === 'object';
  if (isObject && typeof shouldScroll.selector === 'string') {
    var el = document.querySelector(shouldScroll.selector);
    if (el) {
      var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    window.scrollTo(position.x, position.y);
  }
}

/*  */

var supportsPushState = inBrowser && (function () {
  var ua = window.navigator.userAgent;

  if (
    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
    ua.indexOf('Mobile Safari') !== -1 &&
    ua.indexOf('Chrome') === -1 &&
    ua.indexOf('Windows Phone') === -1
  ) {
    return false
  }

  return window.history && 'pushState' in window.history
})();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now
  ? window.performance
  : Date;

var _key = genKey();

function genKey () {
  return Time.now().toFixed(3)
}

function getStateKey () {
  return _key
}

function setStateKey (key) {
  _key = key;
}

function pushState (url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState (url) {
  pushState(url, true);
}

/*  */

function runQueue (queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents (matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function'
            ? resolvedDef
            : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          process.env.NODE_ENV !== 'production' && warn(false, msg);
          if (!error) {
            error = isError(reason)
              ? reason
              : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) { next(); }
  }
}

function flatMapComponents (
  matched,
  fn
) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) { return fn(
      m.components[key],
      m.instances[key],
      m, key
    ); })
  }))
}

function flatten (arr) {
  return Array.prototype.concat.apply([], arr)
}

var hasSymbol =
  typeof Symbol === 'function' &&
  typeof Symbol.toStringTag === 'symbol';

function isESModule (obj) {
  return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once (fn) {
  var called = false;
  return function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    if (called) { return }
    called = true;
    return fn.apply(this, args)
  }
}

/*  */

var History = function History (router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen (cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady (cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError (errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {
    var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) { cb(route); });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }
    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) { cb(err); });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {
    var this$1 = this;

  var current = this.current;
  var abort = function (err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) { cb(err); });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (
    isSameRoute(route, current) &&
    // in the case the route map has been dynamically appended to
    route.matched.length === current.matched.length
  ) {
    this.ensureURL();
    return abort()
  }

  var ref = resolveQueue(this.current.matched, route.matched);
    var updated = ref.updated;
    var deactivated = ref.deactivated;
    var activated = ref.activated;

  var queue = [].concat(
    // in-component leave guards
    extractLeaveGuards(deactivated),
    // global before hooks
    this.router.beforeHooks,
    // in-component update hooks
    extractUpdateHooks(updated),
    // in-config enter guards
    activated.map(function (m) { return m.beforeEnter; }),
    // async components
    resolveAsyncComponents(activated)
  );

  this.pending = route;
  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort()
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (
          typeof to === 'string' ||
          (typeof to === 'object' && (
            typeof to.path === 'string' ||
            typeof to.name === 'string'
          ))
        ) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();
          if (typeof to === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function () { return this$1.current === route; };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort()
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) { cb(); });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute (route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase (base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = (baseEl && baseEl.getAttribute('href')) || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '')
}

function resolveQueue (
  current,
  next
) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  }
}

function extractGuards (
  records,
  name,
  bind,
  reverse
) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard)
        ? guard.map(function (guard) { return bind(guard, instance, match, key); })
        : bind(guard, instance, match, key)
    }
  });
  return flatten(reverse ? guards.reverse() : guards)
}

function extractGuard (
  def,
  key
) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key]
}

function extractLeaveGuards (deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
}

function extractUpdateHooks (updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)
}

function bindGuard (guard, instance) {
  if (instance) {
    return function boundRouteGuard () {
      return guard.apply(instance, arguments)
    }
  }
}

function extractEnterGuards (
  activated,
  cbs,
  isValid
) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid)
  })
}

function bindEnterGuard (
  guard,
  match,
  key,
  cbs,
  isValid
) {
  return function routeEnterGuard (to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    })
  }
}

function poll (
  cb, // somehow flow cannot infer this is a function
  instances,
  key,
  isValid
) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

/*  */


var HTML5History = (function (History$$1) {
  function HTML5History (router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    var initLocation = getLocation(this.base);
    window.addEventListener('popstate', function (e) {
      var current = this$1.current;

      // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.
      var location = getLocation(this$1.base);
      if (this$1.current === START && location === initLocation) {
        return
      }

      this$1.transitionTo(location, function (route) {
        if (expectScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if ( History$$1 ) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go (n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL (push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {
    return getLocation(this.base)
  };

  return HTML5History;
}(History));

function getLocation (base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash
}

/*  */


var HashHistory = (function (History$$1) {
  function HashHistory (router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return
    }
    ensureSlash();
  }

  if ( History$$1 ) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners () {
    var this$1 = this;

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {
      var current = this$1.current;
      if (!ensureSlash()) {
        return
      }
      this$1.transitionTo(getHash(), function (route) {
        if (supportsScroll) {
          handleScroll(this$1.router, route, current, true);
        }
        if (!supportsPushState) {
          replaceHash(route.fullPath);
        }
      });
    });
  };

  HashHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go (n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL (push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    return getHash()
  };

  return HashHistory;
}(History));

function checkFallback (base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(
      cleanPath(base + '/#' + location)
    );
    return true
  }
}

function ensureSlash () {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true
  }
  replaceHash('/' + path);
  return false
}

function getHash () {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1)
}

function getUrl (path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return (base + "#" + path)
}

function pushHash (path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash (path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}

/*  */


var AbstractHistory = (function (History$$1) {
  function AbstractHistory (router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go (n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/'
  };

  AbstractHistory.prototype.ensureURL = function ensureURL () {
    // noop
  };

  return AbstractHistory;
}(History));

/*  */

var VueRouter = function VueRouter (options) {
  if ( options === void 0 ) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break
    default:
      if (process.env.NODE_ENV !== 'production') {
        assert(false, ("invalid mode: " + mode));
      }
  }
};

var prototypeAccessors = { currentRoute: { configurable: true } };

VueRouter.prototype.match = function match (
  raw,
  current,
  redirectedFrom
) {
  return this.matcher.match(raw, current, redirectedFrom)
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current
};

VueRouter.prototype.init = function init (app /* Vue component instance */) {
    var this$1 = this;

  process.env.NODE_ENV !== 'production' && assert(
    install.installed,
    "not installed. Make sure to call `Vue.use(VueRouter)` " +
    "before creating root instance."
  );

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };
    history.transitionTo(
      history.getCurrentLocation(),
      setupHashListener,
      setupHashListener
    );
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach (fn) {
  return registerHook(this.beforeHooks, fn)
};

VueRouter.prototype.beforeResolve = function beforeResolve (fn) {
  return registerHook(this.resolveHooks, fn)
};

VueRouter.prototype.afterEach = function afterEach (fn) {
  return registerHook(this.afterHooks, fn)
};

VueRouter.prototype.onReady = function onReady (cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError (errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push (location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go (n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back () {
  this.go(-1);
};

VueRouter.prototype.forward = function forward () {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
  var route = to
    ? to.matched
      ? to
      : this.resolve(to).route
    : this.currentRoute;
  if (!route) {
    return []
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key]
    })
  }))
};

VueRouter.prototype.resolve = function resolve (
  to,
  current,
  append
) {
  var location = normalizeLocation(
    to,
    current || this.history.current,
    append,
    this
  );
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  }
};

VueRouter.prototype.addRoutes = function addRoutes (routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties( VueRouter.prototype, prototypeAccessors );

function registerHook (list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) { list.splice(i, 1); }
  }
}

function createHref (base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path
}

VueRouter.install = install;
VueRouter.version = '3.0.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

module.exports = VueRouter;

}).call(this,require('_process'))

},{"_process":31}],34:[function(require,module,exports){
(function (process,global){
/*!
 * Vue.js v2.5.17
 * (c) 2014-2018 Evan You
 * Released under the MIT License.
 */
'use strict';

/*  */

var emptyObject = Object.freeze({});

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it... e.g.
 * PhantomJS 1.x. Technically we don't need this anymore since native bind is
 * now more performant in most browsers, but removing it would be breaking for
 * code that was able to run in PhantomJS 1.x, so this must be kept for
 * backwards compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */


/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
})

/*  */

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */


var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  if (!getter && arguments.length === 2) {
    val = obj[key];
  }
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (process.env.NODE_ENV !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && process.env.NODE_ENV !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!/^[a-zA-Z][\w-]*$/.test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'can only contain alphanumeric characters and the hyphen, ' +
      'and must start with a letter.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (process.env.NODE_ENV !== 'production') {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (process.env.NODE_ENV !== 'production') {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    process.env.NODE_ENV !== 'production' &&
    // skip validation for weex recycle-list child component props
    !(false && isObject(value) && ('@binding' in value))
  ) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn(
      "Invalid prop: type check failed for prop \"" + name + "\"." +
      " Expected " + (expectedTypes.map(capitalize).join(', ')) +
      ", got " + (toRawType(value)) + ".",
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

/*  */

function handleError (err, vm, info) {
  if (vm) {
    var cur = vm;
    while ((cur = cur.$parent)) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) { return }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (process.env.NODE_ENV !== 'production') {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both microtasks and (macro) tasks.
// In < 2.4 we used microtasks everywhere, but there are some scenarios where
// microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using (macro) tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use microtask by default, but expose a way to force (macro) task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function () {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine microtask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function () {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a (macro) task instead of a microtask.
 */
function withMacroTask (fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res
  })
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, def, cur, old, event;
  for (name in on) {
    def = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    /* istanbul ignore if */
    if (isUndef(cur)) {
      process.env.NODE_ENV !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      process.env.NODE_ENV !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== 'production'
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break
        }
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (process.env.NODE_ENV !== 'production') {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$1 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$1; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production'
    ? expOrFn.toString()
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  if (process.env.NODE_ENV !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn(
          "Method \"" + key + "\" has an undefined value in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        defineReactive(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject).filter(function (key) {
        /* istanbul ignore next */
        return Object.getOwnPropertyDescriptor(inject, key).enumerable
      })
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (process.env.NODE_ENV !== 'production') {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes) {
      if (process.env.NODE_ENV !== 'production' && slotNodes._rendered) {
        warn(
          "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
          "- this will likely cause render errors.",
          this
        );
      }
      slotNodes._rendered = true;
    }
    nodes = slotNodes || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      process.env.NODE_ENV !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () { return resolveSlots(children, parent); };

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */




// Register the component hook to weex native render engine.
// The hook will be triggered by native, not javascript.


// Updates the state of the component to weex native render engine.

/*  */

// https://github.com/Hanks10100/weex-native-directive/tree/master/component

// listening on native callback

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var options = {
    _isComponent: true,
    parent: parent,
    _parentVnode: vnode,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    hooks[key] = componentVNodeHooks[key];
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    process.env.NODE_ENV !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (process.env.NODE_ENV !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (process.env.NODE_ENV !== 'production') {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    // reset _rendered flag on slots for duplicate slot check
    if (process.env.NODE_ENV !== 'production') {
      for (var key in vm.$slots) {
        // $flow-disable-line
        vm.$slots[key]._rendered = false;
      }
    }

    if (_parentVnode) {
      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production' && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
}

var builtInComponents = {
  KeepAlive: KeepAlive
}

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.5.17';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);



var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
}

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove () {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (process.env.NODE_ENV !== 'production') {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (process.env.NODE_ENV !== 'production') {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (process.env.NODE_ENV !== 'production' &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (process.env.NODE_ENV !== 'production' &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (process.env.NODE_ENV !== 'production') {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
}

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
]

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
}

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
}

/*  */

/*  */









// add a raw attr (use this in preTransforms)








// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.

/*  */

/**
 * Cross-platform code generation for component v-model
 */


/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler (handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

function add$1 (
  event,
  handler,
  once$$1,
  capture,
  passive
) {
  handler = withMacroTask(handler);
  if (once$$1) { handler = createOnceHandler(handler, event, capture); }
  target$1.addEventListener(
    event,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  event,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    event,
    handler._withTask || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
}

/*  */

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.lazy) {
      // inputs with lazy should only be updated when not in focus
      return false
    }
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
}

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
}

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def) {
  if (!def) {
    return
  }
  /* istanbul ignore else */
  if (typeof def === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res
  } else if (typeof def === 'string') {
    return autoCssTransition(def)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

function toMs (s) {
  return Number(s.slice(0, -1)) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {}

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
]

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
}

var platformDirectives = {
  model: directive,
  show: show
}

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
}

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  beforeUpdate: function beforeUpdate () {
    // force removing pass
    this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
}

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
}

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (
        process.env.NODE_ENV !== 'production' &&
        process.env.NODE_ENV !== 'test' &&
        isChrome
      ) {
        console[console.info ? 'info' : 'log'](
          'Download the Vue Devtools extension for a better development experience:\n' +
          'https://github.com/vuejs/vue-devtools'
        );
      }
    }
    if (process.env.NODE_ENV !== 'production' &&
      process.env.NODE_ENV !== 'test' &&
      config.productionTip !== false &&
      typeof console !== 'undefined'
    ) {
      console[console.info ? 'info' : 'log'](
        "You are running Vue in development mode.\n" +
        "Make sure to turn on production mode when deploying for production.\n" +
        "See more tips at https://vuejs.org/guide/deployment.html"
      );
    }
  }, 0);
}

/*  */

module.exports = Vue;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":31}],35:[function(require,module,exports){
(function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("leaflet"),require("leaflet.markercluster"),require("vue2-leaflet")):"function"==typeof define&&define.amd?define(["leaflet","leaflet.markercluster","vue2-leaflet"],t):"object"==typeof exports?exports.Vue2LeafletMarkercluster=t(require("leaflet"),require("leaflet.markercluster"),require("vue2-leaflet")):e.Vue2LeafletMarkercluster=t(e.leaflet,e["leaflet.markercluster"],e["vue2-leaflet"])})(this,function(e,t,r){return function(e){function t(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var r={};return t.m=e,t.c=r,t.i=function(e){return e},t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:n})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="/",t(t.s=7)}([function(e,t,r){var n=r(2)(r(1),r(3),null,null);e.exports=n.exports},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(4),o=function(e){return e&&e.__esModule?e:{default:e}}(n);r(5);var u=r(6),a={options:{type:Object,default:function(){return{}}}};t.default={props:a,data:function(){return{ready:!1}},mounted:function(){this.mapObject=o.default.markerClusterGroup(this.options),o.default.DomEvent.on(this.mapObject,this.$listeners),(0,u.propsBinder)(this,this.mapObject,a),this.ready=!0,this.parentContainer=(0,u.findRealParent)(this.$parent),this.parentContainer.addLayer(this)},beforeDestroy:function(){this.parentContainer.removeLayer(this)},methods:{addLayer:function(e,t){t||this.mapObject.addLayer(e.mapObject)},removeLayer:function(e,t){t||this.mapObject.removeLayer(e.mapObject)}}}},function(e,t){e.exports=function(e,t,r,n){var o,u=e=e||{},a=typeof e.default;"object"!==a&&"function"!==a||(o=e,u=e.default);var i="function"==typeof u?u.options:u;if(t&&(i.render=t.render,i.staticRenderFns=t.staticRenderFns),r&&(i._scopeId=r),n){var f=i.computed||(i.computed={});Object.keys(n).forEach(function(e){var t=n[e];f[e]=function(){return t}})}return{esModule:o,exports:u,options:i}}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement;return(e._self._c||t)("div",{staticStyle:{display:"none"}},[e.ready?e._t("default"):e._e()],2)},staticRenderFns:[]}},function(e,t){e.exports=require("leaflet")},function(e,t){e.exports=require("leaflet.markercluster")},function(e,t){e.exports=require("vue2-leaflet")},function(e,t,r){e.exports=r(0)}])});

},{"leaflet":30,"leaflet.markercluster":29,"vue2-leaflet":36}],36:[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("leaflet")):"function"==typeof define&&define.amd?define(["leaflet"],e):"object"==typeof exports?exports.Vue2Leaflet=e(require("leaflet")):t.Vue2Leaflet=e(t.L)}(window,function(t){return function(t){var e={};function n(i){if(e[i])return e[i].exports;var r=e[i]={i:i,l:!1,exports:{}};return t[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)n.d(i,r,function(e){return t[e]}.bind(null,r));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=53)}([function(t,e,n){"use strict";n.r(e);var i=n(51),r=n.n(i);e.default=function(t,e,n,i){for(var o=r()(n),s=function(){var i=o[a],r="set"+function(t){return t.charAt(0).toUpperCase()+t.slice(1)}(i),s=n[i].type===Object||n[i].type===Array||Array.isArray(n[i].type);n[i].custom?t.$watch(i,function(e,n){t[r](e,n)},{deep:s}):"setOptions"===r?t.$watch(i,function(t,n){L.setOptions(e,t)},{deep:s}):t.$watch(i,function(t,n){e[r](t)},{deep:s})},a=0;a<o.length;a++)s()}},function(t,e,n){"use strict";function i(t,e,n,i,r,o,s,a){var u=typeof(t=t||{}).default;"object"!==u&&"function"!==u||(t=t.default);var c,l="function"==typeof t?t.options:t;if(e&&(l.render=e,l.staticRenderFns=n,l._compiled=!0),i&&(l.functional=!0),o&&(l._scopeId=o),s?(c=function(t){(t=t||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(t=__VUE_SSR_CONTEXT__),r&&r.call(this,t),t&&t._registeredComponents&&t._registeredComponents.add(s)},l._ssrRegister=c):r&&(c=a?function(){r.call(this,this.$root.$options.shadowRoot)}:r),c)if(l.functional){l._injectStyles=c;var p=l.render;l.render=function(t,e){return c.call(e),p(t,e)}}else{var f=l.beforeCreate;l.beforeCreate=f?[].concat(f,c):[c]}return{exports:t,options:l}}n.d(e,"a",function(){return i})},function(t,e,n){"use strict";n.d(e,"a",function(){return s});var i=n(52),r=n.n(i),o=function(t){var e={};for(var n in t){var i=t[n];null!==i&&void 0!==i&&(e[n]=i)}return e},s=function(t,e){var n=e.options&&e.options.constructor===Object?e.options:{};t=t&&t.constructor===Object?t:{};var i=o(n);t=o(t);var s=e.$options.props;for(var a in t){var u=s[a]?s[a].default:r()("unique");i[a]&&u!==t[a]?(console.warn(a+" props is overriding the value passed in the options props"),i[a]=t[a]):i[a]||(i[a]=t[a])}return i}},function(t,e,n){"use strict";n.r(e),e.default=function(t){for(var e=!1;!e;)void 0===t.mapObject?t=t.$parent:e=!0;return t}},function(t,e,n){"use strict";e.__esModule=!0;var i=function(t){return t&&t.__esModule?t:{default:t}}(n(77));e.default=i.default||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t}},function(t,e,n){"use strict";e.a={props:{options:{type:Object,default:function(){return{}}}}}},function(e,n){e.exports=t},function(t,e,n){"use strict";e.a={props:{pane:{type:String,default:"overlayPane"},attribution:{type:String,default:null},name:{type:String,custom:!0,default:void 0},layerType:{type:String,custom:!0,default:void 0},visible:{type:Boolean,custom:!0,default:!0}},mounted:function(){this.layerOptions={attribution:this.attribution,pane:this.pane}},beforeDestroy:function(){this.parentContainer.removeLayer(this)},methods:{setAttribution:function(t,e){this.$parent.mapObject.attributionControl.removeAttribution(e).addAttribution(t)},setName:function(t,e){t!==e&&(this.parentContainer.removeLayer(this),this.visible&&this.parentContainer.addLayer(this))},setLayerType:function(t,e){t!==e&&(this.parentContainer.removeLayer(this),this.visible&&this.parentContainer.addLayer(this))},setVisible:function(t,e){t!==e&&this.mapObject&&(t?this.parentContainer.addLayer(this):this.parentContainer.removeLayer(this))}}}},function(t,e,n){"use strict";e.a={props:{position:{type:String,default:"topright"}},mounted:function(){this.controlOptions={position:this.position}},beforeDestroy:function(){this.mapObject&&this.mapObject.remove()}}},function(t,e){var n=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=n)},function(t,e){var n=t.exports={version:"2.5.3"};"number"==typeof __e&&(__e=n)},function(t,e,n){var i=n(20),r=n(46),o=n(34),s=Object.defineProperty;e.f=n(12)?Object.defineProperty:function(t,e,n){if(i(t),e=o(e,!0),i(n),r)try{return s(t,e,n)}catch(t){}if("get"in n||"set"in n)throw TypeError("Accessors not supported!");return"value"in n&&(t[e]=n.value),t}},function(t,e,n){t.exports=!n(13)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,e){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,e,n){"use strict";var i=n(7);e.a={mixins:[i.a],mounted:function(){this.layerGroupOptions=this.layerOptions},methods:{addLayer:function(t,e){e||this.mapObject.addLayer(t.mapObject),this.parentContainer.addLayer(t,!0)},removeLayer:function(t,e){e||this.mapObject.removeLayer(t.mapObject),this.parentContainer.removeLayer(t,!0)}}}},function(t,e,n){var i=n(41),r=n(31);t.exports=Object.keys||function(t){return i(t,r)}},function(t,e){var n={}.hasOwnProperty;t.exports=function(t,e){return n.call(t,e)}},function(t,e,n){var i=n(42),r=n(40);t.exports=function(t){return i(r(t))}},function(t,e){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,e){var n=0,i=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++n+i).toString(36))}},function(t,e,n){var i=n(18);t.exports=function(t){if(!i(t))throw TypeError(t+" is not an object!");return t}},function(t,e){e.f={}.propertyIsEnumerable},function(t,e,n){"use strict";var i=n(4),r=n.n(i),o=n(23);e.a={mixins:[o.a],props:{radius:{type:Number,default:null}},mounted:function(){this.circleOptions=r()({},this.pathOptions,{radius:this.radius})}}},function(t,e,n){"use strict";var i=n(4),r=n.n(i),o=n(7),s=n(24);e.a={mixins:[o.a,s.a],props:{lStyle:{type:Object,custom:!0,default:null},stroke:{type:Boolean,custom:!0,default:!0},color:{type:String,custom:!0,default:"#3388ff"},weight:{type:Number,custom:!0,default:3},opacity:{type:Number,custom:!0,default:1},lineCap:{type:String,custom:!0,default:"round"},lineJoin:{type:String,custom:!0,default:"round"},dashArray:{type:String,custom:!0,default:null},dashOffset:{type:String,custom:!0,default:null},fill:{type:Boolean,custom:!0,default:!0},fillColor:{type:String,custom:!0,default:"#3388ff"},fillOpacity:{type:Number,custom:!0,default:.2},fillRule:{type:String,custom:!0,default:"evenodd"},className:{type:String,custom:!0,default:null}},mounted:function(){if(this.pathOptions=r()({},this.layerOptions,this.interactiveLayerOptions,{stroke:this.stroke,color:this.color,weight:this.weight,opacity:this.opacity,lineCap:this.lineCap,lineJoin:this.lineJoin,dashArray:this.dashArray,dashOffset:this.dashOffset,fill:this.fill,fillColor:this.fillColor,fillOpacity:this.fillOpacity,fillRule:this.fillRule,className:this.className}),this.lStyle)for(var t in console.warn("lStyle is deprecated and is going to be removed in the next major version"),this.lStyle)this.pathOptions[t]=this.lStyle[t]},beforeDestroy:function(){this.parentContainer?this.parentContainer.removeLayer(this):console.error("Missing parent container")},methods:{setLStyle:function(t){this.mapObject.setStyle(t)},setStroke:function(t,e){t!==e&&this.mapObject.setStyle({stroke:t})},setColor:function(t,e){t!==e&&void 0!==t&&null!==t&&this.mapObject.setStyle({color:t})},setWeight:function(t,e){t!==e&&t&&this.mapObject.setStyle({weight:t})},setOpacity:function(t,e){t!==e&&void 0!==t&&null!==t&&this.mapObject.setStyle({opacity:t})},setLineCap:function(t,e){t!==e&&t&&this.mapObject.setStyle({lineCap:t})},setLineJoin:function(t,e){t!==e&&t&&this.mapObject.setStyle({lineJoin:t})},setDashArray:function(t,e){t!==e&&t&&this.mapObject.setStyle({dashArray:t})},setDashOffset:function(t,e){t!==e&&t&&this.mapObject.setStyle({dashOffset:t})},setFill:function(t,e){t!==e&&this.mapObject.setStyle({fill:t})},setFillColor:function(t,e){t!==e&&t&&this.mapObject.setStyle({fillColor:t})},setFillOpacity:function(t,e){t!==e&&t&&this.mapObject.setStyle({fillOpacity:t})},setFillRule:function(t,e){t!==e&&t&&this.mapObject.setStyle({fillRule:t})},setClassName:function(t,e){t!==e&&t&&this.mapObject.setStyle({className:t})}}}},function(t,e,n){"use strict";e.a={props:{interactive:{type:Boolean,default:!0},bubblingMouseEvents:{type:Boolean,default:!0}},mounted:function(){this.interactiveLayerOptions={interactive:this.interactive,bubblingMouseEvents:this.bubblingMouseEvents}}}},function(t,e,n){"use strict";e.a=function(t,e){var n=void 0;return function(){for(var i=arguments.length,r=Array(i),o=0;o<i;o++)r[o]=arguments[o];var s=this;clearTimeout(n),n=setTimeout(function(){return t.apply(s,r)},e)}}},function(t,e,n){"use strict";var i=n(27);e.a={mixins:[i.a],mounted:function(){this.polygonOptions=this.polyLineOptions},methods:{getGeoJSONData:function(){return this.mapObject.toGeoJSON()}}}},function(t,e,n){"use strict";var i=n(4),r=n.n(i),o=n(23);e.a={mixins:[o.a],props:{smoothFactor:{type:Number,custom:!0,default:1},noClip:{type:Boolean,custom:!0,default:!1}},data:function(){return{ready:!1}},mounted:function(){this.polyLineOptions=r()({},this.pathOptions,{smoothFactor:this.smoothFactor,noClip:this.noClip})},methods:{setSmoothFactor:function(t,e){t!==e&&t&&this.mapObject.setStyle({smoothFactor:t})},setNoClip:function(t,e){t!==e&&t&&this.mapObject.setStyle({noClip:t})},addLatLng:function(t){this.mapObject.addLatLng(t)}}}},function(t,e,n){"use strict";e.a={props:{content:{type:String,default:null,custom:!0}},mounted:function(){this.popperOptions={}},methods:{setContent:function(t){this.mapObject&&null!==t&&void 0!==t&&this.mapObject.setContent(t)}},render:function(t){return this.$slots.default?t("div",this.$slots.default):null}}},function(t,e,n){"use strict";var i=n(4),r=n.n(i),o={mixins:[n(7).a],props:{pane:{type:String,default:"tilePane"},opacity:{type:Number,custom:!1,default:1},zIndex:{type:Number,default:1}},mounted:function(){this.gridLayerOptions=r()({},this.layerOptions,{pane:this.pane,opacity:this.opacity,zIndex:this.zIndex})}};e.a={mixins:[o],props:{tms:{type:Boolean,default:!1},detectRetina:{type:Boolean,default:!1}},mounted:function(){this.tileLayerOptions=r()({},this.gridLayerOptions,{tms:this.tms,detectRetina:this.detectRetina})},render:function(){return null}}},function(t,e,n){var i=n(9),r=i["__core-js_shared__"]||(i["__core-js_shared__"]={});t.exports=function(t){return r[t]||(r[t]={})}},function(t,e){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,e,n){var i=n(9),r=n(10),o=n(60),s=n(33),a=function(t,e,n){var u,c,l,p=t&a.F,f=t&a.G,h=t&a.S,d=t&a.P,m=t&a.B,y=t&a.W,b=f?r:r[e]||(r[e]={}),O=b.prototype,v=f?i:h?i[e]:(i[e]||{}).prototype;for(u in f&&(n=e),n)(c=!p&&v&&void 0!==v[u])&&u in b||(l=c?v[u]:n[u],b[u]=f&&"function"!=typeof v[u]?n[u]:m&&c?o(l,i):y&&v[u]==l?function(t){var e=function(e,n,i){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(e);case 2:return new t(e,n)}return new t(e,n,i)}return t.apply(this,arguments)};return e.prototype=t.prototype,e}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[u]=l,t&a.R&&O&&!O[u]&&s(O,u,l)))};a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,e,n){var i=n(11),r=n(35);t.exports=n(12)?function(t,e,n){return i.f(t,e,r(1,n))}:function(t,e,n){return t[e]=n,t}},function(t,e,n){var i=n(18);t.exports=function(t,e){if(!i(t))return t;var n,r;if(e&&"function"==typeof(n=t.toString)&&!i(r=n.call(t)))return r;if("function"==typeof(n=t.valueOf)&&!i(r=n.call(t)))return r;if(!e&&"function"==typeof(n=t.toString)&&!i(r=n.call(t)))return r;throw TypeError("Can't convert object to primitive value")}},function(t,e){t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},function(t,e,n){var i=n(30)("wks"),r=n(19),o=n(9).Symbol,s="function"==typeof o;(t.exports=function(t){return i[t]||(i[t]=s&&o[t]||(s?o:r)("Symbol."+t))}).store=i},function(t,e,n){var i=n(9),r=n(10),o=n(49),s=n(48),a=n(11).f;t.exports=function(t){var e=r.Symbol||(r.Symbol=o?{}:i.Symbol||{});"_"==t.charAt(0)||t in e||a(e,t,{value:s.f(t)})}},function(t,e){e.f=Object.getOwnPropertySymbols},function(t,e,n){var i=n(40);t.exports=function(t){return Object(i(t))}},function(t,e){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,e,n){var i=n(16),r=n(17),o=n(56)(!1),s=n(45)("IE_PROTO");t.exports=function(t,e){var n,a=r(t),u=0,c=[];for(n in a)n!=s&&i(a,n)&&c.push(n);for(;e.length>u;)i(a,n=e[u++])&&(~o(c,n)||c.push(n));return c}},function(t,e,n){var i=n(43);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==i(t)?t.split(""):Object(t)}},function(t,e){var n={}.toString;t.exports=function(t){return n.call(t).slice(8,-1)}},function(t,e){var n=Math.ceil,i=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?i:n)(t)}},function(t,e,n){var i=n(30)("keys"),r=n(19);t.exports=function(t){return i[t]||(i[t]=r(t))}},function(t,e,n){t.exports=!n(12)&&!n(13)(function(){return 7!=Object.defineProperty(n(47)("div"),"a",{get:function(){return 7}}).a})},function(t,e,n){var i=n(18),r=n(9).document,o=i(r)&&i(r.createElement);t.exports=function(t){return o?r.createElement(t):{}}},function(t,e,n){e.f=n(36)},function(t,e){t.exports=!0},function(t,e,n){var i=n(41),r=n(31).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(t){return i(t,r)}},function(t,e,n){t.exports={default:n(54),__esModule:!0}},function(t,e,n){t.exports={default:n(62),__esModule:!0}},function(t,e,n){e.L=n(6),e.findRealParent=n(3).default,e.propsBinder=n(0).default,e.LCircle=n(96).default,e.LCircleMarker=n(94).default,e.LControl=n(93).default,e.LControlAttribution=n(101).default,e.LControlLayers=n(103).default,e.LControlScale=n(105).default,e.LControlZoom=n(104).default,e.LFeatureGroup=n(87).default,e.LGeoJson=n(100).default,e.LIcon=n(90).default,e.LIconDefault=n(102).default,e.LImageOverlay=n(85).default,e.LLayerGroup=n(84).default,e.LMap=n(95).default,e.LMarker=n(98).default,e.LPolygon=n(92).default,e.LPolyline=n(91).default,e.LPopup=n(99).default,e.LRectangle=n(89).default,e.LTileLayer=n(88).default,e.LTooltip=n(97).default,e.LWMSTileLayer=n(86).default},function(t,e,n){n(55),t.exports=n(10).Object.keys},function(t,e,n){var i=n(39),r=n(15);n(59)("keys",function(){return function(t){return r(i(t))}})},function(t,e,n){var i=n(17),r=n(57),o=n(58);t.exports=function(t){return function(e,n,s){var a,u=i(e),c=r(u.length),l=o(s,c);if(t&&n!=n){for(;c>l;)if((a=u[l++])!=a)return!0}else for(;c>l;l++)if((t||l in u)&&u[l]===n)return t||l||0;return!t&&-1}}},function(t,e,n){var i=n(44),r=Math.min;t.exports=function(t){return t>0?r(i(t),9007199254740991):0}},function(t,e,n){var i=n(44),r=Math.max,o=Math.min;t.exports=function(t,e){return(t=i(t))<0?r(t+e,0):o(t,e)}},function(t,e,n){var i=n(32),r=n(10),o=n(13);t.exports=function(t,e){var n=(r.Object||{})[t]||Object[t],s={};s[t]=e(n),i(i.S+i.F*o(function(){n(1)}),"Object",s)}},function(t,e,n){var i=n(61);t.exports=function(t,e,n){if(i(t),void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 2:return function(n,i){return t.call(e,n,i)};case 3:return function(n,i,r){return t.call(e,n,i,r)}}return function(){return t.apply(e,arguments)}}},function(t,e){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,e,n){n(63),n(74),n(75),n(76),t.exports=n(10).Symbol},function(t,e,n){"use strict";var i=n(9),r=n(16),o=n(12),s=n(32),a=n(64),u=n(65).KEY,c=n(13),l=n(30),p=n(66),f=n(19),h=n(36),d=n(48),m=n(37),y=n(67),b=n(68),O=n(20),v=n(18),j=n(17),g=n(34),L=n(35),S=n(69),C=n(72),x=n(73),_=n(11),$=n(15),w=x.f,A=_.f,E=C.f,T=i.Symbol,I=i.JSON,B=I&&I.stringify,N=h("_hidden"),P=h("toPrimitive"),M={}.propertyIsEnumerable,D=l("symbol-registry"),R=l("symbols"),U=l("op-symbols"),z=Object.prototype,F="function"==typeof T,k=i.QObject,W=!k||!k.prototype||!k.prototype.findChild,G=o&&c(function(){return 7!=S(A({},"a",{get:function(){return A(this,"a",{value:7}).a}})).a})?function(t,e,n){var i=w(z,e);i&&delete z[e],A(t,e,n),i&&t!==z&&A(z,e,i)}:A,J=function(t){var e=R[t]=S(T.prototype);return e._k=t,e},Z=F&&"symbol"==typeof T.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof T},H=function(t,e,n){return t===z&&H(U,e,n),O(t),e=g(e,!0),O(n),r(R,e)?(n.enumerable?(r(t,N)&&t[N][e]&&(t[N][e]=!1),n=S(n,{enumerable:L(0,!1)})):(r(t,N)||A(t,N,L(1,{})),t[N][e]=!0),G(t,e,n)):A(t,e,n)},V=function(t,e){O(t);for(var n,i=y(e=j(e)),r=0,o=i.length;o>r;)H(t,n=i[r++],e[n]);return t},q=function(t){var e=M.call(this,t=g(t,!0));return!(this===z&&r(R,t)&&!r(U,t))&&(!(e||!r(this,t)||!r(R,t)||r(this,N)&&this[N][t])||e)},K=function(t,e){if(t=j(t),e=g(e,!0),t!==z||!r(R,e)||r(U,e)){var n=w(t,e);return!n||!r(R,e)||r(t,N)&&t[N][e]||(n.enumerable=!0),n}},X=function(t){for(var e,n=E(j(t)),i=[],o=0;n.length>o;)r(R,e=n[o++])||e==N||e==u||i.push(e);return i},Y=function(t){for(var e,n=t===z,i=E(n?U:j(t)),o=[],s=0;i.length>s;)!r(R,e=i[s++])||n&&!r(z,e)||o.push(R[e]);return o};F||(a((T=function(){if(this instanceof T)throw TypeError("Symbol is not a constructor!");var t=f(arguments.length>0?arguments[0]:void 0),e=function(n){this===z&&e.call(U,n),r(this,N)&&r(this[N],t)&&(this[N][t]=!1),G(this,t,L(1,n))};return o&&W&&G(z,t,{configurable:!0,set:e}),J(t)}).prototype,"toString",function(){return this._k}),x.f=K,_.f=H,n(50).f=C.f=X,n(21).f=q,n(38).f=Y,o&&!n(49)&&a(z,"propertyIsEnumerable",q,!0),d.f=function(t){return J(h(t))}),s(s.G+s.W+s.F*!F,{Symbol:T});for(var Q="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),tt=0;Q.length>tt;)h(Q[tt++]);for(var et=$(h.store),nt=0;et.length>nt;)m(et[nt++]);s(s.S+s.F*!F,"Symbol",{for:function(t){return r(D,t+="")?D[t]:D[t]=T(t)},keyFor:function(t){if(!Z(t))throw TypeError(t+" is not a symbol!");for(var e in D)if(D[e]===t)return e},useSetter:function(){W=!0},useSimple:function(){W=!1}}),s(s.S+s.F*!F,"Object",{create:function(t,e){return void 0===e?S(t):V(S(t),e)},defineProperty:H,defineProperties:V,getOwnPropertyDescriptor:K,getOwnPropertyNames:X,getOwnPropertySymbols:Y}),I&&s(s.S+s.F*(!F||c(function(){var t=T();return"[null]"!=B([t])||"{}"!=B({a:t})||"{}"!=B(Object(t))})),"JSON",{stringify:function(t){for(var e,n,i=[t],r=1;arguments.length>r;)i.push(arguments[r++]);if(n=e=i[1],(v(e)||void 0!==t)&&!Z(t))return b(e)||(e=function(t,e){if("function"==typeof n&&(e=n.call(this,t,e)),!Z(e))return e}),i[1]=e,B.apply(I,i)}}),T.prototype[P]||n(33)(T.prototype,P,T.prototype.valueOf),p(T,"Symbol"),p(Math,"Math",!0),p(i.JSON,"JSON",!0)},function(t,e,n){t.exports=n(33)},function(t,e,n){var i=n(19)("meta"),r=n(18),o=n(16),s=n(11).f,a=0,u=Object.isExtensible||function(){return!0},c=!n(13)(function(){return u(Object.preventExtensions({}))}),l=function(t){s(t,i,{value:{i:"O"+ ++a,w:{}}})},p=t.exports={KEY:i,NEED:!1,fastKey:function(t,e){if(!r(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,i)){if(!u(t))return"F";if(!e)return"E";l(t)}return t[i].i},getWeak:function(t,e){if(!o(t,i)){if(!u(t))return!0;if(!e)return!1;l(t)}return t[i].w},onFreeze:function(t){return c&&p.NEED&&u(t)&&!o(t,i)&&l(t),t}}},function(t,e,n){var i=n(11).f,r=n(16),o=n(36)("toStringTag");t.exports=function(t,e,n){t&&!r(t=n?t:t.prototype,o)&&i(t,o,{configurable:!0,value:e})}},function(t,e,n){var i=n(15),r=n(38),o=n(21);t.exports=function(t){var e=i(t),n=r.f;if(n)for(var s,a=n(t),u=o.f,c=0;a.length>c;)u.call(t,s=a[c++])&&e.push(s);return e}},function(t,e,n){var i=n(43);t.exports=Array.isArray||function(t){return"Array"==i(t)}},function(t,e,n){var i=n(20),r=n(70),o=n(31),s=n(45)("IE_PROTO"),a=function(){},u=function(){var t,e=n(47)("iframe"),i=o.length;for(e.style.display="none",n(71).appendChild(e),e.src="javascript:",(t=e.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),u=t.F;i--;)delete u.prototype[o[i]];return u()};t.exports=Object.create||function(t,e){var n;return null!==t?(a.prototype=i(t),n=new a,a.prototype=null,n[s]=t):n=u(),void 0===e?n:r(n,e)}},function(t,e,n){var i=n(11),r=n(20),o=n(15);t.exports=n(12)?Object.defineProperties:function(t,e){r(t);for(var n,s=o(e),a=s.length,u=0;a>u;)i.f(t,n=s[u++],e[n]);return t}},function(t,e,n){var i=n(9).document;t.exports=i&&i.documentElement},function(t,e,n){var i=n(17),r=n(50).f,o={}.toString,s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return s&&"[object Window]"==o.call(t)?function(t){try{return r(t)}catch(t){return s.slice()}}(t):r(i(t))}},function(t,e,n){var i=n(21),r=n(35),o=n(17),s=n(34),a=n(16),u=n(46),c=Object.getOwnPropertyDescriptor;e.f=n(12)?c:function(t,e){if(t=o(t),e=s(e,!0),u)try{return c(t,e)}catch(t){}if(a(t,e))return r(!i.f.call(t,e),t[e])}},function(t,e){},function(t,e,n){n(37)("asyncIterator")},function(t,e,n){n(37)("observable")},function(t,e,n){t.exports={default:n(78),__esModule:!0}},function(t,e,n){n(79),t.exports=n(10).Object.assign},function(t,e,n){var i=n(32);i(i.S+i.F,"Object",{assign:n(80)})},function(t,e,n){"use strict";var i=n(15),r=n(38),o=n(21),s=n(39),a=n(42),u=Object.assign;t.exports=!u||n(13)(function(){var t={},e={},n=Symbol(),i="abcdefghijklmnopqrst";return t[n]=7,i.split("").forEach(function(t){e[t]=t}),7!=u({},t)[n]||Object.keys(u({},e)).join("")!=i})?function(t,e){for(var n=s(t),u=arguments.length,c=1,l=r.f,p=o.f;u>c;)for(var f,h=a(arguments[c++]),d=l?i(h).concat(l(h)):i(h),m=d.length,y=0;m>y;)p.call(h,f=d[y++])&&(n[f]=h[f]);return n}:u},function(t,e,n){var i=n(82);"string"==typeof i&&(i=[[t.i,i,""]]),i.locals&&(t.exports=i.locals);(0,n(106).default)("516f1ef6",i,!0,{})},function(t,e,n){(t.exports=n(83)(!1)).push([t.i,".vue2leaflet-map{height:100%;width:100%}",""])},function(t,e){t.exports=function(t){var e=[];return e.toString=function(){return this.map(function(e){var n=function(t,e){var n=t[1]||"",i=t[3];if(!i)return n;if(e&&"function"==typeof btoa){var r=function(t){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(t))))+" */"}(i),o=i.sources.map(function(t){return"/*# sourceURL="+i.sourceRoot+t+" */"});return[n].concat(o).concat([r]).join("\n")}return[n].join("\n")}(e,t);return e[2]?"@media "+e[2]+"{"+n+"}":n}).join("")},e.i=function(t,n){"string"==typeof t&&(t=[[null,t,""]]);for(var i={},r=0;r<this.length;r++){var o=this[r][0];"number"==typeof o&&(i[o]=!0)}for(r=0;r<t.length;r++){var s=t[r];"number"==typeof s[0]&&i[s[0]]||(n&&!s[2]?s[2]=n:n&&(s[2]="("+s[2]+") and ("+n+")"),e.push(s))}},e}},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o={name:"LLayerGroup",mixins:[n(14).a],data:function(){return{ready:!1}},mounted:function(){this.mapObject=L.layerGroup(),Object(i.default)(this,this.mapObject,this.$options.props),L.DomEvent.on(this.mapObject,this.$listeners),this.ready=!0,this.parentContainer=Object(r.default)(this.$parent),this.visible&&this.parentContainer.addLayer(this)}},s=n(1),a=Object(s.a)(o,function(){var t=this.$createElement;return(this._self._c||t)("div",{staticStyle:{display:"none"}},[this.ready?this._t("default"):this._e()],2)},[],!1,null,null,null);e.default=a.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o=n(2),s=n(4),a=n.n(s),u=n(7),c=n(24),l={name:"LImageOverlay",mixins:[{mixins:[u.a,c.a],props:{url:{type:String,custom:!0},bounds:{custom:!0},opacity:{type:Number,custom:!0,default:1},alt:{type:String,default:""},interactive:{type:Boolean,default:!1},crossOrigin:{type:Boolean,default:!1},errorOverlayUrl:{type:String,custom:!0,default:""},zIndex:{type:Number,custom:!0,default:1},className:{type:String,default:""}},mounted:function(){this.imageOverlayOptions=a()({},this.layerOptions,this.interactiveLayerOptions,{opacity:this.opacity,alt:this.alt,interactive:this.interactive,crossOrigin:this.crossOrigin,errorOverlayUrl:this.errorOverlayUrl,zIndex:this.zIndex,className:this.className})},methods:{setOpacity:function(t){return this.mapObject.setOpacity(t)},setUrl:function(t){return this.mapObject.setUrl(t)},setBounds:function(t){return this.mapObject.setBounds(t)},getBounds:function(){return this.mapObject.getBounds()},getElement:function(){return this.mapObject.getElement()},bringToFront:function(){return this.mapObject.bringToFront()},bringToBack:function(){return this.mapObject.bringToBack()}},render:function(){return null}}],mounted:function(){var t=Object(o.a)(this.imageOverlayOptions,this);this.mapObject=L.imageOverlay(this.url,this.bounds,t),L.DomEvent.on(this.mapObject,this.$listeners),Object(i.default)(this,this.mapObject,this.$options.props),this.parentContainer=Object(r.default)(this.$parent),this.parentContainer.addLayer(this,!this.visible)}},p=n(1),f=Object(p.a)(l,void 0,void 0,!1,null,null,null);e.default=f.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o=n(2),s=n(4),a=n.n(s),u={name:"LWMSTileLayer",mixins:[{mixins:[n(29).a],props:{layers:{type:String,default:""},styles:{type:String,default:""},format:{type:String,default:"image/jpeg"},transparent:{type:Boolean,custom:!1},version:{type:String,default:"1.1.1"},crs:{default:null},upperCase:{type:Boolean,default:!1}},mounted:function(){this.tileLayerWMSOptions=a()({},this.tileLayerOptions,{layers:this.layers,styles:this.styles,format:this.format,transparent:this.transparent,version:this.version,crs:this.crs,upperCase:this.upperCase})}},n(5).a],props:{baseUrl:{type:String,default:null}},mounted:function(){var t=Object(o.a)(this.tileLayerWMSOptions,this);this.mapObject=L.tileLayer.wms(this.baseUrl,t),L.DomEvent.on(this.mapObject,this.$listeners),Object(i.default)(this,this.mapObject,this.$options.props),this.parentContainer=Object(r.default)(this.$parent),this.parentContainer.addLayer(this,!this.visible)}},c=n(1),l=Object(c.a)(u,void 0,void 0,!1,null,null,null);e.default=l.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o={name:"LFeatureGroup",mixins:[n(14).a],data:function(){return{ready:!1}},mounted:function(){this.mapObject=L.featureGroup(),Object(i.default)(this,this.mapObject,this.$options.props),L.DomEvent.on(this.mapObject,this.$listeners),this.ready=!0,this.parentContainer=Object(r.default)(this.$parent,!0),this.visible&&this.parentContainer.addLayer(this)}},s=n(1),a=Object(s.a)(o,function(){var t=this.$createElement;return(this._self._c||t)("div",{staticStyle:{display:"none"}},[this.ready?this._t("default"):this._e()],2)},[],!1,null,null,null);e.default=a.exports},function(t,e,n){"use strict";n.r(e);var i=n(6),r=n.n(i),o=n(0),s=n(3),a=n(2),u=n(29),c=n(5),l={name:"LTileLayer",mixins:[u.a,c.a],props:{url:{type:String,default:null},tileLayerClass:{type:Function,default:r.a.tileLayer}},mounted:function(){var t=Object(a.a)(this.tileLayerOptions,this);this.mapObject=this.tileLayerClass(this.url,t),r.a.DomEvent.on(this.mapObject,this.$listeners),Object(o.default)(this,this.mapObject,this.$options.props),this.parentContainer=Object(s.default)(this.$parent),this.parentContainer.addLayer(this,!this.visible)}},p=n(1),f=Object(p.a)(l,function(){var t=this.$createElement;return(this._self._c||t)("div")},[],!1,null,null,null);e.default=f.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o=n(2),s={name:"LRectangle",mixins:[n(26).a],props:{bounds:{type:Array,default:function(){return[]}}},data:function(){return{ready:!1}},mounted:function(){var t=Object(o.a)(this.polygonOptions,this);this.mapObject=L.rectangle(this.bounds,t),L.DomEvent.on(this.mapObject,this.$listeners),Object(i.default)(this,this.mapObject,this.$options.props),this.ready=!0,this.parentContainer=Object(r.default)(this.$parent),this.parentContainer.addLayer(this,!this.visible)}},a=n(1),u=Object(a.a)(s,function(){var t=this.$createElement;return(this._self._c||t)("div",{staticStyle:{display:"none"}},[this.ready?this._t("default"):this._e()],2)},[],!1,null,null,null);e.default=u.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o=n(2),s={name:"LIcon",props:{iconUrl:{type:String,custom:!0,default:null},iconRetinaUrl:{type:String,custom:!0,default:null},iconSize:{type:[Object,Array],custom:!0,default:null},iconAnchor:{type:[Object,Array],custom:!0,default:null},popupAnchor:{type:[Object,Array],custom:!0,default:function(){return[0,0]}},tooltipAnchor:{type:[Object,Array],custom:!0,default:function(){return[0,0]}},shadowUrl:{type:String,custom:!0,default:null},shadowRetinaUrl:{type:String,custom:!0,default:null},shadowSize:{type:[Object,Array],custom:!0,default:null},shadowAnchor:{type:[Object,Array],custom:!0,default:null},bgPos:{type:[Object,Array],custom:!0,default:function(){return[0,0]}},className:{type:String,custom:!0,default:""},options:{type:Object,custom:!0,default:function(){return{}}}},data:function(){return{parentContainer:null,observer:null,recreationNeeded:!1,swapHtmlNeeded:!1}},mounted:function(){var t=this;this.parentContainer=Object(r.default)(this.$parent),Object(i.default)(this,null,this.$options.props),this.observer=new MutationObserver(function(){t.scheduleHtmlSwap()}),this.observer.observe(this.$el,{attributes:!0,childList:!0,characterData:!0,subtree:!0}),this.scheduleCreateIcon()},beforeDestroy:function(){this.parentContainer.mapObject&&this.parentContainer.mapObject.setIcon(this.parentContainer.$props.icon),this.observer.disconnect()},methods:{scheduleCreateIcon:function(){this.recreationNeeded=!0,this.$nextTick(this.createIcon)},scheduleHtmlSwap:function(){this.htmlSwapNeeded=!0,this.$nextTick(this.createIcon)},createIcon:function(){if(this.htmlSwapNeeded&&!this.recreationNeeded&&this.iconObject&&this.parentContainer.mapObject.getElement())return this.parentContainer.mapObject.getElement().innerHTML=this.$el.innerHTML,void(this.htmlSwapNeeded=!1);if(this.recreationNeeded){this.iconObject&&L.DomEvent.off(this.iconObject,this.$listeners);var t=Object(o.a)({iconUrl:this.iconUrl,iconRetinaUrl:this.iconRetinaUrl,iconSize:this.iconSize,iconAnchor:this.iconAnchor,popupAnchor:this.popupAnchor,tooltipAnchor:this.tooltipAnchor,shadowUrl:this.shadowUrl,shadowRetinaUrl:this.shadowRetinaUrl,shadowSize:this.shadowSize,shadowAnchor:this.shadowAnchor,bgPos:this.bgPos,className:this.className,html:this.$el.innerHTML||this.html},this);t.html?this.iconObject=L.divIcon(t):this.iconObject=L.icon(t),L.DomEvent.on(this.iconObject,this.$listeners),this.parentContainer.mapObject.setIcon(this.iconObject),this.recreationNeeded=!1,this.htmlSwapNeeded=!1}},setIconUrl:function(){this.scheduleCreateIcon()},setIconRetinaUrl:function(){this.scheduleCreateIcon()},setIconSize:function(){this.scheduleCreateIcon()},setIconAnchor:function(){this.scheduleCreateIcon()},setPopupAnchor:function(){this.scheduleCreateIcon()},setTooltipAnchor:function(){this.scheduleCreateIcon()},setShadowUrl:function(){this.scheduleCreateIcon()},setShadowRetinaUrl:function(){this.scheduleCreateIcon()},setShadowAnchor:function(){this.scheduleCreateIcon()},setBgPos:function(){this.scheduleCreateIcon()},setClassName:function(){this.scheduleCreateIcon()},setHtml:function(){this.scheduleCreateIcon()}},render:function(){return null}},a=n(1),u=Object(a.a)(s,function(){var t=this.$createElement;return(this._self._c||t)("div",[this._t("default")],2)},[],!1,null,null,null);e.default=u.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o=n(2),s={name:"LPolyline",mixins:[n(27).a],props:{latLngs:{type:Array,default:function(){return[]}}},data:function(){return{ready:!1}},mounted:function(){var t=Object(o.a)(this.polyLineOptions,this);this.mapObject=L.polyline(this.latLngs,t),L.DomEvent.on(this.mapObject,this.$listeners),Object(i.default)(this,this.mapObject,this.$options.props),this.ready=!0,this.parentContainer=Object(r.default)(this.$parent),this.parentContainer.addLayer(this,!this.visible)}},a=n(1),u=Object(a.a)(s,function(){var t=this.$createElement;return(this._self._c||t)("div",{staticStyle:{display:"none"}},[this.ready?this._t("default"):this._e()],2)},[],!1,null,null,null);e.default=u.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o=n(2),s={name:"LPolygon",mixins:[n(26).a],props:{latLngs:{type:Array,default:function(){return[]}}},data:function(){return{ready:!1}},mounted:function(){var t=Object(o.a)(this.polygonOptions,this);this.mapObject=L.polygon(this.latLngs,t),L.DomEvent.on(this.mapObject,this.$listeners),Object(i.default)(this,this.mapObject,this.$options.props),this.ready=!0,this.parentContainer=Object(r.default)(this.$parent),this.parentContainer.addLayer(this,!this.visible)}},a=n(1),u=Object(a.a)(s,function(){var t=this.$createElement;return(this._self._c||t)("div",{staticStyle:{display:"none"}},[this.ready?this._t("default"):this._e()],2)},[],!1,null,null,null);e.default=u.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o=n(2),s=n(8),a=n(5),u={name:"LControl",mixins:[s.a,a.a],mounted:function(){var t=L.Control.extend({element:void 0,onAdd:function(){return this.element},setElement:function(t){this.element=t}}),e=Object(o.a)(this.controlOptions,this);this.mapObject=new t(e),Object(i.default)(this,this.mapObject,this.$options.props),this.parentContainer=Object(r.default)(this.$parent),this.mapObject.setElement(this.$el),this.mapObject.addTo(this.parentContainer.mapObject)}},c=n(1),l=Object(c.a)(u,function(){var t=this.$createElement;return(this._self._c||t)("div",[this._t("default")],2)},[],!1,null,null,null);e.default=l.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o=n(2),s={name:"LCircleMarker",mixins:[n(22).a],props:{latLng:{type:[Object,Array],default:function(){return[]}}},data:function(){return{ready:!1}},mounted:function(){var t=Object(o.a)(this.circleOptions,this);this.mapObject=L.circleMarker(this.latLng,t),L.DomEvent.on(this.mapObject,this.$listeners),Object(i.default)(this,this.mapObject,this.$options.props),this.ready=!0,this.parentContainer=Object(r.default)(this.$parent),this.parentContainer.addLayer(this,!this.visible)}},a=n(1),u=Object(a.a)(s,function(){var t=this.$createElement;return(this._self._c||t)("div",{staticStyle:{display:"none"}},[this.ready?this._t("default"):this._e()],2)},[],!1,null,null,null);e.default=u.exports},function(t,e,n){"use strict";n.r(e);var i=n(4),r=n.n(i),o=n(6),s=n.n(o),a=n(0),u=n(25),c=n(2),l={name:"LMap",mixins:[n(5).a],props:{center:{type:[Object,Array],custom:!0,default:function(){return[0,0]}},bounds:{type:[Array,Object],custom:!0,default:null},maxBounds:{type:[Array,Object],default:null},zoom:{type:Number,custom:!0,default:0},minZoom:{type:Number,default:null},maxZoom:{type:Number,default:null},paddingBottomRight:{type:Array,custom:!0,default:null},paddingTopLeft:{type:Array,custom:!0,default:null},padding:{type:Array,custom:!0,default:null},worldCopyJump:{type:Boolean,default:!1},crs:{type:Object,custom:!0,default:function(){return s.a.CRS.EPSG3857}},maxBoundsViscosity:{type:Number,default:null}},data:function(){return{ready:!1,lastSetCenter:null,lastSetBounds:null,lastSetZoom:null,layerControl:void 0,layersToAdd:[]}},mounted:function(){var t=Object(c.a)({minZoom:this.minZoom,maxZoom:this.maxZoom,maxBounds:this.maxBounds,maxBoundsViscosity:this.maxBoundsViscosity,worldCopyJump:this.worldCopyJump,crs:this.crs,center:this.center,zoom:this.zoom},this);this.mapObject=s.a.map(this.$el,t),this.setBounds(this.bounds),this.mapObject.on("moveend",Object(u.a)(this.moveEndHandler,100)),s.a.DomEvent.on(this.mapObject,this.$listeners),Object(a.default)(this,this.mapObject,this.$options.props),this.ready=!0,this.$emit("leaflet:load")},methods:{registerLayerControl:function(t){for(var e in this.layerControl=t,this.mapObject.addControl(t.mapObject),this.layersToAdd)this.layerControl.addLayer(e);this.layersToAdd=[]},addLayer:function(t,e){void 0!==t.layerType&&(void 0===this.layerControl?this.layersToAdd.push(t):this.layerControl.addLayer(t)),e||this.mapObject.addLayer(t.mapObject)},removeLayer:function(t,e){void 0!==t.layerType&&(void 0===this.layerControl?this.layersToAdd=this.layersToAdd.filter(function(e){return e.name!==t.name}):this.layerControl.removeLayer(t)),e||this.mapObject.removeLayer(t.mapObject)},setZoom:function(t,e){this.mapObject.setZoom(t)},setCenter:function(t,e){if(null!=t){var n=0,i=0;Array.isArray(t)?(n=t[0],i=t[1]):(n=t.lat,i=t.lng);var o=null==this.lastSetCenter?this.mapObject.getCenter():this.lastSetCenter;(o=r()({},o)).lat===n&&o.lng===i||(o.lat=t.lat,o.lng=t.lng,this.lastSetCenter=o,this.mapObject.panTo(t))}},setBounds:function(t,e){if(t){if(t instanceof s.a.LatLngBounds){if(!t.isValid())return}else if(!Array.isArray(t))return;var n=null==this.lastSetBounds?this.mapObject.getBounds():this.lastSetBounds,i=0,r=0,o=0,a=0;Array.isArray(n)?(Array.isArray(n[0])?(i=n[0][0],r=n[0][1]):(i=n[0].lat,r=n[0].lng),Array.isArray(n[1])?(o=n[1][0],a=n[1][1]):(o=n[1].lat,a=n[1].lng)):(i=n._southWest.lat,r=n._southWest.lng,o=n._northEast.lat,a=n._northEast.lng);var u,c,l,p;if(Array.isArray(t)&&(t=s.a.latLngBounds(t)),u=t._southWest.lat,c=t._southWest.lng,l=t._northEast.lat,p=t._northEast.lng,u!==i||c!==r||l!==o||p!==a){var f={};this.padding?f.padding=this.padding:(this.paddingBottomRight&&(f.paddingBottomRight=this.paddingBottomRight),this.paddingTopLeft&&(f.paddingTopLeft=this.paddingTopLeft)),this.lastSetBounds=n,Array.isArray(n)?(Array.isArray(n[0])?(n[0][0]=i,n[0][1]=r):(n[0].lat=i,n[0].lng=r),Array.isArray(n[1])?(n[1][0]=o,n[1][1]=a):(n[1].lat=o,n[1].lng=a)):(n._southWest.lat=i,n._southWest.lng=r,n._northEast.lat=o,n._northEast.lng=a),this.mapObject.fitBounds(t,f)}}},setPaddingBottomRight:function(t,e){this.paddingBottomRight=t},setPaddingTopLeft:function(t,e){this.paddingTopLeft=t},setPadding:function(t,e){this.padding=t},setCrs:function(t,e){console.log("Changing CRS is not yet supported by Leaflet")},fitBounds:function(t){this.mapObject.fitBounds(t)},moveEndHandler:function(){this.$emit("update:zoom",this.mapObject.getZoom());var t=this.mapObject.getCenter();this.$emit("update:center",t);var e=this.mapObject.getBounds();this.$emit("update:bounds",e)}}},p=n(1);var f=function(t){n(81)},h=Object(p.a)(l,function(){var t=this.$createElement;return(this._self._c||t)("div",{staticClass:"vue2leaflet-map"},[this.ready?this._t("default"):this._e()],2)},[],!1,f,null,null);e.default=h.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o=n(2),s={name:"LCircle",mixins:[n(22).a],props:{latLng:{type:[Object,Array],default:function(){return[]}}},data:function(){return{ready:!1}},mounted:function(){var t=Object(o.a)(this.circleOptions,this);this.mapObject=L.circle(this.latLng,t),L.DomEvent.on(this.mapObject,this.$listeners),Object(i.default)(this,this.mapObject,this.$options.props),this.ready=!0,this.parentContainer=Object(r.default)(this.$parent),this.parentContainer.addLayer(this,!this.visible)},methods:{}},a=n(1),u=Object(a.a)(s,function(){var t=this.$createElement;return(this._self._c||t)("div",{staticStyle:{display:"none"}},[this.ready?this._t("default"):this._e()],2)},[],!1,null,null,null);e.default=u.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o=n(2),s=n(28),a=n(5),u={name:"LTooltip",mixins:[s.a,a.a],mounted:function(){var t=Object(o.a)(this.popperOptions,this);this.mapObject=L.tooltip(t),L.DomEvent.on(this.mapObject,this.$listeners),Object(i.default)(this,this.mapObject,this.$options.props),this.mapObject.setContent(this.content||this.$el),this.parentContainer=Object(r.default)(this.$parent),this.parentContainer.mapObject.bindTooltip(this.mapObject)},beforeDestroy:function(){this.parentContainer.mapObject&&this.parentContainer.mapObject.getTooltip()&&this.parentContainer.mapObject.unbindTooltip()}},c=n(1),l=Object(c.a)(u,void 0,void 0,!1,null,null,null);e.default=l.exports},function(t,e,n){"use strict";n.r(e);var i=n(4),r=n.n(i),o=n(0),s=n(3),a=n(25),u=n(2),c=n(7),l=n(5),p={name:"LMarker",mixins:[c.a,l.a],props:{pane:{type:String,default:"markerPane"},draggable:{type:Boolean,custom:!0,default:!1},latLng:{type:[Object,Array],custom:!0,default:null},icon:{type:[Object],custom:!1,default:function(){return new L.Icon.Default}},zIndexOffset:{type:Number,custom:!1,default:null}},data:function(){return{ready:!1}},mounted:function(){var t=Object(u.a)(r()({},this.layerOptions,{icon:this.icon,zIndexOffset:this.zIndexOffset,draggable:this.draggable}),this);this.mapObject=L.marker(this.latLng,t),L.DomEvent.on(this.mapObject,this.$listeners),this.mapObject.on("move",Object(a.a)(this.latLngSync,100)),Object(o.default)(this,this.mapObject,this.$options.props),this.parentContainer=Object(s.default)(this.$parent),this.parentContainer.addLayer(this,!this.visible),this.ready=!0},methods:{setDraggable:function(t,e){this.mapObject.dragging&&(t?this.mapObject.dragging.enable():this.mapObject.dragging.disable())},setLatLng:function(t){if(null!=t&&this.mapObject){var e=this.mapObject.getLatLng(),n={lat:t[0]||t.lat,lng:t[1]||t.lng};n.lat===e.lat&&n.lng===e.lng||this.mapObject.setLatLng(n)}},latLngSync:function(t){this.$emit("update:latLng",t.latlng)}},render:function(t){return this.ready&&this.$slots.default?t("div",{style:{display:"none"}},this.$slots.default):null}},f=n(1),h=Object(f.a)(p,void 0,void 0,!1,null,null,null);e.default=h.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r=n(3),o=n(2),s=n(28),a=n(5),u={name:"LPopup",mixins:[s.a,a.a],props:{latLng:{type:[Object,Array],default:function(){return[]}}},mounted:function(){var t=Object(o.a)(this.popperOptions,this);this.mapObject=L.popup(t),void 0!==this.latLng&&this.mapObject.setLatLng(this.latLng),L.DomEvent.on(this.mapObject,this.$listeners),Object(i.default)(this,this.mapObject,this.$options.props),this.mapObject.setContent(this.content||this.$el),this.parentContainer=Object(r.default)(this.$parent),this.parentContainer.mapObject.bindPopup(this.mapObject)},beforeDestroy:function(){this.parentContainer.mapObject&&this.parentContainer.mapObject.getPopup()&&this.parentContainer.mapObject.unbindPopup()}},c=n(1),l=Object(c.a)(u,void 0,void 0,!1,null,null,null);e.default=l.exports},function(t,e,n){"use strict";n.r(e);var i=n(4),r=n.n(i),o=n(0),s=n(3),a=n(2),u=n(6),c=n.n(u),l={name:"LGeoJson",mixins:[n(14).a],props:{geojson:{type:[Object,Array],custom:!0,default:function(){return{}}},options:{type:Object,custom:!0,default:function(){return{}}},optionsStyle:{type:[Object,Function],custom:!0,default:null}},computed:{mergedOptions:function(){return Object(a.a)(r()({},this.layerGroupOptions,{style:this.optionsStyle}),this)}},mounted:function(){this.mapObject=c.a.geoJSON(this.geojson,this.mergedOptions),c.a.DomEvent.on(this.mapObject,this.$listeners),Object(o.default)(this,this.mapObject,this.$options.props),this.parentContainer=Object(s.default)(this.$parent,!0),this.parentContainer.addLayer(this,!this.visible)},beforeDestroy:function(){this.parentContainer.mapObject.removeLayer(this.mapObject)},methods:{setGeojson:function(t){this.mapObject.clearLayers(),this.mapObject.addData(t)},getGeoJSONData:function(){return this.mapObject.toGeoJSON()},getBounds:function(){return this.mapObject.getBounds()},setOptions:function(t,e){this.mapObject.clearLayers(),c.a.setOptions(this.mapObject,this.mergedOptions),this.mapObject.addData(this.geojson)},setOptionsStyle:function(t,e){this.mapObject.setStyle(t)}},render:function(){return null}},p=n(1),f=Object(p.a)(l,void 0,void 0,!1,null,null,null);e.default=f.exports},function(t,e,n){"use strict";n.r(e);var i=n(4),r=n.n(i),o=n(0),s=n(2),a=n(8),u=n(5),c={name:"LControlAttribution",mixins:[a.a,u.a],props:{prefix:{type:String,default:null}},mounted:function(){var t=Object(s.a)(r()({},this.controlOptions,{prefix:this.prefix}),this);this.mapObject=L.control.attribution(t),Object(o.default)(this,this.mapObject,this.$options.props),this.mapObject.addTo(this.$parent.mapObject)},render:function(){return null}},l=n(1),p=Object(l.a)(c,void 0,void 0,!1,null,null,null);e.default=p.exports},function(t,e,n){"use strict";n.r(e);var i=n(0),r={name:"LIconDefault",props:{imagePath:{type:String,custom:!0,default:""}},mounted:function(){L.Icon.Default.imagePath=this.imagePath,Object(i.default)(this,this.mapObject,this.$options.props)},methods:{setImagePath:function(t,e){L.Icon.Default.imagePath=t}},render:function(){return null}},o=n(1),s=Object(o.a)(r,void 0,void 0,!1,null,null,null);e.default=s.exports},function(t,e,n){"use strict";n.r(e);var i=n(4),r=n.n(i),o=n(0),s=n(2),a=n(8),u=n(5),c={name:"LControlLayers",mixins:[a.a,u.a],props:{collapsed:{type:Boolean,default:!0},autoZIndex:{type:Boolean,default:!0},hideSingleBase:{type:Boolean,default:!1},sortLayers:{type:Boolean,default:!1},sortFunction:{type:Function,default:void 0}},mounted:function(){var t=Object(s.a)(r()({},this.controlOptions,{collapsed:this.collapsed,autoZIndex:this.autoZIndex,hideSingleBase:this.hideSingleBase,sortLayers:this.sortLayers,sortFunction:this.sortFunction}),this);this.mapObject=L.control.layers(null,null,t),Object(o.default)(this,this.mapObject,this.$options.props),this.$parent.registerLayerControl(this)},methods:{addLayer:function(t){"base"===t.layerType?this.mapObject.addBaseLayer(t.mapObject,t.name):"overlay"===t.layerType&&this.mapObject.addOverlay(t.mapObject,t.name)},removeLayer:function(t){this.mapObject.removeLayer(t.mapObject)}},render:function(){return null}},l=n(1),p=Object(l.a)(c,void 0,void 0,!1,null,null,null);e.default=p.exports},function(t,e,n){"use strict";n.r(e);var i=n(4),r=n.n(i),o=n(0),s=n(2),a=n(8),u=n(5),c={name:"LControlZoom",mixins:[a.a,u.a],props:{zoomInText:{type:String,default:"+"},zoomInTitle:{type:String,default:"Zoom in"},zoomOutText:{type:String,default:"-"},zoomOutTitle:{type:String,default:"Zoom out"}},mounted:function(){var t=Object(s.a)(r()({},this.controlOptions,{zoomInText:this.zoomInText,zoomInTitle:this.zoomInTitle,zoomOutText:this.zoomOutText,zoomOutTitle:this.zoomOutTitle}),this);this.mapObject=L.control.zoom(t),Object(o.default)(this,this.mapObject,this.$options.props),this.mapObject.addTo(this.$parent.mapObject)},render:function(){return null}},l=n(1),p=Object(l.a)(c,void 0,void 0,!1,null,null,null);e.default=p.exports},function(t,e,n){"use strict";n.r(e);var i=n(4),r=n.n(i),o=n(0),s=n(2),a=n(8),u=n(5),c={name:"LControlScale",mixins:[a.a,u.a],props:{maxWidth:{type:Number,default:100},metric:{type:Boolean,default:!0},imperial:{type:Boolean,default:!0},updateWhenIdle:{type:Boolean,default:!1}},mounted:function(){var t=Object(s.a)(r()({},this.controlOptions,{maxWidth:this.maxWidth,metric:this.metric,imperial:this.imperial,updateWhenIdle:this.updateWhenIdle}),this);this.mapObject=L.control.scale(t),Object(o.default)(this,this.mapObject,this.$options.props),this.mapObject.addTo(this.$parent.mapObject)},render:function(){return null}},l=n(1),p=Object(l.a)(c,void 0,void 0,!1,null,null,null);e.default=p.exports},function(t,e,n){"use strict";function i(t,e){for(var n=[],i={},r=0;r<e.length;r++){var o=e[r],s=o[0],a={id:t+":"+r,css:o[1],media:o[2],sourceMap:o[3]};i[s]?i[s].parts.push(a):n.push(i[s]={id:s,parts:[a]})}return n}n.r(e),n.d(e,"default",function(){return d});var r="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!r)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var o={},s=r&&(document.head||document.getElementsByTagName("head")[0]),a=null,u=0,c=!1,l=function(){},p=null,f="data-vue-ssr-id",h="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function d(t,e,n,r){c=n,p=r||{};var s=i(t,e);return m(s),function(e){for(var n=[],r=0;r<s.length;r++){var a=s[r];(u=o[a.id]).refs--,n.push(u)}e?m(s=i(t,e)):s=[];for(r=0;r<n.length;r++){var u;if(0===(u=n[r]).refs){for(var c=0;c<u.parts.length;c++)u.parts[c]();delete o[u.id]}}}}function m(t){for(var e=0;e<t.length;e++){var n=t[e],i=o[n.id];if(i){i.refs++;for(var r=0;r<i.parts.length;r++)i.parts[r](n.parts[r]);for(;r<n.parts.length;r++)i.parts.push(b(n.parts[r]));i.parts.length>n.parts.length&&(i.parts.length=n.parts.length)}else{var s=[];for(r=0;r<n.parts.length;r++)s.push(b(n.parts[r]));o[n.id]={id:n.id,refs:1,parts:s}}}}function y(){var t=document.createElement("style");return t.type="text/css",s.appendChild(t),t}function b(t){var e,n,i=document.querySelector("style["+f+'~="'+t.id+'"]');if(i){if(c)return l;i.parentNode.removeChild(i)}if(h){var r=u++;i=a||(a=y()),e=v.bind(null,i,r,!1),n=v.bind(null,i,r,!0)}else i=y(),e=function(t,e){var n=e.css,i=e.media,r=e.sourceMap;i&&t.setAttribute("media",i);p.ssrId&&t.setAttribute(f,e.id);r&&(n+="\n/*# sourceURL="+r.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */");if(t.styleSheet)t.styleSheet.cssText=n;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(n))}}.bind(null,i),n=function(){i.parentNode.removeChild(i)};return e(t),function(i){if(i){if(i.css===t.css&&i.media===t.media&&i.sourceMap===t.sourceMap)return;e(t=i)}else n()}}var O=function(){var t=[];return function(e,n){return t[e]=n,t.filter(Boolean).join("\n")}}();function v(t,e,n,i){var r=n?"":i.css;if(t.styleSheet)t.styleSheet.cssText=O(e,r);else{var o=document.createTextNode(r),s=t.childNodes;s[e]&&t.removeChild(s[e]),s.length?t.insertBefore(o,s[e]):t.appendChild(o)}}}])});

},{"leaflet":30}],37:[function(require,module,exports){
exports.sync = function (store, router, options) {
  var moduleName = (options || {}).moduleName || 'route'

  store.registerModule(moduleName, {
    namespaced: true,
    state: cloneRoute(router.currentRoute),
    mutations: {
      'ROUTE_CHANGED': function ROUTE_CHANGED (state, transition) {
        store.state[moduleName] = cloneRoute(transition.to, transition.from)
      }
    }
  })

  var isTimeTraveling = false
  var currentPath

  // sync router on store change
  var storeUnwatch = store.watch(
    function (state) { return state[moduleName]; },
    function (route) {
      var fullPath = route.fullPath;
      if (fullPath === currentPath) {
        return
      }
      if (currentPath != null) {
        isTimeTraveling = true
        router.push(route)
      }
      currentPath = fullPath
    },
    { sync: true }
  )

  // sync store on router navigation
  var afterEachUnHook = router.afterEach(function (to, from) {
    if (isTimeTraveling) {
      isTimeTraveling = false
      return
    }
    currentPath = to.fullPath
    store.commit(moduleName + '/ROUTE_CHANGED', { to: to, from: from })
  })

  return function unsync () {
    // On unsync, remove router hook
    if (afterEachUnHook != null) {
      afterEachUnHook()
    }

    // On unsync, remove store watch
    if (storeUnwatch != null) {
      storeUnwatch()
    }

    // On unsync, unregister Module with store
    store.unregisterModule(moduleName)
  }
}

function cloneRoute (to, from) {
  var clone = {
    name: to.name,
    path: to.path,
    hash: to.hash,
    query: to.query,
    params: to.params,
    fullPath: to.fullPath,
    meta: to.meta
  }
  if (from) {
    clone.from = cloneRoute(from)
  }
  return Object.freeze(clone)
}


},{}],38:[function(require,module,exports){
(function (process){
/**
 * vuex v3.0.1
 * (c) 2017 Evan You
 * @license MIT
 */
'use strict';

var applyMixin = function (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if ( options === void 0 ) options = {};

      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit () {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
};

var devtoolHook =
  typeof window !== 'undefined' &&
  window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
  if (!devtoolHook) { return }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */


/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: { configurable: true } };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors$1 );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if (process.env.NODE_ENV !== 'production') {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) { return }

  parent.removeChild(key);
};

function update (path, targetModule, newModule) {
  if (process.env.NODE_ENV !== 'production') {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
            'manual reload is needed'
          );
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

var functionAssert = {
  assert: function (value) { return typeof value === 'function'; },
  expected: 'function'
};

var objectAssert = {
  assert: function (value) { return typeof value === 'function' ||
    (typeof value === 'object' && typeof value.handler === 'function'); },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule (path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) { return }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";
  return buf
}

var Vue; // bind on install

var Store = function Store (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "Store must be called with the new operator.");
  }

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;

  var state = options.state; if ( state === void 0 ) state = {};
  if (typeof state === 'function') {
    state = state() || {};
  }

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1); });

  if (Vue.config.devtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors = { state: { configurable: true } };

prototypeAccessors.state.get = function () {
  return this._vm._data.$$state
};

prototypeAccessors.state.set = function (v) {
  if (process.env.NODE_ENV !== 'production') {
    assert(false, "Use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(("[vuex] unknown mutation type: " + type));
    }
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });
  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });

  if (
    process.env.NODE_ENV !== 'production' &&
    options && options.silent
  ) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(("[vuex] unknown action type: " + type));
    }
    return
  }

  this._actionSubscribers.forEach(function (sub) { return sub(action, this$1.state); });

  return entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload)
};

Store.prototype.subscribe = function subscribe (fn) {
  return genericSubscribe(fn, this._subscribers)
};

Store.prototype.subscribeAction = function subscribeAction (fn) {
  return genericSubscribe(fn, this._actionSubscribers)
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

  if (typeof path === 'string') { path = [path]; }

  if (process.env.NODE_ENV !== 'production') {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if (process.env.NODE_ENV !== 'production') {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors );

function genericSubscribe (fn, subs) {
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
}

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () { return fn(store); };
    Object.defineProperty(store.getters, key, {
      get: function () { return store._vm[key]; },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () { return oldVm.$destroy(); });
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (process.env.NODE_ENV !== 'production' && !store._actions[type]) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (process.env.NODE_ENV !== 'production' && !store._mutations[type]) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  var gettersProxy = {};

  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) { return }

    // extract local getter type
    var localType = type.slice(splitPos);

    // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.
    Object.defineProperty(gettersProxy, localType, {
      get: function () { return store.getters[type]; },
      enumerable: true
    });
  });

  return gettersProxy
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload, cb) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(("[vuex] duplicate getter key: " + type));
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, function () {
    if (process.env.NODE_ENV !== 'production') {
      assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, sync: true });
}

function getNestedState (state, path) {
  return path.length
    ? path.reduce(function (state, key) { return state[key]; }, state)
    : state
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof type === 'string', ("Expects string as the type, but found " + (typeof type) + "."));
  }

  return { type: type, payload: payload, options: options }
}

function install (_Vue) {
  if (Vue && _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      );
    }
    return
  }
  Vue = _Vue;
  applyMixin(Vue);
}

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return
        }
        commit = module.context.commit;
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (process.env.NODE_ENV !== 'production' && !(val in this.$store.getters)) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

function normalizeMap (map) {
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (process.env.NODE_ENV !== 'production' && !module) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

var index = {
  Store: Store,
  install: install,
  version: '3.0.1',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers
};

module.exports = index;

}).call(this,require('_process'))

},{"_process":31}],39:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  props: ['logo', 'logoTo', 'brand'],
  computed: {
    showNav: function showNav() {
      return this.$store.getters.getNavbarVisibility;
    }
  },
  methods: {
    triggerBurger: function triggerBurger() {
      this.$store.commit('switchNavbarMenu');
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"navbar-brand",attrs:{"title":_vm.brand}},[_c('router-link',{staticClass:"navbar-item",attrs:{"id":"logo_home","to":_vm.logoTo}},[_c('img',{attrs:{"id":"navbar-logo","src":this.logo.url,"alt":'Logo ' + _vm.brand}})]),_vm._v(" "),_c('div',{class:("navbar-burger " + (_vm.showNav ? 'is-active' : '')),attrs:{"aria-expanded":"false","data-target":"navbar-main"},on:{"click":function($event){_vm.triggerBurger()}}},[_c('span'),_vm._v(" "),_c('span'),_vm._v(" "),_c('span')])],1)}
__vue__options__.staticRenderFns = []

},{}],40:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".count-and-tabs[data-v-37502840]{display:flex;flex-direction:row;justify-content:space-between;align-items:flex-start;margin-bottom:1em}.count-and-tabs .result-count-parent[data-v-37502840]{padding-top:1rem;padding:0 1em;position:relative;left:-1em;max-width:20em;background-color:transparent}.count-and-tabs .result-count-parent.open[data-v-37502840]{background-color:#f6f6f6;top:-1rem;padding-top:1rem}.count-and-tabs .result-count-parent .results-count[data-v-37502840]{padding:.5em 1em;background-color:#fff;border-radius:3px;font-size:1.2em;display:flex;flex-direction:row;align-items:center}.count-and-tabs .result-count-parent .results-count .nb[data-v-37502840]{color:#513085;font-size:1.3em;font-weight:700;margin-right:.5em}.count-and-tabs .buttons>[data-v-37502840]{width:7em;justify-content:left}.count-and-tabs .buttons>* img[data-v-37502840]{max-height:1.5em}.count-and-tabs .buttons>* span[data-v-37502840]{margin-left:.2em}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _constants = require("../constants.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  name: 'CISSearchResultsCountAndTabs',
  props: ['view', 'open'],
  data: function data() {
    return {
      VIEW_MAP: _constants.VIEW_MAP,
      VIEW_LIST: _constants.VIEW_LIST,
      VIEW_STAT: _constants.VIEW_STAT
    };
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    pending: function pending(_ref) {
      var search = _ref.search;
      return !!search.answer.pendingAbort;
    },
    total: function total(_ref2) {
      var search = _ref2.search;
      return search.answer.result && search.answer.result.total;
    }
  }), {
    endpointConfigFilters: function endpointConfigFilters() {
      return this.$store.getters.getEndpointConfigFilters;
    },
    endpointConfigList: function endpointConfigList() {
      return this.$store.getters.getEndpointConfigList;
    },
    endpointConfigMap: function endpointConfigMap() {
      return this.$store.getters.getEndpointConfigMap;
    },
    endpointConfigDetail: function endpointConfigDetail() {
      return this.$store.getters.getEndpointConfigDetail;
    },
    endpointConfigStat: function endpointConfigStat() {
      var endpointStat = this.$store.getters.getEndpointConfigStat;
      console.log("endpointStat : ", endpointStat);
      return endpointStat;
    },
    endpointConfigUrlToList: function endpointConfigUrlToList() {
      var routeConfig = this.$store.getters.getRouteConfigListForDataset;
      return routeConfig;
    },
    endpointConfigUrlToMap: function endpointConfigUrlToMap() {
      var routeConfig = this.$store.getters.getRouteConfigMapForDataset;
      return routeConfig;
    }
  }),
  methods: {
    configTabs: function configTabs(tabField) {
      var tabsConf = this.$store.state.config.global.app_screen_tabs;
      return tabsConf[tabField];
    },
    translate: function translate(textsToTranslate) {
      var listTexts = textsToTranslate.link_text;
      return this.$store.getters.getTranslation({
        texts: listTexts
      });
    },
    translateBis: function translateBis(textsToTranslate, listField) {
      var listTexts = textsToTranslate[listField];
      return this.$store.getters.getTranslation({
        texts: listTexts
      });
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:("count-and-tabs " + (_vm.view == _vm.VIEW_MAP ? 'is-map' : 'is-not-map'))},[_c('div',{class:['result-count-parent', _vm.open ? 'open' : undefined]},[_c('div',{staticClass:"results-count"},[_c('span',{staticClass:"nb"},[_vm._v("\n        "+_vm._s(_vm.pending ? '?' : _vm.total)+"\n      ")]),_vm._v(" "),_c('span',[_vm._v("\n        "+_vm._s(_vm.translateBis(_vm.endpointConfigFilters, 'items_found' ))+"\n      ")])]),_vm._v(" "),_vm._t("project")],2),_vm._v(" "),_c('div',{staticClass:"buttons has-addons is-right"},[(typeof _vm.endpointConfigList !== 'undefined')?_c('router-link',{class:['button', _vm.view === _vm.VIEW_LIST ? 'is-selected is-primary' : undefined],attrs:{"disabled":_vm.endpointConfigList.is_disabled,"to":_vm.endpointConfigUrlToList.urls[0]}},[_c('img',{attrs:{"src":("/static/icons/" + (_vm.view === _vm.VIEW_LIST ? 'icon_list_blanc.svg': 'icon_list.svg'))}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm.translate(_vm.configTabs('tab_list'))))])]):_vm._e(),_vm._v(" "),(typeof _vm.endpointConfigMap !== 'undefined')?_c('router-link',{class:['button', _vm.view === _vm.VIEW_MAP ? 'is-selected is-primary' : undefined],attrs:{"disabled":_vm.endpointConfigMap.is_disabled,"to":_vm.endpointConfigUrlToMap.urls[0]}},[_c('img',{attrs:{"src":("/static/icons/" + (_vm.view === _vm.VIEW_MAP ? 'icon_map_blanc.svg': 'icon_map.svg'))}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm.translate(_vm.configTabs('tab_map'))))])]):_vm._e()],1)])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-37502840"

},{"../constants.js":69,"@nymag/vueify/lib/insert-css":1,"vuex":38}],41:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _vue2Leaflet = require("vue2-leaflet");

var _utilsPruneCluster = require("../utilsPruneCluster.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  name: "CustomMarkers",
  props: ['routeConfig', 'endPointConfig', 'itemsForMap', 'mapObject', 'checkIfStringFloat', 'contentFields', 'highlightedItem'],
  data: function data() {
    return {
      itemsOnMap: [],
      pruneCluster: undefined,
      iconSizeNormal: [29, 29],
      iconSizeHighlighted: [49, 49]
    };
  },
  mounted: function mounted() {
    console.log(" - - CustomMarkers / mounted... ");
    this.itemsOnMap = this.projects;
    this.pruneCluster = new _utilsPruneCluster.PruneClusterForLeaflet();
    var iconNormalSize = this.iconSizeNormal;
    var iconBigSize = this.iconSizeHighlighted;
    var emitDataFunction = this.emitItem;
    var IconSize = this.getIconSize;

    var smallIcon = _vue2Leaflet.L.icon({
      iconUrl: '/static/icons/icon_pin_plein_violet.svg',
      iconSize: iconNormalSize
    });

    var bigIcon = _vue2Leaflet.L.icon({
      iconUrl: '/static/icons/icon_pin_plein_violet.svg',
      iconSize: iconBigSize
    });

    this.pruneCluster.PrepareLeafletMarker = function (leafletMarker, data) {
      leafletMarker.setIcon(smallIcon);
      leafletMarker.on('click', function (e) {
        leafletMarker.setIcon(bigIcon);
        emitDataFunction(data);
      });
    };

    this.pruneCluster.BuildLeafletClusterIcon = function (cluster) {
      var e = new _vue2Leaflet.L.Icon.MarkerCluster();
      e.stats = cluster.stats;
      e.population = cluster.population;
      return e;
    };

    var colors = ['#ff4b00', '#bac900', '#EC1813', '#55BCBE', '#D2204C', '#FF0000', '#ada59a', '#3e647e'],
        pi2 = Math.PI * 2;
    _vue2Leaflet.L.Icon.MarkerCluster = _vue2Leaflet.L.Icon.extend({
      options: {
        iconUrl: '/static/icons/icon_cluster_yellow.svg',
        iconSize: new _vue2Leaflet.L.Point(44, 44),
        className: 'prunecluster leaflet-markercluster-icon'
      },
      createIcon: function createIcon() {
        var e = document.createElement('canvas');

        this._setIconStyles(e, 'icon');

        var s = this.options.iconSize;
        e.width = s.x;
        e.height = s.y;
        this.draw(e.getContext('2d'), s.x, s.y);
        return e;
      },
      createShadow: function createShadow() {
        return null;
      },
      draw: function draw(canvas, width, height) {
        var lol = 0;
        var start = 0;

        for (var i = 0, l = colors.length; i < l; ++i) {
          var size = this.stats[i] / this.population;

          if (size > 0) {
            canvas.beginPath();
            canvas.moveTo(22, 22);
            canvas.fillStyle = colors[i];
            var from = start + 0.14,
                to = start + size * pi2;

            if (to < from) {
              from = start;
            }

            canvas.arc(22, 22, 22, from, to);
            start = start + size * pi2;
            canvas.lineTo(22, 22);
            canvas.fill();
            canvas.closePath();
          }
        }

        canvas.beginPath();
        canvas.fillStyle = '#a174ac';
        canvas.arc(22, 22, 18, 0, Math.PI * 2);
        canvas.fill();
        canvas.closePath();
        canvas.fillStyle = 'white';
        canvas.textAlign = 'center';
        canvas.textBaseline = 'middle';
        canvas.font = 'bold 12px sans-serif';
        canvas.fillText(this.population, 22, 22, 40);
      }
    });
    var map = this.mapObject.mapObject;
    map.addLayer(this.pruneCluster);
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    projects: function projects(_ref) {
      var search = _ref.search;
      return search.answer.result && search.answer.result.projects;
    }
  })),
  watch: {
    projects: function projects(old) {
      if (this.projects && this.projects.length > 0) {
        this.reDraw();
      }
    }
  },
  methods: {
    emitItem: function emitItem(item) {
      this.$emit('getSelectedItem', item);
    },
    checkIfItemHasLatLng: function checkIfItemHasLatLng(item) {
      return this.checkIfStringFloat(item.lat) && this.checkIfStringFloat(item.lon);
    },
    reDraw: function reDraw() {
      var _this = this;

      console.log('------------- redraw -------------');
      var pruneCluster = this.pruneCluster;
      pruneCluster.RemoveMarkers();
      console.log('removed all the markers - number of markers to map: ', this.itemsForMap().length);
      this.itemsForMap().forEach(function (item) {
        var marker = _this.createMarker(item, pruneCluster);

        pruneCluster.RegisterMarker(marker);
      });
    },
    createMarker: function createMarker(obj, pruneCluster) {
      var parsedObj = JSON.parse(JSON.stringify(obj));
      var marker = new _utilsPruneCluster.PruneCluster.Marker(parsedObj.lat, parsedObj.lon);
      marker.data.ID = this.itemId(obj);
      marker.data.lat = parsedObj.lat;
      marker.data.lon = parsedObj.lon;
      return marker;
    },
    getIconSize: function getIconSize(item) {
      if (this.highlightedItem) {
        var itemID = item.ID;
        var highlightedItemID = this.itemId(this.highlightedItem, 'block_id');
        return itemID === highlightedItemID ? [49, 49] : [29, 29];
      } else {
        return this.iconSizeNormal;
      }
    },
    matchItemWithConfig: function matchItemWithConfig(item, fieldBlock) {
      var contentField = this.contentFields.find(function (f) {
        return f.position == fieldBlock;
      });

      if (contentField) {
        var field = contentField.field;
        return item[field];
      } else {
        return undefined;
      }
    },
    itemId: function itemId(item) {
      return this.matchItemWithConfig(item, 'block_id');
    },
    getHighlightedItemId: function getHighlightedItemId() {
      if (this.highlightedItem) {
        return this.itemId(highlightedItem, 'block_id');
      } else {
        return false;
      }
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c("div")}
__vue__options__.staticRenderFns = []

},{"../utilsPruneCluster.js":78,"vue2-leaflet":36,"vuex":38}],42:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".banner-height-with-filters[data-v-e63bd77c]{margin-top:100px;margin-bottom:30px;max-height:250px}.banner-height-without-filters[data-v-e63bd77c]{padding-top:60px;margin-top:10px;margin-bottom:30px;height:250px}.buttons[data-v-e63bd77c]{margin-right:3em}.close[data-v-e63bd77c]{z-index:2;position:absolute}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _axios = _interopRequireDefault(require("axios"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  props: ['template_url', 'dynamicTemplate', 'navbarConfig'],
  data: function data() {
    return {
      rawHtml: '',
      visible: true
    };
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user',
    bannerVisible: 'bannerVisible'
  }), {
    hasFilters: function hasFilters() {
      return this.dynamicTemplate === 'DynamicStatic' ? false : true;
    }
  }),
  mounted: function mounted() {
    var _this = this;

    var template_url = this.template_url ? this.template_url : 'https://co-demos.com/error';
    var head = {
      headers: {
        'accept': 'text/html'
      }
    };

    _axios.default.get(template_url, head).then(function (response) {
      _this.rawHtml = response && response.data ? response.data : '<br><br>there is an Error <br><br>';
    }).catch(function (err) {
      _this.rawHtml = '<br><br>there is an <strong> Error </strong><br><br>';
    });
  },
  methods: {
    disableBanners: function disableBanners() {
      this.rawHtml = '';
      this.$store.commit('disableBanners');
    },
    goBack: function goBack(e) {
      e.preventDefault();
      this.$router.back();
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{directives:[{name:"show",rawName:"v-show",value:(_vm.rawHtml !== '' && _vm.bannerVisible),expression:"rawHtml !== '' && bannerVisible"}],class:("is-hidden-touch " + (_vm.hasFilters ? 'banner-height-with-filters' : 'banner-height-without-filters') + " has-text-center skip-navbar")},[_c('div',{staticClass:"buttons is-right"},[_c('button',{staticClass:"button close is-primary is-inverted",on:{"click":_vm.disableBanners}},[_vm._m(0)])]),_vm._v(" "),_c('div',{staticClass:"container"},[_c('div',{staticClass:"content"},[_c('span',{domProps:{"innerHTML":_vm._s(_vm.rawHtml)}})])])])}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small"},[_c('i',{staticClass:"fas fa-times"})])}]
__vue__options__._scopeId = "data-v-e63bd77c"

},{"@nymag/vueify/lib/insert-css":1,"axios":2,"vuex":38}],43:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert("main[data-v-e6c8da32]{background-color:#f6f6f6;margin-top:3.33333rem;height:100%;padding-bottom:3em}.block-color[data-v-e6c8da32]{background-color:#a174ac!important;color:#fff}.tag[data-v-e6c8da32]{background-color:#a174ac;color:#fff;margin-right:1em;margin-bottom:.5em}a.disabled[data-v-e6c8da32]{pointer-events:none;border-bottom:none!important;cursor:default}a.back[data-v-e6c8da32]{padding:1em 0;display:block;color:#3d3a39}a.back .icon[data-v-e6c8da32],a.back img[data-v-e6c8da32]{height:1.5em;transform:translateY(.3em)}a.back span[data-v-e6c8da32]{margin-left:1em}.columns[data-v-e6c8da32]{margin-top:0}.illustration[data-v-e6c8da32]{width:100%;margin-bottom:1em}.added[data-v-e6c8da32],.description[data-v-e6c8da32]{background-color:#fff;padding:1em;margin-bottom:1em}.description h1[data-v-e6c8da32]{font-weight:700}.description p[data-v-e6c8da32]{margin-bottom:1em}.description a[data-v-e6c8da32]{color:#513085;border-bottom:1px solid #513085}.added[data-v-e6c8da32]{display:flex;flex-direction:row;align-items:center;justify-content:left}.added .link-at-sourcer img[data-v-e6c8da32]{max-height:1.1em;transform:translateY(.2em)}.added img[data-v-e6c8da32]{height:auto}.added .no-left-padding[data-v-e6c8da32]{padding-left:0}.added .is-vertical-centered[data-v-e6c8da32]{display:flex;align-items:center}.added .logo[data-v-e6c8da32]{height:auto;width:100%}.added a[data-v-e6c8da32]{color:#513085;font-weight:700}.content h2[data-v-e6c8da32]{font-weight:700}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _NotFoundError = _interopRequireDefault(require("./NotFoundError.vue"));

var _utils = require("../utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  name: 'DynamicDetail',
  components: {
    NotFoundError: _NotFoundError.default
  },
  props: ['routeConfig', 'endPointConfig'],
  data: function data() {
    return {
      displayableItem: null,
      contentFields: null,
      isError: false
    };
  },
  beforeMount: function beforeMount() {
    this.contentFields = this.routeConfig.contents_fields;
  },
  mounted: function mounted() {
    var _this = this;

    var int = setInterval(function () {
      if (window.pageYOffset < 50) {
        clearInterval(int);
      } else {
        window.scrollTo(0, 0);
      }
    }, 100);
    (0, _utils.getItemById)(this.$route.query.id, this.$store.state.search.endpoint).then(function (item) {
      _this.displayableItem = item;
    }).catch(function (err) {
      this.isError = true;
      console.error('item route error', err);
    });
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user'
  }), {
    backToResults: function backToResults() {
      return this.$store.getters.defaultText({
        txt: 'back_to_results'
      });
    },
    listOfPositions: function listOfPositions() {
      return this.contentFields.map(function (c) {
        return c.position;
      });
    },
    noData: function noData() {
      return this.$store.getters.defaultText({
        txt: 'no_data'
      });
    },
    noAbstractText: function noAbstractText() {
      return this.$store.getters.defaultText({
        txt: 'no_abstract'
      });
    },
    noInfos: function noInfos() {
      return this.$store.getters.defaultText({
        txt: 'no_info'
      });
    },
    noAddress: function noAddress() {
      return this.$store.getters.defaultText({
        txt: 'no_address'
      });
    },
    seeWebsite: function seeWebsite() {
      return this.$store.getters.defaultText({
        txt: 'see_website'
      });
    },
    seeContact: function seeContact() {
      return this.$store.getters.defaultText({
        txt: 'see_contact'
      });
    },
    shareLink: function shareLink() {
      return this.$store.getters.defaultText({
        txt: 'share_link'
      });
    },
    sourceData: function sourceData() {
      return this.$store.getters.defaultText({
        txt: 'source'
      });
    },
    periodData: function periodData() {
      return this.$store.getters.defaultText({
        txt: 'period'
      });
    },
    infosData: function infosData() {
      return this.$store.getters.defaultText({
        txt: 'infos'
      });
    },
    infosTel: function infosTel() {
      return this.$store.getters.defaultText({
        txt: 'tel'
      });
    },
    infosOpen: function infosOpen() {
      return this.$store.getters.defaultText({
        txt: 'open_infos'
      });
    },
    infosMore: function infosMore() {
      return this.$store.getters.defaultText({
        txt: 'more_infos'
      });
    },
    servicesData: function servicesData() {
      return this.$store.getters.defaultText({
        txt: 'services'
      });
    },
    downloadFile: function downloadFile() {
      return this.$store.getters.defaultText({
        txt: 'dowload_file'
      });
    }
  }),
  methods: {
    isPositionFilled: function isPositionFilled(fieldBlock) {
      return this.listOfPositions.indexOf(fieldBlock) !== -1;
    },
    itemImage: function itemImage(fieldBlock) {
      return this.$store.getters.getImageUrl({
        item: this.displayableItem,
        position: fieldBlock
      });
    },
    matchProjectWithConfig: function matchProjectWithConfig(fieldBlock) {
      var contentField = this.contentFields.find(function (f) {
        return f.position == fieldBlock;
      });

      if (contentField) {
        var field = contentField.field;
        var content = this.displayableItem[field];

        if (content && content !== "None" && content !== "") {
          if (contentField.is_tag_like) {
            content = content.split(contentField.tags_separator).filter(function (c) {
              return c != "";
            });
            return content;
          } else {
            return content;
          }
        } else {
          return this.noData;
        }
      } else {
        return undefined;
      }
    },
    getCustomBlockTitle: function getCustomBlockTitle(fieldBlock) {
      var customBlockTitle = undefined;
      var contentField = this.contentFields.find(function (f) {
        return f.position == fieldBlock;
      });

      if (contentField) {
        customBlockTitle = contentField.custom_title;
      }

      return customBlockTitle;
    },
    projectId: function projectId() {
      return this.matchProjectWithConfig('block_id');
    },
    goBack: function goBack(e) {
      e.preventDefault();
      this.$router.back();
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[(_vm.displayableItem)?_c('main',[_c('div',{staticClass:"container"},[_c('a',{staticClass:"back",on:{"click":_vm.goBack}},[_vm._m(0),_vm._v(" "),_c('span',[_vm._v("\n          "+_vm._s(_vm.backToResults)+"\n        ")])]),_vm._v(" "),_c('div',{staticClass:"columns"},[_c('div',{staticClass:"column is-5 is-offset-1"},[_c('div',{staticClass:"description"},[_c('h1',{staticClass:"title is-3",attrs:{"id":"block-title"}},[_vm._v("\n               "+_vm._s(_vm.matchProjectWithConfig('block_title'))+"\n            ")]),_vm._v(" "),(_vm.isPositionFilled('block_main_tags'))?_c('div',{attrs:{"id":"block-main-tags"}},[(_vm.getCustomBlockTitle('block_main_tags'))?_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                "+_vm._s(_vm.getCustomBlockTitle('block_main_tags'))+"\n              ")]):_vm._e(),_vm._v(" "),_c('br'),_vm._v(" "),_vm._l((_vm.matchProjectWithConfig('block_main_tags')),function(tag,i){return _c('span',{key:tag + i,staticClass:"tag"},[_vm._v("\n                "+_vm._s(tag)+"\n              ")])}),_vm._v(" "),_c('br'),_c('br')],2):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_address'))?_c('p',{attrs:{"id":"block-address"}},[_vm._m(1),_vm._v("\n              "+_vm._s(_vm.matchProjectWithConfig('block_address'))+"\n            ")]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_pre_abstract'))?_c('p',{attrs:{"id":"block-pre-abstract"}},[(_vm.getCustomBlockTitle('block_pre_abstract'))?_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                "+_vm._s(_vm.getCustomBlockTitle('block_pre_abstract'))+"\n                "),_c('br'),_c('br')]):_vm._e(),_vm._v("\n              "+_vm._s(_vm.matchProjectWithConfig('block_pre_abstract'))+"\n            ")]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_abstract'))?_c('p',{attrs:{"id":"block-abstract"}},[(_vm.getCustomBlockTitle('block_abstract'))?_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                "+_vm._s(_vm.getCustomBlockTitle('block_abstract'))+"\n                "),_c('br'),_c('br')]):_vm._e(),_vm._v("\n              "+_vm._s(_vm.matchProjectWithConfig('block_abstract'))+"\n            ")]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_partners'))?_c('div',{attrs:{"id":"block-partners"}},[_c('p',[_vm._v(_vm._s(_vm.matchProjectWithConfig('block_partners')))])]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_post_abstract_1'))?_c('p',{attrs:{"id":"block-post-abstract-1"}},[(_vm.getCustomBlockTitle('block_post_abstract_1'))?_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                "+_vm._s(_vm.getCustomBlockTitle('block_post_abstract_1'))+"\n                "),_c('br'),_c('br')]):_vm._e(),_vm._v("\n              "+_vm._s(_vm.matchProjectWithConfig('block_post_abstract_1'))+"\n            ")]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_post_abstract_2'))?_c('p',{attrs:{"id":"block-post-abstract-2"}},[(_vm.getCustomBlockTitle('block_post_abstract_2'))?_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                "+_vm._s(_vm.getCustomBlockTitle('block_post_abstract_2'))+"\n                "),_c('br'),_c('br')]):_vm._e(),_vm._v("\n              "+_vm._s(_vm.matchProjectWithConfig('block_post_abstract_2'))+"\n            ")]):_vm._e(),_vm._v(" "),_c('div',{staticClass:"columns"},[_c('div',{staticClass:"column is-5 is-offset-1 link",attrs:{"id":"block-main-website"}},[(_vm.matchProjectWithConfig('block_wesite'))?_c('a',{class:_vm.matchProjectWithConfig('block_wesite') === _vm.noData ? 'disabled has-text-grey' : '',attrs:{"href":_vm.matchProjectWithConfig('block_wesite') === _vm.noData ? '' : _vm.matchProjectWithConfig('block_wesite'),"target":"_blank"}},[_vm._v("\n                  "+_vm._s(_vm.seeWebsite)+"\n                ")]):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"column is-5 is-offset-1 link",attrs:{"id":"block-main-contact"}},[(_vm.matchProjectWithConfig('block_contact'))?_c('a',{class:_vm.matchProjectWithConfig('block_contact') === _vm.noData ? 'disabled has-text-grey' : '',attrs:{"href":_vm.matchProjectWithConfig('block_wesite') === _vm.noData ? '' :'mailto:' + _vm.matchProjectWithConfig('block_contact'),"target":"_blank"}},[_vm._v("\n                  "+_vm._s(_vm.seeContact)+"\n                ")]):_vm._e()])])]),_vm._v(" "),(_vm.isPositionFilled('block_services'))?_c('div',{staticClass:"added",attrs:{"id":"block-services"}},[_c('div',{staticClass:"columns"},[_c('div',{staticClass:"column is-12"},[_c('div',[_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                    "+_vm._s(_vm.servicesData)+" : "),_c('br'),_c('br')]),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.matchProjectWithConfig('block_services'))+"\n                  ")])])])])]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_left_bottom_2'))?_c('div',{staticClass:"added",attrs:{"id":"block-LB2"}},[_c('div',{staticClass:"columns"},[_c('div',{staticClass:"column is-12"},[_c('div',[(_vm.getCustomBlockTitle('block_left_bottom_2'))?_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                    "+_vm._s(_vm.getCustomBlockTitle('block_left_bottom_2'))+"\n                    "),_c('br'),_c('br')]):_vm._e(),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.matchProjectWithConfig('block_left_bottom_2'))+"\n                  ")])])])])]):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"column is-5"},[_c('a',{attrs:{"id":"block-illustration","href":_vm.matchProjectWithConfig('block_wesite'),"target":"_blank"}},[_c('img',{staticClass:"illustration",attrs:{"src":_vm.itemImage('card_img_main'),"alt":_vm.matchProjectWithConfig('block_title')}})]),_vm._v(" "),(_vm.isPositionFilled('block_file_1'))?_c('div',{staticClass:"added",attrs:{"id":"block-file"}},[_c('div',{staticClass:"columns"},[_c('div',{staticClass:"column is-12"},[_c('div',[_c('a',{attrs:{"target":"_blank","href":_vm.matchProjectWithConfig('block_file_1')}},[_vm._m(2),_vm._v(" "),_c('span',[_vm._v("\n                      "+_vm._s(_vm.downloadFile)+"\n                    ")])])])])])]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_src'))?_c('div',{staticClass:"added",attrs:{"id":"block-src"}},[_c('div',{staticClass:"columns"},[_c('div',{staticClass:"column is-12"},[_c('div',[_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                    "+_vm._s(_vm.sourceData)+" : \n                  ")]),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.matchProjectWithConfig('block_src'))+"\n                  ")])])])])]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_scale') || _vm.isPositionFilled('block_scale_address'))?_c('div',{staticClass:"added",attrs:{"id":"block-scale"}},[_c('div',{staticClass:"columns"},[_c('div',{staticClass:"column is-12"},[_c('div',[(_vm.getCustomBlockTitle('block_scale_tags'))?_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                    "+_vm._s(_vm.getCustomBlockTitle('block_scale_tags'))+"\n                  ")]):_vm._e(),_vm._v(" "),_vm._l((_vm.matchProjectWithConfig('block_scale_tags')),function(tag,i){return _c('span',{key:tag + i,staticClass:"tag"},[_vm._v("\n                    "+_vm._s(tag)+"\n                  ")])})],2),_vm._v(" "),_c('div',{attrs:{"id":"block-scale-2"}},[(_vm.getCustomBlockTitle('block_scale_2'))?_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                    "+_vm._s(_vm.getCustomBlockTitle('block_scale_2'))+" \n                  ")]):_vm._e(),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.matchProjectWithConfig('block_scale_2'))+"\n                  ")])]),_vm._v(" "),(_vm.isPositionFilled('block_scale_address'))?_c('div',{attrs:{"id":"block-scale-address"}},[_vm._m(3),_vm._v("\n                  "+_vm._s(_vm.matchProjectWithConfig('block_scale_address'))+"\n                ")]):_vm._e()])])]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_period'))?_c('div',{staticClass:"added",attrs:{"id":"block-period"}},[_c('div',{staticClass:"columns"},[_c('div',{staticClass:"column is-12"},[_c('div',[_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                    "+_vm._s(_vm.periodData)+" : \n                  ")]),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.matchProjectWithConfig('block_period'))+"\n                  ")])])])])]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_contact_name'))?_c('div',{staticClass:"added block-color",attrs:{"id":"block-contact"}},[_c('div',{staticClass:"columns"},[_c('div',{staticClass:"column is-12"},[_c('div',[_c('span',{staticClass:"has-text-weight-semibold"},[_vm._v("\n                    "+_vm._s(_vm.seeContact)+" : \n                  ")])]),_vm._v(" "),_c('br'),_vm._v(" "),(_vm.isPositionFilled('block_contact_name'))?_c('div',[_vm._m(4),_vm._v(" "),_c('span',[(_vm.isPositionFilled('block_contact_name'))?_c('span',[_vm._v("\n                      "+_vm._s(_vm.matchProjectWithConfig('block_contact_name'))+" \n                    ")]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_contact_surname'))?_c('span',[_vm._v("\n                      "+_vm._s(_vm.matchProjectWithConfig('block_contact_surname'))+"\n                    ")]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_contact_fullname'))?_c('span',[_vm._v("\n                      "+_vm._s(_vm.matchProjectWithConfig('block_contact_fullname'))+"\n                    ")]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_contact_title'))?_c('span',[_c('br'),_vm._v("\n                      "+_vm._s(_vm.matchProjectWithConfig('block_contact_title'))+"\n                      "),_c('br')]):_vm._e()]),_vm._v(" "),_c('br')]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_contact_email'))?_c('div',[_vm._m(5),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.matchProjectWithConfig('block_contact_email'))+" "),_c('br')])]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_contact_tel'))?_c('div',[_vm._m(6),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.matchProjectWithConfig('block_contact_tel'))+" "),_c('br')])]):_vm._e()])])]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_open_infos'))?_c('div',{staticClass:"added",attrs:{"id":"block-infos"}},[_c('div',{staticClass:"columns"},[_c('div',{staticClass:"column is-12"},[_c('div',[_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                    "+_vm._s(_vm.infosData)+" : "),_c('br'),_c('br')])]),_vm._v(" "),(_vm.isPositionFilled('block_tel'))?_c('div',{attrs:{"id":"block-tel"}},[_vm._m(7),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.infosTel)+" : \n                    "+_vm._s(_vm.matchProjectWithConfig('block_tel'))+" "),_c('br')])]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_open_infos'))?_c('div',{attrs:{"id":"block-open-infos"}},[_vm._m(8),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.infosOpen)+" : "),_c('br'),_vm._v("\n                    "+_vm._s(_vm.matchProjectWithConfig('block_open_infos'))+" "),_c('br')])]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_infos_pract'))?_c('div',{attrs:{"id":"block-infos-pract"}},[_vm._m(9),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.infosMore)+" : \n                    "+_vm._s(_vm.matchProjectWithConfig('block_infos_pract'))+"\n                  ")])]):_vm._e()])])]):_vm._e(),_vm._v(" "),(_vm.isPositionFilled('block_right_bottom_1'))?_c('div',{staticClass:"added",attrs:{"id":"block-RB1"}},[_c('div',{staticClass:"columns"},[_c('div',{staticClass:"column is-12"},[_c('div',[(_vm.getCustomBlockTitle('block_right_bottom_1'))?_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                    "+_vm._s(_vm.getCustomBlockTitle('block_right_bottom_1'))+"\n                    "),_c('br'),_c('br')]):_vm._e(),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.matchProjectWithConfig('block_right_bottom_1'))+"\n                  ")])]),_vm._v(" "),(_vm.isPositionFilled('block_right_bottom_2'))?_c('div',[_c('br'),_vm._v(" "),(_vm.getCustomBlockTitle('block_right_bottom_2'))?_c('span',{staticClass:"has-text-weight-semibold has-text-primary"},[_vm._v("\n                    "+_vm._s(_vm.getCustomBlockTitle('block_right_bottom_2'))+"\n                    "),_c('br'),_c('br')]):_vm._e(),_vm._v(" "),_c('span',[_vm._v("\n                    "+_vm._s(_vm.matchProjectWithConfig('block_right_bottom_2'))+"\n                  ")])]):_vm._e()])])]):_vm._e()])])])]):_vm._e(),_vm._v(" "),(_vm.isError)?_c('NotFoundError'):_vm._e(),_vm._v(" "),_c('br')],1)}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon"},[_c('i',{staticClass:"fas fa-arrow-left"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon"},[_c('img',{staticClass:"image is-16x16",attrs:{"src":"/static/icons/icon_pin.svg"}})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small"},[_c('i',{staticClass:"fas fa-download"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon"},[_c('img',{staticClass:"image is-16x16",attrs:{"src":"/static/icons/icon_pin.svg"}})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small"},[_c('i',{staticClass:"far fa-user"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small"},[_c('i',{staticClass:"fas fa-at"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small"},[_c('i',{staticClass:"fas fa-phone"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small"},[_c('i',{staticClass:"fas fa-angle-right"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small"},[_c('i',{staticClass:"fas fa-angle-right"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small"},[_c('i',{staticClass:"fas fa-angle-right"})])}]
__vue__options__._scopeId = "data-v-e6c8da32"

},{"../utils.js":77,"./NotFoundError.vue":56,"@nymag/vueify/lib/insert-css":1,"vuex":38}],44:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".list .filter-feedback{padding-bottom:0}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _DynamicSearchScreenSqueleton = _interopRequireDefault(require("./DynamicSearchScreenSqueleton.vue"));

var _SearchResultsList = _interopRequireDefault(require("./SearchResultsList.vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  name: 'DynamicList',
  props: ['routeConfig', 'endPointConfig', 'filtersConfig'],
  data: function data() {
    return {};
  },
  components: {
    DynamicSearchScreenSqueleton: _DynamicSearchScreenSqueleton.default,
    SearchResultsList: _SearchResultsList.default
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user'
  }))
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('DynamicSearchScreenSqueleton',{attrs:{"filtersConfig":_vm.filtersConfig,"mainClass":"list"}},[_c('SearchResultsList',{attrs:{"routeConfig":_vm.routeConfig,"projectContentsFields":_vm.routeConfig.contents_fields}})],1)}
__vue__options__.staticRenderFns = []

},{"./DynamicSearchScreenSqueleton.vue":46,"./SearchResultsList.vue":58,"@nymag/vueify/lib/insert-css":1,"vuex":38}],45:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".list .filter-feedback{padding-bottom:1em}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _DynamicSearchScreenSqueleton = _interopRequireDefault(require("./DynamicSearchScreenSqueleton.vue"));

var _SearchResultsMap = _interopRequireDefault(require("./SearchResultsMap.vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  name: 'DynamicMap',
  props: ['routeConfig', 'endPointConfig', 'filtersConfig'],
  components: {
    DynamicSearchScreenSqueleton: _DynamicSearchScreenSqueleton.default,
    SearchResultsMap: _SearchResultsMap.default
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user'
  }))
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('DynamicSearchScreenSqueleton',{attrs:{"filtersConfig":_vm.filtersConfig,"mainClass":"list"}},[_c('SearchResultsMap',{attrs:{"routeConfig":_vm.routeConfig,"endPointConfig":_vm.endPointConfig}})],1)}
__vue__options__.staticRenderFns = []

},{"./DynamicSearchScreenSqueleton.vue":46,"./SearchResultsMap.vue":59,"@nymag/vueify/lib/insert-css":1,"vuex":38}],46:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert("main{margin-top:6.94444rem}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _SearchWithFilters = _interopRequireDefault(require("./SearchWithFilters.vue"));

var _FiltersFeedback = _interopRequireDefault(require("./FiltersFeedback.vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  name: 'DynamicSearchScreenSqueleton',
  components: {
    SearchWithFilters: _SearchWithFilters.default,
    FiltersFeedback: _FiltersFeedback.default
  },
  props: ['filtersConfig', 'mainClass'],
  computed: {}
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('SearchWithFilters',{attrs:{"filtersConfig":_vm.filtersConfig}}),_vm._v(" "),_c('main',{class:_vm.mainClass},[_c('FiltersFeedback'),_vm._v(" "),_vm._t("default")],2)],1)}
__vue__options__.staticRenderFns = []

},{"./FiltersFeedback.vue":50,"./SearchWithFilters.vue":60,"@nymag/vueify/lib/insert-css":1}],47:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _axios = _interopRequireDefault(require("axios"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  name: 'DynamicStatic',
  props: ['routeConfig', 'navbarConfig'],
  data: function data() {
    return {
      rawHtml: ''
    };
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user'
  })),
  watch: {
    routeConfig: function routeConfig(old) {
      this.rawHtml = '';
      this.getRawHtml();
    },
    rawHtml: function rawHtml(newRawHtml, oldRawHtml) {
      if (oldRawHtml == '' && newRawHtml != '') {
        console.log("rawHtml is not blank anymore");
        this.loadExtScript();
      } else {}
    }
  },
  beforeMount: function beforeMount() {},
  mounted: function mounted() {
    this.getRawHtml();
  },
  methods: {
    getRawHtml: function getRawHtml() {
      var _this = this;

      var int = setInterval(function () {
        if (window.pageYOffset < 50) {
          clearInterval(int);
        } else {
          window.scrollTo(0, 0);
        }
      }, 100);
      var template_url = this.routeConfig && this.routeConfig.template_url ? this.routeConfig.template_url : 'https://co-demos.com/error';
      console.log(template_url + " is template");
      var head = {
        headers: {
          'accept': 'text/html'
        }
      };
      this.rawHtml = '';

      _axios.default.get(template_url, head).then(function (response) {
        _this.rawHtml = response && response.data ? response.data : '<br><br>there is an Error <br><br>';
      }).catch(function (err) {
        _this.rawHtml = '<br><br>there is an <strong> Error </strong><br><br>';
      });
    },
    loadExtScript: function loadExtScript() {
      if (this.routeConfig && this.routeConfig.has_ext_script) {
        var ext_script_url = this.routeConfig.ext_script_url;
        console.log(ext_script_url + " is ext_script");
        var extScript = document.createElement('script');
        extScript.setAttribute('src', ext_script_url);
        extScript.setAttribute('type', "text/javascript");
        document.head.appendChild(extScript);
      }

      if (this.routeConfig && this.routeConfig.has_carousel) {
        console.log("load carousel from utils");
        (0, _utils.loadScript)("https://cdn.jsdelivr.net/npm/bulma-carousel@4.0.4/dist/js/bulma-carousel.min.js", _utils.activateCarousel);
      }
    },
    goBack: function goBack(e) {
      e.preventDefault();
      this.$router.back();
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"skip-navbar"},[_c('span',{domProps:{"innerHTML":_vm._s(_vm.rawHtml)}})])}
__vue__options__.staticRenderFns = []

},{"../utils":77,"axios":2,"vuex":38}],48:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _axios = _interopRequireDefault(require("axios"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  props: ['templateURL'],
  data: function data() {
    return {
      rawHtml: ''
    };
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user'
  })),
  mounted: function mounted() {
    var _this = this;

    var template_url = this.templateURL ? this.templateURL : 'https://co-demos.com/error';
    var head = {
      headers: {
        'accept': 'text/html'
      }
    };

    _axios.default.get(template_url, head).then(function (response) {
      _this.rawHtml = response && response.data ? response.data : '<br><br>there is an Error <br><br>';
    }).catch(function (err) {
      _this.rawHtml = '<br><br>there is an <strong> Error </strong><br><br>';
    });
  },
  methods: {
    goBack: function goBack(e) {
      e.preventDefault();
      this.$router.back();
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{domProps:{"innerHTML":_vm._s(_vm.rawHtml)}})}
__vue__options__.staticRenderFns = []

},{"axios":2,"vuex":38}],49:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _axios = _interopRequireDefault(require("axios"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  props: [],
  data: function data() {
    return {
      rawHtml: ''
    };
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user'
  })),
  mounted: function mounted() {},
  methods: {
    goBack: function goBack(e) {
      e.preventDefault();
      this.$router.back();
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"skip-navbar"},[_c('div',{attrs:{"id":"top"}}),_vm._v(" "),_c('section',{staticStyle:{"padding":"5em 0em 5em 0em"}},[_c('div',{staticClass:"container"},[_c('div',{staticClass:"row"},[_c('h1',{staticClass:"title has-text-centered"},[_vm._v("\n          Faire société à l'heure du numérique :"),_c('br'),_vm._v("\n          Former et accompagner chacun \n        ")]),_vm._v(" "),_c('br'),_vm._v(" "),_c('h1',{staticClass:"subtitle has-text-centered"},[_vm._v("\n          Plateforme ressource pour les collectivités territoriales\n        ")])])])]),_vm._v(" "),_c('div',{attrs:{"id":"deploy"}}),_vm._v(" "),_c('section',{staticClass:"has-background-info",staticStyle:{"padding":"3em 0em 3em 0em"}},[_c('div',{staticClass:"container"},[_c('div',{staticClass:"columns is-centered is-mobile"},[_c('div',{staticClass:"column is-two-thirds"},[_c('div',{staticClass:"card",staticStyle:{"display":"flex","flex-direction":"column","height":"100%","padding":"2em"}},[_c('div',{staticClass:"card-content",staticStyle:{"flex":"auto"}},[_c('div',{staticClass:"media"},[_c('div',{staticClass:"media-content has-text-centered"},[_c('p',{staticClass:"title is-4 "},[_vm._v("\n                    Comment déployer le Pass Numérique sur mon territoire ?\n                  ")])])]),_vm._v(" "),_c('br'),_vm._v(" "),_c('div',{staticClass:"content"},[_vm._v("\n                En 2019, l'Etat mobilise 7,5 millions d'euros pour le déploiement du Pass Numérique sur l'ensemble du territoire. Un appel à projets à destination des collectivités est lancé afin de leur permettre d'obtenir un financement de l'Etat pour acheter des Pass Numériques.\n                "),_c('br'),_c('br'),_vm._v("\n                A quel montant de cofinancement suis-je éligible ?\n                "),_c('br'),_c('br')]),_vm._v(" "),_c('div',{staticClass:"content has-text-centered"},[_c('a',{staticClass:"button is-primary is-medium",staticStyle:{"padding":"1.5em"},attrs:{"href":"https://societenumerique.gouv.fr/pass-numerique/","target":"_blank"}},[_c('span',[_vm._v("\n                    En savoir plus \n                  ")]),_vm._v(" "),_c('span',{staticClass:"icon is-medium "},[_c('i',{staticClass:"fas fa-external-link-alt"})])])])])])])])])]),_vm._v(" "),_c('div',{attrs:{"id":"toolbox"}}),_vm._v(" "),_c('section',{staticClass:"has-background-primary",staticStyle:{"padding":"4em 0em 4em 0em"}},[_c('div',{staticClass:"container"},[_c('div',{staticClass:"has-text-centered"},[_c('h2',{staticClass:"title has-text-white is-size-4 has-text-weight-bold"},[_vm._v("\n          Boîte à outils\n        ")]),_vm._v(" "),_c('h2',{staticClass:"subtitle has-text-white is-size-5 has-text-weight-semi-bold"},[_vm._v("\n          Retrouvez ici des ressources utiles pour la mise en place de votre politique publique\n        ")]),_vm._v(" "),_c('br')]),_vm._v(" "),_c('div',{staticClass:"columns is-multiline is-narrow-desktop is-8"},[_c('div',{staticClass:"column is-one-quarter"},[_c('div',{staticClass:"card",staticStyle:{"display":"flex","flex-direction":"column","height":"100%"}},[_c('a',{attrs:{"href":"https://societenumerique.gouv.fr/territoires/","target":"_blank"}},[_c('div',{staticClass:"card-image has-text-centered",staticStyle:{"flex":"auto"}},[_c('figure',{staticClass:"image is-inline-block",staticStyle:{"padding":"35px 10px 10px 10px"}},[_c('img',{staticStyle:{"max-height":"150px","width":"auto","height":"150px"},attrs:{"src":"https://raw.githubusercontent.com/co-demos/xp-sonum/master/illustrations/images/outil.png"}})])]),_vm._v(" "),_c('div',{staticClass:"card-content"},[_c('div',{staticClass:"media"},[_c('div',{staticClass:"media-content has-text-centered"},[_c('p',{staticClass:"title is-5"},[_vm._v("\n                      Bénéficier des outils mis à disposition\n                    ")])])])])])])]),_vm._v(" "),_c('div',{staticClass:"column is-one-quarter"},[_c('div',{staticClass:"card",staticStyle:{"display":"flex","flex-direction":"column","height":"100%"}},[_c('a',{attrs:{"href":"https://societenumerique.gouv.fr/hubs/","target":"_blank"}},[_c('div',{staticClass:"card-image has-text-centered",staticStyle:{"flex":"auto"}},[_c('figure',{staticClass:"image is-inline-block",staticStyle:{"padding":"35px 10px 10px 10px"}},[_c('img',{staticStyle:{"max-height":"150px","width":"auto","height":"150px"},attrs:{"src":"https://raw.githubusercontent.com/co-demos/xp-sonum/master/illustrations/images/orientations.png"}})])]),_vm._v(" "),_c('div',{staticClass:"card-content"},[_c('div',{staticClass:"media"},[_c('div',{staticClass:"media-content has-text-centered"},[_c('p',{staticClass:"title is-5"},[_vm._v("\n                      Mobiliser les interlocuteurs sur son territoire\n                    ")])])])])])])]),_vm._v(" "),_c('div',{staticClass:"column is-one-quarter"},[_c('div',{staticClass:"card",staticStyle:{"display":"flex","flex-direction":"column","height":"100%"}},[_c('a',{attrs:{"href":"/sonum-xp/strategie"}},[_c('div',{staticClass:"card-image has-text-centered",staticStyle:{"flex":"auto"}},[_c('figure',{staticClass:"image is-inline-block",staticStyle:{"padding":"35px 10px 10px 10px"}},[_c('img',{staticStyle:{"max-height":"150px","width":"auto","height":"150px"},attrs:{"src":"https://raw.githubusercontent.com/co-demos/xp-sonum/master/illustrations/images/enjeux.png"}})])]),_vm._v(" "),_c('div',{staticClass:"card-content"},[_c('div',{staticClass:"media"},[_c('div',{staticClass:"media-content has-text-centered"},[_c('p',{staticClass:"title is-5"},[_vm._v("\n                      Elaborer une stratégie locale d'inclusion numérique\n                    ")])])])])])])]),_vm._v(" "),_c('div',{staticClass:"column is-one-quarter"},[_c('div',{staticClass:"card",staticStyle:{"display":"flex","flex-direction":"column","height":"100%"}},[_c('a',{attrs:{"href":"/sonum-xp/liste","target":"_blank"}},[_c('div',{staticClass:"card-image has-text-centered",staticStyle:{"flex":"auto"}},[_c('figure',{staticClass:"image is-inline-block",staticStyle:{"padding":"35px 10px 10px 10px"}},[_c('img',{staticStyle:{"max-height":"150px","width":"auto","height":"150px"},attrs:{"src":"https://raw.githubusercontent.com/co-demos/xp-sonum/master/illustrations/images/ressource.png"}})])]),_vm._v(" "),_c('div',{staticClass:"card-content"},[_c('div',{staticClass:"media"},[_c('div',{staticClass:"media-content has-text-centered"},[_c('p',{staticClass:"title is-5"},[_vm._v("\n                      Découvrir les initiatives d'inclusion numérique dans les territoires\n                    ")])])])])])])])])])]),_vm._v(" "),_c('div',{attrs:{"id":"toolbox"}}),_vm._v(" "),_c('section',{staticClass:"has-background-info",staticStyle:{"padding":"4em 0em 4em 0em"}},[_c('div',{staticClass:"container"},[_c('div',{staticClass:"has-text-centered"},[_c('h2',{staticClass:"title has-text-white is-size-4 has-text-weight-bold"},[_vm._v("\n          Ce site est contributif\n        ")]),_vm._v(" "),_c('br')]),_vm._v(" "),_c('div',{staticClass:"columns is-multiline is-centered is-narrow-desktop is-8"},[_c('div',{staticClass:"column is-two-fifths"},[_c('div',{staticClass:"card",staticStyle:{"display":"flex","flex-direction":"column","height":"100%"}},[_c('div',{staticClass:"card-content"},[_c('div',{staticClass:"media"},[_c('div',{staticClass:"media-content"},[_c('div',{},[_c('p',{},[_vm._v("\n                      Vous avez mis en place une initiative ou une politique publique innovante en matière d'usages, de services ou d'inclusion numérique ? Documentez-les en remplissant ce formulaire ! \n                    ")]),_vm._v(" "),_c('br'),_vm._v(" "),_c('p',{},[_vm._v("\n                      Le formulaire est à compléter via ce lien :                     \n                    ")]),_vm._v(" "),_c('br')]),_vm._v(" "),_c('div',{staticClass:"has-text-centered"},[_c('a',{attrs:{"href":"https://framaforms.org/documentation-dinitiatives-et-politiques-publiques-numeriques-innovantes-1540547339","target":"_blank"}},[_c('span',{staticClass:"icon is-medium "},[_c('i',{staticClass:"fas fa-external-link-alt"})]),_vm._v("\n                      Formulaire de documentation \n                    ")])])])])])])]),_vm._v(" "),_c('div',{staticClass:"column is-two-fifths"},[_c('div',{staticClass:"card",staticStyle:{"display":"flex","flex-direction":"column","height":"100%"}},[_c('div',{staticClass:"card-content"},[_c('div',{staticClass:"media"},[_c('div',{staticClass:"media-content"},[_c('p',{},[_vm._v("\n                    Vous souhaitez partager tout autre outil (outil de diagnostic de compétences numériques), ressource (étude des pratiques numériques sur votre territoire…) ou nous faire part d’une suggestion ? \n                    "),_c('br'),_c('br'),_vm._v("\n                    Vous pouvez nous écrire à : \n                    "),_c('a',{staticClass:"link",attrs:{"href":"mailto:societe.numerique@finances.gouv.fr"}},[_vm._v("\n                    societe.numerique@finances.gouv.fr.\n                    ")])])])])])])])])])])])}]

},{"axios":2,"vuex":38}],50:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".filter-feedback[data-v-05660e57]{width:100%;background-color:#fff;z-index:10}.filter-feedback>.inline-filters[data-v-05660e57]{padding-top:1em;padding-bottom:1em;font-size:12px}.filter-feedback>.inline-filters a.button[data-v-05660e57]{border-radius:3px;margin-right:.5em;border:1px solid #767676;padding-top:.1em;padding-bottom:.1em;height:inherit}.filter-feedback>.inline-filters span.all[data-v-05660e57]{background-color:#fff;color:#767676}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  name: 'FiltersFeedback',
  computed: _objectSpread({}, (0, _vuex.mapState)({
    filterDescriptions: 'filterDescriptions',
    selectedFilters: function selectedFilters(_ref) {
      var search = _ref.search;
      var selectedFilters = search.question.selectedFilters;
      var filters = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = selectedFilters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              filter = _step$value[0],
              values = _step$value[1];

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = values[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var value = _step2.value;
              filters.push({
                filter: filter,
                value: value
              });
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return filters;
    }
  })),
  methods: {
    clearAllFilters: function clearAllFilters() {
      this.$store.dispatch('clearAllFilters');
    },
    clearFilter: function clearFilter(_ref2) {
      var filter = _ref2.filter,
          value = _ref2.value;
      this.$store.dispatch('toggleFilter', {
        filter: filter,
        value: value
      });
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.selectedFilters.length >= 1)?_c('section',{staticClass:"filter-feedback"},[_c('div',{staticClass:"container inline-filters"},[_c('a',{staticClass:"button is-small",on:{"click":_vm.clearAllFilters}},[_c('span',[_vm._v("\n        effacer les filtres\n      ")]),_vm._v(" "),_vm._m(0)]),_vm._v(" "),_vm._l((_vm.selectedFilters),function(ref){
var filter = ref.filter;
var value = ref.value;
return _c('a',{key:filter+value,staticClass:"button is-small is-grey",on:{"click":function($event){_vm.clearFilter({filter: filter, value: value})}}},[_c('span',[_vm._v("\n        "+_vm._s(_vm.filterDescriptions
            .find(function (f) { return f.name === filter; })
            .choices
            .find(function (c) { return c.name === value; })
            .fullname)+"\n      ")]),_vm._v(" "),_vm._m(1,true)])})],2)]):_vm._e()}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small"},[_c('i',{staticClass:"fas fa-times"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small"},[_c('i',{staticClass:"fas fa-times"})])}]
__vue__options__._scopeId = "data-v-05660e57"

},{"@nymag/vueify/lib/insert-css":1,"vuex":38}],51:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  components: {},
  props: ['footerConfig', 'appSocials'],
  computed: {
    footerUI: function footerUI() {
      return this.footerConfig.ui_options;
    }
  },
  methods: {
    footerLinks: function footerLinks(position) {
      var allLinks = this.footerConfig.links_options;
      var blockLinks = allLinks[position];
      return blockLinks;
    },
    footerContents: function footerContents(position) {
      var allContents = this.footerConfig.contents_fields;
      var blockContents = allContents[position];
      return blockContents;
    },
    isVisible: function isVisible(block) {
      return block.is_visible;
    },
    translate: function translate(textsToTranslate, listField) {
      var listTexts = textsToTranslate[listField];
      return this.$store.getters.getTranslation({
        texts: listTexts
      });
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('footer',{staticClass:"footer"},[_c('div',{staticClass:"container"},[_c('div',{staticClass:"columns"},_vm._l((['block_center_left', 'block_center_right','block_right']),function(block_pos,index){return _c('div',{key:index,staticClass:"column is-3 is-offset-1"},[_c('h3',{staticClass:"has-text-left has-text-primary"},[_vm._v(" \n          "+_vm._s(_vm.translate(_vm.footerLinks(block_pos), 'title_block'))+"\n        ")]),_vm._v(" "),(_vm.isVisible( _vm.footerLinks(block_pos) ))?[_c('ul',_vm._l((_vm.footerLinks(block_pos)['links']),function(link,index){return _c('li',{key:index},[_c('a',{attrs:{"href":link.link_to,"target":"_blank"}},[_vm._v(" \n                "+_vm._s(_vm.translate(link, 'link_text'))+"\n              ")])])}))]:_vm._e(),_vm._v(" "),(block_pos === 'block_right' )?[_c('br'),_vm._v(" "),_c('div',{staticClass:"content"},[_vm._l((_vm.appSocials),function(icon,index){return [_c('a',{key:index,staticClass:"button is-primary",attrs:{"href":icon.url}},[_c('span',{staticClass:"icon"},[_c('i',{class:icon.icon_class})])]),_vm._v("\n                 \n            ")]})],2)]:_vm._e()],2)}))])])}
__vue__options__.staticRenderFns = []

},{}],52:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _axios = _interopRequireDefault(require("axios"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  data: function data() {
    return {
      userEmail: '',
      userPassword: '',
      userRememberMe: true,
      customformError: ''
    };
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user',
    jwt: 'jwt'
  }), {
    isUserAdmin: function isUserAdmin() {
      return this.$store.getters.getCheckUserRole('admin');
    },
    isUserStaff: function isUserStaff() {
      return this.$store.getters.getCheckUserRole('staff');
    }
  }),
  methods: {
    getText: function getText(textCode) {
      return this.$store.getters.defaultText({
        txt: textCode
      });
    },
    sendLoginForm: function sendLoginForm(e) {
      var _this = this;

      this.customformError = '';
      e.preventDefault();
      var urlAuthRoot = this.$store.getters.getRootUrlAuth;
      var urlAuthLogin = this.$store.getters.getEndpointConfigAuthSpecific('login');
      var urlAuthLoginSuffix = urlAuthLogin.root_url;
      var payload = {
        email: this.userEmail,
        pwd: this.userPassword
      };

      _axios.default.post(urlAuthRoot + urlAuthLoginSuffix, payload).catch(function (error) {
        console.log(error);
        _this.customformError = 'Login failed';
      }).then(function (response) {
        return _this.$store.dispatch('saveLoginInfos', {
          APIresponse: response
        });
      });

      this.userPassword = '';
    },
    sendLogout: function sendLogout(e) {
      e.preventDefault();
      this.userEmail = '';
      this.userPassword = '';
      this.$store.dispatch('logout');
      this.$router.push('logout');
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[(!_vm.user.isLoggedin)?_c('h5',{staticClass:"title has-text-grey"},[_vm._v("\n    "+_vm._s(_vm.getText('login'))+"\n  ")]):_vm._e(),_vm._v(" "),(!_vm.user.isLoggedin)?_c('form',{attrs:{"name":"form"},on:{"submit":function($event){$event.preventDefault();return _vm.sendLoginForm($event)}}},[_c('span',[_vm._v(_vm._s(this.customformError))]),_vm._v(" "),_c('div',{staticClass:"field"},[_c('div',{staticClass:"control has-icons-left"},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.userEmail),expression:"userEmail"},{name:"validate",rawName:"v-validate",value:('required|email'),expression:"'required|email'"}],staticClass:"input",attrs:{"name":"userEmail","placeholder":_vm.getText('email'),"type":"email"},domProps:{"value":(_vm.userEmail)},on:{"input":function($event){if($event.target.composing){ return; }_vm.userEmail=$event.target.value}}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm.errors.first('userEmail')))]),_vm._v(" "),_vm._m(0)])]),_vm._v(" "),_c('div',{staticClass:"field"},[_c('div',{staticClass:"control has-icons-left"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.userPassword),expression:"userPassword"}],staticClass:"input",attrs:{"name":"userPassword","placeholder":_vm.getText('password'),"type":"password"},domProps:{"value":(_vm.userPassword)},on:{"input":function($event){if($event.target.composing){ return; }_vm.userPassword=$event.target.value}}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm.errors.first('userPassword')))]),_vm._v(" "),_vm._m(1)])]),_vm._v(" "),_c('div',{staticClass:"field"},[_c('input',{staticClass:"checkbox",attrs:{"name":"userRememberMe","type":"checkbox","value":""}}),_vm._v(" "),_c('label',{attrs:{"for":"checkbox"}},[_vm._v("\n          "+_vm._s(_vm.getText('remember_me'))+"\n        ")])]),_vm._v(" "),_c('br'),_vm._v(" "),_c('button',{staticClass:"button is-block is-primary is-fullwidth",attrs:{"type":"submit"}},[_vm._v("\n      "+_vm._s(_vm.getText('connect'))+"\n    ")])]):_vm._e(),_vm._v(" "),(_vm.isUserAdmin || _vm.isUserStaff)?_c('div',[_c('router-link',{staticClass:"button is-block is-primary is-fullwidth",attrs:{"to":'/backoffice'}},[_vm._v("\n      back office\n    ")]),_vm._v(" "),_c('br')],1):_vm._e(),_vm._v(" "),(_vm.user.isLoggedin)?_c('button',{staticClass:"button is-block is-primary is-fullwidth",attrs:{"type":"submit"},on:{"click":_vm.sendLogout}},[_vm._v("\n    "+_vm._s(_vm.getText('disconnect'))+"\n  ")]):_vm._e()])}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small is-left"},[_c('i',{staticClass:"fas fa-envelope"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small is-left"},[_c('i',{staticClass:"fas fa-key"})])}]

},{"axios":2,"vuex":38}],53:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _axios = _interopRequireDefault(require("axios"));

var _api = require("../config/api.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  data: function data() {
    return {
      userName: '',
      userSurname: '',
      userEmail: '',
      userPassword: '',
      userAcceptCGU: '',
      customformError: ''
    };
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user'
  }), {
    enableBtn: function enableBtn() {
      return this.errors.all().length === 0 ? true : false;
    }
  }),
  methods: {
    getText: function getText(textCode) {
      return this.$store.getters.defaultText({
        txt: textCode
      });
    },
    sendRegisterForm: function sendRegisterForm(e) {
      var _this = this;

      this.customformError = '';
      e.preventDefault();
      this.$validator.validate().then(function (boo) {
        if (!boo) {
          _this.customformError = 'Register failed - ' + _this.errors.all();
        } else {
          var urlAuthRoot = _this.$store.getters.getRootUrlAuth;

          var urlAuthRegister = _this.$store.getters.getEndpointConfigAuthSpecific('register');

          var urlAuthRegisterSuffix = urlAuthRegister.root_url;
          console.log("urlAuthRegisterSuffix : ", urlAuthRegisterSuffix);
          var payload = {
            name: _this.userName,
            surname: _this.userSurname,
            email: _this.userEmail,
            pwd: _this.userPassword,
            lang: "en",
            agreement: _this.userAcceptCGU
          };

          _axios.default.post(urlAuthRoot + urlAuthRegisterSuffix, payload).then(function (response) {
            _this.$store.dispatch('saveLoginInfos', {
              APIresponse: response
            });

            _this.$router.push('login');
          }).catch(function (error) {
            try {
              var msg = error.response && error.response.data && error.response.data.msg ? ' - ' + error.response.data.msg : '';

              switch (error.response.status) {
                case 401:
                  _this.customformError = 'Register failed' + msg;
                  break;

                default:
                  console.log('error unkown', error, Object.keys(error));
                  _this.customformError = 'Register failed - contact the webmaster';
                  break;
              }
            } catch (e) {
              console.log('we cannot read the error message from the API', e);
              _this.customformError = 'Register failed';
            }
          }).then(function () {
            _this.userPassword = '';
            _this.userConfirmPassword = '';
          });
        }
      });
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('h5',{staticClass:"title has-text-grey"},[_vm._v("\n    "+_vm._s(_vm.getText('register'))+"\n  ")]),_vm._v(" "),(!_vm.user.isLoggedin)?_c('form',{attrs:{"name":"form"},on:{"submit":function($event){$event.preventDefault();return _vm.sendRegisterForm($event)}}},[_c('span',[_vm._v(_vm._s(this.customformError))]),_vm._v(" "),_c('div',{staticClass:"field"},[_c('div',{staticClass:"control has-icons-left"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.userName),expression:"userName"}],staticClass:"input",attrs:{"name":"userName","type":"text","placeholder":_vm.getText('name')},domProps:{"value":(_vm.userName)},on:{"input":function($event){if($event.target.composing){ return; }_vm.userName=$event.target.value}}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm.errors.first('userName')))]),_vm._v(" "),_vm._m(0)])]),_vm._v(" "),_c('div',{staticClass:"field"},[_c('div',{staticClass:"control has-icons-left"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.userSurname),expression:"userSurname"}],staticClass:"input",attrs:{"name":"userSurname","type":"text","placeholder":_vm.getText('surname')},domProps:{"value":(_vm.userSurname)},on:{"input":function($event){if($event.target.composing){ return; }_vm.userSurname=$event.target.value}}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm.errors.first('userSurname')))]),_vm._v(" "),_vm._m(1)])]),_vm._v(" "),_c('div',{staticClass:"field"},[_c('div',{staticClass:"control has-icons-left"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required|email'),expression:"'required|email'"},{name:"model",rawName:"v-model",value:(_vm.userEmail),expression:"userEmail"}],staticClass:"input",attrs:{"name":"userEmail","type":"email","placeholder":_vm.getText('email')},domProps:{"value":(_vm.userEmail)},on:{"input":function($event){if($event.target.composing){ return; }_vm.userEmail=$event.target.value}}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm.errors.first('userEmail')))]),_vm._v(" "),_vm._m(2)])]),_vm._v(" "),_c('div',{staticClass:"field"},[_c('div',{staticClass:"control has-icons-left"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.userPassword),expression:"userPassword"}],ref:"userPassword",staticClass:"input",attrs:{"name":"userPassword","type":"password","placeholder":_vm.getText('password')},domProps:{"value":(_vm.userPassword)},on:{"input":function($event){if($event.target.composing){ return; }_vm.userPassword=$event.target.value}}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm.errors.first('userPassword')))]),_vm._v(" "),_vm._m(3)])]),_vm._v(" "),_c('div',{staticClass:"field"},[_c('div',{staticClass:"control has-icons-left"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required|confirmed:userPassword'),expression:"'required|confirmed:userPassword'"}],staticClass:"input",attrs:{"name":"userConfirmPassword","type":"password","data-vv-as":"userPassword","placeholder":_vm.getText('password_bis')}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm.errors.first('userConfirmPassword')))]),_vm._v(" "),_vm._m(4)])]),_vm._v(" "),_c('div',{staticClass:"field"},[_c('div',{staticClass:"control has-icons-left"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.userAcceptCGU),expression:"userAcceptCGU"}],staticClass:"checkbox",attrs:{"name":"userAcceptCGU","type":"checkbox"},domProps:{"checked":Array.isArray(_vm.userAcceptCGU)?_vm._i(_vm.userAcceptCGU,null)>-1:(_vm.userAcceptCGU)},on:{"change":function($event){var $$a=_vm.userAcceptCGU,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.userAcceptCGU=$$a.concat([$$v]))}else{$$i>-1&&(_vm.userAcceptCGU=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.userAcceptCGU=$$c}}}}),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm.errors.first('userAcceptCGU')))]),_vm._v(" "),_c('label',{attrs:{"for":"userAcceptCGU"}},[_c('a',{staticClass:"modal-button has-text-primary",attrs:{"data-target":"modal_legal","aria-haspopup":"true"}},[_vm._v("\n            "+_vm._s(_vm.getText('accept_cgu'))+"\n          ")])])])]),_vm._v(" "),_c('br'),_vm._v(" "),_c('button',{staticClass:"button is-block is-primary is-fullwidth ",attrs:{"disabled":!_vm.enableBtn,"type":"submit"}},[_vm._v("\n      "+_vm._s(_vm.getText('register'))+"\n  \t")])]):_vm._e(),_vm._v(" "),(_vm.user.isLoggedin)?_c('p',{staticClass:"button is-block is-primary is-fullwidth",attrs:{"type":"submit"}},[_vm._v("\n    "+_vm._s(_vm.getText('connected'))+"\n  ")]):_vm._e()])}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small is-left"},[_c('i',{staticClass:"fas fa-user"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small is-left"},[_c('i',{staticClass:"fas fa-user"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small is-left"},[_c('i',{staticClass:"fas fa-envelope"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small is-left"},[_c('i',{staticClass:"fas fa-key"})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon is-small is-left"},[_c('i',{staticClass:"fas fa-key"})])}]

},{"../config/api.js":68,"axios":2,"vuex":38}],54:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert("nav{height:60px;z-index:10}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Brand = _interopRequireDefault(require("./Brand.vue"));

var _NavBarContent = _interopRequireDefault(require("./NavBarContent.vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  components: {
    Brand: _Brand.default,
    NavBarContent: _NavBarContent.default
  },
  props: ['navbarConfig', 'appLocales', 'logo', 'brand', 'localRouteConfig', 'user']
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('nav',{staticClass:"navbar is-white is-fixed-top",attrs:{"role":"navigation","aria-label":"main navigation"}},[_c('div',{staticClass:"container"},[_c('Brand',{attrs:{"logo":_vm.logo,"logoTo":this.navbarConfig.logo_to,"brand":_vm.brand}}),_vm._v(" "),_c('NavBarContent',{attrs:{"NavbarLinks":this.navbarConfig.links_options,"user":_vm.user,"localRouteConfig":_vm.localRouteConfig}})],1)])}
__vue__options__.staticRenderFns = []

},{"./Brand.vue":39,"./NavBarContent.vue":55,"@nymag/vueify/lib/insert-css":1}],55:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".router-link-active[data-v-cf356140]{color:#513085}.is-underlined[data-v-cf356140]{border-bottom:solid;border-color:#513085}.navbar-dropdown[data-v-cf356140]{z-index:100}.menu-delimiter[data-v-cf356140]{margin:0 0 1.5em;background-color:#513085}hr.menu-ender[data-v-cf356140]{margin:1.5em 0 0;background-color:#513085}.buttons[data-v-cf356140]{margin-bottom:0}.btn-menu[data-v-cf356140]{margin-left:1em;margin-bottom:0}.is-flex-touch[data-v-cf356140]{margin-top:1em}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  props: ['NavbarLinks', 'localRouteConfig'],
  beforeMount: function beforeMount() {},
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user'
  }), {
    showNav: function showNav() {
      return this.$store.getters.getNavbarVisibility;
    },
    isUserAdmin: function isUserAdmin() {
      return this.$store.getters.getCheckUserRole('admin');
    },
    isUserStaff: function isUserStaff() {
      return this.$store.getters.getCheckUserRole('staff');
    }
  }),
  methods: {
    getText: function getText(textCode) {
      return this.$store.getters.defaultText({
        txt: textCode
      });
    },
    loadExternalURL: function loadExternalURL(link_to) {
      console.log("loadExternalURL / link_to : ", link_to);
      var win = window.open(link_to, '_blank');
      win.focus();
    },
    isActiveLink: function isActiveLink(link_to) {
      var currentRoute = this.$route.path;
      var routeURL = this.localRouteConfig.urls;
      return link_to === currentRoute || routeURL.indexOf(link_to) != -1;
    },
    isItemActive: function isItemActive(link) {
      var currentRoute = this.$route.path;
      var isLinkToRoute = this.isActiveLink(link.link_to);
      var isSublinkRoute = false;

      if (link.has_dropdown) {
        var linkDropdowns = link.dropdowns;
        var linkDropdownsList = linkDropdowns.map(function (e) {
          return e.link_to;
        });
        isSublinkRoute = linkDropdownsList.indexOf(currentRoute) != -1;
      }

      return isLinkToRoute || isSublinkRoute;
    },
    translate: function translate(textsToTranslate, listField) {
      var listTexts = textsToTranslate.link_text;
      return this.$store.getters.getTranslation({
        texts: listTexts
      });
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:("navbar-menu " + (_vm.showNav ? 'is-active' : '')),attrs:{"id":"navbar-main"}},[_c('div',{staticClass:"navbar-end"},[_vm._l((this.NavbarLinks.extra_buttons),function(link,index){return [(link.link_type == 'link' && link.is_visible == true)?_c('router-link',{key:("'link-' + " + index),class:("navbar-item " + (link.has_dropdown ? 'has-dropdown is-hoverable' : '') + "  "),attrs:{"to":link.link_to}},[_c('div',{class:((link.has_dropdown ? 'navbar-link is-arrowless' : '') + " " + (_vm.isItemActive(link) ? 'has-text-primary' : ''))},[_c('span',{class:("" + (_vm.isItemActive(link) ? 'is-underlined' : ''))},[_vm._v("\n            "+_vm._s(_vm.translate(link, 'link_text' ))+"\n          ")])]),_vm._v(" "),(link.has_dropdown)?_c('div',{staticClass:"navbar-dropdown"},[_vm._l((link.dropdowns),function(sublink,i){return [(!sublink.is_divider && sublink.is_external_link)?_c('a',{key:("'sublink-ext-' + " + i),staticClass:"navbar-item",attrs:{"href":sublink.link_to},on:{"click":function($event){_vm.loadExternalURL(sublink.link_to)}}},[_vm._v("\n              "+_vm._s(_vm.translate(sublink, 'link_text' ))+"\n            ")]):_vm._e(),_vm._v(" "),(!sublink.is_divider && !sublink.is_external_link)?_c('router-link',{key:("'sublink-int-' + " + i),class:("navbar-item " + (_vm.isActiveLink(sublink.link_to) ? 'has-text-white has-background-primary' : '')),attrs:{"to":sublink.link_to}},[_vm._v("\n              "+_vm._s(_vm.translate(sublink, 'link_text' ))+"\n            ")]):_vm._e(),_vm._v(" "),(sublink.is_divider)?_c('hr',{key:("'sublink-div-' + " + i),staticClass:"navbar-divider"}):_vm._e()]})],2):_vm._e()]):_vm._e(),_vm._v(" "),(link.link_type == 'link' && link.is_visible == true)?_c('hr',{key:index,staticClass:"is-flex-touch menu-delimiter"}):_vm._e()]}),_vm._v(" "),_c('div',{staticClass:"buttons"},[_vm._l((this.NavbarLinks.extra_buttons),function(link,index){return [(!link.has_dropdown && !link.is_external_link && link.link_type == 'button' && link.is_visible == true)?_c('router-link',{key:("'btnlink-ext-' + " + index),class:"navbar-item button is-primary is-outlined is-small btn-menu",attrs:{"to":link.link_to}},[_c('span',[_vm._v(_vm._s(_vm.translate( link,'link_text' )))])]):_vm._e(),_vm._v(" "),(!link.has_dropdown && link.is_external_link && link.link_type == 'button' && link.is_visible == true)?_c('a',{key:("'sublink-int-' + " + _vm.i),class:"navbar-item button is-primary is-outlined is-small btn-menu",attrs:{"href":link.link_to,"target":"_blank"}},[_c('span',[_vm._v(_vm._s(_vm.translate( link,'link_text' )))])]):_vm._e(),_vm._v(" "),(!link.has_dropdown && link.link_type == 'button' && link.is_visible == true)?_c('hr',{key:("'sublink-div-' + " + _vm.i),staticClass:"is-flex-touch menu-delimiter"}):_vm._e()]})],2),_vm._v(" "),(_vm.user.isLoggedin)?_c('div',{staticClass:"navbar-item has-dropdown is-hoverable"},[_vm._m(0),_vm._v(" "),_c('div',{staticClass:"navbar-dropdown is-right"},[_c('p',{staticClass:"navbar-item"},[_vm._v("\n          "+_vm._s(_vm.getText('hello'))+" "+_vm._s(_vm.user.infos.name)+"\n        ")]),_vm._v(" "),_c('hr',{staticClass:"navbar-divider"}),_vm._v(" "),(_vm.isUserAdmin || _vm.isUserStaff)?_c('router-link',{staticClass:"navbar-item",attrs:{"to":'/backoffice'}},[_vm._v("\n          "+_vm._s(_vm.getText('backoffice'))+"\n        ")]):_vm._e(),_vm._v(" "),_c('router-link',{staticClass:"navbar-item",attrs:{"to":'/preferences'}},[_vm._v("\n          "+_vm._s(_vm.getText('pref_user'))+"\n        ")]),_vm._v(" "),_c('hr',{staticClass:"navbar-divider"}),_vm._v(" "),_c('router-link',{staticClass:"navbar-item",attrs:{"to":'/logout'}},[_vm._v("\n          "+_vm._s(_vm.getText('disconnect'))+"\n        ")])],1)]):_vm._e()],2),_vm._v(" "),_c('hr',{staticClass:"is-flex-touch menu-ender"})])}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('a',{staticClass:"navbar-link is-arrowless"},[_c('span',{staticClass:"icon is-large"},[_c('i',{staticClass:"far fa-user-circle"})])])}]
__vue__options__._scopeId = "data-v-cf356140"

},{"@nymag/vueify/lib/insert-css":1,"vuex":38}],56:[function(require,module,exports){
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('main',{staticClass:"error error-404"},[_c('img',{attrs:{"src":"/static/illustrations/erreur_404.png"}}),_vm._v(" "),_c('div',[_c('h1',{staticClass:"title is-1 is-primary"},[_vm._v("Oops, La page que vous cherchez n'existe pas !")]),_vm._v(" "),_c('a',{staticClass:"button is-primary is-outlined",attrs:{"href":"/"}},[_vm._v("Revenir à la page principale")])])])}]

},{}],57:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".card-image[data-v-2b61f680]{min-height:100px}.card-image img[data-v-2b61f680]{width:100%}.proj-card[data-v-2b61f680]{border-radius:3px;box-shadow:0 3px 6px #d6d6d6}.hover-effect[data-v-2b61f680]:hover{transition:all .3s cubic-bezier(.25,.8,.25,1);box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22)}.proj-card-img[data-v-2b61f680]{border-radius:3px 3px 0 0}.card-content .tag[data-v-2b61f680]{margin-right:.5em;margin-bottom:.5em;padding:.2em 1em;background-color:#767676;color:#fff;font-size:12px}.card-content img[data-v-2b61f680]{max-height:1.1em;transform:translateY(.1em)}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var MAX_SUMMARY_LENGTH = 120;
var _default = {
  name: 'ProjectCard',
  components: {},
  props: ['item', 'contentFields', 'view'],
  beforeMount: function beforeMount() {},
  computed: {
    dataset_uri: function dataset_uri() {
      return this.$store.state.search.dataset_uri;
    },
    itemInfos: function itemInfos() {
      return this.$store.getters.getProjectConfigUniform(this.item);
    },
    noData: function noData() {
      return this.$store.getters.defaultText({
        txt: 'no_data'
      });
    },
    noAbstractText: function noAbstractText() {
      return this.$store.getters.defaultText({
        txt: 'no_abstract'
      });
    },
    noInfos: function noInfos() {
      return this.$store.getters.defaultText({
        txt: 'no_info'
      });
    },
    noAddress: function noAddress() {
      return this.$store.getters.defaultText({
        txt: 'no_address'
      });
    }
  },
  methods: {
    matchItemWithConfig: function matchItemWithConfig(fieldBlock) {
      var contentField = this.contentFields.find(function (f) {
        return f.position == fieldBlock;
      });

      if (contentField) {
        var field = contentField.field;
        return this.item[field];
      } else {
        return undefined;
      }
    },
    itemImage: function itemImage(fieldBlock) {
      return this.$store.getters.getImageUrl({
        item: this.item,
        position: fieldBlock
      });
    },
    projectId: function projectId() {
      return this.matchItemWithConfig('block_id');
    },
    projectAbstract: function projectAbstract() {
      var fullAbstract = this.matchItemWithConfig('block_abstract');
      fullAbstract = fullAbstract == null ? this.noAbstractText : fullAbstract;
      var tail = fullAbstract.length > MAX_SUMMARY_LENGTH ? '...' : '';
      return fullAbstract.slice(0, MAX_SUMMARY_LENGTH) + tail;
    },
    projectInfo: function projectInfo(field) {
      var fullInfo = this.matchItemWithConfig(field);
      fullInfo = fullInfo == null ? this.noInfos : fullInfo;
      return fullInfo;
    },
    projectAddress: function projectAddress() {
      var fullAddress = this.matchItemWithConfig('block_address');
      console.log('fullAddress : ', fullAddress);
      var address = fullAddress || fullAddress !== 'None' ? fullAddress : this.noAddress;
      return address;
    },
    projectCity: function projectCity() {
      var cityItem = this.matchItemWithConfig('block_city');
      var city = cityItem || cityItem !== 'None' ? cityItem : this.noAddress;
      return city;
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:("column is-12 " + (_vm.view === 'VIEW_MAP' ? 'hover-effect' : ''))},[_c('div',{class:("card proj-card " + (_vm.view === 'VIEW_LIST' ? 'hover-effect' : ''))},[_c('router-link',{staticClass:"card-image",attrs:{"to":("/" + _vm.dataset_uri + "/detail?id=" + (_vm.matchItemWithConfig('block_id')))}},[_c('img',{staticClass:"proj-card-img",attrs:{"src":_vm.itemInfos.image,"alt":_vm.itemInfos.title}})]),_vm._v(" "),_c('div',{staticClass:"card-content"},[(_vm.projectCity())?_c('div',{staticClass:"content"},[_vm._m(0),_vm._v(" "),_c('span',{staticClass:"subtitle is-6 is-capitalized"},[_vm._v("\n          "+_vm._s(_vm.projectCity())+"\n\n          ")])]):_vm._e(),_vm._v(" "),(_vm.matchItemWithConfig('block_id'))?_c('p',{staticClass:"title is-5 has-text-weight-bold has-text-black-ter"},[_c('router-link',{attrs:{"to":("/" + _vm.dataset_uri + "/detail?id=" + (_vm.matchItemWithConfig('block_id')))}},[_vm._v("\n          "+_vm._s(_vm.matchItemWithConfig('block_title'))+"\n        ")])],1):_vm._e(),_vm._v(" "),(_vm.projectAbstract())?_c('div',{staticClass:"content"},[_c('p',{staticClass:"subtitle is-6"},[_vm._v("\n          "+_vm._s(_vm.projectAbstract())+"\n        ")])]):_vm._e(),_vm._v(" "),(_vm.matchItemWithConfig('block_src'))?_c('div',{staticClass:"content"},[_c('p',{staticClass:"subtitle is-6 is-italic has-text-grey"},[_vm._v("\n          "+_vm._s(this.$store.getters.defaultText({txt:'source'}))+" : "+_vm._s(_vm.matchItemWithConfig('block_src'))+"\n        ")])]):_vm._e(),_vm._v(" "),(Array.isArray( _vm.itemInfos.tags ) && _vm.itemInfos.tags.length >=1)?_c('div',{staticClass:"content"},_vm._l((_vm.itemInfos.tags),function(tag){return _c('span',{key:tag,staticClass:"tag"},[_vm._v("\n            "+_vm._s(tag)+"\n        ")])})):_vm._e()])],1)])}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon"},[_c('img',{staticClass:"image is-16x16",attrs:{"src":"/static/icons/icon_pin.svg"}})])}]
__vue__options__._scopeId = "data-v-2b61f680"

},{"@nymag/vueify/lib/insert-css":1,"vuex":38}],58:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".search-results-list[data-v-8963da3a]{background-color:#f6f6f6;width:100%;padding-bottom:1.5rem;padding-top:1rem}.pending[data-v-8963da3a]{text-align:center;padding:2em}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _ProjectCard = _interopRequireDefault(require("./ProjectCard.vue"));

var _CISSearchResultsCountAndTabs = _interopRequireDefault(require("./CISSearchResultsCountAndTabs.vue"));

var _constants = require("../constants.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var scrollListener;
var _default = {
  name: 'SearchResultsList',
  components: {
    ProjectCard: _ProjectCard.default,
    CISSearchResultsCountAndTabs: _CISSearchResultsCountAndTabs.default
  },
  props: ['routeConfig', 'projectContentsFields'],
  data: function data() {
    return {
      VIEW_LIST: _constants.VIEW_LIST,
      showCount: undefined
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$store.dispatch('setSearchConfigDisplay');
    this.showCount = this.$store.getters.getSearchConfigDefaultShowCount;

    scrollListener = function scrollListener() {
      var getSearchConfigScrollBeforeBottomTrigger = _this.$store.getters.getSearchConfigScrollBeforeBottomTrigger;
      var getSearchConfigMoreProjectOnScrollCount = _this.$store.getters.getSearchConfigMoreProjectOnScrollCount;

      if (getSearchConfigMoreProjectOnScrollCount && getSearchConfigScrollBeforeBottomTrigger && window.innerHeight + window.scrollY >= document.body.offsetHeight - getSearchConfigScrollBeforeBottomTrigger) {
        if (_this.$store.state.search.answer.result && _this.showCount < _this.$store.state.search.answer.result.projects.length) {
          _this.showCount = _this.showCount + getSearchConfigMoreProjectOnScrollCount;
        }
      }
    };

    window.addEventListener('scroll', scrollListener, {
      passive: true
    });
  },
  watch: {
    projects: function projects(prev, next) {
      this.showCount = this.$store.getters.getSearchConfigDefaultShowCount;
    }
  },
  computed: _objectSpread({
    projectColumns: function projectColumns() {
      var projects = this.$store.state.search.answer.result.projects;
      var getSearchConfigColumnCount = this.$store.getters.getSearchConfigColumnCount;

      if (projects && getSearchConfigColumnCount) {
        var columnsData = Array(getSearchConfigColumnCount).fill().map(function () {
          return [];
        });
        projects.slice(0, this.showCount).forEach(function (p, i) {
          columnsData[i % getSearchConfigColumnCount].push(p);
        });
        return columnsData;
      }
    }
  }, (0, _vuex.mapState)({
    pending: function pending(_ref) {
      var search = _ref.search;
      return !!search.answer.pendingAbort;
    },
    projects: function projects(_ref2) {
      var search = _ref2.search;
      return search.answer.result && search.answer.result.projects;
    },
    total: function total(_ref3) {
      var search = _ref3.search;
      return search.answer.result && search.answer.result.total;
    },
    hasSelectedFilters: function hasSelectedFilters(_ref4) {
      var search = _ref4.search;
      var selectedFilters = search.question && search.question.selectedFilters;
      if (!selectedFilters) return false;
      return _toConsumableArray(selectedFilters.values()).some(function (selectedFilterValues) {
        return selectedFilterValues.size >= 1;
      });
    }
  })),
  methods: {
    clearAllFilters: function clearAllFilters() {
      this.$store.dispatch('clearAllFilters');
    }
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('scroll', scrollListener);
    scrollListener = undefined;
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:"search-results-list"},[(_vm.pending)?_c('div',{staticClass:"container"},[_c('div',{staticClass:"pending"},[_vm._v("Recherche en cours...")])]):_vm._e(),_vm._v(" "),(!_vm.pending)?_c('div',{staticClass:"container"},[_c('CISSearchResultsCountAndTabs',{attrs:{"view":_vm.VIEW_LIST}}),_vm._v(" "),(_vm.total > 0)?_c('div',{staticClass:"columns"},_vm._l((_vm.projectColumns),function(itemsColumn,i){return _c('div',{key:i,staticClass:"column is-3"},[_c('div',{staticClass:"columns is-multiline"},_vm._l((itemsColumn),function(item){return _c('ProjectCard',{key:item.id,attrs:{"item":item,"contentFields":_vm.projectContentsFields,"view":_vm.VIEW_LIST}})}))])})):_vm._e(),_vm._v(" "),(_vm.total === 0)?_c('div',{staticClass:"no-result error"},[_c('img',{attrs:{"src":"/static/illustrations/erreur_no_results.png"}}),_vm._v(" "),_c('div',[_c('h1',{staticClass:"title is-1 is-primary"},[_vm._v("Aucun projet trouvé !")]),_vm._v(" "),_c('p',[_vm._v("Pour obtenir plus de résultats, modifier vos critères de recherche")]),_vm._v(" "),(_vm.hasSelectedFilters)?_c('button',{staticClass:"button is-primary is-outlined",attrs:{"href":"/"},on:{"click":_vm.clearAllFilters}},[_vm._v("\n          Supprimer tous les filtres\n        ")]):_vm._e()])]):_vm._e()],1):_vm._e()])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-8963da3a"

},{"../constants.js":69,"./CISSearchResultsCountAndTabs.vue":40,"./ProjectCard.vue":57,"@nymag/vueify/lib/insert-css":1,"vuex":38}],59:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".floating{position:absolute;z-index:200;top:50%;left:50%}.leaflet-control-loader{margin-top:-40px;margin-left:-50px;background:url(/static/illustrations/leaflet-loader.gif) 50% no-repeat hsla(0,0%,100%,.8)}.lds-roller,.leaflet-control-loader{height:80px;width:100px;border-radius:10px}.lds-roller{display:inline-block;margin-left:30px}.lds-roller div{animation:lds-roller 1.2s cubic-bezier(.5,0,.5,1) infinite;transform-origin:32px 32px}.lds-roller div:after{content:\" \";display:block;position:absolute;width:6px;height:6px;border-radius:50%;background:#513085;margin:-3px 0 0 -3px}.lds-roller div:first-child{animation-delay:-36ms}.lds-roller div:first-child:after{top:50px;left:50px}.lds-roller div:nth-child(2){animation-delay:-72ms}.lds-roller div:nth-child(2):after{top:54px;left:45px}.lds-roller div:nth-child(3){animation-delay:-.108s}.lds-roller div:nth-child(3):after{top:57px;left:39px}.lds-roller div:nth-child(4){animation-delay:-.144s}.lds-roller div:nth-child(4):after{top:58px;left:32px}.lds-roller div:nth-child(5){animation-delay:-.18s}.lds-roller div:nth-child(5):after{top:57px;left:25px}.lds-roller div:nth-child(6){animation-delay:-.216s}.lds-roller div:nth-child(6):after{top:54px;left:19px}.lds-roller div:nth-child(7){animation-delay:-.252s}.lds-roller div:nth-child(7):after{top:50px;left:14px}.lds-roller div:nth-child(8){animation-delay:-.288s}.lds-roller div:nth-child(8):after{top:45px;left:10px}@keyframes lds-roller{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.app-loader{margin:1.5em;padding:1.5em}.map{height:calc(100vh - 120px);width:100%}.map .leaflet-container *{z-index:1}.map{position:relative}.map .count-and-tabs-container{position:absolute;top:1rem;width:100%}.map .count-and-tabs-container .buttons,.map .count-and-tabs-container .result-count-parent{z-index:2}.map .cis-marker-cluster{display:flex;flex-direction:row;align-items:center;justify-content:center;background-color:#a174ac;color:#fff;font-size:16px;font-weight:700;border-radius:50%}.highlighted-project{display:flex;flex-direction:column;margin-bottom:1em}.highlighted-project button.close{margin:.5em 0;background-color:transparent;border:0;align-self:flex-end}.highlighted-project .card{font-size:.9em;box-shadow:none}.highlighted-project .card .card-content{padding:.2em .5em}.highlighted-project .card .card-content:first-of-type{padding-top:.5em}.highlighted-project .card .card-content:last-of-type{padding-bottom:.5em}.highlighted-project .card .card-content h1{font-size:1.1em;font-weight:700}.highlighted-project .tag{margin-right:.5em;margin-bottom:.5em;padding:.2em 1em;background-color:#767676;color:#fff}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _vue2Leaflet = require("vue2-leaflet");

var _vue2LeafletMarkercluster = _interopRequireDefault(require("vue2-leaflet-markercluster"));

var _ProjectCard = _interopRequireDefault(require("./ProjectCard.vue"));

var _CISSearchResultsCountAndTabs = _interopRequireDefault(require("./CISSearchResultsCountAndTabs.vue"));

var _CustomMarkers = _interopRequireDefault(require("./CustomMarkers.vue"));

var _constants = require("../constants.js");

var _utils = require("../utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var FRANCE_CENTER = [46.2276, 2.2137];
var _default = {
  name: "SearchResultsMap",
  components: {
    LMap: _vue2Leaflet.LMap,
    LControlZoom: _vue2Leaflet.LControlZoom,
    LTileLayer: _vue2Leaflet.LTileLayer,
    LMarker: _vue2Leaflet.LMarker,
    LIcon: _vue2Leaflet.LIcon,
    CustomMarkers: _CustomMarkers.default,
    ProjectCard: _ProjectCard.default,
    CISSearchResultsCountAndTabs: _CISSearchResultsCountAndTabs.default
  },
  props: ['routeConfig', 'endPointConfig'],
  data: function data() {
    return {
      VIEW_MAP: _constants.VIEW_MAP,
      iconSizeNormal: [29, 29],
      iconSizeHighlighted: [49, 49],
      contentFields: undefined,
      highlightedItem: undefined,
      itemLoaded: false,
      itemLoading: false,
      showCard: false,
      itemsOnMap: [],
      preferCanvas: true,
      zoom: 6,
      maxZoom: 19,
      minZoom: 2,
      currentZoom: 6,
      center: FRANCE_CENTER,
      currentCenter: FRANCE_CENTER,
      url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd'
    };
  },
  beforeMount: function beforeMount() {
    this.contentFields = this.routeConfig.contents_fields;
    var mapOptions = this.endPointConfig.map_options;
    this.zoom = mapOptions.zoom;
    this.maxZoom = mapOptions.maxZoom;
    this.minZoom = mapOptions.minZoom;
    this.currentZoom = mapOptions.currentZoom;
    this.center = mapOptions.center;
    this.currentCenter = mapOptions.currentCenter;
    this.url = mapOptions.url;
    this.attribution = mapOptions.attribution;
    this.subdomains = mapOptions.subdomains;
  },
  mounted: function mounted() {
    this.itemsOnMap = this.projects;
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    projects: function projects(_ref) {
      var search = _ref.search;
      return search.answer.result && search.answer.result.projects;
    }
  }), {
    bounds: function bounds() {
      var displayedItems = this.itemsForMap();
      return displayedItems && new _vue2Leaflet.L.LatLngBounds(displayedItems.map(function (p) {
        return {
          lng: parseFloat(p.lon),
          lat: parseFloat(p.lat)
        };
      }));
    }
  }),
  methods: {
    handleIconSignal: function handleIconSignal(itemData) {
      this.highlightItem(itemData);
    },
    itemsForMap: function itemsForMap() {
      var _this = this;

      if (this.projects) {
        return this.projects.filter(function (item) {
          return _this.checkIfItemHasLatLng(item);
        });
      }
    },
    getIconSize: function getIconSize(item, highlightedItem) {
      if (highlightedItem) {
        return this.itemId(item, 'block_id') === this.itemId(highlightedItem, 'block_id') ? this.iconSizeHighlighted : this.iconSizeNormal;
      } else {
        return this.iconSizeNormal;
      }
    },
    matchItemWithConfig: function matchItemWithConfig(item, fieldBlock) {
      var contentField = this.contentFields.find(function (f) {
        return f.position == fieldBlock;
      });

      if (contentField) {
        var field = contentField.field;
        return item[field];
      } else {
        return undefined;
      }
    },
    itemId: function itemId(item) {
      return this.matchItemWithConfig(item, 'block_id');
    },
    getHighlightedItemId: function getHighlightedItemId() {
      if (this.highlightedItem) {
        return this.itemId(highlightedItem, 'block_id');
      } else {
        return false;
      }
    },
    checkIfStringFloat: function checkIfStringFloat(value) {
      var val = parseFloat(value);

      if (!isNaN(val)) {
        return val;
      } else {
        return false;
      }
    },
    checkIfItemHasLatLng: function checkIfItemHasLatLng(item) {
      return this.checkIfStringFloat(item.lat) && this.checkIfStringFloat(item.lon);
    },
    zoomUpdate: function zoomUpdate(zoom) {
      this.currentZoom = zoom;
    },
    centerUpdate: function centerUpdate(center) {
      this.currentCenter = center;
    },
    highlightItem: function highlightItem(i) {
      var _this2 = this;

      this.showCard = true;
      this.itemLoaded = false;
      this.center = [i.lat, i.lon];
      var item_id = i.ID;
      (0, _utils.getItemById)(item_id, this.$store.state.search.endpoint).then(function (item) {
        _this2.highlightedItem = item;
        _this2.itemLoaded = true;
      }).catch(function (err) {
        this.isError = true;
        console.error('item route error', err);
      });
    },
    iconCreateFunction: function iconCreateFunction(cluster) {
      var markerCount = cluster.getChildCount();
      return new _vue2Leaflet.L.DivIcon({
        html: "<span>".concat(markerCount, "</span>"),
        className: 'cis-marker-cluster',
        iconSize: new _vue2Leaflet.L.Point(40, 40)
      });
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"map"},[_c('div',{staticClass:"count-and-tabs-container"},[_c('div',{staticClass:"container"},[_c('CISSearchResultsCountAndTabs',{attrs:{"view":_vm.VIEW_MAP,"open":!!_vm.showCard}},[(_vm.showCard)?_c('div',{staticClass:"highlighted-project",attrs:{"slot":"project"},slot:"project"},[_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.itemLoaded),expression:"itemLoaded"}],staticClass:"button close",on:{"click":function($event){_vm.showCard = false}}},[_c('span',{staticClass:"icon is-small"},[_c('i',{staticClass:"fas fa-times"})])]),_vm._v(" "),_c('div',{staticClass:"card"},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.itemLoaded),expression:"!itemLoaded"}],staticClass:"columns is-mobile is-vcentered "},[_c('div',{staticClass:"column is-12 has-text-centered has-text-primary"},[_c('div',{staticClass:"lds-roller"},[_c('div'),_c('div'),_c('div'),_c('div'),_c('div'),_c('div'),_c('div'),_c('div')])])]),_vm._v(" "),(_vm.itemLoaded)?_c('ProjectCard',{attrs:{"item":_vm.highlightedItem,"contentFields":_vm.contentFields,"view":_vm.VIEW_MAP}}):_vm._e()],1)]):_vm._e()])],1)]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.projects || _vm.itemLoading),expression:"!projects || itemLoading"}],staticClass:"lds-roller floating"},[_c('div'),_c('div'),_c('div'),_c('div'),_c('div'),_c('div'),_c('div'),_c('div')]),_vm._v(" "),_c('l-map',{ref:"map",attrs:{"zoom":_vm.zoom,"bounds":_vm.bounds,"preferCanvas":_vm.preferCanvas,"min-zoom":_vm.minZoom,"max-zoom":_vm.maxZoom,"options":{ zoomControl: false },"center":_vm.center},on:{"update:center":_vm.centerUpdate,"update:zoom":_vm.zoomUpdate}},[_c('l-control-zoom',{attrs:{"position":"bottomright"}}),_vm._v(" "),_c('l-tile-layer',{attrs:{"url":_vm.url,"attribution":_vm.attribution}}),_vm._v(" "),_vm._v(" -->\n\n    "),_c('CustomMarkers',{attrs:{"routeConfig":_vm.routeConfig,"endPointConfig":_vm.endPointConfig,"itemsForMap":_vm.itemsForMap,"checkIfStringFloat":_vm.checkIfStringFloat,"mapObject":this.$refs.map,"contentFields":_vm.contentFields,"highlightedItem":_vm.highlightedItem},on:{"getSelectedItem":_vm.handleIconSignal}})],1)],1)}
__vue__options__.staticRenderFns = []

},{"../constants.js":69,"../utils.js":77,"./CISSearchResultsCountAndTabs.vue":40,"./CustomMarkers.vue":41,"./ProjectCard.vue":57,"@nymag/vueify/lib/insert-css":1,"vue2-leaflet":36,"vue2-leaflet-markercluster":35,"vuex":38}],60:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".hide-choices[data-v-4d65a504]{display:none}.filters-delimiter[data-v-4d65a504]{margin:0;background-color:#513085}.search-bar[data-v-4d65a504]{top:3.33333rem;height:3.61111rem;z-index:10;font-size:.88889rem}.search-bar .search[data-v-4d65a504]{flex:1;display:flex;flex-direction:row;align-items:center}.search-bar .search .image-container[data-v-4d65a504]{display:flex;flex-direction:row;justify-content:center;align-items:center}.search-bar .search .image-container img[data-v-4d65a504]{width:2rem}.search-bar .search input[type=search][data-v-4d65a504]{height:100%;border:0}.search-bar .navbar-end .navbar-link[data-v-4d65a504]:after{content:url(/static/icons/icon_chevron3.svg);border:0;transform:none;margin-right:-.5em;width:1.11111rem;right:1em;top:47%}.search-bar .navbar-end .navbar-item[data-v-4d65a504]{padding:.2em;border-left:1px solid #cbcbcb}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  computed: _objectSpread({}, (0, _vuex.mapState)({
    selectedFilters: function selectedFilters(_ref) {
      var search = _ref.search;
      return search.question.selectedFilters;
    },
    'filterDescriptions': 'filterDescriptions'
  }), {
    searchedText: {
      get: function get() {
        return this.$store.state.search.question.query;
      },
      set: function set(value) {
        this.$store.dispatch('searchedTextChanged', {
          searchedText: value
        });
      }
    },
    endpointConfigFilters: function endpointConfigFilters() {
      var configFilter = this.$store.getters.getEndpointConfigFilters;
      return configFilter;
    }
  }),
  methods: {
    collapseChoices: function collapseChoices(filterName) {
      var element = this.$refs[filterName][0];
      element.classList.toggle("hide-choices");
    },
    emptyOneFilter: function emptyOneFilter(_ref2) {
      var filter = _ref2.filter;
      this.$store.dispatch('emptyOneFilter', {
        filter: filter
      });
    },
    changeFilter: function changeFilter(_ref3) {
      var target = _ref3.target;
      this.$store.dispatch('toggleFilter', {
        filter: target.getAttribute('data-filter'),
        value: target.getAttribute('data-choice')
      });
    },
    translate: function translate(textsToTranslate, listField) {
      var listTexts = textsToTranslate[listField];
      return this.$store.getters.getTranslation({
        texts: listTexts
      });
    },
    isFilterFromSelectedFiltersBold: function isFilterFromSelectedFiltersBold(filterName) {
      return false;
    },
    isFilterFromSelectedFiltersChecked: function isFilterFromSelectedFiltersChecked(filterName) {
      return false;
    }
  },
  mounted: function mounted() {
    if (!this.$store.state.search.answer.result) {
      this.$store.dispatch('searchedTextChanged', {
        searchedText: this.searchedText
      });
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"search-bar navbar is-white is-fixed-top",attrs:{"role":"menubar","aria-label":"filters navigation"}},[_c('div',{staticClass:"container"},[_c('div',{staticClass:"search control is-expanded"},[_vm._m(0),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.searchedText),expression:"searchedText"}],staticClass:"input is-large is-light input-navbar",attrs:{"type":"search","placeholder":_vm.translate(_vm.endpointConfigFilters, 'placeholder' )},domProps:{"value":(_vm.searchedText)},on:{"input":[function($event){if($event.target.composing){ return; }_vm.searchedText=$event.target.value},_vm.searchedTextChanged]}})]),_vm._v(" "),_c('hr',{staticClass:"is-flex-touch filters-delimiter"}),_vm._v(" "),_c('div',{staticClass:"navbar-end has-background-white "},_vm._l((_vm.filterDescriptions),function(filter){return _c('span',{key:filter.name,staticClass:"navbar-item navbar-item-filter has-dropdown is-hoverable ",attrs:{"id":filter.name,"href":"#"}},[_c('a',{class:["navbar-link", {"has-text-weight-semibold" : _vm.selectedFilters.get(filter.name).size >= 1 } ],on:{"click":function($event){_vm.collapseChoices(filter.name)}}},[_c('span',[_vm._v("\n            "+_vm._s(filter.fullname)+"\n          ")])]),_vm._v(" "),_c('div',{ref:filter.name,refInFor:true,staticClass:"navbar-dropdown is-right hide-choices",attrs:{"id":filter.name}},[_vm._l((filter.choices),function(choice){return _c('a',{key:choice.name,staticClass:"navbar-item"},[_c('div',{staticClass:"field is-narrow"},[_c('input',{staticClass:"is-checkradio is-default is-normal",attrs:{"id":choice.name,"type":"checkbox","data-filter":filter.name,"data-choice":choice.name},domProps:{"checked":_vm.selectedFilters.get(filter.name).has(choice.name)},on:{"change":_vm.changeFilter}}),_vm._v(" "),_c('label',{attrs:{"for":choice.name}},[_vm._v("\n                "+_vm._s(choice.fullname)+"\n              ")])])])}),_vm._v(" "),_c('div',{staticClass:"navbar-item"},[_c('button',{staticClass:"button is-text is-fullwidth has-text-primary",attrs:{"data-filter":filter.name},on:{"click":function($event){_vm.emptyOneFilter({filter: filter.name})}}},[_vm._v("\n              "+_vm._s(_vm.translate(_vm.endpointConfigFilters, 'reset' ))+"\n            ")])])],2),_vm._v(" "),_c('hr',{staticClass:"is-flex-touch filters-delimiter"})])}))])])}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"image-container"},[_c('img',{attrs:{"src":"/static/icons/icon_search_violet.svg"}})])}]
__vue__options__._scopeId = "data-v-4d65a504"

},{"@nymag/vueify/lib/insert-css":1,"vuex":38}],61:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _axios = _interopRequireDefault(require("axios"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  components: {},
  props: ['configCollection', 'currentTab', 'fieldConfig', 'config'],
  data: function data() {
    return {
      isOpen: false,
      customformError: '',
      configBloc: undefined,
      docId: undefined,
      isDefault: undefined
    };
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    apivizFrontUUID: 'apivizFrontUUID',
    rootUrlBackend: 'rootUrlBackend',
    jwt: 'jwt'
  })),
  beforeMount: function beforeMount() {
    var configBloc = this.config[this.fieldConfig.field];
    this.configBloc = configBloc;
    this.isDefault = configBloc['is_default'];
    this.docId = configBloc._id;
  },
  methods: {
    toggleContent: function toggleContent() {
      this.isOpen = !this.isOpen;
    },
    getText: function getText(textCode) {
      return this.$store.getters.defaultText({
        txt: textCode
      });
    },
    sendConfigModif: function sendConfigModif(e) {
      var _this = this;

      var currentColl = this.configCollection;
      var argsConfig = '';

      if (currentColl === 'routes' || currentColl === 'endpoints') {
        argsConfig = '&as_list=true';
      }

      this.customformError = '';
      e.preventDefault();
      var payload = {
        test: 'test payload',
        token: this.jwt.access_token,
        doc_id: this.docId
      };
      var requestUrl = this.rootUrlBackend + '/config/' + currentColl + "?uuid=" + this.apivizFrontUUID;
      console.log('requestUrl : ', requestUrl);

      _axios.default.post(requestUrl, payload).catch(function (error) {
        console.log(error);
        _this.customformError = 'Modif failed';
      }).then(function (response) {
        return _this.$store.dispatch('getConfigType', {
          type: currentColl,
          configTypeEndpoint: currentColl,
          args: argsConfig
        });
      });
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"card"},[_c('div',{staticClass:"card-header"},[_c('a',{staticClass:"card-header-title",on:{"click":_vm.toggleContent}},[_vm._v("\n        "+_vm._s(_vm.fieldConfig.field)+"\n      ")]),_vm._v(" "),_vm._m(0)]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isOpen),expression:"isOpen"}],staticClass:"card-content"},[_c('div',{staticClass:"content"},[_vm._v("\n        rootUrlBackend : "),_c('code',[_vm._v(_vm._s(_vm.rootUrlBackend))]),_c('br'),_vm._v(" "),_vm._v("\n        jwt.access_token : "),_c('code',[_vm._v(_vm._s(_vm.jwt.access_token))]),_c('br'),_vm._v(" "),_vm._v("\n\n        configCollection : "),_c('code',[_vm._v(_vm._s(_vm.configCollection))]),_c('br'),_vm._v("\n        currentTab : "),_c('code',[_vm._v(_vm._s(_vm.currentTab))]),_c('br'),_vm._v("\n        fieldConfig : "),_c('code',[_vm._v(_vm._s(_vm.fieldConfig))]),_c('br'),_vm._v(" "),_vm._v("\n        configBloc : "),_c('code',[_vm._v(_vm._s(_vm.configBloc))]),_c('br'),_vm._v(" "),_c('hr'),_vm._v(" "),_c('form',{attrs:{"name":"formConfig"},on:{"submit":function($event){$event.preventDefault();return _vm.sendConfigModif($event)}}},[_vm._l((_vm.fieldConfig.edit),function(conf,index){return _c('div',{key:index},[(conf.type === 'text')?_c('div',{staticClass:"field"},[_c('label',{staticClass:"label"},[_vm._v(_vm._s(conf.subfield))]),_vm._v(" "),_c('div',{staticClass:"control"},[_c('input',{staticClass:"input",attrs:{"type":"text","placeholder":"Text input"},domProps:{"value":_vm.configBloc[conf.subfield]}})]),_vm._v(" "),_c('p',{staticClass:"help"},[_vm._v("\n                "+_vm._s(_vm.configBloc['help'])+"\n              ")])]):_vm._e(),_vm._v(" "),(conf.type === 'select')?_c('div',{staticClass:"field"},[_c('label',{staticClass:"label"},[_vm._v("Subject")]),_vm._v(" "),_vm._m(1,true)]):_vm._e(),_vm._v(" "),(conf.type === 'textarea')?_c('div',{staticClass:"field"},[_c('label',{staticClass:"label"},[_vm._v("Message")]),_vm._v(" "),_vm._m(2,true)]):_vm._e(),_vm._v(" "),(conf.type === 'check')?_c('div',{staticClass:"field"},[_vm._m(3,true)]):_vm._e(),_vm._v(" "),(conf.type === 'bool')?_c('div',{staticClass:"field"},[_vm._m(4,true)]):_vm._e(),_vm._v(" "),_c('br')])}),_vm._v(" "),_c('hr'),_vm._v(" "),_c('div',{staticClass:"field"},[_c('div',{staticClass:"control"},[_c('label',{staticClass:"checkbox"},[_c('input',{attrs:{"type":"checkbox"},domProps:{"value":_vm.isDefault,"checked":_vm.isDefault}}),_vm._v("\n                is default value (will be reset if server restarts)\n              ")])])]),_vm._v(" "),_c('hr'),_vm._v(" "),_vm._m(5)],2)])])]),_vm._v(" "),_c('br')])}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('a',{staticClass:"card-header-icon",attrs:{"href":"#","aria-label":"more options"}},[_c('span',{staticClass:"icon"},[_c('i',{staticClass:"fas fa-angle-down",attrs:{"aria-hidden":"true"}})])])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"control"},[_c('div',{staticClass:"select"},[_c('select',[_c('option',[_vm._v("Select dropdown")]),_vm._v(" "),_c('option',[_vm._v("With options")])])])])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"control"},[_c('textarea',{staticClass:"textarea",attrs:{"placeholder":"Textarea"}})])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"control"},[_c('label',{staticClass:"checkbox"},[_c('input',{attrs:{"type":"checkbox"}}),_vm._v("\n                  I agree to the "),_c('a',{attrs:{"href":"#"}},[_vm._v("terms and conditions")])])])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"control"},[_c('label',{staticClass:"radio"},[_c('input',{attrs:{"type":"radio","name":"question"}}),_vm._v("\n                  Yes\n                ")]),_vm._v(" "),_c('label',{staticClass:"radio"},[_c('input',{attrs:{"type":"radio","name":"question"}}),_vm._v("\n                  No\n                ")])])},function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"field is-grouped"},[_c('div',{staticClass:"control"},[_c('button',{staticClass:"button is-link"},[_vm._v("Submit")])]),_vm._v(" "),_c('div',{staticClass:"control"},[_c('button',{staticClass:"button is-text"},[_vm._v("Cancel")])])])}]

},{"axios":2,"vuex":38}],62:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _BackOfficeForm = _interopRequireDefault(require("../backoffice/BackOfficeForm.vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  components: {
    BackOfficeForm: _BackOfficeForm.default
  },
  props: ['logo', 'brand'],
  data: function data() {
    return {
      activeMenu: 'global',
      activeTab: 'gl_general',
      userMenu: [{
        'config_coll': 'u_infos',
        'title': 'infos',
        "is_divider": false,
        'icon': 'far fa-user'
      }, {
        'config_coll': 'u_password',
        'title': 'password',
        "is_divider": false,
        'icon': 'fas fa-unlock'
      }],
      backOfficeMenu: [{
        'config_coll': 'global',
        'title': 'global settings',
        "is_divider": false,
        'icon': 'fas fa-cog',
        'tabs': [{
          'tab_code': 'gl_general',
          'title': 'general',
          'fields': [{
            'field': 'app_title',
            'type': 'bloc',
            'edit': [{
              'subfield': 'content',
              'type': 'text',
              'list': false
            }]
          }, {
            'field': 'app_description',
            'type': 'bloc',
            'edit': [{
              'subfield': 'content',
              'type': 'text-lang',
              'list': false
            }]
          }, {
            'field': 'app_languages',
            'type': 'bloc',
            'edit': [{
              'subfield': 'locale',
              'type': 'text',
              'list': false
            }, {
              'subfield': 'languages',
              'type': 'text',
              'list': true
            }]
          }]
        }, {
          'tab_code': 'gl_identity',
          'title': 'site identity',
          'fields': [{
            'field': 'app_logo',
            'type': 'bloc',
            'edit': [{
              'subfield': 'url',
              'type': 'text',
              'list': false
            }]
          }, {
            'field': 'app_favicon',
            'type': 'bloc',
            'edit': [{
              'subfield': 'url',
              'type': 'text',
              'list': false
            }]
          }, {
            'field': 'app_welcome',
            'type': 'bloc',
            'edit': [{
              'subfield': 'content',
              'type': 'text-lang',
              'list': false
            }]
          }, {
            'field': 'app_pitch',
            'type': 'bloc',
            'edit': [{
              'subfield': 'content',
              'type': 'text-lang',
              'list': false
            }]
          }]
        }, {
          'tab_code': 'gl_meta',
          'title': 'meta',
          'fields': [{
            'field': 'app_keywords',
            'type': 'bloc',
            'edit': [{
              'subfield': 'content',
              'type': 'text',
              'list': false
            }]
          }, {
            'field': 'app_code',
            'type': 'bloc',
            'edit': [{
              'subfield': 'url',
              'type': 'text',
              'list': false
            }, {
              'subfield': 'content',
              'type': 'text-lang',
              'list': false
            }]
          }]
        }, {
          'tab_code': 'gl_seo',
          'title': 'seo',
          'fields': [{
            'field': 'app_analytics',
            'type': 'bloc',
            'edit': [{
              'subfield': 'content',
              'type': 'text',
              'list': false
            }, {
              'subfield': 'url',
              'type': 'text',
              'list': false
            }, {
              'subfield': 'activated',
              'type': 'bool',
              'list': false
            }]
          }, {
            'field': 'app_support',
            'type': 'bloc',
            'edit': [{
              'subfield': 'content',
              'type': 'text',
              'list': false
            }, {
              'subfield': 'url',
              'type': 'text',
              'list': false
            }, {
              'subfield': 'activated',
              'type': 'bool',
              'list': false
            }]
          }, {
            'field': 'app_indexing',
            'type': 'bloc',
            'edit': [{
              'subfield': 'content',
              'type': 'text',
              'list': false
            }, {
              'subfield': 'activated',
              'type': 'bool',
              'list': false
            }]
          }]
        }, {
          'tab_code': 'gl_lang',
          'title': 'international',
          'fields': [{
            'field': 'app_basic_dict',
            'type': 'bloc',
            'edit': ['content']
          }]
        }]
      }, {
        'config_coll': 'navbar',
        'title': 'navbar',
        "is_divider": false,
        'icon': 'fas fa-bars',
        'tabs': [{
          'tab_code': 'na_logo',
          'title': 'logo'
        }, {
          'tab_code': 'na_links',
          'title': 'links'
        }, {
          'tab_code': 'na_btn',
          'title': 'call_button'
        }]
      }, {
        'config_coll': 'routes',
        'title': 'routes',
        "is_divider": false,
        'icon': 'far fa-sticky-note',
        'tabs': [{
          'tab_code': 'ro_home',
          'title': 'home page'
        }, {
          'tab_code': 'ro_data',
          'title': 'datasets pages'
        }, {
          'tab_code': 'ro_statics',
          'title': 'static pages'
        }]
      }, {
        'config_coll': 'endpoints',
        'title': 'API endpoints',
        "is_divider": false,
        'icon': 'fas fa-database',
        'tabs': [{
          'tab_code': 'ep_data',
          'title': 'datasets'
        }, {
          'tab_code': 'ep_user',
          'title': 'user'
        }, {
          'tab_code': 'ep_auth',
          'title': 'authentication'
        }]
      }, {
        'config_coll': 'footer',
        'title': 'footer',
        "is_divider": false,
        'icon': 'fas fa-link',
        'tabs': [{
          'tab_code': 'fo_settings',
          'title': 'settings'
        }, {
          'tab_code': 'fo_contents',
          'title': 'contents'
        }, {
          'tab_code': 'fo_ui',
          'title': 'ui'
        }, {
          'tab_code': 'fo_links',
          'title': 'links'
        }]
      }, {
        'config_coll': 'socials',
        'title': 'socials',
        "is_divider": false,
        'icon': 'fas fa-share-alt',
        'tabs': [{
          'tab_code': 'so_settings',
          'title': 'settings',
          'fields': [{
            'field': 'app_twitter',
            'type': 'bloc',
            'edit': [{
              'subfield': 'url',
              'type': 'text',
              'list': false
            }, {
              'subfield': 'tooltip',
              'type': 'text-lang',
              'list': false
            }, {
              'subfield': 'in_footer',
              'type': 'bool',
              'list': false
            }]
          }, {
            'field': 'app_facebook',
            'type': 'bloc',
            'edit': [{
              'subfield': 'url',
              'type': 'text',
              'list': false
            }, {
              'subfield': 'tooltip',
              'type': 'text-lang',
              'list': false
            }, {
              'subfield': 'in_footer',
              'type': 'bool',
              'list': false
            }]
          }, {
            'field': 'app_github',
            'type': 'bloc',
            'edit': [{
              'subfield': 'url',
              'type': 'text',
              'list': false
            }, {
              'subfield': 'tooltip',
              'type': 'text-lang',
              'list': false
            }, {
              'subfield': 'in_footer',
              'type': 'bool',
              'list': false
            }]
          }]
        }]
      }, {
        'config_coll': 'styles',
        'title': 'styles',
        "is_divider": false,
        'icon': 'fas fa-paint-brush',
        'tabs': [{
          'tab_code': 'st_colors',
          'title': 'app colors'
        }, {
          'tab_code': 'st_typo',
          'title': 'app typo'
        }, {
          'tab_code': 'st_typocolors',
          'title': 'app typo colors'
        }, {
          'tab_code': 'st_banners',
          'title': 'app banners'
        }, {
          'tab_code': 'st_images',
          'title': 'app default images sets'
        }]
      }, {
        'config_coll': 'users',
        'title': 'users',
        "is_divider": false,
        'icon': 'fas fa-users',
        'tabs': [{
          'tab_code': 'us_users',
          'title': 'users',
          'fields': []
        }, {
          'tab_code': 'us_teams',
          'title': 'teams',
          'fields': []
        }]
      }]
    };
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user',
    config: 'config'
  }), {
    isUserAdmin: function isUserAdmin() {
      return this.$store.getters.getCheckUserRole('admin');
    },
    isUserStaff: function isUserStaff() {
      return this.$store.getters.getCheckUserRole('staff');
    }
  }),
  mounted: function mounted() {
    var int = setInterval(function () {
      if (window.pageYOffset < 50) {
        clearInterval(int);
      } else {
        window.scrollTo(0, 0);
      }
    }, 100);
  },
  methods: {
    getMenuConfig: function getMenuConfig(menuConfigField) {
      var menuConfig = this.backOfficeMenu.find(function (menu) {
        return menu.config_coll === menuConfigField;
      });
      return menuConfig;
    },
    menuTabs: function menuTabs(menuConfigField) {
      var menuConfig = this.getMenuConfig(menuConfigField);
      return menuConfig.tabs;
    },
    getTabConfig: function getTabConfig() {
      var menuTabs = this.menuTabs(this.activeMenu);
      var activeTab = this.activeTab;
      var tabConfig = menuTabs.find(function (tab) {
        return tab.tab_code === activeTab;
      });
      return tabConfig;
    },
    tabFields: function tabFields() {
      var tabConfig = this.getTabConfig();
      return tabConfig.fields;
    },
    setActiveMenu: function setActiveMenu(menuConfigField) {
      this.activeMenu = menuConfigField;
      var menuConfig = this.getMenuConfig(menuConfigField);
      this.activeTab = menuConfig.tabs[0]['tab_code'];
    },
    setActiveTab: function setActiveTab(tabCode) {
      this.activeTab = tabCode;
    },
    getText: function getText(textCode) {
      return this.$store.getters.defaultText({
        txt: textCode
      });
    },
    goBack: function goBack(e) {
      e.preventDefault();
      this.$router.back();
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:"main-content skip-navbar columns is-fullheight"},[_c('aside',{staticClass:"column is-3 is-narrow-mobile is-fullheight section"},[(_vm.user.isLoggedin)?_c('p',{staticClass:"menu-label is-hidden-touch"},[_vm._v("\n      PREFERENCES\n    ")]):_vm._e(),_vm._v(" "),(_vm.user.isLoggedin)?_c('ul',{staticClass:"menu-list"},_vm._l((_vm.userMenu),function(uMenu){return _c('li',{key:uMenu.config_coll},[_c('a',{class:("" + (uMenu.config_coll == _vm.activeMenu ? 'is-active' : '')),attrs:{"href":"#"},on:{"click":function($event){_vm.setActiveMenu(uMenu.config_coll)}}},[_c('span',{staticClass:"icon"},[_c('i',{class:uMenu.icon})]),_vm._v(" \n          "+_vm._s(uMenu.title)+"\n        ")])])})):_vm._e(),_vm._v(" "),_c('p',{staticClass:"menu-label is-hidden-touch"},[_vm._v("\n      APP SETTINGS\n    ")]),_vm._v(" "),_c('ul',{staticClass:"menu-list"},_vm._l((_vm.backOfficeMenu),function(menu){return _c('li',{key:menu.config_coll},[_c('a',{class:("" + (menu.config_coll == _vm.activeMenu ? 'is-active' : '')),attrs:{"href":"#"},on:{"click":function($event){_vm.setActiveMenu(menu.config_coll)}}},[_c('span',{staticClass:"icon"},[_c('i',{class:menu.icon})]),_vm._v(" \n          "+_vm._s(menu.title)+"\n        ")])])}))]),_vm._v(" "),_c('div',{staticClass:"container column is-9"},[_c('div',{staticClass:"section"},[_c('div',{staticClass:"tabs is-centered"},[_c('ul',_vm._l((_vm.menuTabs(_vm.activeMenu)),function(tab){return _c('li',{key:tab.tab_code,class:("" + (tab.tab_code == _vm.activeTab ? 'is-active' : ''))},[_c('a',{on:{"click":function($event){_vm.setActiveTab(tab.tab_code)}}},[_vm._v("\n              "+_vm._s(tab.title)+"\n            ")])])}))]),_vm._v(" "),_vm._l((_vm.tabFields()),function(fieldConfig){return _c('BackOfficeForm',{key:fieldConfig.field,attrs:{"configCollection":_vm.activeMenu,"currentTab":_vm.activeTab,"fieldConfig":fieldConfig,"config":_vm.config[_vm.activeMenu]}})})],2)])])}
__vue__options__.staticRenderFns = []

},{"../backoffice/BackOfficeForm.vue":61,"vuex":38}],63:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".extra-footer[data-v-9b71380c]{background-color:#513085;color:#fff;padding-top:10px;padding-bottom:10px}.extra-footer a[data-v-9b71380c]{color:#fff}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _NavBar = _interopRequireDefault(require("../NavBar.vue"));

var _Footer = _interopRequireDefault(require("../Footer.vue"));

var _DynamicBanner = _interopRequireDefault(require("../DynamicBanner.vue"));

var _DynamicStatic = _interopRequireDefault(require("../DynamicStatic.vue"));

var _DynamicStaticRaw = _interopRequireDefault(require("../DynamicStaticRaw.vue"));

var _DynamicStaticTest = _interopRequireDefault(require("../DynamicStaticTest.vue"));

var _DynamicList = _interopRequireDefault(require("../DynamicList.vue"));

var _DynamicMap = _interopRequireDefault(require("../DynamicMap.vue"));

var _DynamicDetail = _interopRequireDefault(require("../DynamicDetail.vue"));

var _LoginScreen = _interopRequireDefault(require("./LoginScreen.vue"));

var _LogoutScreen = _interopRequireDefault(require("./LogoutScreen.vue"));

var _RegisterScreen = _interopRequireDefault(require("./RegisterScreen.vue"));

var _BackOfficeScreen = _interopRequireDefault(require("./BackOfficeScreen.vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = {
  components: {
    NavBar: _NavBar.default,
    Footer: _Footer.default,
    DynamicBanner: _DynamicBanner.default,
    DynamicStatic: _DynamicStatic.default,
    DynamicStaticRaw: _DynamicStaticRaw.default,
    DynamicStaticTest: _DynamicStaticTest.default,
    DynamicList: _DynamicList.default,
    DynamicMap: _DynamicMap.default,
    DynamicDetail: _DynamicDetail.default,
    LoginScreen: _LoginScreen.default,
    LogoutScreen: _LogoutScreen.default,
    RegisterScreen: _RegisterScreen.default,
    BackOfficeScreen: _BackOfficeScreen.default
  },
  props: [],
  data: function data() {
    return {
      localRouteConfig: undefined,
      localEndpointConfig: undefined,
      localFiltersConfig: undefined,
      currentDatasetURI: undefined
    };
  },
  beforeMount: function beforeMount() {
    var DynamicComponents = ['DynamicList', 'DynamicDetail', 'DynamicMap'];
    this.localRouteConfig = this.routeConfig;
    var currentTemplate = this.localRouteConfig.dynamic_template;

    if (DynamicComponents.indexOf(this.routeConfig.dynamic_template) !== -1) {
      var path = this.$router.currentRoute.path;
      this.$store.dispatch('setSearchEndpointConfig', {
        path: path
      });
      this.localEndpointConfig = this.$store.getters.getEndpointConfig;
      this.currentDatasetURI = this.localEndpointConfig.dataset_uri;
      this.localFiltersConfig = this.$store.getters.getEndpointConfigFilters;
      this.$store.dispatch('createDatasetFilters');
      this.$store.commit('setIsMapSearch', this.routeConfig);
    }
  },
  mounted: function mounted() {
    if (!this.routeConfig) {
      this.$router.push({
        name: 'error'
      });
    }
  },
  watch: {
    '$route.fullPath': function $routeFullPath(newPath, oldPath) {
      this.$store.dispatch('setSearchEndpointConfig', {
        path: this.$route.path
      });
      this.localRouteConfig = this.$store.getters.getCurrentRouteConfig(this.$route.path);
      var currentDatasetURI = this.localRouteConfig.dataset_uri;
      this.$store.commit('setIsMapSearch', this.localRouteConfig);

      if (this.localRouteConfig.dynamic_templates !== 'DynamicStatic') {
        this.localEndpointConfig = this.$store.getters.getEndpointConfig;

        if (currentDatasetURI !== this.currentDatasetURI) {
          this.currentDatasetURI = currentDatasetURI;
          this.localFiltersConfig = this.$store.getters.getEndpointConfigFilters;
          this.$store.dispatch('createDatasetFilters');
        }

        if (this.localEndpointConfig) {
          this.$store.dispatch('search');
        }
      } else {
        this.localEndpointConfig = undefined;
        this.localFiltersConfig = undefined;
      }
    }
  },
  computed: _objectSpread({}, (0, _vuex.mapState)({
    user: 'user'
  }), {
    globalConfig: function globalConfig() {
      var globalConfig = this.$store.getters.getGlobalConfig;
      return globalConfig;
    },
    stylesConfig: function stylesConfig() {
      return this.$store.getters.getStylesConfig;
    },
    socialsConfig: function socialsConfig() {
      var socialsConf = this.$store.getters.getSocialsConfig;
      return socialsConf;
    },
    navbarConfig: function navbarConfig() {
      var navbarConf = this.$store.getters.getNavbarConfig;
      return navbarConf;
    },
    footerConfig: function footerConfig() {
      return this.$store.getters.getFooterConfig;
    },
    dynamic_template: function dynamic_template() {
      return this.routeConfig ? this.routeConfig.dynamic_template : undefined;
    },
    routeConfig: function routeConfig() {
      var routeConf = this.$store.getters.getCurrentRouteConfig(this.$router.currentRoute.path);
      return routeConf;
    },
    has_navbar: function has_navbar() {
      return this.routeConfig ? this.routeConfig.has_navbar : undefined;
    },
    has_footer: function has_footer() {
      return this.routeConfig ? this.routeConfig.has_footer : undefined;
    },
    has_credits_footer: function has_credits_footer() {
      return this.footerConfig ? this.footerConfig.has_credits_footer : undefined;
    },
    has_banner: function has_banner() {
      return this.localRouteConfig ? this.localRouteConfig.banner.activated : false;
    },
    getCurrentBanner: function getCurrentBanner() {
      var bannersSet = this.stylesConfig.app_banners.banners_set;
      var routeBannerUri = this.localRouteConfig.banner.banner_uri;
      var resultSet = bannersSet.find(function (b) {
        return b.banner_uri == routeBannerUri;
      });
      return resultSet;
    }
  }),
  methods: {
    goBack: function goBack(e) {
      e.preventDefault();
      this.$router.back();
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[(this.has_navbar)?_c('NavBar',{attrs:{"navbarConfig":this.navbarConfig,"logo":this.globalConfig.app_logo,"brand":this.globalConfig.app_title.content,"appLocales":this.globalConfig.app_languages,"currentDatasetURI":_vm.currentDatasetURI,"localRouteConfig":_vm.localRouteConfig}}):_vm._e(),_vm._v(" "),(this.has_banner)?_c('DynamicBanner',{attrs:{"template_url":this.getCurrentBanner.template_url,"dynamicTemplate":_vm.localRouteConfig.dynamic_template}}):_vm._e(),_vm._v(" "),(_vm.localRouteConfig.dynamic_template == 'DynamicStatic' )?_c('DynamicStatic',{attrs:{"routeConfig":_vm.localRouteConfig}}):_vm._e(),_vm._v(" "),(_vm.localRouteConfig.dynamic_template == 'DynamicStaticTest' )?_c('DynamicStaticTest'):_vm._e(),_vm._v(" "),(_vm.localRouteConfig.dynamic_template == 'DynamicList' )?_c('DynamicList',{attrs:{"routeConfig":_vm.localRouteConfig,"endPointConfig":_vm.localEndpointConfig,"filtersConfig":_vm.localFiltersConfig}}):_vm._e(),_vm._v(" "),(_vm.localRouteConfig.dynamic_template == 'DynamicMap' )?_c('DynamicMap',{attrs:{"routeConfig":_vm.localRouteConfig,"endPointConfig":_vm.localEndpointConfig,"filtersConfig":_vm.localFiltersConfig}}):_vm._e(),_vm._v(" "),(_vm.localRouteConfig.dynamic_template == 'DynamicDetail' )?_c('DynamicDetail',{attrs:{"routeConfig":_vm.localRouteConfig,"endPointConfig":_vm.localEndpointConfig}}):_vm._e(),_vm._v(" "),(_vm.localRouteConfig.dynamic_template == 'Login' )?_c('LoginScreen',{attrs:{"routeConfig":_vm.localRouteConfig,"endPointConfig":_vm.localEndpointConfig}}):_vm._e(),_vm._v(" "),(_vm.localRouteConfig.dynamic_template == 'Logout' )?_c('LogoutScreen',{attrs:{"routeConfig":_vm.localRouteConfig,"endPointConfig":_vm.localEndpointConfig}}):_vm._e(),_vm._v(" "),(_vm.localRouteConfig.dynamic_template == 'Register' )?_c('RegisterScreen',{attrs:{"routeConfig":_vm.localRouteConfig,"endPointConfig":_vm.localEndpointConfig}}):_vm._e(),_vm._v(" "),(_vm.localRouteConfig.dynamic_template == 'BackOffice' )?_c('BackOfficeScreen',{attrs:{"routeConfig":_vm.localRouteConfig,"endPointConfig":_vm.localEndpointConfig}}):_vm._e(),_vm._v(" "),(this.has_footer)?_c('Footer',{attrs:{"footerConfig":this.footerConfig,"appSocials":this.socialsConfig}}):_vm._e(),_vm._v(" "),(this.has_credits_footer)?_c('DynamicStaticRaw',{attrs:{"templateURL":this.footerConfig.credits_footer_url}}):_vm._e(),_vm._v(" "),_c('DynamicStaticRaw',{attrs:{"templateURL":'https://raw.githubusercontent.com/co-demos/structure/master/pages-html/codemos-footer.html'}})],1)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-9b71380c"

},{"../DynamicBanner.vue":42,"../DynamicDetail.vue":43,"../DynamicList.vue":44,"../DynamicMap.vue":45,"../DynamicStatic.vue":47,"../DynamicStaticRaw.vue":48,"../DynamicStaticTest.vue":49,"../Footer.vue":51,"../NavBar.vue":54,"./BackOfficeScreen.vue":62,"./LoginScreen.vue":64,"./LogoutScreen.vue":65,"./RegisterScreen.vue":67,"@nymag/vueify/lib/insert-css":1,"vuex":38}],64:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _FormLogin = _interopRequireDefault(require("../FormLogin.vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  components: {
    FormLogin: _FormLogin.default
  },
  props: ['logo', 'brand'],
  computed: (0, _vuex.mapState)({
    user: 'user',
    jwt: 'jwt'
  }),
  mounted: function mounted() {
    var int = setInterval(function () {
      if (window.pageYOffset < 50) {
        clearInterval(int);
      } else {
        window.scrollTo(0, 0);
      }
    }, 100);
  },
  methods: {
    getText: function getText(textCode) {
      return this.$store.getters.defaultText({
        txt: textCode
      });
    },
    goBack: function goBack(e) {
      e.preventDefault();
      this.$router.back();
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:"hero has-background-white-ter is-fullheight skip-navbar"},[_c('div',{staticClass:"hero-body"},[_c('div',{staticClass:"container has-text-centered"},[_c('div',{staticClass:"columns is-mobile is-centered"},[(!_vm.user.isLoggedin)?_c('div',{staticClass:"column is-6"},[_c('p',{staticClass:"subtitle has-text-grey"},[_vm._v("\n            "+_vm._s(_vm.getText('is_account'))+"\n          ")]),_vm._v(" "),_c('div',{staticClass:"box"},[_c('FormLogin')],1),_vm._v(" "),_c('div',{staticClass:"columns is-mobile is-centered"},[_c('div',{staticClass:"column is-6"},[_c('p',{staticClass:"has-text-grey"},[_c('router-link',{attrs:{"to":'/register'}},[_vm._v("\n                  "+_vm._s(_vm.getText('create_account'))+"\n                ")])],1)]),_vm._v(" "),_c('div',{staticClass:"column is-6"},[_c('p',{staticClass:"has-text-grey"},[_c('router-link',{attrs:{"disabled":"","to":'/forgot-password'}},[_vm._v("\n                  "+_vm._s(_vm.getText('forgot_password'))+"\n                ")])],1)])]),_vm._v(" "),_c('br'),_vm._v(" "),_c('br')]):_vm._e(),_vm._v(" "),(_vm.user.isLoggedin)?_c('div',{staticClass:"column is-6"},[_c('p',{staticClass:"subtitle has-text-grey"},[_vm._v("\n            "+_vm._s(_vm.getText('hello'))+"\n            "+_vm._s(_vm.user.infos.name)+"\n          ")]),_vm._v(" "),_c('div',{staticClass:"box"},[_c('FormLogin')],1)]):_vm._e()])])])])}
__vue__options__.staticRenderFns = []

},{"../FormLogin.vue":52,"vuex":38}],65:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _default = {
  components: {},
  props: ['logo', 'brand'],
  computed: (0, _vuex.mapState)({
    user: 'user'
  }),
  mounted: function mounted() {
    var int = setInterval(function () {
      if (window.pageYOffset < 50) {
        clearInterval(int);
      } else {
        window.scrollTo(0, 0);
      }
    }, 100);
  },
  methods: {
    getText: function getText(textCode) {
      return this.$store.getters.defaultText({
        txt: textCode
      });
    },
    goBack: function goBack(e) {
      e.preventDefault();
      this.$router.back();
    },
    sendLogout: function sendLogout(e) {
      e.preventDefault();
      this.userEmail = '';
      this.userPassword = '';
      this.$store.dispatch('logout');
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:"hero has-background-white-ter is-fullheight skip-navbar"},[_c('div',{staticClass:"hero-body"},[_c('div',{staticClass:"container has-text-centered"},[_c('div',{staticClass:"columns is-mobile is-centered"},[(!_vm.user.isLoggedin)?_c('div',{staticClass:"column is-6"},[_c('h3',{staticClass:"title has-text-grey"},[_vm._v("\n            "+_vm._s(_vm.getText('disconnect_msg'))+"\n          ")]),_vm._v(" "),_c('div',{staticClass:"box"},[_c('router-link',{staticClass:"button is-block is-primary is-fullwidth",attrs:{"type":"submit","to":'/login'}},[_vm._v("\n              "+_vm._s(_vm.getText('reconnect'))+"\n            ")])],1)]):_vm._e(),_vm._v(" "),(_vm.user.isLoggedin)?_c('div',{staticClass:"column is-6"},[_c('h3',{staticClass:"title has-text-grey"},[_vm._v("\n            "+_vm._s(_vm.getText('want_disconnect'))+"\n          ")]),_vm._v(" "),_c('div',{staticClass:"box"},[_c('button',{staticClass:"button is-block is-primary is-fullwidth",attrs:{"type":"submit"},on:{"click":_vm.sendLogout}},[_vm._v("\n              "+_vm._s(_vm.getText('disconnect'))+"\n            ")])])]):_vm._e()])])])])}
__vue__options__.staticRenderFns = []

},{"vuex":38}],66:[function(require,module,exports){
var __vueify_style_dispose__ = require("@nymag/vueify/lib/insert-css").insert(".list .filter-feedback{padding-bottom:0}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _NavBar = _interopRequireDefault(require("../NavBar.vue"));

var _NotFoundError = _interopRequireDefault(require("../NotFoundError.vue"));

var _Footer = _interopRequireDefault(require("../Footer.vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  name: 'NotFoundScreen',
  components: {
    NavBar: _NavBar.default,
    NotFoundError: _NotFoundError.default,
    Footer: _Footer.default
  },
  props: ['logo', 'brand']
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('NavBar',{attrs:{"logo":_vm.logo,"brand":_vm.brand}}),_vm._v(" "),_c('NotFoundError'),_vm._v(" "),_c('Footer')],1)}
__vue__options__.staticRenderFns = []

},{"../Footer.vue":51,"../NavBar.vue":54,"../NotFoundError.vue":56,"@nymag/vueify/lib/insert-css":1}],67:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = require("vuex");

var _FormRegister = _interopRequireDefault(require("../FormRegister.vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  components: {
    FormRegister: _FormRegister.default
  },
  props: [],
  computed: (0, _vuex.mapState)({
    user: 'user'
  }),
  mounted: function mounted() {
    var int = setInterval(function () {
      if (window.pageYOffset < 50) {
        clearInterval(int);
      } else {
        window.scrollTo(0, 0);
      }
    }, 100);
  },
  methods: {
    getText: function getText(textCode) {
      return this.$store.getters.defaultText({
        txt: textCode
      });
    },
    goBack: function goBack(e) {
      e.preventDefault();
      this.$router.back();
    }
  }
};
exports.default = _default;
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:"hero has-background-white-ter is-fullheight skip-navbar"},[_c('div',{staticClass:"hero-body"},[_c('div',{staticClass:"container has-text-centered"},[_c('div',{staticClass:"columns is-mobile is-centered"},[(!_vm.user.isLoggedin)?_c('div',{staticClass:"column is-6"},[_c('p',{staticClass:"subtitle has-text-grey"},[_vm._v("\n            "+_vm._s(_vm.getText('no_account'))+"\n          ")]),_vm._v(" "),_c('div',{staticClass:"box"},[_c('FormRegister')],1),_vm._v(" "),_c('p',{staticClass:"has-text-grey"},[_c('router-link',{attrs:{"to":'/login'}},[_vm._v("\n              "+_vm._s(_vm.getText('connect'))+"\n            ")])],1)]):_vm._e(),_vm._v(" "),(_vm.user.isLoggedin)?_c('div',{staticClass:"column is-6"},[_c('p',{staticClass:"subtitle has-text-grey"},[_vm._v("\n            "+_vm._s(_vm.getText('hello'))+"\n            "+_vm._s(_vm.user.infos.email)+", \n            "),_vm._v("\n            "+_vm._s(_vm.getText('is_registered'))+"\n          ")])]):_vm._e()])])])])}
__vue__options__.staticRenderFns = []

},{"../FormRegister.vue":53,"vuex":38}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.apiConfig = exports.apivizFrontUUID = void 0;
var apivizFrontUUID = Object.freeze({
  apiviz_front_uuid: "c5efafab-1733-4ad1-9eb8-d529bc87c481" // config SONUM
  // apiviz_front_uuid : "f0a482da-28be-4929-a443-f22ecb03ee68" // config APCIS

});
exports.apivizFrontUUID = apivizFrontUUID;
var apiConfig = Object.freeze({
  // APIVIZ backend URL
  // SWITCHES FOR DYNAMIC SETTING
  default: {
    rootURL: 'http://localhost:8100/backend/api'
  },
  default_docker: {
    rootURL: 'http://localhost:8081/backend/api'
  },
  preprod: {
    rootURL: 'https://preprod.sonum-beta.fr/backend/api'
  },
  production: {
    rootURL: 'https://sonum-beta.fr/backend/api'
  }
});
exports.apiConfig = apiConfig;

},{}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VIEW_STAT = exports.VIEW_MAP = exports.VIEW_LIST = void 0;
var VIEW_LIST = 'VIEW_LIST';
exports.VIEW_LIST = VIEW_LIST;
var VIEW_MAP = 'VIEW_MAP';
exports.VIEW_MAP = VIEW_MAP;
var VIEW_STAT = 'VIEW_STAT';
exports.VIEW_STAT = VIEW_STAT;

},{}],70:[function(require,module,exports){
"use strict";

var _vue = _interopRequireDefault(require("vue"));

var _vueRouter = _interopRequireDefault(require("vue-router"));

var _veeValidate = _interopRequireDefault(require("vee-validate"));

var _vuexRouterSync = require("vuex-router-sync");

var _store = _interopRequireDefault(require("./store/store.js"));

var _main = _interopRequireDefault(require("./routes/main.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue.default.use(_veeValidate.default);

_vue.default.use(_vueRouter.default);

// import { getConfigName } from './utils.js';
// because of this call 'beforeEnter' in dynamicRoutesGenerator is triggered first
var router = (0, _main.default)(_store.default);
var unsync = (0, _vuexRouterSync.sync)(_store.default, router); // unsync() to Unsyncs store from router

document.addEventListener('DOMContentLoaded', function () {
  new _vue.default({
    el: document.querySelector('#vue-content'),
    router: router,
    store: _store.default,
    render: function render(h) {
      return h(_vue.default.component('router-view'));
    }
  });
}, {
  once: true
});

},{"./routes/main.js":72,"./store/store.js":76,"vee-validate":32,"vue":34,"vue-router":33,"vuex-router-sync":37}],71:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dynamicRoutesGenerator = void 0;

var _DynamicScreen = _interopRequireDefault(require("../components/screens/DynamicScreen.vue"));

var _NotFoundScreen = _interopRequireDefault(require("../components/screens/NotFoundScreen.vue"));

var _utils = require("../utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import { apiConfig } from '../config/api.js';
// import axios from 'axios';
// import { BRAND_DATA } from '../config/brand.js';
// FUNCTION TO GET THE RUN MODE FROM <HEAD>
// function getConfigName(metaName) {
//   const metas = document.getElementsByTagName('meta');
//   for (let i = 0; i < metas.length; i++) {
//     if (metas[i].getAttribute('name') === metaName) {
//       return metas[i].getAttribute('content');
//     }
//   }
//   return '';
// }
var dynamicRoutesGenerator = function dynamicRoutesGenerator(store) {
  return [{
    name: 'dynamic',
    path: '/*',
    component: _DynamicScreen.default,
    // props(route){
    //   return {
    //       ...BRAND_DATA
    //   }
    // },
    // beforeEach(to, from, next) {
    //   console.log("\n... dynamicRoutesGenerator / beforeEach ... ")
    //   console.log("... dynamicRoutesGenerator / to : ", to)
    // },
    beforeEnter: function beforeEnter(to, from, next) {
      // console.log("\n... dynamicRoutesGenerator / beforeEnter ... ")
      console.log("... process.env.NODE_ENV : \n", process.env.NODE_ENV);

      if (typeof store.apivizFrontUUID === 'undefined') {
        store.commit('setApivizFrontUUID');
      } // SET RUN MODE AND rootUrlBackend FOR SEARCHES


      if (typeof store.state.runMode === 'undefined' || typeof store.state.rootUrlBackend === 'undefined') {
        var configName = (0, _utils.getConfigName)('config_name');
        store.commit('setRunMode', configName);
      } // console.log("... dynamicRoutesGenerator / store.state :  \n ", store.state)
      // console.log("... dynamicRoutesGenerator / store.state.config :  \n ", store.state.config)
      // CHECK IF config.global is undefined yet


      if (typeof store.state.config.global === 'undefined') {
        // console.log("... dynamicRoutesGenerator / store.state.config.global is undefined ...")
        store.dispatch('getConfigAll').then(function () {
          // console.log("... dynamicRoutesGenerator / after getConfigAll ... ");
          var authUrlRoots = store.getters.getEndpointConfigAuthSpecific('auth_root'); // console.log("... dynamicRoutesGenerator / authUrlRoots : ", authUrlRoots);

          var runMode = store.getters.getRunMode;
          var authUrlRoot = authUrlRoots.root_url[runMode]; // console.log("... dynamicRoutesGenerator / authUrlRoot : ", authUrlRoot);

          store.commit('setAuthUrlRoot', authUrlRoot);
          next();
        }).catch(function () {
          console.log('error...');
          next('error');
        });
      } else {
        next();
      }
    }
  }, {
    path: '*',
    name: 'error',
    component: _NotFoundScreen.default // props(route){
    //   return {
    //       ...BRAND_DATA
    //   }
    // },

  }];
};

exports.dynamicRoutesGenerator = dynamicRoutesGenerator;

}).call(this,require('_process'))

},{"../components/screens/DynamicScreen.vue":63,"../components/screens/NotFoundScreen.vue":66,"../utils.js":77,"_process":31}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vue = _interopRequireDefault(require("vue"));

var _vueRouter = _interopRequireDefault(require("vue-router"));

var _dynamicRoutes = require("./dynamicRoutes.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

_vue.default.use(_vueRouter.default); // import { userRoutesGenerator } from './userRoutes.js';


var routerGenerator = function routerGenerator(store) {
  var routes = _toConsumableArray((0, _dynamicRoutes.dynamicRoutesGenerator)(store));

  return new _vueRouter.default({
    mode: 'history',
    routes: routes,
    props: true,
    scrollBehavior: function scrollBehavior(to, from, savedPosition) {
      return savedPosition ? savedPosition : {
        x: 0,
        y: 0
      };
    }
  });
};

var _default = routerGenerator;
exports.default = _default;

},{"./dynamicRoutes.js":71,"vue":34,"vue-router":33}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _axios = _interopRequireDefault(require("axios"));

var _d3Dsv = require("d3-dsv");

var _utils = require("../utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import {apiConfig} from '../config/api.js';
var _default = {
  // FOR FILTERS
  createDatasetFilters: function createDatasetFilters(_ref) {
    var state = _ref.state,
        getters = _ref.getters,
        commit = _ref.commit;
    // console.log("\n// createDatasetFilters / state : ", state )
    var currentFiltersConfig = getters.getEndpointConfigFilters; // console.log("// createDatasetFilters / currentFiltersConfig : ", currentFiltersConfig)

    if (currentFiltersConfig && currentFiltersConfig.filter_options) {
      var filterDescriptions = currentFiltersConfig.filter_options;
      commit('setFilterDescriptions', filterDescriptions);
      commit('clearAllFilters');
    }
  },
  // FOR QUERY SEARCH FILTERS
  toggleFilter: function toggleFilter(_ref2, _ref3) {
    var state = _ref2.state,
        commit = _ref2.commit,
        dispatch = _ref2.dispatch,
        getters = _ref2.getters;
    var filter = _ref3.filter,
        value = _ref3.value;
    // console.log("\n// toggleFilter ..." )
    var selectedFilters = new Map(getters.getSelectedFilters); // console.log("// toggleFilter / selectedFilters : ", selectedFilters);

    var selectedValues = selectedFilters.get(filter);
    if (selectedValues.has(value)) selectedValues.delete(value);else selectedValues.add(value);
    commit('setSelectedFilters', {
      selectedFilters: selectedFilters
    });
    dispatch('search');
  },
  emptyOneFilter: function emptyOneFilter(_ref4, _ref5) {
    var state = _ref4.state,
        commit = _ref4.commit,
        dispatch = _ref4.dispatch,
        getters = _ref4.getters;
    var filter = _ref5.filter;
    // console.log("\n// emptyOneFilter ..." )
    var selectedFilters = new Map(getters.getSelectedFilters);
    selectedFilters.set(filter, new Set());
    commit('setSelectedFilters', {
      selectedFilters: selectedFilters
    });
    dispatch('search');
  },
  clearAllFilters: function clearAllFilters(_ref6) {
    var commit = _ref6.commit,
        dispatch = _ref6.dispatch;
    // console.log("\n// clearAllFilters ..." )
    commit('clearAllFilters');
    dispatch('search');
  },
  // FOR QUERY SEARCH TEXT
  searchedTextChanged: function searchedTextChanged(_ref7, _ref8) {
    var commit = _ref7.commit,
        dispatch = _ref7.dispatch;
    var searchedText = _ref8.searchedText;
    // console.log("\n// searchedTextChanged ..." )
    commit('setSearchedText', {
      searchedText: searchedText
    });
    dispatch('search');
  },
  // MAIN SEARCH ACTION
  search: function search(_ref9) {
    var state = _ref9.state,
        commit = _ref9.commit,
        dispatch = _ref9.dispatch,
        getters = _ref9.getters;
    // console.log("\n// search / main action to query endpoint..." )
    var search = state.search; // console.log("// search / search : ", search )

    var selectedFilters = (0, _utils.createSelectedFiltersForSearch)(getters.getSelectedFilters); // console.log('selectedFilters',selectedFilters);
    // abort previous search if any

    if (search.answer.pendingAbort) {
      search.answer.pendingAbort.abort();
    } //create the endpoints
    // let root_url = (state.search && state.search.endpoint) ? state.search.endpoint.root_url : dispatch('getConfigType',{type:'endpoints',configTypeEndpoint:'endpoints'})
    // let endpoint = searchEnpointCreator({
    //   baseUrl:root_url,
    //   // query from main input in search bar
    //   search: search.question.query,
    //   // tags / filters
    //   search_filters:selectedFilters,
    //   // pagination
    //   page:1,
    //   per_page:100,
    //   // here for map requests
    //   map_list : search.question.for_map,
    //   as_latlng : search.question.for_map
    // })
    // console.log("-- search / endpoint : \n", endpoint )
    // ENDPOINT GENERATOR


    var endpointGenerated = (0, _utils.searchEndpointGenerator)({
      endpointConfig: state.search.endpoint,
      questionParams: state.search.question,
      selectedFilters: selectedFilters
    }); // console.log("-- search / endpointBis : \n", endpointGenerated )
    // perform search --> !!! only request map search if map search results empty in store !!! 
    // const searchPendingAbort = searchItems(endpoint)

    var searchPendingAbort = (0, _utils.searchItems)(endpointGenerated);
    commit('setSearchPending', {
      pendingAbort: searchPendingAbort
    });
    searchPendingAbort.promise.then(function (_ref10) {
      var projects = _ref10.projects,
          total = _ref10.total;
      // console.log("-- search / total : \n", total )
      // console.log("-- search / projects : \n", projects )
      // if search is for map either fill resultMap if empty or do nothing
      commit('setSearchResult', {
        result: {
          projects: projects,
          total: total
        }
      }); // commit ('setSearchResultMap', {resultMap: {projects, total}})
    }).catch(function (error) {
      // don't report aborted fetch as errors
      if (error.name !== 'AbortError') commit('setSearchError', {
        error: error
      });
    });
  },
  ////////////////////////////////////////////////
  // TO COMMENT ABSOLUTLY -> data must be pre-geocoded when arriving as response
  findProjectsGeolocs: function findProjectsGeolocs(_ref11, projects) {
    var commit = _ref11.commit;
    var projectWithValidAddress = projects.filter(function (p) {
      return p['address'];
    });
    var addresses = projectWithValidAddress.map(function (p) {
      return p['address'].replace(/[^(\w|\s)]/g, '').slice(0, 200);
    });
    var adressesCSV = 'adresse\n' + addresses.join('\n');
    var adresseCSVBANBody = new FormData();
    adresseCSVBANBody.append('data', new File([adressesCSV], 'adresses.csv'));
    return fetch('https://api-adresse.data.gouv.fr/search/csv/', {
      method: 'POST',
      body: adresseCSVBANBody
    }).then(function (r) {
      return r.text();
    }).then(function (geolocsTxt) {
      var geolocs = (0, _d3Dsv.csvParse)(geolocsTxt);
      var geolocByProjectId = new Map();
      projectWithValidAddress.forEach(function (_ref12, i) {
        var id = _ref12.id;
        var _geolocs$i = geolocs[i],
            latitude = _geolocs$i.latitude,
            longitude = _geolocs$i.longitude;
        geolocByProjectId.set(id, Number.isFinite(parseFloat(latitude)) && Number.isFinite(parseFloat(longitude)) ? {
          latitude: parseFloat(latitude),
          longitude: parseFloat(longitude)
        } : false);
      });
      projects.forEach(function (_ref13) {
        var id = _ref13.id;

        if (!geolocByProjectId.has(id)) {
          geolocByProjectId.set(id, false);
        }
      });
      commit('addGeolocs', {
        geolocByProjectId: geolocByProjectId
      });
    });
  },
  /////////////////////////:
  // FOR CONFIGs
  getConfigAll: function getConfigAll(_ref14) {
    var dispatch = _ref14.dispatch;
    var arr = [];
    arr.push(dispatch('getConfigType', {
      type: 'global',
      configTypeEndpoint: 'global',
      args: ''
    }));
    arr.push(dispatch('getConfigType', {
      type: 'styles',
      configTypeEndpoint: 'styles',
      args: ''
    }));
    arr.push(dispatch('getConfigType', {
      type: 'socials',
      configTypeEndpoint: 'socials',
      args: ''
    }));
    arr.push(dispatch('getConfigType', {
      type: 'footer',
      configTypeEndpoint: 'footer',
      args: ''
    }));
    arr.push(dispatch('getConfigType', {
      type: 'navbar',
      configTypeEndpoint: 'navbar',
      args: ''
    }));
    arr.push(dispatch('getConfigType', {
      type: 'routes',
      configTypeEndpoint: 'routes',
      args: '&as_list=true'
    }));
    arr.push(dispatch('getConfigType', {
      type: 'tabs',
      configTypeEndpoint: 'tabs',
      args: '&as_list=true'
    }));
    arr.push(dispatch('getConfigType', {
      type: 'endpoints',
      configTypeEndpoint: 'endpoints',
      args: '&as_list=true'
    }));
    return Promise.all(arr);
  },
  getConfigType: function getConfigType(_ref15, _ref16) {
    var commit = _ref15.commit,
        getters = _ref15.getters;
    var type = _ref16.type,
        configTypeEndpoint = _ref16.configTypeEndpoint,
        args = _ref16.args;
    var rootURLbackend = getters.getRootUrlBackend;
    var apivizFrontUUID = getters.getApivizFrontUUID;
    return _axios.default.get(rootURLbackend + '/config/' + configTypeEndpoint + "?uuid=" + apivizFrontUUID + args) // .get(apiConfig.rootURL+'/config/'+configTypeEndpoint)
    .then(function (response) {
      // console.log("type : ", type," / response : ", response)
      var app_config = response && response.data && response.data.app_config ? response.data.app_config : undefined;
      commit('setConfig', {
        type: type,
        result: app_config
      });
      return app_config;
    }).catch(function (err) {
      return console.log('there was an error trying to fetch some configuration file', err);
    });
  },
  // TO VARIABILIZE
  setSearchConfigDisplay: function setSearchConfigDisplay(_ref17) {
    var commit = _ref17.commit;
    // here this function will probably change when this may be inherited from the configuration files
    var defaultDisplay = {
      columnCount: 4,
      defaultShowCount: 50,
      moreProjectOnScrollCount: 20,
      scrollBeforeBottomTrigger: 500
    };
    commit('setSearchConfig', {
      type: 'display',
      result: defaultDisplay
    });
  },
  // USER-RELATED
  saveLoginInfos: function saveLoginInfos(_ref18, _ref19) {
    var commit = _ref18.commit,
        getters = _ref18.getters;
    var APIresponse = _ref19.APIresponse;
    var authConfig = getters.getConfirmTokenConfig;
    console.log("\n// authConfig : \n", authConfig);
    var accessTokenPath = authConfig.resp_fields.access_token.path;
    var refreshTokenPath = authConfig.resp_fields.refresh_token.path;
    var userRolePath = authConfig.resp_fields.user_role.path;
    var userIdPath = authConfig.resp_fields.user_id.path;
    var userNamePath = authConfig.resp_fields.user_name.path;
    var userSurnamePath = authConfig.resp_fields.user_surname.path;
    var userPseudoPath = authConfig.resp_fields.user_pseudo.path;
    var userEmailPath = authConfig.resp_fields.user_email.path;
    var r = APIresponse;
    console.log("\n// r = APIresponse : \n", r); // let tokens = (r && r.data && r.data.data && r.data.data.tokens) ? r.data.data.tokens : undefined

    var tokens = r && r.data ? {
      access_token: (0, _utils.getObjectDataFromPath)(r.data, accessTokenPath),
      refresh_token: (0, _utils.getObjectDataFromPath)(r.data, refreshTokenPath)
    } : undefined; // console.log('tokens : \n', tokens)
    // let infos = (r && r.data && r.data.data && r.data.data.infos) ? r.data.data.infos : undefined

    var infos = r && r.data ? {
      name: (0, _utils.getObjectDataFromPath)(r.data, userNamePath),
      surname: (0, _utils.getObjectDataFromPath)(r.data, userSurnamePath),
      email: (0, _utils.getObjectDataFromPath)(r.data, userEmailPath),
      id: (0, _utils.getObjectDataFromPath)(r.data, userIdPath),
      pseudo: (0, _utils.getObjectDataFromPath)(r.data, userPseudoPath)
    } : undefined; // console.log('infos : \n', infos)
    // let role = (r && r.data && r.data.data && r.data.data.auth && r.data.data.auth.role) ? r.data.data.auth.role : undefined

    var role = r && r.data ? (0, _utils.getObjectDataFromPath)(r.data, userRolePath) : undefined;
    commit('setTokens', {
      tokens: tokens
    });
    commit('setInfos', {
      infos: infos
    });
    commit('setRole', {
      role: role
    }); // test user role

    console.log('then... getCheckUserRole - guest : ', getters.getCheckUserRole('guest'));
    console.log('then... getCheckUserRole - admin : ', getters.getCheckUserRole('admin'));
  },
  logout: function logout(_ref20) {
    var commit = _ref20.commit;
    commit('setTokens', {});
    commit('setInfos', {});
    commit('setRole', {});
  },
  // FOR ENDPOINT CONFIG
  setSearchEndpointConfig: function setSearchEndpointConfig(_ref21, _ref22) {
    var commit = _ref21.commit,
        getters = _ref21.getters,
        state = _ref21.state;
    var path = _ref22.path;
    var routeConfig = getters.getCurrentRouteConfig(path);
    commit('setSearchParam', {
      type: 'currentRouteConfig',
      result: routeConfig
    });
    commit('setSearchParam', {
      type: 'dataset_uri',
      result: routeConfig.dataset_uri
    });
    commit('setSearchParam', {
      type: 'endpoint_type',
      result: routeConfig.endpoint_type
    });
    var endpointConfig = getters.getEndpointConfig;
    commit('setSearchParam', {
      type: 'endpoint',
      result: endpointConfig
    });
  }
};
exports.default = _default;

},{"../utils.js":77,"axios":2,"d3-dsv":27}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("../utils");

var getSearchConfigColumnCount = function getSearchConfigColumnCount(state) {
  return state.search.config.display.columnCount;
};

var getSearchConfigDefaultShowCount = function getSearchConfigDefaultShowCount(state) {
  return state.search.config.display.defaultShowCount;
};

var getSearchConfigMoreProjectOnScrollCount = function getSearchConfigMoreProjectOnScrollCount(state) {
  return state.search.config.display.moreProjectOnScrollCount;
};

var getSearchConfigScrollBeforeBottomTrigger = function getSearchConfigScrollBeforeBottomTrigger(state) {
  return state.search.config.display.scrollBeforeBottomTrigger;
}; // FOR TRANSLATIONS
// - - - - - - - - - - - - - - - //


var getTranslation = function getTranslation(state) {
  return function (textsData) {
    var locale = state.locale;
    var textField = 'text'; // console.log("textsData : ", textsData)

    return (0, _utils.textFromLocale)(textsData.texts, locale, textField);
  };
}; // UX GETTERS


var getNavbarVisibility = function getNavbarVisibility(state) {
  return state.showNav;
}; // GLOBAL APP CONFIG GETTERS
// - - - - - - - - - - - - - - - //


var getApivizFrontUUID = function getApivizFrontUUID(state) {
  console.log("...I'm you, I dee... ", state.apivizFrontUUID);
  return state.apivizFrontUUID;
};

var getRunMode = function getRunMode(state) {
  return state.runMode;
};

var getRootUrlBackend = function getRootUrlBackend(state) {
  console.log("...I'm roooot... ", state.rootUrlBackend);
  return state.rootUrlBackend;
};

var getRootUrlAuth = function getRootUrlAuth(state) {
  return state.rootUrlAuth;
}; // const getRootUrlUser = state => {
//   return state.rootUrlUser
// }


var getGlobalConfig = function getGlobalConfig(state) {
  // console.log("state.config : \n", state.config )
  if (!state.config || !state.config.global) {// console.log('getGlobalConfig - some condition not respected');       return undefined;
  }

  return state.config.global;
};

var getStylesConfig = function getStylesConfig(state) {
  // console.log("state.config : \n", state.config )
  if (!state.config || !state.config.styles) {// console.log('getStylesConfig - some condition not respected');       return undefined;
  }

  return state.config.styles;
};

var getSocialsConfig = function getSocialsConfig(state) {
  // console.log("state.config : \n", state.config )
  // if (!state.config
  //   || !state.config.socials
  //   ) {
  //     console.log('getSocialsConfig - some condition not respected');       return undefined;
  // }
  return state.config.socials;
};

var getNavbarConfig = function getNavbarConfig(state) {
  // console.log("state.config : \n", state.config )
  if (!state.config || !state.config.navbar) {// console.log('getNavbarConfig - some condition not respected');       return undefined;
  }

  return state.config.navbar.app_navbar;
};

var getFooterConfig = function getFooterConfig(state) {
  // console.log("state.config : \n", state.config )
  if (!state.config || !state.config.footer) {// console.log('getFooterConfig - some condition not respected');       return undefined;
  }

  return state.config.footer.app_footer;
}; // ROUTE CONFIG GETTERS
// - - - - - - - - - - - - - - - //


var getCurrentRouteConfig = function getCurrentRouteConfig(state) {
  return function (currentRoute) {
    // console.log('\n ++ getCurrentRouteConfig / currentRoute : \n', currentRoute)
    // console.log(' ++ getCurrentRouteConfig / state.config.routes : \n', state.config.routes)
    try {
      return state.config.routes.find(function (r) {
        return r.urls.indexOf(currentRoute) !== -1;
      });
    } catch (e) {
      console.log('err', e);
      return undefined;
    }
  };
};

var getRouteConfigListForDataset = function getRouteConfigListForDataset(state) {
  return state.config.routes.find(function (r) {
    return r.endpoint_type === 'list' && r.dataset_uri === state.search.dataset_uri;
  });
};

var getRouteConfigMapForDataset = function getRouteConfigMapForDataset(state) {
  return state.config.routes.find(function (r) {
    return r.endpoint_type === 'map' && r.dataset_uri === state.search.dataset_uri;
  });
};

var getRouteConfigStatForDataset = function getRouteConfigStatForDataset(state) {
  return state.config.routes.find(function (r) {
    return r.endpoint_type === 'stat' && r.dataset_uri === state.search.dataset_uri;
  });
};

var getRouteConfigDefaultDatasetImages = function getRouteConfigDefaultDatasetImages(state) {
  return state.config.styles.app_search_default_images_sets.images_sets.find(function (r) {
    return r.dataset_uri === state.search.dataset_uri;
  });
};

var getSearchDatasetURI = function getSearchDatasetURI(state) {
  return state.search.dataset_uri;
}; // DEFAULT TEXTS GETTERS
// - - - - - - - - - - - - - - - //


var defaultText = function defaultText(state) {
  return function (field) {
    // default texts fields are :
    // 'reinit_filters', 'no_abstract', 'no_address'
    // 'source', 'no_info'
    var f = field.txt;
    var noAbstractDict = state.config.global.app_basic_dict[f];
    var text = noAbstractDict.find(function (t) {
      return t.locale == state.locale;
    });
    return text.text;
  };
}; // ITEMS CONFIG GETTERS
// - - - - - - - - - - - - - - - //


var getProjectConfig = function getProjectConfig(state) {
  return function (position) {
    try {
      return state.search.currentRouteConfig.contents_fields.find(function (f) {
        return f.position === position;
      });
    } catch (e) {
      console.log('err', e);
      return undefined;
    }
  };
};

var getProjectConfigUniform = function getProjectConfigUniform(state, getters) {
  return function (itemData) {
    // console.log(" ++ getProjectConfigUniform - itemData : ", itemData)
    var res = {};
    var infoTypes = ['id', 'title', 'image', 'address', 'tags'];
    infoTypes.forEach(function (infoType) {
      var fieldObj = getters.getProjectConfig('block_' + infoType);
      res[infoType] = fieldObj && fieldObj.field ? itemData[fieldObj.field] : undefined;
    });
    res.image = getters.getImgUrl(res);
    res.fullItem = itemData;
    return res;
  };
};

var getResults = function getResults(state) {
  return state.search.answer.result && state.search.answer.result.projects;
};

var getGeoResults = function getGeoResults(state, getters) {
  var allResults = getters.getResults; // console.log(" ++ getGeoResults / allResults : ", allResults)

  if (typeof allResults !== 'undefined') {
    var filtered = allResults.filter(function (i) {
      return !i.lat && !i.lon;
    }); // console.log(" ++ getGeoResults / filtered : ", filtered)

    return filtered;
  } else {
    return undefined;
  }
}; // IMAGES CONFIG GETTERS
// - - - - - - - - - - - - - - - //


var getImgUrl = function getImgUrl(state, getters) {
  return function (obj) {
    // console.log("getImgUrl - obj : ", obj)
    var image = obj.image;

    if (!image) {
      var images_set = undefined;

      if (state.search.dataset_uri && state.config.styles && state.config.styles.app_search_default_images_sets && state.config.styles.app_search_default_images_sets.images_sets) {
        var d = state.config.styles.app_search_default_images_sets.images_sets.find(function (d) {
          return d.dataset_uri === state.search.dataset_uri;
        });
        images_set = d ? d.images_set : undefined;
      }

      if (images_set && images_set.length > 0) {
        var _textureCount = images_set.length + 1;

        var _id = obj.id ? parseInt(obj.id.substr(obj.id.length - 6), 16) % _textureCount : 111111111111111111;

        var reste = _id % images_set.length + 1;
        var imageObj = images_set.find(function (i) {
          return i.dft_text === 'img_' + reste;
        });
        image = imageObj.src_image;
      } else {
        var random = Math.floor(Math.random() * (7 - 1) + 1);
        image = "/static/illustrations/textures/medium_fiche_".concat(parseInt(id.substr(id.length - 6), 16) % textureCount + 1, ".png");
      }
    }

    return image;
  };
};

var getImageUrl = function getImageUrl(state, getters) {
  return function (obj) {
    // console.log("getImageUrl - obj : ", obj)
    var item = obj.item;
    console.log("getImageUrl - item : ", item);
    var position = obj.position;
    console.log("getImageUrl - position : ", position);
    var defaultImages = getters.getRouteConfigDefaultDatasetImages; // console.log("getImageUrl - defaultImages : ", defaultImages)

    console.log("getImageUrl - state.search.currentRouteConfig : ", state.search.currentRouteConfig);
    var routeContentImagesFields = state.search.currentRouteConfig.images_fields; // console.log("getImageUrl - routeContentImagesFields : ", routeContentImagesFields)

    var fieldToGet = routeContentImagesFields[position];
    var fieldImage = fieldToGet.field; // console.log("getImageUrl - fieldImage : ", fieldImage)

    var image = item[fieldImage];
    console.log("getImageUrl - image (A) : ", image);

    if (!image) {
      var d = defaultImages;
      var images_set = d ? d.images_set : undefined;

      if (images_set && images_set.length > 0) {
        var _textureCount2 = images_set.length + 1;

        var _id2 = item.id ? parseInt(item.id.substr(item.id.length - 6), 16) % _textureCount2 : 111111111111111111;

        var tail = _id2 % images_set.length + 1;
        var imageObj = images_set.find(function (i) {
          return i.dft_text === 'img_' + tail;
        });
        image = imageObj.src_image;
      } else {
        image = "/static/illustrations/textures/medium_fiche_".concat(parseInt(id.substr(id.length - 6), 16) % textureCount + 1, ".png");
      }
    }

    console.log("getImageUrl - image (B) : ", image);
    return image;
  };
}; // - - - - - - - - - - - - - - - //
// BROADER CONFIG GETTERS
// - - - - - - - - - - - - - - - //
// USER-RELATED / BACKOFFICE GETTERS
// - - - - - - - - - - - - - - - //


var getConfirmTokenConfig = function getConfirmTokenConfig(state) {
  return state.config.endpoints.find(function (r) {
    return r.field === 'app_data_API_user_auth';
  });
};

var getCheckUserRole = function getCheckUserRole(state, getters) {
  return function (roleToCheck) {
    var user = state.user;
    var userRole = user.role; // role from auth confirm access response

    var authConfig = getters.getConfirmTokenConfig;
    var roleUserToCheck = authConfig.roles[roleToCheck]['resp_role']; // role corresponding to roleToCheck

    return roleUserToCheck === userRole;
  };
};

var getEndpointConfigAuthUsers = function getEndpointConfigAuthUsers(state) {
  // console.log("getEndpointConfigAuthUsers...")
  return state.config.endpoints.filter(function (r) {
    return r.data_type === "user";
  });
};

var getEndpointConfigAuthSpecific = function getEndpointConfigAuthSpecific(state, getters) {
  return function (endpointType) {
    // console.log("getEndpointConfigAuthSpecific / endpointType : ", endpointType)
    var allAuthEndpoints = getters.getEndpointConfigAuthUsers; // console.log("getEndpointConfigAuthSpecific / allAuthEndpoints", allAuthEndpoints)

    return allAuthEndpoints.find(function (r) {
      return r.endpoint_type === endpointType;
    });
  };
};

var getEndpointConfig = function getEndpointConfig(state) {
  return state.config.endpoints.find(function (r) {
    return r.endpoint_type === state.search.endpoint_type && r.dataset_uri === state.search.dataset_uri;
  });
};

var getEndpointConfigFilters = function getEndpointConfigFilters(state) {
  // console.log("getEndpointConfigFilters - state.config.endpoints : \n", state.config.endpoints)
  return state.config.endpoints.find(function (r) {
    return r.endpoint_type === 'filters' && r.dataset_uri === state.search.dataset_uri;
  });
};

var getEndpointConfigList = function getEndpointConfigList(state) {
  // console.log("getEndpointConfigList - state.config.endpoints : \n", state.config.endpoints)
  return state.config.endpoints.find(function (r) {
    return r.endpoint_type === 'list' && r.dataset_uri === state.search.dataset_uri;
  });
};

var getEndpointConfigMap = function getEndpointConfigMap(state) {
  // console.log("getEndpointConfigMap - state.config.endpoints : \n", state.config.endpoints)
  return state.config.endpoints.find(function (r) {
    return r.endpoint_type === 'map' && r.dataset_uri === state.search.dataset_uri;
  });
};

var getEndpointConfigDetail = function getEndpointConfigDetail(state) {
  // console.log("getEndpointConfigDetail - state.config.endpoints : \n", state.config.endpoints)
  return state.config.endpoints.find(function (r) {
    return r.endpoint_type === 'detail' && r.dataset_uri === state.search.dataset_uri;
  });
};

var getEndpointConfigStat = function getEndpointConfigStat(state) {
  // console.log("getEndpointConfigStat - state.config.endpoints : \n", state.config.endpoints)
  return state.config.endpoints.find(function (r) {
    return r.endpoint_type === 'stat' && r.dataset_uri === state.search.dataset_uri;
  });
};

var getSelectedFilters = function getSelectedFilters(state) {
  return state.search.question.selectedFilters;
}; // - - - - - - - - - - - - - - - //
// FINALLY EXPORT GETTERS
// - - - - - - - - - - - - - - - //


var _default = {
  getTranslation: getTranslation,
  getNavbarVisibility: getNavbarVisibility,
  getApivizFrontUUID: getApivizFrontUUID,
  getRunMode: getRunMode,
  getRootUrlBackend: getRootUrlBackend,
  getRootUrlAuth: getRootUrlAuth,
  // getRootUrlUser,
  getSearchConfigColumnCount: getSearchConfigColumnCount,
  getSearchConfigDefaultShowCount: getSearchConfigDefaultShowCount,
  getSearchConfigMoreProjectOnScrollCount: getSearchConfigMoreProjectOnScrollCount,
  getSearchConfigScrollBeforeBottomTrigger: getSearchConfigScrollBeforeBottomTrigger,
  getGlobalConfig: getGlobalConfig,
  getStylesConfig: getStylesConfig,
  getSocialsConfig: getSocialsConfig,
  getNavbarConfig: getNavbarConfig,
  getFooterConfig: getFooterConfig,
  getEndpointConfig: getEndpointConfig,
  getCurrentRouteConfig: getCurrentRouteConfig,
  getRouteConfigListForDataset: getRouteConfigListForDataset,
  getRouteConfigMapForDataset: getRouteConfigMapForDataset,
  getRouteConfigStatForDataset: getRouteConfigStatForDataset,
  getRouteConfigDefaultDatasetImages: getRouteConfigDefaultDatasetImages,
  getSearchDatasetURI: getSearchDatasetURI,
  getConfirmTokenConfig: getConfirmTokenConfig,
  getCheckUserRole: getCheckUserRole,
  getEndpointConfigAuthUsers: getEndpointConfigAuthUsers,
  getEndpointConfigAuthSpecific: getEndpointConfigAuthSpecific,
  getEndpointConfigFilters: getEndpointConfigFilters,
  getEndpointConfigList: getEndpointConfigList,
  getEndpointConfigMap: getEndpointConfigMap,
  getEndpointConfigDetail: getEndpointConfigDetail,
  getEndpointConfigStat: getEndpointConfigStat,
  defaultText: defaultText,
  getResults: getResults,
  getGeoResults: getGeoResults,
  getProjectConfig: getProjectConfig,
  getProjectConfigUniform: getProjectConfigUniform,
  getImgUrl: getImgUrl,
  getImageUrl: getImageUrl,
  getSelectedFilters: getSelectedFilters
};
exports.default = _default;

},{"../utils":77}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _api = require("../config/api.js");

var _utils = require("../utils");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var _default = {
  // APP UUID, APP MODE, AND ROOT URL BACKEND
  setApivizFrontUUID: function setApivizFrontUUID(state) {
    // console.log("\n=== setApivizFrontUUID / apivizFrontUUID : ", apivizFrontUUID )
    state.apivizFrontUUID = _api.apivizFrontUUID.apiviz_front_uuid;
  },
  setRunMode: function setRunMode(state, runMode) {
    // console.log("\n=== setRunMode / runMode : ", runMode )
    state.runMode = runMode; // console.log("=== setRunMode / apiConfig : \n ", apiConfig )

    var roots = _api.apiConfig[runMode];
    state.rootUrlBackend = roots.rootURL; // TO DO --> check in config which authURL and 
    // state.rootUrlAuth = roots.authURL
    // state.rootUrlUser = roots.userURL
  },
  setAuthUrlRoot: function setAuthUrlRoot(state, urlRoot) {
    state.rootUrlAuth = urlRoot;
  },
  // UX OPTIONS-RELATED
  disableBanners: function disableBanners(state) {
    state.bannerVisible = false;
  },
  switchNavbarMenu: function switchNavbarMenu(state) {
    state.showNav = !state.showNav;
  },
  // FILTERS-RELATED
  setDatasetFilters: function setDatasetFilters(state, datasetFilter) {
    // console.log("\n=== setDatasetFilters / datasetFilter : ", datasetFilter )
    var filterOptions = datasetFilter.filter_options; // console.log("=== setDatasetFilters / filterOptions : ", filterOptions )

    state.datasetFilters = filterOptions;
  },
  // SEARCH-RELATED
  setDatasetURI: function setDatasetURI(state, datasetURI) {
    state.search.dataset_uri = datasetURI;
  },
  setIsMapSearch: function setIsMapSearch(state, routeConfig) {
    // console.log("\n=== setIsMapSearch / routeConfig : ", routeConfig )
    state.search.question.forMap = routeConfig.dynamic_template === 'DynamicMap' ? true : false; // console.log("=== setIsMapSearch / state.search : ", state.search )
  },
  setSearchedText: function setSearchedText(state, _ref) {
    var searchedText = _ref.searchedText;
    state.search.question.query = searchedText;
  },
  setSelectedFilters: function setSelectedFilters(state, _ref2) {
    var selectedFilters = _ref2.selectedFilters;
    // trigger re-render
    state.search.question.selectedFilters = new Map(selectedFilters);
  },
  setFilterDescriptions: function setFilterDescriptions(state, filterDescriptions) {
    state.filterDescriptions = filterDescriptions;
  },
  emptyOneFilter: function emptyOneFilter(state, _ref3) {
    var filter = _ref3.filter;
    state.search.question.selectedFilters.set(filter, new Set()); // trigger re-render

    state.search.question.selectedFilters = new Map(state.search.question.selectedFilters);
  },
  clearAllFilters: function clearAllFilters(state) {
    state.search.question.selectedFilters = (0, _utils.makeEmptySelectedFilters)(state.filterDescriptions);
  },
  setSearchParam: function setSearchParam(state, _ref4) {
    var type = _ref4.type,
        result = _ref4.result;
    // console.log("\n== setSearchParam / state.search : ", state.search)
    // console.log("== setSearchParam / type : ", type)
    // console.log("== setSearchParam / result : ", result)
    state.search[type] = result;
  },
  setSearchConfig: function setSearchConfig(state, _ref5) {
    var type = _ref5.type,
        result = _ref5.result;
    state.search.config[type] = result;
  },
  // RESULTS-RELATED
  setSearchResult: function setSearchResult(state, _ref6) {
    var result = _ref6.result;
    // console.log("== setSearchResult / result : ", result)
    state.search.answer = {
      pendingAbort: undefined,
      result: result,
      // resultMap: undefined,
      error: undefined
    };
  },
  // setSearchResultMap(state, {resultMap}){
  //   console.log("== setSearchResultMap / resultMap : ", resultMap)
  //   state.search.answer = {
  //     pendingAbort: undefined,
  //     result:undefined,
  //     // resultMap,
  //     error: undefined
  //   }
  // },
  setSearchPending: function setSearchPending(state, _ref7) {
    var pendingAbort = _ref7.pendingAbort;
    state.search.answer = {
      pendingAbort: pendingAbort,
      result: undefined,
      // resultMap: undefined,
      error: undefined
    };
  },
  setSearchError: function setSearchError(state, _ref8) {
    var error = _ref8.error;
    console.error('search error', error);
    state.search.answer = {
      pendingAbort: undefined,
      result: undefined,
      // resultMap: undefined,
      error: error
    };
  },
  setDisplayedProject: function setDisplayedProject(state, _ref9) {
    var project = _ref9.project;
    state.displayedProject = project;
  },
  // GEOLOC
  addGeolocs: function addGeolocs(state, _ref10) {
    var geolocByProjectId = _ref10.geolocByProjectId;
    state.geolocByProjectId = new Map([].concat(_toConsumableArray(state.geolocByProjectId), _toConsumableArray(geolocByProjectId)));
  },
  // CONFIG
  setConfig: function setConfig(state, _ref11) {
    var type = _ref11.type,
        result = _ref11.result;
    // console.log("result : ", result)
    state.config[type] = result;
  },
  // USER-RELATED
  setTokens: function setTokens(state, _ref12) {
    var tokens = _ref12.tokens;
    console.log('tokens : ', tokens); // state.jwt = (tokens && tokens.access_token && tokens.refresh_token) ? tokens : undefined

    state.jwt = tokens;
    console.log('state.jwt : ', state.jwt);
  },
  setInfos: function setInfos(state, _ref13) {
    var infos = _ref13.infos;
    state.user.infos = infos && infos.email ? infos : undefined;
    state.user.isLoggedin = infos && infos.email ? true : false;
  },
  setRole: function setRole(state, _ref14) {
    var role = _ref14.role;
    state.user.role = typeof role === 'string' ? role : undefined;
  }
};
exports.default = _default;

},{"../config/api.js":68,"../utils":77}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vue = _interopRequireDefault(require("vue"));

var _vuex = _interopRequireDefault(require("vuex"));

var _axios = _interopRequireDefault(require("axios"));

var _getters = _interopRequireDefault(require("./getters"));

var _actions = _interopRequireDefault(require("./actions"));

var _mutations = _interopRequireDefault(require("./mutations"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue.default.use(_vuex.default); // MAIN STORE


var storeGenerator = new _vuex.default.Store({
  strict: true,
  state: {
    // APIVIZ FRONTEND UUID
    apivizFrontUUID: undefined,
    // APP MODE : default | preprod | prod
    runMode: undefined,
    rootUrlBackend: undefined,
    rootUrlAuth: undefined,
    // rootUrlUser : undefined,
    // UX OPTIONS
    showNav: false,
    bannerVisible: true,
    // FOR TRANSLATIONS
    locale: 'fr',
    // USER-RELATED
    user: {
      infos: undefined,
      role: undefined,
      isLoggedin: false
    },
    jwt: undefined,
    // LEGACY
    geolocByProjectId: new Map(),
    // CURRENT
    displayedProject: undefined,
    // FILTERS
    filterDescriptions: undefined,
    datasetFilters: undefined,
    // APIVIZ CONFIG
    config: {},
    // SEARCH PARAMETERS
    search: {
      // DATASET
      dataset_uri: undefined,
      endpoint_type: undefined,
      endpoint: undefined,
      // QUERY FROM USER
      question: {
        query: new URL(location).searchParams.get('text') || '',
        forMap: false,
        onlyGeocoded: true,
        shuffleSeed: 1234,
        page: 1,
        perPage: 100,
        selectedDatasetFilters: undefined,
        selectedFilters: new Map()
      },
      // RESULTS
      answer: {
        pendingAbort: undefined,
        // function that can be used to abort the current pending search
        result: undefined,
        // search results {projects, total}
        // resultMap : undefined, // complete search results with minimal items as { _id, latlng } --> to be loaded just once for better experience + getters
        error: undefined // if last search ended in an error

      },
      // UI IN SEARCH PAGES CONFIG
      config: {
        display: {
          columnCount: undefined,
          defaultShowCount: undefined,
          moreProjectOnScrollCount: undefined,
          scrollBeforeBottomTrigger: undefined
        }
      }
    }
  },
  // STORE MODULES
  getters: _getters.default,
  mutations: _mutations.default,
  actions: _actions.default
});
var _default = storeGenerator;
exports.default = _default;

},{"./actions":73,"./getters":74,"./mutations":75,"axios":2,"vue":34,"vuex":38}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getObjectDataFromPath = getObjectDataFromPath;
exports.getConfigName = getConfigName;
exports.getItemById = getItemById;
exports.searchItems = searchItems;
exports.searchEndpointGenerator = searchEndpointGenerator;
exports.makeEmptySelectedFilters = makeEmptySelectedFilters;
exports.textFromLocale = textFromLocale;
exports.createSelectedFiltersForSearch = createSelectedFiltersForSearch;
exports.loadScript = loadScript;
exports.activateCarousel = activateCarousel;
// feature test for AbortController that works in Safari 12
var abortableFetchSupported = false;

try {
  var ac = new AbortController();
  fetch('.', {
    signal: ac.signal
  }).then(function (r) {
    return r.text();
  }).then(function (result) {
    abortableFetchSupported = false;
  }).catch(function (err) {
    abortableFetchSupported = err.name === 'AbortError';
  });
  ac.abort();
} catch (e) {
  abortableFetchSupported = false;
} // FUNCTION TO PARSE AN OBJECT GIVEN A PATH


function getObjectDataFromPath(obj, path) {
  var splitter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';
  var current = obj; // console.log("+ + + getObjectDataFromPath / current raw : \n", current )

  try {
    var current_temp = current;
    path.split(splitter).forEach(function (p) {
      current_temp = current_temp[p];
    }); // console.log("+ + + getObjectDataFromPath / current final : \n", current )

    return current_temp;
  } catch (e) {
    return "";
  }
} // FUNCTION TO GET THE RUN MODE FROM <HEAD>


function getConfigName(metaName) {
  var metas = document.getElementsByTagName('meta');

  for (var i = 0; i < metas.length; i++) {
    if (metas[i].getAttribute('name') === metaName) {
      return metas[i].getAttribute('content');
    }
  }

  return '';
} // server-side end-point to get only one project


function getItemById(id, endpointConfig) {
  // const url = searchEnpointCreator({
  //   page:1,
  //   per_page:1,
  //   baseUrl:root_url,
  //   item_id:id
  // })
  var url = searchEndpointGenerator({
    endpointConfig: endpointConfig,
    questionParams: {
      itemId: id
    },
    selectedFilters: []
  });
  return fetch(url).then(function (r) {
    return r.json();
  }).then(function (_ref) {
    var data = _ref.data,
        query = _ref.query;
    return data && data.data_raw && data.data_raw.f_data && Array.isArray(data.data_raw.f_data) ? data.data_raw.f_data[0] : undefined;
  });
}

function searchItems() {
  var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
  // console.log("+ + + searchItems ... ");
  // abort fetch if this is supported
  // abort manually when response arrives otherwise
  var ac = abortableFetchSupported ? new AbortController() : undefined;
  var searchAborted = false;
  return {
    abort: function abort() {
      searchAborted = true;
      if (ac) ac.abort();
    },
    promise: (ac ? fetch(url, {
      signal: ac.signal
    }) : fetch(url)).then(function (r) {
      return r.json();
    }).then(function (_ref2) {
      var data = _ref2.data,
          query = _ref2.query;

      if (searchAborted) {
        var error = new Error('Search aborted');
        error.name = 'AbortError';
        throw error;
      } else {
        // console.log("+ + + searchItems (response) / data :", data);
        return {
          projects: data && data.data_raw && data.data_raw.f_data && Array.isArray(data.data_raw.f_data) ? data.data_raw.f_data : [],
          total: data && data.data_raw && data.data_raw.f_data_count ? data.data_raw.f_data_count : 0
        };
      }
    })
  };
}

function searchEndpointGenerator(obj) {
  if (!obj) {
    throw 'error in searchEndpointGenerator: no parameter defined';
  } // console.log("+ + + searchEndpointGenerator / ...")
  // console.log("+ + + searchEndpointGenerator / obj : \n ", obj)
  // endpoint config related


  var endpointConfig = obj.endpointConfig;
  var endpointConfigArgs = endpointConfig.args_options; // question related

  var questionParams = obj.questionParams;
  var selectedFilters = obj.selectedFilters; // base query to be completed with args + questions

  var baseQuery = endpointConfig.root_url + '?';
  var appArgs = ['query', 'forMap', 'page', 'perPage', 'onlyGeocoded', 'itemId', 'shuffleSeed']; // loop in routeArgs + queries then append to baseQuery

  var argsArray = [];

  for (var key in endpointConfigArgs) {
    var EndpointArg = endpointConfigArgs[key]; // console.log("+ + + searchEndpointGenerator / EndpointArg : ", EndpointArg)

    if (!EndpointArg.optional || appArgs.indexOf(EndpointArg.app_arg) !== -1) {
      if (questionParams[EndpointArg.app_arg]) {
        var argString = EndpointArg.arg + '=' + questionParams[EndpointArg.app_arg];
        argsArray.push(argString);
      }
    }
  } // loop in selectedFilters to add filters request if any
  // find corresponding mapper in endPointConfig


  var filterMapper = endpointConfigArgs.find(function (c) {
    return c.app_arg === 'filters';
  }); // console.log("+ + + searchEndpointGenerator / filterMapper : \n ", filterMapper)

  if (filterMapper && selectedFilters.length > 0) {
    var _EndpointArg = filterMapper.arg;

    for (var index in selectedFilters) {
      var argFilterString = _EndpointArg + '=' + selectedFilters[index];
      argsArray.push(argFilterString);
    }
  }

  var argsLongString = argsArray.join('&');
  baseQuery += argsLongString; // console.log("+ + + searchEndpointGenerator / baseQuery : \n ", baseQuery)

  return baseQuery;
} // export function searchEnpointCreator(obj){
//   // (text, tags, page=1, per_page=100, baseUrl = `${APISearchOrigin}`, token = undefined ){
//   if (!obj) { throw 'error in searchEnpointCreator: no parameter defined' }
//   // console.log("+ + + searchEnpointCreator / ...")
//   console.log("+ + + searchEnpointCreator / obj : \n ", obj)
//   // the first argument: no & at the begining
//   const pageArg = (typeof obj.page == 'number') ? 'page='+obj.page : 'page=1';
//   // then come the other arguments
//   const searchArg = (typeof obj.search === 'string' && obj.search.length >= 1) ? '&search_for='+encodeURIComponent( obj.search.trim() ) : '';
//   const shuffle_seedArg = (typeof obj.shuffle_seed == 'number') ? '&shuffle_seed='+obj.shuffle_seed : '&shuffle_seed=' + Math.floor((Math.random() * 10000) + 1) ;
//   const tagsArg = (obj.tags && obj.tags.size >= 1) ? `&search_in_tags=${encodeURIComponent([...obj.tags].join(','))}` : '';
//   const tokenArg = (obj.token) ? `&token=${encodeURIComponent(obj.token)}` : ''
//   //if none, default value provided (otherwise the backend will provide anyway)
//   const per_pageArg = (typeof obj.per_page == 'number') ? '&per_page='+obj.per_page : '&per_page=100';
//   const map_listArg = (typeof obj.map_list == 'boolean') ? '&map_list='+obj.map_list : '&map_list=false';
//   const as_latlngArg = (typeof obj.as_latlng == 'boolean') ? '&as_latlng='+obj.as_latlng : '&as_latlng=false';
//   const only_geocodedArg = (typeof obj.only_geocoded == 'boolean') ? '&only_geocoded='+obj.only_geocoded : '&only_geocoded=true';
//   const geo_precisionArg = (typeof obj.geo_precision == 'number') ? '&geo_precision='+obj.geo_precision : '&geo_precision=6';
//   const get_filtersArg = (typeof obj.get_filters == 'boolean') ? '&get_filters='+obj.get_filters : '&get_filters=false';
//   const is_completeArg = (typeof obj.is_complete == 'boolean') ? '&is_complete='+obj.is_complete : '&is_complete=false';
//   const only_statsArg = (typeof obj.only_stats == 'boolean') ? '&only_stats='+obj.only_stats : '&only_stats=false';
//   const normalizeArg = (typeof obj.normalize == 'boolean') ? '&normalize='+obj.normalize : '&normalize=false';
//   // if none, don't do
//   const search_forArg = (typeof obj.search_for == 'string') ? '&search_for='+obj.search_for : '';
//   const search_inArg = (typeof obj.search_in == 'string') ? '&search_in='+obj.search_in : '';
//   const search_tagsArg = (typeof obj.search_tags == 'string') ? '&search_tags='+obj.search_tags : '';
//   const search_filtersArg = (obj.search_filters && obj.search_filters.length >= 1) ? `&search_filters=${[...obj.search_filters].join('&search_filters=')}` : '';
//   const search_intArg = (typeof obj.search_int == 'number') ? '&search_int='+obj.search_int : '';
//   const search_floatArg = (typeof obj.search_float == 'number') ? '&search_float='+obj.search_float : '';
//   const item_idArg = (typeof obj.item_id == 'string') ? '&item_id='+obj.item_id : '';
//   const sort_byArg = (typeof obj.sort_by == 'string') ? '&sort_by='+obj.sort_by : '';
//   const descendingArg = (typeof obj.descending == 'boolean') ? '&descending='+obj.descending : '';
//   // WITHOUT SHUFFLE
//   // return obj.baseUrl+`?${pageArg}${per_pageArg}${searchArg}${tagsArg}${tokenArg}${map_listArg}${as_latlngArg}${only_geocodedArg}${geo_precisionArg}${get_filtersArg}${is_completeArg}${only_statsArg}${normalizeArg}${search_forArg}${search_inArg}${search_tagsArg}${search_intArg}${search_floatArg}${item_idArg}${sort_byArg}${descendingArg}`
//   // WITH SHUFFLE
//   return obj.baseUrl+`?${pageArg}${per_pageArg}${shuffle_seedArg}${searchArg}${tagsArg}${tokenArg}${map_listArg}${as_latlngArg}${only_geocodedArg}${geo_precisionArg}${get_filtersArg}${is_completeArg}${only_statsArg}${normalizeArg}${search_forArg}${search_inArg}${search_tagsArg}${search_filtersArg}${search_intArg}${search_floatArg}${item_idArg}${sort_byArg}${descendingArg}`
// }


function makeEmptySelectedFilters(filterDescriptions) {
  // console.log("::: makeEmptySelectedFilters / filterDescriptions : ", filterDescriptions)
  var selectedFilters = new Map();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = filterDescriptions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var f = _step.value;
      selectedFilters.set(f.name, new Set());
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return selectedFilters;
}

function textFromLocale(textsList, locale, field) {
  // console.log("::: textFromLocale / textsList : ", textsList)
  // console.log("::: textFromLocale / locale : ", locale)
  // console.log("::: textFromLocale / field : ", field)
  var textObject = textsList.find(function (t) {
    return t.locale == locale;
  });
  var textOut = textObject[field]; // console.log("::: textFromLocale / textOut : ", textOut)

  return textOut;
}

function createSelectedFiltersForSearch(selectedFiltersMap) {
  var filtersUri = [];
  selectedFiltersMap.forEach(function (val, key, map) {
    // console.log('val,key,map',val,key,map);
    val.forEach(function (v) {
      filtersUri.push(key + v);
    });
  }); // console.log(filtersUri);

  return filtersUri;
} // To load external librairies in components


function loadScript(url, callback) {
  console.log("try to load script:", url);
  var script = document.createElement('script');
  script.type = "text/javascript";
  script.src = url;
  script.onreadystatechange = callback;
  script.onload = callback;
  document.head.appendChild(script);
} // To activate carousels from components


function activateCarousel() {
  var slidesNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
  var isInfinite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var hasPagination = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  console.log("activate carousel from utils");
  var carousels = bulmaCarousel.attach('.carousel', {
    // TODO: give the parameters as args?
    slidesToShow: 2,
    infinite: true,
    pagination: false // slidesToShow: slidesNumber,
    // infinite: isInfinite,
    // pagination: hasPagination

  }); // "hacky" way to get custom icons

  document.getElementsByClassName("slider-navigation-previous")[0].childNodes[0].remove();
  document.getElementsByClassName("slider-navigation-next")[0].childNodes[0].remove();
}

},{}],78:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (b.hasOwnProperty(p)) d[p] = b[p];
    }
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var PruneCluster;

(function (PruneCluster_1) {
  var Point = function () {
    function Point() {}

    return Point;
  }();

  PruneCluster_1.Point = Point;

  var ClusterObject = function () {
    function ClusterObject() {}

    return ClusterObject;
  }();

  PruneCluster_1.ClusterObject = ClusterObject;
  var hashCodeCounter = 1;
  var maxHashCodeValue = Math.pow(2, 53) - 1;

  var Marker = function (_super) {
    __extends(Marker, _super);

    function Marker(lat, lng, data, category, weight, filtered) {
      if (data === void 0) {
        data = {};
      }

      if (weight === void 0) {
        weight = 1;
      }

      if (filtered === void 0) {
        filtered = false;
      }

      var _this = _super.call(this) || this;

      _this.data = data;
      _this.position = {
        lat: +lat,
        lng: +lng
      };
      _this.weight = weight;
      _this.category = category;
      _this.filtered = filtered;
      _this.hashCode = hashCodeCounter++;
      return _this;
    }

    Marker.prototype.Move = function (lat, lng) {
      this.position.lat = +lat;
      this.position.lng = +lng;
    };

    Marker.prototype.SetData = function (data) {
      for (var key in data) {
        this.data[key] = data[key];
      }
    };

    return Marker;
  }(ClusterObject);

  PruneCluster_1.Marker = Marker;

  var Cluster = function (_super) {
    __extends(Cluster, _super);

    function Cluster(marker) {
      var _this = _super.call(this) || this;

      _this.stats = [0, 0, 0, 0, 0, 0, 0, 0];
      _this.data = {};

      if (!marker) {
        _this.hashCode = 1;

        if (Cluster.ENABLE_MARKERS_LIST) {
          _this._clusterMarkers = [];
        }

        return _this;
      }

      if (Cluster.ENABLE_MARKERS_LIST) {
        _this._clusterMarkers = [marker];
      }

      _this.lastMarker = marker;
      _this.hashCode = 31 + marker.hashCode;
      _this.population = 1;

      if (marker.category !== undefined) {
        _this.stats[marker.category] = 1;
      }

      _this.totalWeight = marker.weight;
      _this.position = {
        lat: marker.position.lat,
        lng: marker.position.lng
      };
      _this.averagePosition = {
        lat: marker.position.lat,
        lng: marker.position.lng
      };
      return _this;
    }

    Cluster.prototype.AddMarker = function (marker) {
      if (Cluster.ENABLE_MARKERS_LIST) {
        this._clusterMarkers.push(marker);
      }

      var h = this.hashCode;
      h = (h << 5) - h + marker.hashCode;

      if (h >= maxHashCodeValue) {
        this.hashCode = h % maxHashCodeValue;
      } else {
        this.hashCode = h;
      }

      this.lastMarker = marker;
      var weight = marker.weight,
          currentTotalWeight = this.totalWeight,
          newWeight = weight + currentTotalWeight;
      this.averagePosition.lat = (this.averagePosition.lat * currentTotalWeight + marker.position.lat * weight) / newWeight;
      this.averagePosition.lng = (this.averagePosition.lng * currentTotalWeight + marker.position.lng * weight) / newWeight;
      ++this.population;
      this.totalWeight = newWeight;

      if (marker.category !== undefined) {
        this.stats[marker.category] = this.stats[marker.category] + 1 || 1;
      }
    };

    Cluster.prototype.Reset = function () {
      this.hashCode = 1;
      this.lastMarker = undefined;
      this.population = 0;
      this.totalWeight = 0;
      this.stats = [0, 0, 0, 0, 0, 0, 0, 0];

      if (Cluster.ENABLE_MARKERS_LIST) {
        this._clusterMarkers = [];
      }
    };

    Cluster.prototype.ComputeBounds = function (cluster) {
      var proj = cluster.Project(this.position.lat, this.position.lng);
      var size = cluster.Size;
      var nbX = Math.floor(proj.x / size),
          nbY = Math.floor(proj.y / size),
          startX = nbX * size,
          startY = nbY * size;
      var a = cluster.UnProject(startX, startY),
          b = cluster.UnProject(startX + size, startY + size);
      this.bounds = {
        minLat: b.lat,
        maxLat: a.lat,
        minLng: a.lng,
        maxLng: b.lng
      };
    };

    Cluster.prototype.GetClusterMarkers = function () {
      return this._clusterMarkers;
    };

    Cluster.prototype.ApplyCluster = function (newCluster) {
      this.hashCode = this.hashCode * 41 + newCluster.hashCode * 43;

      if (this.hashCode > maxHashCodeValue) {
        this.hashCode = this.hashCode = maxHashCodeValue;
      }

      var weight = newCluster.totalWeight,
          currentTotalWeight = this.totalWeight,
          newWeight = weight + currentTotalWeight;
      this.averagePosition.lat = (this.averagePosition.lat * currentTotalWeight + newCluster.averagePosition.lat * weight) / newWeight;
      this.averagePosition.lng = (this.averagePosition.lng * currentTotalWeight + newCluster.averagePosition.lng * weight) / newWeight;
      this.population += newCluster.population;
      this.totalWeight = newWeight;
      this.bounds.minLat = Math.min(this.bounds.minLat, newCluster.bounds.minLat);
      this.bounds.minLng = Math.min(this.bounds.minLng, newCluster.bounds.minLng);
      this.bounds.maxLat = Math.max(this.bounds.maxLat, newCluster.bounds.maxLat);
      this.bounds.maxLng = Math.max(this.bounds.maxLng, newCluster.bounds.maxLng);

      for (var category in newCluster.stats) {
        if (newCluster.stats.hasOwnProperty(category)) {
          if (this.stats.hasOwnProperty(category)) {
            this.stats[category] += newCluster.stats[category];
          } else {
            this.stats[category] = newCluster.stats[category];
          }
        }
      }

      if (Cluster.ENABLE_MARKERS_LIST) {
        this._clusterMarkers = this._clusterMarkers.concat(newCluster.GetClusterMarkers());
      }
    };

    Cluster.ENABLE_MARKERS_LIST = false;
    return Cluster;
  }(ClusterObject);

  PruneCluster_1.Cluster = Cluster;

  function checkPositionInsideBounds(a, b) {
    return a.lat >= b.minLat && a.lat <= b.maxLat && a.lng >= b.minLng && a.lng <= b.maxLng;
  }

  function insertionSort(list) {
    for (var i = 1, j, tmp, tmpLng, length = list.length; i < length; ++i) {
      tmp = list[i];
      tmpLng = tmp.position.lng;

      for (j = i - 1; j >= 0 && list[j].position.lng > tmpLng; --j) {
        list[j + 1] = list[j];
      }

      list[j + 1] = tmp;
    }
  }

  function shouldUseInsertionSort(total, nbChanges) {
    if (nbChanges > 300) {
      return false;
    } else {
      return nbChanges / total < 0.2;
    }
  }

  var PruneCluster = function () {
    function PruneCluster() {
      this._markers = [];
      this._nbChanges = 0;
      this._clusters = [];
      this.Size = 166;
      this.ViewPadding = 0.2;
    }

    PruneCluster.prototype.RegisterMarker = function (marker) {
      if (marker._removeFlag) {
        delete marker._removeFlag;
      }

      this._markers.push(marker);

      this._nbChanges += 1;
    };

    PruneCluster.prototype.RegisterMarkers = function (markers) {
      var _this = this;

      markers.forEach(function (marker) {
        _this.RegisterMarker(marker);
      });
    };

    PruneCluster.prototype._sortMarkers = function () {
      var markers = this._markers,
          length = markers.length;

      if (this._nbChanges && !shouldUseInsertionSort(length, this._nbChanges)) {
        this._markers.sort(function (a, b) {
          return a.position.lng - b.position.lng;
        });
      } else {
        insertionSort(markers);
      }

      this._nbChanges = 0;
    };

    PruneCluster.prototype._sortClusters = function () {
      insertionSort(this._clusters);
    };

    PruneCluster.prototype._indexLowerBoundLng = function (lng) {
      var markers = this._markers,
          it,
          step,
          first = 0,
          count = markers.length;

      while (count > 0) {
        step = Math.floor(count / 2);
        it = first + step;

        if (markers[it].position.lng < lng) {
          first = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }

      return first;
    };

    PruneCluster.prototype._resetClusterViews = function () {
      for (var i = 0, l = this._clusters.length; i < l; ++i) {
        var cluster = this._clusters[i];
        cluster.Reset();
        cluster.ComputeBounds(this);
      }
    };

    PruneCluster.prototype.ProcessView = function (bounds) {
      var heightBuffer = Math.abs(bounds.maxLat - bounds.minLat) * this.ViewPadding,
          widthBuffer = Math.abs(bounds.maxLng - bounds.minLng) * this.ViewPadding;
      var extendedBounds = {
        minLat: bounds.minLat - heightBuffer - heightBuffer,
        maxLat: bounds.maxLat + heightBuffer + heightBuffer,
        minLng: bounds.minLng - widthBuffer - widthBuffer,
        maxLng: bounds.maxLng + widthBuffer + widthBuffer
      };

      this._sortMarkers();

      this._resetClusterViews();

      var firstIndex = this._indexLowerBoundLng(extendedBounds.minLng);

      var markers = this._markers,
          clusters = this._clusters;
      var workingClusterList = clusters.slice(0);

      for (var i = firstIndex, l = markers.length; i < l; ++i) {
        var marker = markers[i],
            markerPosition = marker.position;

        if (markerPosition.lng > extendedBounds.maxLng) {
          break;
        }

        if (markerPosition.lat > extendedBounds.minLat && markerPosition.lat < extendedBounds.maxLat && !marker.filtered) {
          var clusterFound = false,
              cluster;

          for (var j = 0, ll = workingClusterList.length; j < ll; ++j) {
            cluster = workingClusterList[j];

            if (cluster.bounds.maxLng < marker.position.lng) {
              workingClusterList.splice(j, 1);
              --j;
              --ll;
              continue;
            }

            if (checkPositionInsideBounds(markerPosition, cluster.bounds)) {
              cluster.AddMarker(marker);
              clusterFound = true;
              break;
            }
          }

          if (!clusterFound) {
            cluster = new Cluster(marker);
            cluster.ComputeBounds(this);
            clusters.push(cluster);
            workingClusterList.push(cluster);
          }
        }
      }

      var newClustersList = [];

      for (i = 0, l = clusters.length; i < l; ++i) {
        cluster = clusters[i];

        if (cluster.population > 0) {
          newClustersList.push(cluster);
        }
      }

      this._clusters = newClustersList;

      this._sortClusters();

      return this._clusters;
    };

    PruneCluster.prototype.RemoveMarkers = function (markers) {
      if (!markers) {
        this._markers = [];
        return;
      }

      for (var i = 0, l = markers.length; i < l; ++i) {
        markers[i]._removeFlag = true;
      }

      var newMarkersList = [];

      for (i = 0, l = this._markers.length; i < l; ++i) {
        if (!this._markers[i]._removeFlag) {
          newMarkersList.push(this._markers[i]);
        } else {
          delete this._markers[i]._removeFlag;
        }
      }

      this._markers = newMarkersList;
    };

    PruneCluster.prototype.FindMarkersInArea = function (area) {
      var aMinLat = area.minLat,
          aMaxLat = area.maxLat,
          aMinLng = area.minLng,
          aMaxLng = area.maxLng,
          markers = this._markers,
          result = [];

      var firstIndex = this._indexLowerBoundLng(aMinLng);

      for (var i = firstIndex, l = markers.length; i < l; ++i) {
        var pos = markers[i].position;

        if (pos.lng > aMaxLng) {
          break;
        }

        if (pos.lat >= aMinLat && pos.lat <= aMaxLat && pos.lng >= aMinLng) {
          result.push(markers[i]);
        }
      }

      return result;
    };

    PruneCluster.prototype.ComputeBounds = function (markers, withFiltered) {
      if (withFiltered === void 0) {
        withFiltered = true;
      }

      if (!markers || !markers.length) {
        return null;
      }

      var rMinLat = Number.MAX_VALUE,
          rMaxLat = -Number.MAX_VALUE,
          rMinLng = Number.MAX_VALUE,
          rMaxLng = -Number.MAX_VALUE;

      for (var i = 0, l = markers.length; i < l; ++i) {
        if (!withFiltered && markers[i].filtered) {
          continue;
        }

        var pos = markers[i].position;
        if (pos.lat < rMinLat) rMinLat = pos.lat;
        if (pos.lat > rMaxLat) rMaxLat = pos.lat;
        if (pos.lng < rMinLng) rMinLng = pos.lng;
        if (pos.lng > rMaxLng) rMaxLng = pos.lng;
      }

      return {
        minLat: rMinLat,
        maxLat: rMaxLat,
        minLng: rMinLng,
        maxLng: rMaxLng
      };
    };

    PruneCluster.prototype.FindMarkersBoundsInArea = function (area) {
      return this.ComputeBounds(this.FindMarkersInArea(area));
    };

    PruneCluster.prototype.ComputeGlobalBounds = function (withFiltered) {
      if (withFiltered === void 0) {
        withFiltered = true;
      }

      return this.ComputeBounds(this._markers, withFiltered);
    };

    PruneCluster.prototype.GetMarkers = function () {
      return this._markers;
    };

    PruneCluster.prototype.GetPopulation = function () {
      return this._markers.length;
    };

    PruneCluster.prototype.ResetClusters = function () {
      this._clusters = [];
    };

    return PruneCluster;
  }();

  PruneCluster_1.PruneCluster = PruneCluster;
})(PruneCluster || (PruneCluster = {})); // var PruneCluster;
// (function (PruneCluster) {
// })(PruneCluster || (PruneCluster = {}));


var PruneClusterForLeaflet = (L.Layer ? L.Layer : L.Class).extend({
  initialize: function initialize(size, clusterMargin) {
    var _this = this;

    if (size === void 0) {
      size = 120;
    }

    if (clusterMargin === void 0) {
      clusterMargin = 20;
    }

    this.Cluster = new PruneCluster.PruneCluster();
    this.Cluster.Size = size;
    this.clusterMargin = Math.min(clusterMargin, size / 4);

    this.Cluster.Project = function (lat, lng) {
      return _this._map.project(new L.LatLng(lat, lng), Math.floor(_this._map.getZoom()));
    };

    this.Cluster.UnProject = function (x, y) {
      return _this._map.unproject(new L.Point(x, y), Math.floor(_this._map.getZoom()));
    };

    this._objectsOnMap = [];
    this.spiderfier = new PruneClusterLeafletSpiderfier(this);
    this._hardMove = false;
    this._resetIcons = false;
    this._removeTimeoutId = 0;
    this._markersRemoveListTimeout = [];
  },
  RegisterMarker: function RegisterMarker(marker) {
    this.Cluster.RegisterMarker(marker);
  },
  RegisterMarkers: function RegisterMarkers(markers) {
    this.Cluster.RegisterMarkers(markers);
  },
  RemoveMarkers: function RemoveMarkers(markers) {
    this.Cluster.RemoveMarkers(markers);
  },
  BuildLeafletCluster: function BuildLeafletCluster(cluster, position) {
    var _this = this;

    var m = new L.Marker(position, {
      icon: this.BuildLeafletClusterIcon(cluster)
    });
    m._leafletClusterBounds = cluster.bounds;
    m.on('click', function () {
      var cbounds = m._leafletClusterBounds;

      var markersArea = _this.Cluster.FindMarkersInArea(cbounds);

      var b = _this.Cluster.ComputeBounds(markersArea);

      if (b) {
        var bounds = new L.LatLngBounds(new L.LatLng(b.minLat, b.maxLng), new L.LatLng(b.maxLat, b.minLng));

        var zoomLevelBefore = _this._map.getZoom(),
            zoomLevelAfter = _this._map.getBoundsZoom(bounds, false, new L.Point(20, 20));

        if (zoomLevelAfter === zoomLevelBefore) {
          var filteredBounds = [];

          for (var i = 0, l = _this._objectsOnMap.length; i < l; ++i) {
            var o = _this._objectsOnMap[i];

            if (o.data._leafletMarker !== m) {
              if (o.bounds.minLat >= cbounds.minLat && o.bounds.maxLat <= cbounds.maxLat && o.bounds.minLng >= cbounds.minLng && o.bounds.maxLng <= cbounds.maxLng) {
                filteredBounds.push(o.bounds);
              }
            }
          }

          if (filteredBounds.length > 0) {
            var newMarkersArea = [];
            var ll = filteredBounds.length;

            for (i = 0, l = markersArea.length; i < l; ++i) {
              var markerPos = markersArea[i].position;
              var isFiltered = false;

              for (var j = 0; j < ll; ++j) {
                var currentFilteredBounds = filteredBounds[j];

                if (markerPos.lat >= currentFilteredBounds.minLat && markerPos.lat <= currentFilteredBounds.maxLat && markerPos.lng >= currentFilteredBounds.minLng && markerPos.lng <= currentFilteredBounds.maxLng) {
                  isFiltered = true;
                  break;
                }
              }

              if (!isFiltered) {
                newMarkersArea.push(markersArea[i]);
              }
            }

            markersArea = newMarkersArea;
          }

          if (markersArea.length < 200 || zoomLevelAfter >= _this._map.getMaxZoom()) {
            _this._map.fire('overlappingmarkers', {
              cluster: _this,
              markers: markersArea,
              center: m.getLatLng(),
              marker: m
            });
          } else {
            zoomLevelAfter++;
          }

          _this._map.setView(m.getLatLng(), zoomLevelAfter);
        } else {
          _this._map.fitBounds(bounds);
        }
      }
    });
    return m;
  },
  BuildLeafletClusterIcon: function BuildLeafletClusterIcon(cluster) {
    var c = 'prunecluster prunecluster-';
    var iconSize = 38;
    var maxPopulation = this.Cluster.GetPopulation();

    if (cluster.population < Math.max(10, maxPopulation * 0.01)) {
      c += 'small';
    } else if (cluster.population < Math.max(100, maxPopulation * 0.05)) {
      c += 'medium';
      iconSize = 40;
    } else {
      c += 'large';
      iconSize = 44;
    }

    return new L.DivIcon({
      html: "<div><span>" + cluster.population + "</span></div>",
      className: c,
      iconSize: L.point(iconSize, iconSize)
    });
  },
  BuildLeafletMarker: function BuildLeafletMarker(marker, position) {
    var m = new L.Marker(position);
    this.PrepareLeafletMarker(m, marker.data, marker.category);
    return m;
  },
  PrepareLeafletMarker: function PrepareLeafletMarker(marker, data, category) {
    if (data.icon) {
      if (typeof data.icon === 'function') {
        marker.setIcon(data.icon(data, category));
      } else {
        marker.setIcon(data.icon);
      }
    }

    if (data.popup) {
      var content = typeof data.popup === 'function' ? data.popup(data, category) : data.popup;

      if (marker.getPopup()) {
        marker.setPopupContent(content, data.popupOptions);
      } else {
        marker.bindPopup(content, data.popupOptions);
      }
    }
  },
  onAdd: function onAdd(map) {
    this._map = map;
    map.on('movestart', this._moveStart, this);
    map.on('moveend', this._moveEnd, this);
    map.on('zoomend', this._zoomStart, this);
    map.on('zoomend', this._zoomEnd, this);
    this.ProcessView();
    map.addLayer(this.spiderfier);
  },
  onRemove: function onRemove(map) {
    map.off('movestart', this._moveStart, this);
    map.off('moveend', this._moveEnd, this);
    map.off('zoomend', this._zoomStart, this);
    map.off('zoomend', this._zoomEnd, this);

    for (var i = 0, l = this._objectsOnMap.length; i < l; ++i) {
      map.removeLayer(this._objectsOnMap[i].data._leafletMarker);
    }

    this._objectsOnMap = [];
    this.Cluster.ResetClusters();
    map.removeLayer(this.spiderfier);
    this._map = null;
  },
  _moveStart: function _moveStart() {
    this._moveInProgress = true;
  },
  _moveEnd: function _moveEnd(e) {
    this._moveInProgress = false;
    this._hardMove = e.hard;
    this.ProcessView();
  },
  _zoomStart: function _zoomStart() {
    this._zoomInProgress = true;
  },
  _zoomEnd: function _zoomEnd() {
    this._zoomInProgress = false;
    this.ProcessView();
  },
  ProcessView: function ProcessView() {
    var _this = this;

    if (!this._map || this._zoomInProgress || this._moveInProgress) {
      return;
    }

    var map = this._map,
        bounds = map.getBounds(),
        zoom = Math.floor(map.getZoom()),
        marginRatio = this.clusterMargin / this.Cluster.Size,
        resetIcons = this._resetIcons;
    var southWest = bounds.getSouthWest(),
        northEast = bounds.getNorthEast();
    var clusters = this.Cluster.ProcessView({
      minLat: southWest.lat,
      minLng: southWest.lng,
      maxLat: northEast.lat,
      maxLng: northEast.lng
    });
    var objectsOnMap = this._objectsOnMap,
        newObjectsOnMap = [],
        markersOnMap = new Array(objectsOnMap.length);

    for (var i = 0, l = objectsOnMap.length; i < l; ++i) {
      var marker = objectsOnMap[i].data._leafletMarker;
      markersOnMap[i] = marker;
      marker._removeFromMap = true;
    }

    var clusterCreationList = [];
    var clusterCreationListPopOne = [];
    var opacityUpdateList = [];
    var workingList = [];

    for (i = 0, l = clusters.length; i < l; ++i) {
      var icluster = clusters[i],
          iclusterData = icluster.data;
      var latMargin = (icluster.bounds.maxLat - icluster.bounds.minLat) * marginRatio,
          lngMargin = (icluster.bounds.maxLng - icluster.bounds.minLng) * marginRatio;

      for (var j = 0, ll = workingList.length; j < ll; ++j) {
        var c = workingList[j];

        if (c.bounds.maxLng < icluster.bounds.minLng) {
          workingList.splice(j, 1);
          --j;
          --ll;
          continue;
        }

        var oldMaxLng = c.averagePosition.lng + lngMargin,
            oldMinLat = c.averagePosition.lat - latMargin,
            oldMaxLat = c.averagePosition.lat + latMargin,
            newMinLng = icluster.averagePosition.lng - lngMargin,
            newMinLat = icluster.averagePosition.lat - latMargin,
            newMaxLat = icluster.averagePosition.lat + latMargin;

        if (oldMaxLng > newMinLng && oldMaxLat > newMinLat && oldMinLat < newMaxLat) {
          iclusterData._leafletCollision = true;
          c.ApplyCluster(icluster);
          break;
        }
      }

      if (!iclusterData._leafletCollision) {
        workingList.push(icluster);
      }
    }

    clusters.forEach(function (cluster) {
      var m = undefined;
      var data = cluster.data;

      if (data._leafletCollision) {
        data._leafletCollision = false;
        data._leafletOldPopulation = 0;
        data._leafletOldHashCode = 0;
        return;
      }

      var position = new L.LatLng(cluster.averagePosition.lat, cluster.averagePosition.lng);
      var oldMarker = data._leafletMarker;

      if (oldMarker) {
        if (cluster.population === 1 && data._leafletOldPopulation === 1 && cluster.hashCode === oldMarker._hashCode) {
          if (resetIcons || oldMarker._zoomLevel !== zoom || cluster.lastMarker.data.forceIconRedraw) {
            _this.PrepareLeafletMarker(oldMarker, cluster.lastMarker.data, cluster.lastMarker.category);

            if (cluster.lastMarker.data.forceIconRedraw) {
              cluster.lastMarker.data.forceIconRedraw = false;
            }
          }

          oldMarker.setLatLng(position);
          m = oldMarker;
        } else if (cluster.population > 1 && data._leafletOldPopulation > 1 && (oldMarker._zoomLevel === zoom || data._leafletPosition.equals(position))) {
          oldMarker.setLatLng(position);

          if (resetIcons || cluster.population != data._leafletOldPopulation || cluster.hashCode !== data._leafletOldHashCode) {
            var boundsCopy = {};
            L.Util.extend(boundsCopy, cluster.bounds);
            oldMarker._leafletClusterBounds = boundsCopy;
            oldMarker.setIcon(_this.BuildLeafletClusterIcon(cluster));
          }

          data._leafletOldPopulation = cluster.population;
          data._leafletOldHashCode = cluster.hashCode;
          m = oldMarker;
        }
      }

      if (!m) {
        if (cluster.population === 1) {
          clusterCreationListPopOne.push(cluster);
        } else {
          clusterCreationList.push(cluster);
        }

        data._leafletPosition = position;
        data._leafletOldPopulation = cluster.population;
        data._leafletOldHashCode = cluster.hashCode;
      } else {
        m._removeFromMap = false;
        newObjectsOnMap.push(cluster);
        m._zoomLevel = zoom;
        m._hashCode = cluster.hashCode;
        m._population = cluster.population;
        data._leafletMarker = m;
        data._leafletPosition = position;
      }
    });
    clusterCreationList = clusterCreationListPopOne.concat(clusterCreationList);

    for (i = 0, l = objectsOnMap.length; i < l; ++i) {
      icluster = objectsOnMap[i];
      var idata = icluster.data;
      marker = idata._leafletMarker;

      if (idata._leafletMarker._removeFromMap) {
        var remove = true;

        if (marker._zoomLevel === zoom) {
          var pa = icluster.averagePosition;
          latMargin = (icluster.bounds.maxLat - icluster.bounds.minLat) * marginRatio, lngMargin = (icluster.bounds.maxLng - icluster.bounds.minLng) * marginRatio;

          for (j = 0, ll = clusterCreationList.length; j < ll; ++j) {
            var jcluster = clusterCreationList[j],
                jdata = jcluster.data;

            if (marker._population === 1 && jcluster.population === 1 && marker._hashCode === jcluster.hashCode) {
              if (resetIcons || jcluster.lastMarker.data.forceIconRedraw) {
                this.PrepareLeafletMarker(marker, jcluster.lastMarker.data, jcluster.lastMarker.category);

                if (jcluster.lastMarker.data.forceIconRedraw) {
                  jcluster.lastMarker.data.forceIconRedraw = false;
                }
              }

              marker.setLatLng(jdata._leafletPosition);
              remove = false;
            } else {
              var pb = jcluster.averagePosition;
              var oldMinLng = pa.lng - lngMargin,
                  newMaxLng = pb.lng + lngMargin;
              oldMaxLng = pa.lng + lngMargin;
              oldMinLat = pa.lat - latMargin;
              oldMaxLat = pa.lat + latMargin;
              newMinLng = pb.lng - lngMargin;
              newMinLat = pb.lat - latMargin;
              newMaxLat = pb.lat + latMargin;

              if (marker._population > 1 && jcluster.population > 1 && oldMaxLng > newMinLng && oldMinLng < newMaxLng && oldMaxLat > newMinLat && oldMinLat < newMaxLat) {
                marker.setLatLng(jdata._leafletPosition);
                marker.setIcon(this.BuildLeafletClusterIcon(jcluster));
                var poisson = {};
                L.Util.extend(poisson, jcluster.bounds);
                marker._leafletClusterBounds = poisson;
                jdata._leafletOldPopulation = jcluster.population;
                jdata._leafletOldHashCode = jcluster.hashCode;
                marker._population = jcluster.population;
                remove = false;
              }
            }

            if (!remove) {
              jdata._leafletMarker = marker;
              marker._removeFromMap = false;
              newObjectsOnMap.push(jcluster);
              clusterCreationList.splice(j, 1);
              --j;
              --ll;
              break;
            }
          }
        }

        if (remove) {
          if (!marker._removeFromMap) console.error("wtf");
        }
      }
    }

    for (i = 0, l = clusterCreationList.length; i < l; ++i) {
      icluster = clusterCreationList[i], idata = icluster.data;
      var iposition = idata._leafletPosition;
      var creationMarker;

      if (icluster.population === 1) {
        creationMarker = this.BuildLeafletMarker(icluster.lastMarker, iposition);
      } else {
        creationMarker = this.BuildLeafletCluster(icluster, iposition);
      }

      creationMarker.addTo(map);
      creationMarker.setOpacity(0);
      opacityUpdateList.push(creationMarker);
      idata._leafletMarker = creationMarker;
      creationMarker._zoomLevel = zoom;
      creationMarker._hashCode = icluster.hashCode;
      creationMarker._population = icluster.population;
      newObjectsOnMap.push(icluster);
    }

    window.setTimeout(function () {
      for (i = 0, l = opacityUpdateList.length; i < l; ++i) {
        var m = opacityUpdateList[i];
        if (m._icon) L.DomUtil.addClass(m._icon, "prunecluster-anim");
        if (m._shadow) L.DomUtil.addClass(m._shadow, "prunecluster-anim");
        m.setOpacity(1);
      }
    }, 1);

    if (this._hardMove) {
      for (i = 0, l = markersOnMap.length; i < l; ++i) {
        marker = markersOnMap[i];

        if (marker._removeFromMap) {
          map.removeLayer(marker);
        }
      }
    } else {
      if (this._removeTimeoutId !== 0) {
        window.clearTimeout(this._removeTimeoutId);

        for (i = 0, l = this._markersRemoveListTimeout.length; i < l; ++i) {
          map.removeLayer(this._markersRemoveListTimeout[i]);
        }
      }

      var toRemove = [];

      for (i = 0, l = markersOnMap.length; i < l; ++i) {
        marker = markersOnMap[i];

        if (marker._removeFromMap) {
          marker.setOpacity(0);
          toRemove.push(marker);
        }
      }

      if (toRemove.length > 0) {
        this._removeTimeoutId = window.setTimeout(function () {
          for (i = 0, l = toRemove.length; i < l; ++i) {
            map.removeLayer(toRemove[i]);
          }

          _this._removeTimeoutId = 0;
        }, 300);
      }

      this._markersRemoveListTimeout = toRemove;
    }

    this._objectsOnMap = newObjectsOnMap;
    this._hardMove = false;
    this._resetIcons = false;
  },
  FitBounds: function FitBounds(withFiltered) {
    if (withFiltered === void 0) {
      withFiltered = true;
    }

    var bounds = this.Cluster.ComputeGlobalBounds(withFiltered);

    if (bounds) {
      this._map.fitBounds(new L.LatLngBounds(new L.LatLng(bounds.minLat, bounds.maxLng), new L.LatLng(bounds.maxLat, bounds.minLng)));
    }
  },
  GetMarkers: function GetMarkers() {
    return this.Cluster.GetMarkers();
  },
  RedrawIcons: function RedrawIcons(processView) {
    if (processView === void 0) {
      processView = true;
    }

    this._resetIcons = true;

    if (processView) {
      this.ProcessView();
    }
  }
});
var PruneClusterLeafletSpiderfier = (L.Layer ? L.Layer : L.Class).extend({
  _2PI: Math.PI * 2,
  _circleFootSeparation: 25,
  _circleStartAngle: Math.PI / 6,
  _spiralFootSeparation: 28,
  _spiralLengthStart: 11,
  _spiralLengthFactor: 5,
  _spiralCountTrigger: 8,
  spiderfyDistanceMultiplier: 1,
  initialize: function initialize(cluster) {
    this._cluster = cluster;
    this._currentMarkers = [];
    this._multiLines = !!L.multiPolyline;
    this._lines = this._multiLines ? L.multiPolyline([], {
      weight: 1.5,
      color: '#222'
    }) : L.polyline([], {
      weight: 1.5,
      color: '#222'
    });
  },
  onAdd: function onAdd(map) {
    this._map = map;

    this._map.on('overlappingmarkers', this.Spiderfy, this);

    this._map.on('click', this.Unspiderfy, this);

    this._map.on('zoomend', this.Unspiderfy, this);
  },
  Spiderfy: function Spiderfy(data) {
    var _this = this;

    if (data.cluster !== this._cluster) {
      return;
    }

    this.Unspiderfy();
    var markers = data.markers.filter(function (marker) {
      return !marker.filtered;
    });
    this._currentCenter = data.center;

    var centerPoint = this._map.latLngToLayerPoint(data.center);

    var points;

    if (markers.length >= this._spiralCountTrigger) {
      points = this._generatePointsSpiral(markers.length, centerPoint);
    } else {
      if (this._multiLines) {
        centerPoint.y += 10;
      }

      points = this._generatePointsCircle(markers.length, centerPoint);
    }

    var polylines = [];
    var leafletMarkers = [];
    var projectedPoints = [];

    for (var i = 0, l = points.length; i < l; ++i) {
      var pos = this._map.layerPointToLatLng(points[i]);

      var m = this._cluster.BuildLeafletMarker(markers[i], data.center);

      m.setZIndexOffset(5000);
      m.setOpacity(0);

      this._currentMarkers.push(m);

      this._map.addLayer(m);

      leafletMarkers.push(m);
      projectedPoints.push(pos);
    }

    window.setTimeout(function () {
      for (i = 0, l = points.length; i < l; ++i) {
        leafletMarkers[i].setLatLng(projectedPoints[i]).setOpacity(1);
      }

      var startTime = +new Date();
      var interval = 42,
          duration = 290;
      var anim = window.setInterval(function () {
        polylines = [];
        var now = +new Date();
        var d = now - startTime;

        if (d >= duration) {
          window.clearInterval(anim);
          stepRatio = 1.0;
        } else {
          var stepRatio = d / duration;
        }

        var center = data.center;

        for (i = 0, l = points.length; i < l; ++i) {
          var p = projectedPoints[i],
              diffLat = p.lat - center.lat,
              diffLng = p.lng - center.lng;
          polylines.push([center, new L.LatLng(center.lat + diffLat * stepRatio, center.lng + diffLng * stepRatio)]);
        }

        _this._lines.setLatLngs(polylines);
      }, interval);
    }, 1);

    this._lines.setLatLngs(polylines);

    this._map.addLayer(this._lines);

    if (data.marker) {
      this._clusterMarker = data.marker.setOpacity(0.3);
    }
  },
  _generatePointsCircle: function _generatePointsCircle(count, centerPt) {
    var circumference = this.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),
        legLength = circumference / this._2PI,
        angleStep = this._2PI / count,
        res = [],
        i,
        angle;
    res.length = count;

    for (i = count - 1; i >= 0; i--) {
      angle = this._circleStartAngle + i * angleStep;
      res[i] = new L.Point(Math.round(centerPt.x + legLength * Math.cos(angle)), Math.round(centerPt.y + legLength * Math.sin(angle)));
    }

    return res;
  },
  _generatePointsSpiral: function _generatePointsSpiral(count, centerPt) {
    var legLength = this.spiderfyDistanceMultiplier * this._spiralLengthStart,
        separation = this.spiderfyDistanceMultiplier * this._spiralFootSeparation,
        lengthFactor = this.spiderfyDistanceMultiplier * this._spiralLengthFactor,
        angle = 0,
        res = [],
        i;
    res.length = count;

    for (i = count - 1; i >= 0; i--) {
      angle += separation / legLength + i * 0.0005;
      res[i] = new L.Point(Math.round(centerPt.x + legLength * Math.cos(angle)), Math.round(centerPt.y + legLength * Math.sin(angle)));
      legLength += this._2PI * lengthFactor / angle;
    }

    return res;
  },
  Unspiderfy: function Unspiderfy() {
    var _this = this;

    for (var i = 0, l = this._currentMarkers.length; i < l; ++i) {
      this._currentMarkers[i].setLatLng(this._currentCenter).setOpacity(0);
    }

    var markers = this._currentMarkers;
    window.setTimeout(function () {
      for (i = 0, l = markers.length; i < l; ++i) {
        _this._map.removeLayer(markers[i]);
      }
    }, 300);
    this._currentMarkers = [];

    this._map.removeLayer(this._lines);

    if (this._clusterMarker) {
      this._clusterMarker.setOpacity(1);
    }
  },
  onRemove: function onRemove(map) {
    this.Unspiderfy();
    map.off('overlappingmarkers', this.Spiderfy, this);
    map.off('click', this.Unspiderfy, this);
    map.off('zoomend', this.Unspiderfy, this);
  }
});
module.exports = {
  PruneCluster: PruneCluster,
  PruneClusterForLeaflet: PruneClusterForLeaflet
};

},{}]},{},[70])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQG55bWFnL3Z1ZWlmeS9saWIvaW5zZXJ0LWNzcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZDMtZHN2L2J1aWxkL2QzLWRzdi5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL2Rpc3QvbGVhZmxldC5tYXJrZXJjbHVzdGVyLXNyYy5qcyIsIm5vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZS12YWxpZGF0ZS9kaXN0L3ZlZS12YWxpZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5jb21tb24uanMiLCJub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZTItbGVhZmxldC1tYXJrZXJjbHVzdGVyL2Rpc3QvVnVlMkxlYWZsZXRNYXJrZXJjbHVzdGVyLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZTItbGVhZmxldC9kaXN0L3Z1ZTItbGVhZmxldC5taW4uanMiLCJub2RlX21vZHVsZXMvdnVleC1yb3V0ZXItc3luYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWV4L2Rpc3QvdnVleC5jb21tb24uanMiLCJzY3JpcHRzL2NvbXBvbmVudHMvQnJhbmQudnVlPzI1YzdmMDAzIiwic2NyaXB0cy9jb21wb25lbnRzL0NJU1NlYXJjaFJlc3VsdHNDb3VudEFuZFRhYnMudnVlPzBlNDAzNzliIiwic2NyaXB0cy9jb21wb25lbnRzL0N1c3RvbU1hcmtlcnMudnVlP2Y1YWQ5N2EwIiwic2NyaXB0cy9jb21wb25lbnRzL0R5bmFtaWNCYW5uZXIudnVlP2NjZWI3YmUyIiwic2NyaXB0cy9jb21wb25lbnRzL0R5bmFtaWNEZXRhaWwudnVlPzRjMzE3Y2YzIiwic2NyaXB0cy9jb21wb25lbnRzL0R5bmFtaWNMaXN0LnZ1ZT8zYWI3ZDBiMCIsInNjcmlwdHMvY29tcG9uZW50cy9EeW5hbWljTWFwLnZ1ZT83ZDMwNzg5OCIsInNjcmlwdHMvY29tcG9uZW50cy9EeW5hbWljU2VhcmNoU2NyZWVuU3F1ZWxldG9uLnZ1ZT82ZTZjNGFjMiIsInNjcmlwdHMvY29tcG9uZW50cy9EeW5hbWljU3RhdGljLnZ1ZT82MTE2ZjkwYiIsInNjcmlwdHMvY29tcG9uZW50cy9EeW5hbWljU3RhdGljUmF3LnZ1ZT84NWRkYzI5OCIsInNjcmlwdHMvY29tcG9uZW50cy9EeW5hbWljU3RhdGljVGVzdC52dWU/MzBhMjUwNWIiLCJzY3JpcHRzL2NvbXBvbmVudHMvRmlsdGVyc0ZlZWRiYWNrLnZ1ZT82NjU1NDIyYSIsInNjcmlwdHMvY29tcG9uZW50cy9Gb290ZXIudnVlPzY4OTkwYjYwIiwic2NyaXB0cy9jb21wb25lbnRzL0Zvcm1Mb2dpbi52dWU/NzY2ZmI0Y2EiLCJzY3JpcHRzL2NvbXBvbmVudHMvRm9ybVJlZ2lzdGVyLnZ1ZT9kOGZmMzVlMCIsInNjcmlwdHMvY29tcG9uZW50cy9OYXZCYXIudnVlPzY4NmM3ZWFjIiwic2NyaXB0cy9jb21wb25lbnRzL05hdkJhckNvbnRlbnQudnVlP2IwNThiNmQyIiwic2NyaXB0cy9jb21wb25lbnRzL05vdEZvdW5kRXJyb3IudnVlIiwic2NyaXB0cy9jb21wb25lbnRzL1Byb2plY3RDYXJkLnZ1ZT9hM2Q1MWQ0MiIsInNjcmlwdHMvY29tcG9uZW50cy9TZWFyY2hSZXN1bHRzTGlzdC52dWU/Y2UyZWJkZWUiLCJzY3JpcHRzL2NvbXBvbmVudHMvU2VhcmNoUmVzdWx0c01hcC52dWU/N2I0NDY2ZGEiLCJzY3JpcHRzL2NvbXBvbmVudHMvU2VhcmNoV2l0aEZpbHRlcnMudnVlP2U2YmE3NjJhIiwic2NyaXB0cy9jb21wb25lbnRzL2JhY2tvZmZpY2UvQmFja09mZmljZUZvcm0udnVlP2ZjODI3N2FjIiwic2NyaXB0cy9jb21wb25lbnRzL3NjcmVlbnMvQmFja09mZmljZVNjcmVlbi52dWU/NjcxZTU5MjciLCJzY3JpcHRzL2NvbXBvbmVudHMvc2NyZWVucy9EeW5hbWljU2NyZWVuLnZ1ZT81NTJmMTUxNiIsInNjcmlwdHMvY29tcG9uZW50cy9zY3JlZW5zL0xvZ2luU2NyZWVuLnZ1ZT81NWJjMTY4YiIsInNjcmlwdHMvY29tcG9uZW50cy9zY3JlZW5zL0xvZ291dFNjcmVlbi52dWU/NjEyNzNiODIiLCJzY3JpcHRzL2NvbXBvbmVudHMvc2NyZWVucy9Ob3RGb3VuZFNjcmVlbi52dWU/NGI4NDgxNDkiLCJzY3JpcHRzL2NvbXBvbmVudHMvc2NyZWVucy9SZWdpc3RlclNjcmVlbi52dWU/MGI5MjY2YzIiLCJzY3JpcHRzL2NvbmZpZy9hcGkuanMiLCJzY3JpcHRzL2NvbnN0YW50cy5qcyIsInNjcmlwdHMvbWFpbi5qcyIsInNjcmlwdHMvcm91dGVzL2R5bmFtaWNSb3V0ZXMuanMiLCJzY3JpcHRzL3JvdXRlcy9tYWluLmpzIiwic2NyaXB0cy9zdG9yZS9hY3Rpb25zLmpzIiwic2NyaXB0cy9zdG9yZS9nZXR0ZXJzLmpzIiwic2NyaXB0cy9zdG9yZS9tdXRhdGlvbnMuanMiLCJzY3JpcHRzL3N0b3JlL3N0b3JlLmpzIiwic2NyaXB0cy91dGlscy5qcyIsInNjcmlwdHMvdXRpbHNQcnVuZUNsdXN0ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsb0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxK2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqdFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2prRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsMlBBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOTNCQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBWEE7Ozs7O0FBckNBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUNzREE7O0FBRUE7Ozs7Ozs7QUFHQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFaQTtBQXpEQTs7OztBQTFEQTtBQUFBOzs7Ozs7Ozs7Ozs7QUNLQTs7QUFDQTs7QUFDQTs7Ozs7OztBQUdBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFMQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQ0E7QUFGQTs7QUFNQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbERBO0FBdURBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBOztBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFhQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpGQTtBQTVJQTs7Ozs7QUFUQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FDMkVBOztBQUNBOzs7Ozs7Ozs7QUFHQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUFBOztBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFEQTs7QUFNQTtBQUdBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQXZDQTs7OztBQTFDQTtBQUFBOzs7Ozs7Ozs7Ozs7OztBQ3lhQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFLQTtBQURBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFsRUE7QUEwRkE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBckVBO0FBMUlBOzs7O0FBbmRBO0FBQUE7Ozs7Ozs7Ozs7Ozs7O0FDZUE7O0FBRUE7O0FBQ0E7Ozs7Ozs7OztBQUlBO0FBRUE7QUFRQTtBQUNBO0FBR0E7QUFtQkE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBREE7QUF4Q0E7Ozs7QUFwQkE7QUFBQTs7Ozs7Ozs7Ozs7OztBQ2FBOztBQUVBOztBQUNBOzs7Ozs7Ozs7QUFHQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBREE7QUFkQTs7OztBQWxCQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FDdUJBOztBQUNBOzs7OztBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBSEE7QUFNQTtBQU1BO0FBZEE7Ozs7QUEzQkE7QUFBQTs7Ozs7Ozs7Ozs7QUM0QkE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7OztBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFFQTtBQURBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQWRBO0FBaUJBO0FBSUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBREE7QUFNQTs7QUFDQTtBQUdBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBN0RBO0FBM0NBOzs7OztBQWhDQTtBQUFBOzs7Ozs7Ozs7OztBQ01BOztBQUNBOzs7Ozs7Ozs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBREE7QUFJQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFEQTs7QUFNQTtBQUdBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUEvQkE7Ozs7O0FBVEE7QUFBQTs7Ozs7Ozs7Ozs7QUNzV0E7O0FBQ0E7Ozs7Ozs7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBRUE7QUFEQTtBQUlBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQS9CQTs7Ozs7QUF6V0E7QUFBQTs7Ozs7Ozs7Ozs7OztBQ3dDQTs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFGQTtBQUFBO0FBQUE7O0FBQUE7QUFJQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVUE7QUFDQTtBQWJBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU5BO0FBbkJBOzs7O0FBMUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7O0FDaUdBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQXJCQTtBQWpCQTs7Ozs7QUEvRkE7QUFBQTs7Ozs7Ozs7Ozs7QUNxR0E7O0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0Q0E7QUFyQkE7Ozs7O0FBM0dBO0FBQUE7Ozs7Ozs7Ozs7O0FDd0tBOztBQUNBOztBQUNBOzs7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBRUE7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTs7QUFRQTtBQUtBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQXBFQTtBQW5CQTs7Ozs7QUE3S0E7QUFBQTs7Ozs7Ozs7Ozs7OztBQzBCQTs7QUFDQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBTEE7Ozs7QUE3QkE7QUFBQTs7Ozs7Ozs7Ozs7OztBQzhNQTs7Ozs7OztBQUdBO0FBS0E7QUFJQTtBQUVBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQXpDQTtBQXhCQTs7OztBQTVLQTtBQUFBOzs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNxRUE7O0FBRUE7O0FBSUE7QUFFQTtBQUVBO0FBV0E7QUFZQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUF4QkE7QUEwQkE7QUFDQTtBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBekNBO0FBdkRBOzs7O0FBNUVBO0FBQUE7Ozs7Ozs7Ozs7Ozs7O0FDd0NBOztBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBZ0JBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFBQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQVZBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBbEdBOzs7O0FBakRBO0FBQUE7Ozs7Ozs7Ozs7Ozs7O0FDK0lBOztBQUVBOztBQUNBOztBQUlBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOzs7Ozs7OztBQUVBOztBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBYkE7QUFpQkE7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFsQ0E7QUFxQ0E7QUFFQTtBQVNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBUUE7QUFFQTtBQUVBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQWVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFJQTtBQXZCQTtBQTZCQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUFBOztBQUdBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUF6R0E7QUF0SUE7Ozs7QUFoS0E7QUFBQTs7Ozs7Ozs7Ozs7OztBQ29GQTs7Ozs7OztBQUlBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQW9CQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUEvQkE7QUFrQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUE1REE7Ozs7QUF0RkE7QUFBQTs7Ozs7Ozs7Ozs7O0FDMEtBOztBQUNBOzs7Ozs7Ozs7QUFHQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFQQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBTEE7QUFVQTtBQUNBOztBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBSUE7QUE3Q0E7QUFuQ0E7Ozs7O0FBN0tBO0FBQUE7Ozs7Ozs7Ozs7O0FDK0dBOztBQUVBOzs7Ozs7Ozs7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUpBO0FBZkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFIQTtBQXJCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUpBO0FBVEE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFKQTtBQW5CQTtBQTRCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQUhBO0FBeEdBO0FBcUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFiQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUZBO0FBYkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFGQTtBQWJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFqQkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFMQTtBQXBCQTtBQUxBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRkE7QUFyQkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBUUE7QUFDQTtBQUNBO0FBSEE7QUFaQTtBQS9SQTtBQXVUQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFhQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQS9DQTtBQTFWQTs7Ozs7QUFuSEE7QUFBQTs7Ozs7Ozs7Ozs7OztBQzRJQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQWZBO0FBa0JBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQVNBO0FBRUE7QUFhQTtBQUVBOztBQUtBO0FBSUE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUtBO0FBS0E7QUFHQTtBQUdBO0FBRUE7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQVFBO0FBQUE7QUFBQTtBQUtBO0FBTUE7QUFNQTs7QUFFQTtBQUdBOztBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQXREQTtBQTZEQTtBQUdBO0FBREE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuRUE7QUF5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBM09BOzs7O0FBL0pBO0FBQUE7Ozs7Ozs7Ozs7OztBQ2dGQTs7QUFJQTs7Ozs7QUFHQTtBQUdBO0FBSEE7QUFLQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQTVCQTs7Ozs7QUF0RkE7QUFBQTs7Ozs7Ozs7Ozs7QUN3REE7OztBQU1BO0FBSUE7QUFLQTtBQUNBO0FBREE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBekJBOzs7OztBQTdEQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FDU0E7O0FBQ0E7O0FBQ0E7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBR0E7QUFMQTs7OztBQWJBO0FBQUE7Ozs7Ozs7Ozs7O0FDcURBOztBQUlBOzs7OztBQUdBO0FBR0E7QUFIQTtBQUtBO0FBS0E7QUFDQTtBQURBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQTNCQTs7Ozs7QUEzREE7QUFBQTs7Ozs7Ozs7O0FDQU8sSUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLE1BQVAsQ0FBYztBQUMzQyxFQUFBLGlCQUFpQixFQUFHLHNDQUR1QixDQUNnQjtBQUMzRDs7QUFGMkMsQ0FBZCxDQUF4Qjs7QUFLQSxJQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBUCxDQUFjO0FBRXJDO0FBQ0E7QUFFQSxFQUFBLE9BQU8sRUFBRztBQUNSLElBQUEsT0FBTyxFQUFFO0FBREQsR0FMMkI7QUFTckMsRUFBQSxjQUFjLEVBQUc7QUFDZixJQUFBLE9BQU8sRUFBRTtBQURNLEdBVG9CO0FBYXJDLEVBQUEsT0FBTyxFQUFHO0FBQ1IsSUFBQSxPQUFPLEVBQUU7QUFERCxHQWIyQjtBQWlCckMsRUFBQSxVQUFVLEVBQUc7QUFDWCxJQUFBLE9BQU8sRUFBRTtBQURFO0FBakJ3QixDQUFkLENBQWxCOzs7Ozs7Ozs7O0FDTEEsSUFBTSxTQUFTLEdBQUcsV0FBbEI7O0FBQ0EsSUFBTSxRQUFRLEdBQUcsVUFBakI7O0FBQ0EsSUFBTSxTQUFTLEdBQUcsV0FBbEI7Ozs7OztBQ0ZQOztBQUNBOztBQUNBOztBQUNBOztBQUtBOztBQUNBOzs7O0FBSkEsYUFBSSxHQUFKLENBQVEsb0JBQVI7O0FBQ0EsYUFBSSxHQUFKLENBQVEsa0JBQVI7O0FBSUE7QUFFQTtBQUNBLElBQU0sTUFBTSxHQUFHLG1CQUFnQixjQUFoQixDQUFmO0FBRUEsSUFBTSxNQUFNLEdBQUcsMEJBQUssY0FBTCxFQUFZLE1BQVosQ0FBZixDLENBQ0E7O0FBR0EsUUFBUSxDQUFDLGdCQUFULENBQTBCLGtCQUExQixFQUE4QyxZQUFNO0FBRWxELE1BQUksWUFBSixDQUFRO0FBQ04sSUFBQSxFQUFFLEVBQUUsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsY0FBdkIsQ0FERTtBQUVOLElBQUEsTUFBTSxFQUFOLE1BRk07QUFHTixJQUFBLEtBQUssRUFBTCxjQUhNO0FBSU4sSUFBQSxNQUFNLEVBQUUsZ0JBQUEsQ0FBQztBQUFBLGFBQUksQ0FBQyxDQUFFLGFBQUksU0FBSixDQUFjLGFBQWQsQ0FBRixDQUFMO0FBQUE7QUFKSCxHQUFSO0FBT0QsQ0FURCxFQVNHO0FBQUMsRUFBQSxJQUFJLEVBQUU7QUFBUCxDQVRIOzs7Ozs7Ozs7OztBQ2hCQTs7QUFDQTs7QUFDQTs7OztBQUpBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRU8sSUFBTSxzQkFBc0IsR0FBRyxTQUF6QixzQkFBeUIsQ0FBUyxLQUFULEVBQWU7QUFDbkQsU0FBTyxDQUNMO0FBQ0UsSUFBQSxJQUFJLEVBQUUsU0FEUjtBQUVFLElBQUEsSUFBSSxFQUFFLElBRlI7QUFHRSxJQUFBLFNBQVMsRUFBRSxzQkFIYjtBQUlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLElBQUEsV0FmRix1QkFlYyxFQWZkLEVBZWtCLElBZmxCLEVBZXdCLElBZnhCLEVBZTZCO0FBRXpCO0FBRUEsTUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLCtCQUFaLEVBQTZDLE9BQU8sQ0FBQyxHQUFSLENBQVksUUFBekQ7O0FBRUEsVUFBSyxPQUFPLEtBQUssQ0FBQyxlQUFiLEtBQWlDLFdBQXRDLEVBQW1EO0FBQ2pELFFBQUEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxvQkFBYjtBQUNELE9BUndCLENBU3pCOzs7QUFDQSxVQUFLLE9BQU8sS0FBSyxDQUFDLEtBQU4sQ0FBWSxPQUFuQixLQUErQixXQUEvQixJQUE4QyxPQUFPLEtBQUssQ0FBQyxLQUFOLENBQVksY0FBbkIsS0FBc0MsV0FBekYsRUFBdUc7QUFDckcsWUFBTSxVQUFVLEdBQUcsMEJBQWMsYUFBZCxDQUFuQjtBQUNBLFFBQUEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxZQUFiLEVBQTJCLFVBQTNCO0FBQ0QsT0Fid0IsQ0FlekI7QUFDQTtBQUdBOzs7QUFDQSxVQUFLLE9BQU8sS0FBSyxDQUFDLEtBQU4sQ0FBWSxNQUFaLENBQW1CLE1BQTFCLEtBQXFDLFdBQTFDLEVBQXdEO0FBQ3REO0FBQ0EsUUFBQSxLQUFLLENBQUMsUUFBTixDQUFlLGNBQWYsRUFDQyxJQURELENBQ00sWUFBTTtBQUNWO0FBQ0EsY0FBSSxZQUFZLEdBQUcsS0FBSyxDQUFDLE9BQU4sQ0FBYyw2QkFBZCxDQUE0QyxXQUE1QyxDQUFuQixDQUZVLENBR1Y7O0FBQ0EsY0FBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU4sQ0FBYyxVQUE5QjtBQUNBLGNBQU0sV0FBVyxHQUFHLFlBQVksQ0FBQyxRQUFiLENBQXNCLE9BQXRCLENBQXBCLENBTFUsQ0FNVjs7QUFDQSxVQUFBLEtBQUssQ0FBQyxNQUFOLENBQWEsZ0JBQWIsRUFBK0IsV0FBL0I7QUFDQSxVQUFBLElBQUk7QUFDTCxTQVZELEVBV0MsS0FYRCxDQVdPLFlBQU07QUFBQyxVQUFBLE9BQU8sQ0FBQyxHQUFSLENBQWEsVUFBYjtBQUEwQixVQUFBLElBQUksQ0FBQyxPQUFELENBQUo7QUFBYyxTQVh0RDtBQVlELE9BZEQsTUFjTztBQUNMLFFBQUEsSUFBSTtBQUNMO0FBQ0Y7QUFwREgsR0FESyxFQXlETDtBQUNFLElBQUEsSUFBSSxFQUFFLEdBRFI7QUFFRSxJQUFBLElBQUksRUFBRSxPQUZSO0FBR0UsSUFBQSxTQUFTLEVBQUUsdUJBSGIsQ0FJRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVJGLEdBekRLLENBQVA7QUFvRUQsQ0FyRU07Ozs7Ozs7Ozs7Ozs7O0FDckJQOztBQUNBOztBQUtBOzs7Ozs7Ozs7Ozs7QUFIQSxhQUFJLEdBQUosQ0FBUSxrQkFBUixFLENBRUE7OztBQUlBLElBQU0sZUFBZSxHQUFHLFNBQWxCLGVBQWtCLENBQVMsS0FBVCxFQUFlO0FBRXJDLE1BQU0sTUFBTSxzQkFFUCwyQ0FBdUIsS0FBdkIsQ0FGTyxDQUFaOztBQUtBLFNBQU8sSUFBSSxrQkFBSixDQUFjO0FBQ2pCLElBQUEsSUFBSSxFQUFFLFNBRFc7QUFFakIsSUFBQSxNQUFNLEVBQU4sTUFGaUI7QUFHakIsSUFBQSxLQUFLLEVBQUMsSUFIVztBQUlqQixJQUFBLGNBSmlCLDBCQUlELEVBSkMsRUFJRyxJQUpILEVBSVMsYUFKVCxFQUl3QjtBQUN2QyxhQUFPLGFBQWEsR0FBRyxhQUFILEdBQW1CO0FBQUUsUUFBQSxDQUFDLEVBQUUsQ0FBTDtBQUFRLFFBQUEsQ0FBQyxFQUFFO0FBQVgsT0FBdkM7QUFDRDtBQU5nQixHQUFkLENBQVA7QUFRRCxDQWZEOztlQWlCZSxlOzs7Ozs7Ozs7OztBQzFCZjs7QUFFQTs7QUFDQTs7OztBQUZBO2VBVWU7QUFHYjtBQUNBLEVBQUEsb0JBSmEsc0NBSWlDO0FBQUEsUUFBeEIsS0FBd0IsUUFBeEIsS0FBd0I7QUFBQSxRQUFqQixPQUFpQixRQUFqQixPQUFpQjtBQUFBLFFBQVIsTUFBUSxRQUFSLE1BQVE7QUFDNUM7QUFDQSxRQUFNLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyx3QkFBckMsQ0FGNEMsQ0FHNUM7O0FBQ0EsUUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsQ0FBQyxjQUFqRCxFQUFnRTtBQUM5RCxVQUFJLGtCQUFrQixHQUFHLG9CQUFvQixDQUFDLGNBQTlDO0FBQ0EsTUFBQSxNQUFNLENBQUMsdUJBQUQsRUFBMEIsa0JBQTFCLENBQU47QUFDQSxNQUFBLE1BQU0sQ0FBQyxpQkFBRCxDQUFOO0FBQ0Q7QUFDRixHQWJZO0FBZWI7QUFDQSxFQUFBLFlBaEJhLHNDQWdCb0Q7QUFBQSxRQUFuRCxLQUFtRCxTQUFuRCxLQUFtRDtBQUFBLFFBQTVDLE1BQTRDLFNBQTVDLE1BQTRDO0FBQUEsUUFBcEMsUUFBb0MsU0FBcEMsUUFBb0M7QUFBQSxRQUExQixPQUEwQixTQUExQixPQUEwQjtBQUFBLFFBQWYsTUFBZSxTQUFmLE1BQWU7QUFBQSxRQUFQLEtBQU8sU0FBUCxLQUFPO0FBQy9EO0FBQ0EsUUFBTSxlQUFlLEdBQUcsSUFBSSxHQUFKLENBQVEsT0FBTyxDQUFDLGtCQUFoQixDQUF4QixDQUYrRCxDQUcvRDs7QUFDQSxRQUFNLGNBQWMsR0FBRyxlQUFlLENBQUMsR0FBaEIsQ0FBb0IsTUFBcEIsQ0FBdkI7QUFDQSxRQUFHLGNBQWMsQ0FBQyxHQUFmLENBQW1CLEtBQW5CLENBQUgsRUFDRSxjQUFjLENBQUMsTUFBZixDQUFzQixLQUF0QixFQURGLEtBR0UsY0FBYyxDQUFDLEdBQWYsQ0FBbUIsS0FBbkI7QUFFRixJQUFBLE1BQU0sQ0FBQyxvQkFBRCxFQUF1QjtBQUFDLE1BQUEsZUFBZSxFQUFmO0FBQUQsS0FBdkIsQ0FBTjtBQUNBLElBQUEsUUFBUSxDQUFDLFFBQUQsQ0FBUjtBQUNELEdBNUJZO0FBOEJiLEVBQUEsY0E5QmEsd0NBOEIrQztBQUFBLFFBQTVDLEtBQTRDLFNBQTVDLEtBQTRDO0FBQUEsUUFBckMsTUFBcUMsU0FBckMsTUFBcUM7QUFBQSxRQUE3QixRQUE2QixTQUE3QixRQUE2QjtBQUFBLFFBQW5CLE9BQW1CLFNBQW5CLE9BQW1CO0FBQUEsUUFBUixNQUFRLFNBQVIsTUFBUTtBQUMxRDtBQUNBLFFBQU0sZUFBZSxHQUFHLElBQUksR0FBSixDQUFRLE9BQU8sQ0FBQyxrQkFBaEIsQ0FBeEI7QUFDQSxJQUFBLGVBQWUsQ0FBQyxHQUFoQixDQUFvQixNQUFwQixFQUE0QixJQUFJLEdBQUosRUFBNUI7QUFFQSxJQUFBLE1BQU0sQ0FBQyxvQkFBRCxFQUF1QjtBQUFDLE1BQUEsZUFBZSxFQUFmO0FBQUQsS0FBdkIsQ0FBTjtBQUNBLElBQUEsUUFBUSxDQUFDLFFBQUQsQ0FBUjtBQUNELEdBckNZO0FBdUNiLEVBQUEsZUF2Q2Esa0NBdUNzQjtBQUFBLFFBQWxCLE1BQWtCLFNBQWxCLE1BQWtCO0FBQUEsUUFBVixRQUFVLFNBQVYsUUFBVTtBQUNqQztBQUNBLElBQUEsTUFBTSxDQUFDLGlCQUFELENBQU47QUFDQSxJQUFBLFFBQVEsQ0FBQyxRQUFELENBQVI7QUFDRCxHQTNDWTtBQTZDYjtBQUNBLEVBQUEsbUJBOUNhLDZDQThDMEM7QUFBQSxRQUFsQyxNQUFrQyxTQUFsQyxNQUFrQztBQUFBLFFBQTFCLFFBQTBCLFNBQTFCLFFBQTBCO0FBQUEsUUFBZCxZQUFjLFNBQWQsWUFBYztBQUNyRDtBQUNBLElBQUEsTUFBTSxDQUFDLGlCQUFELEVBQW9CO0FBQUMsTUFBQSxZQUFZLEVBQVo7QUFBRCxLQUFwQixDQUFOO0FBQ0EsSUFBQSxRQUFRLENBQUMsUUFBRCxDQUFSO0FBQ0QsR0FsRFk7QUFxRGI7QUFDQSxFQUFBLE1BdERhLHlCQXNENkI7QUFBQSxRQUFsQyxLQUFrQyxTQUFsQyxLQUFrQztBQUFBLFFBQTNCLE1BQTJCLFNBQTNCLE1BQTJCO0FBQUEsUUFBbkIsUUFBbUIsU0FBbkIsUUFBbUI7QUFBQSxRQUFULE9BQVMsU0FBVCxPQUFTO0FBRXhDO0FBRndDLFFBR2pDLE1BSGlDLEdBR3ZCLEtBSHVCLENBR2pDLE1BSGlDLEVBSXhDOztBQUVBLFFBQU0sZUFBZSxHQUFHLDJDQUErQixPQUFPLENBQUMsa0JBQXZDLENBQXhCLENBTndDLENBT3hDO0FBQ0E7O0FBQ0EsUUFBRyxNQUFNLENBQUMsTUFBUCxDQUFjLFlBQWpCLEVBQThCO0FBQzVCLE1BQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxZQUFkLENBQTJCLEtBQTNCO0FBQ0QsS0FYdUMsQ0FjeEM7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBQ0EsUUFBSSxpQkFBaUIsR0FBRyxvQ0FBd0I7QUFDOUMsTUFBQSxjQUFjLEVBQUcsS0FBSyxDQUFDLE1BQU4sQ0FBYSxRQURnQjtBQUU5QyxNQUFBLGNBQWMsRUFBRyxLQUFLLENBQUMsTUFBTixDQUFhLFFBRmdCO0FBRzlDLE1BQUEsZUFBZSxFQUFHO0FBSDRCLEtBQXhCLENBQXhCLENBbEN3QyxDQXVDeEM7QUFHQTtBQUNBOztBQUNBLFFBQU0sa0JBQWtCLEdBQUcsd0JBQVksaUJBQVosQ0FBM0I7QUFDQSxJQUFBLE1BQU0sQ0FBQyxrQkFBRCxFQUFxQjtBQUFFLE1BQUEsWUFBWSxFQUFFO0FBQWhCLEtBQXJCLENBQU47QUFFQSxJQUFBLGtCQUFrQixDQUFDLE9BQW5CLENBQ0csSUFESCxDQUNRLGtCQUF1QjtBQUFBLFVBQXJCLFFBQXFCLFVBQXJCLFFBQXFCO0FBQUEsVUFBWCxLQUFXLFVBQVgsS0FBVztBQUMzQjtBQUNBO0FBRUE7QUFDQSxNQUFBLE1BQU0sQ0FBQyxpQkFBRCxFQUFvQjtBQUFDLFFBQUEsTUFBTSxFQUFFO0FBQUMsVUFBQSxRQUFRLEVBQVIsUUFBRDtBQUFXLFVBQUEsS0FBSyxFQUFMO0FBQVg7QUFBVCxPQUFwQixDQUFOLENBTDJCLENBTTNCO0FBQ0QsS0FSSCxFQVNHLEtBVEgsQ0FTUyxVQUFBLEtBQUssRUFBSTtBQUNkO0FBQ0EsVUFBSSxLQUFLLENBQUMsSUFBTixLQUFlLFlBQW5CLEVBQ0UsTUFBTSxDQUFDLGdCQUFELEVBQW1CO0FBQUMsUUFBQSxLQUFLLEVBQUw7QUFBRCxPQUFuQixDQUFOO0FBQ0gsS0FiSDtBQWNELEdBbkhZO0FBc0hiO0FBQ0E7QUFDQSxFQUFBLG1CQXhIYSx1Q0F3SGlCLFFBeEhqQixFQXdIMEI7QUFBQSxRQUFsQixNQUFrQixVQUFsQixNQUFrQjtBQUNyQyxRQUFNLHVCQUF1QixHQUFHLFFBQVEsQ0FBQyxNQUFULENBQWdCLFVBQUEsQ0FBQztBQUFBLGFBQUksQ0FBQyxDQUFDLFNBQUQsQ0FBTDtBQUFBLEtBQWpCLENBQWhDO0FBQ0EsUUFBTSxTQUFTLEdBQUcsdUJBQXVCLENBQUMsR0FBeEIsQ0FBNEIsVUFBQSxDQUFDO0FBQUEsYUFBSSxDQUFDLENBQUMsU0FBRCxDQUFELENBQWEsT0FBYixDQUFxQixhQUFyQixFQUFvQyxFQUFwQyxFQUF3QyxLQUF4QyxDQUE4QyxDQUE5QyxFQUFpRCxHQUFqRCxDQUFKO0FBQUEsS0FBN0IsQ0FBbEI7QUFFQSxRQUFNLFdBQVcsR0FBRyxjQUFjLFNBQVMsQ0FBQyxJQUFWLENBQWUsSUFBZixDQUFsQztBQUNBLFFBQU0saUJBQWlCLEdBQUcsSUFBSSxRQUFKLEVBQTFCO0FBQ0EsSUFBQSxpQkFBaUIsQ0FBQyxNQUFsQixDQUF5QixNQUF6QixFQUFpQyxJQUFJLElBQUosQ0FBUyxDQUFDLFdBQUQsQ0FBVCxFQUF3QixjQUF4QixDQUFqQztBQUVBLFdBQU8sS0FBSyxDQUFDLDhDQUFELEVBQWlEO0FBQzNELE1BQUEsTUFBTSxFQUFFLE1BRG1EO0FBRTNELE1BQUEsSUFBSSxFQUFFO0FBRnFELEtBQWpELENBQUwsQ0FJTixJQUpNLENBSUQsVUFBQSxDQUFDO0FBQUEsYUFBSSxDQUFDLENBQUMsSUFBRixFQUFKO0FBQUEsS0FKQSxFQUtOLElBTE0sQ0FLRCxVQUFBLFVBQVUsRUFBSTtBQUNsQixVQUFNLE9BQU8sR0FBRyxxQkFBUyxVQUFULENBQWhCO0FBRUEsVUFBTSxpQkFBaUIsR0FBRyxJQUFJLEdBQUosRUFBMUI7QUFFQSxNQUFBLHVCQUF1QixDQUFDLE9BQXhCLENBQWdDLGtCQUFPLENBQVAsRUFBYTtBQUFBLFlBQVgsRUFBVyxVQUFYLEVBQVc7QUFBQSx5QkFDYixPQUFPLENBQUMsQ0FBRCxDQURNO0FBQUEsWUFDcEMsUUFEb0MsY0FDcEMsUUFEb0M7QUFBQSxZQUMxQixTQUQwQixjQUMxQixTQUQwQjtBQUczQyxRQUFBLGlCQUFpQixDQUFDLEdBQWxCLENBQ0UsRUFERixFQUVHLE1BQU0sQ0FBQyxRQUFQLENBQWdCLFVBQVUsQ0FBQyxRQUFELENBQTFCLEtBQXlDLE1BQU0sQ0FBQyxRQUFQLENBQWdCLFVBQVUsQ0FBQyxTQUFELENBQTFCLENBQTFDLEdBQ0U7QUFBQyxVQUFBLFFBQVEsRUFBRSxVQUFVLENBQUMsUUFBRCxDQUFyQjtBQUFpQyxVQUFBLFNBQVMsRUFBRSxVQUFVLENBQUMsU0FBRDtBQUF0RCxTQURGLEdBRUUsS0FKSjtBQU1ELE9BVEQ7QUFXQSxNQUFBLFFBQVEsQ0FBQyxPQUFULENBQWlCLGtCQUFVO0FBQUEsWUFBUixFQUFRLFVBQVIsRUFBUTs7QUFDekIsWUFBRyxDQUFDLGlCQUFpQixDQUFDLEdBQWxCLENBQXNCLEVBQXRCLENBQUosRUFBOEI7QUFDNUIsVUFBQSxpQkFBaUIsQ0FBQyxHQUFsQixDQUFzQixFQUF0QixFQUEwQixLQUExQjtBQUNEO0FBQ0YsT0FKRDtBQU1BLE1BQUEsTUFBTSxDQUFDLFlBQUQsRUFBZTtBQUFDLFFBQUEsaUJBQWlCLEVBQWpCO0FBQUQsT0FBZixDQUFOO0FBQ0QsS0E1Qk0sQ0FBUDtBQTZCRCxHQTdKWTtBQThKYjtBQUlBO0FBQ0EsRUFBQSxZQW5LYSxnQ0FtS1k7QUFBQSxRQUFYLFFBQVcsVUFBWCxRQUFXO0FBQ3ZCLFFBQUksR0FBRyxHQUFHLEVBQVY7QUFDQSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsUUFBUSxDQUFDLGVBQUQsRUFBaUI7QUFBQyxNQUFBLElBQUksRUFBQyxRQUFOO0FBQW1CLE1BQUEsa0JBQWtCLEVBQUMsUUFBdEM7QUFBZ0QsTUFBQSxJQUFJLEVBQUM7QUFBckQsS0FBakIsQ0FBakI7QUFDQSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsUUFBUSxDQUFDLGVBQUQsRUFBaUI7QUFBQyxNQUFBLElBQUksRUFBQyxRQUFOO0FBQW1CLE1BQUEsa0JBQWtCLEVBQUMsUUFBdEM7QUFBZ0QsTUFBQSxJQUFJLEVBQUM7QUFBckQsS0FBakIsQ0FBakI7QUFDQSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsUUFBUSxDQUFDLGVBQUQsRUFBaUI7QUFBQyxNQUFBLElBQUksRUFBQyxTQUFOO0FBQW1CLE1BQUEsa0JBQWtCLEVBQUMsU0FBdEM7QUFBaUQsTUFBQSxJQUFJLEVBQUM7QUFBdEQsS0FBakIsQ0FBakI7QUFDQSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsUUFBUSxDQUFDLGVBQUQsRUFBaUI7QUFBQyxNQUFBLElBQUksRUFBQyxRQUFOO0FBQW1CLE1BQUEsa0JBQWtCLEVBQUMsUUFBdEM7QUFBZ0QsTUFBQSxJQUFJLEVBQUM7QUFBckQsS0FBakIsQ0FBakI7QUFDQSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsUUFBUSxDQUFDLGVBQUQsRUFBaUI7QUFBQyxNQUFBLElBQUksRUFBQyxRQUFOO0FBQW1CLE1BQUEsa0JBQWtCLEVBQUMsUUFBdEM7QUFBZ0QsTUFBQSxJQUFJLEVBQUM7QUFBckQsS0FBakIsQ0FBakI7QUFDQSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsUUFBUSxDQUFDLGVBQUQsRUFBaUI7QUFBQyxNQUFBLElBQUksRUFBQyxRQUFOO0FBQW1CLE1BQUEsa0JBQWtCLEVBQUMsUUFBdEM7QUFBZ0QsTUFBQSxJQUFJLEVBQUM7QUFBckQsS0FBakIsQ0FBakI7QUFDQSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsUUFBUSxDQUFDLGVBQUQsRUFBaUI7QUFBQyxNQUFBLElBQUksRUFBQyxNQUFOO0FBQW1CLE1BQUEsa0JBQWtCLEVBQUMsTUFBdEM7QUFBOEMsTUFBQSxJQUFJLEVBQUM7QUFBbkQsS0FBakIsQ0FBakI7QUFDQSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsUUFBUSxDQUFDLGVBQUQsRUFBaUI7QUFBQyxNQUFBLElBQUksRUFBQyxXQUFOO0FBQW1CLE1BQUEsa0JBQWtCLEVBQUMsV0FBdEM7QUFBbUQsTUFBQSxJQUFJLEVBQUM7QUFBeEQsS0FBakIsQ0FBakI7QUFDQSxXQUFPLE9BQU8sQ0FBQyxHQUFSLENBQVksR0FBWixDQUFQO0FBQ0QsR0E5S1k7QUFnTGIsRUFBQSxhQWhMYSx5Q0FnTG1EO0FBQUEsUUFBakQsTUFBaUQsVUFBakQsTUFBaUQ7QUFBQSxRQUF6QyxPQUF5QyxVQUF6QyxPQUF5QztBQUFBLFFBQS9CLElBQStCLFVBQS9CLElBQStCO0FBQUEsUUFBMUIsa0JBQTBCLFVBQTFCLGtCQUEwQjtBQUFBLFFBQVAsSUFBTyxVQUFQLElBQU87QUFDOUQsUUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLGlCQUEvQjtBQUNBLFFBQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxrQkFBaEM7QUFDQSxXQUFPLGVBQ04sR0FETSxDQUNGLGNBQWMsR0FBQyxVQUFmLEdBQTBCLGtCQUExQixHQUE2QyxRQUE3QyxHQUFzRCxlQUF0RCxHQUFzRSxJQURwRSxFQUVQO0FBRk8sS0FHTixJQUhNLENBR0QsVUFBQSxRQUFRLEVBQUk7QUFDaEI7QUFDQSxVQUFJLFVBQVUsR0FBSSxRQUFRLElBQUksUUFBUSxDQUFDLElBQXJCLElBQTZCLFFBQVEsQ0FBQyxJQUFULENBQWMsVUFBNUMsR0FBMEQsUUFBUSxDQUFDLElBQVQsQ0FBYyxVQUF4RSxHQUFxRixTQUF0RztBQUNBLE1BQUEsTUFBTSxDQUFDLFdBQUQsRUFBYztBQUFDLFFBQUEsSUFBSSxFQUFDLElBQU47QUFBVyxRQUFBLE1BQU0sRUFBQztBQUFsQixPQUFkLENBQU47QUFDQSxhQUFPLFVBQVA7QUFDRCxLQVJNLEVBU04sS0FUTSxDQVNDLFVBQUEsR0FBRztBQUFBLGFBQUksT0FBTyxDQUFDLEdBQVIsQ0FBWSw0REFBWixFQUF5RSxHQUF6RSxDQUFKO0FBQUEsS0FUSixDQUFQO0FBVUQsR0E3TFk7QUFnTWI7QUFDQSxFQUFBLHNCQWpNYSwwQ0FpTW9CO0FBQUEsUUFBVCxNQUFTLFVBQVQsTUFBUztBQUMvQjtBQUNBLFFBQU0sY0FBYyxHQUFHO0FBQ3JCLE1BQUEsV0FBVyxFQUFHLENBRE87QUFFckIsTUFBQSxnQkFBZ0IsRUFBRyxFQUZFO0FBR3JCLE1BQUEsd0JBQXdCLEVBQUcsRUFITjtBQUlyQixNQUFBLHlCQUF5QixFQUFHO0FBSlAsS0FBdkI7QUFNQSxJQUFBLE1BQU0sQ0FBQyxpQkFBRCxFQUFvQjtBQUFDLE1BQUEsSUFBSSxFQUFDLFNBQU47QUFBZ0IsTUFBQSxNQUFNLEVBQUM7QUFBdkIsS0FBcEIsQ0FBTjtBQUNELEdBMU1ZO0FBNE1iO0FBQ0EsRUFBQSxjQTdNYSwwQ0E2TW1DO0FBQUEsUUFBaEMsTUFBZ0MsVUFBaEMsTUFBZ0M7QUFBQSxRQUF4QixPQUF3QixVQUF4QixPQUF3QjtBQUFBLFFBQWIsV0FBYSxVQUFiLFdBQWE7QUFFOUMsUUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLHFCQUEzQjtBQUNBLElBQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxzQkFBWixFQUFvQyxVQUFwQztBQUVBLFFBQU0sZUFBZSxHQUFHLFVBQVUsQ0FBQyxXQUFYLENBQXVCLFlBQXZCLENBQW9DLElBQTVEO0FBQ0EsUUFBTSxnQkFBZ0IsR0FBRyxVQUFVLENBQUMsV0FBWCxDQUF1QixhQUF2QixDQUFxQyxJQUE5RDtBQUNBLFFBQU0sWUFBWSxHQUFHLFVBQVUsQ0FBQyxXQUFYLENBQXVCLFNBQXZCLENBQWlDLElBQXREO0FBQ0EsUUFBTSxVQUFVLEdBQUcsVUFBVSxDQUFDLFdBQVgsQ0FBdUIsT0FBdkIsQ0FBK0IsSUFBbEQ7QUFDQSxRQUFNLFlBQVksR0FBRyxVQUFVLENBQUMsV0FBWCxDQUF1QixTQUF2QixDQUFpQyxJQUF0RDtBQUNBLFFBQU0sZUFBZSxHQUFHLFVBQVUsQ0FBQyxXQUFYLENBQXVCLFlBQXZCLENBQW9DLElBQTVEO0FBQ0EsUUFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDLFdBQVgsQ0FBdUIsV0FBdkIsQ0FBbUMsSUFBMUQ7QUFDQSxRQUFNLGFBQWEsR0FBRyxVQUFVLENBQUMsV0FBWCxDQUF1QixVQUF2QixDQUFrQyxJQUF4RDtBQUVBLFFBQUksQ0FBQyxHQUFHLFdBQVI7QUFDQSxJQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksMkJBQVosRUFBeUMsQ0FBekMsRUFmOEMsQ0FpQjlDOztBQUNBLFFBQUksTUFBTSxHQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBUixHQUFpQjtBQUM1QixNQUFBLFlBQVksRUFBSyxrQ0FBc0IsQ0FBQyxDQUFDLElBQXhCLEVBQThCLGVBQTlCLENBRFc7QUFFNUIsTUFBQSxhQUFhLEVBQUcsa0NBQXNCLENBQUMsQ0FBQyxJQUF4QixFQUE4QixnQkFBOUI7QUFGWSxLQUFqQixHQUdULFNBSEosQ0FsQjhDLENBc0I5QztBQUVBOztBQUNBLFFBQUksS0FBSyxHQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBVCxHQUFrQjtBQUMxQixNQUFBLElBQUksRUFBTSxrQ0FBc0IsQ0FBQyxDQUFDLElBQXhCLEVBQThCLFlBQTlCLENBRGdCO0FBRTFCLE1BQUEsT0FBTyxFQUFHLGtDQUFzQixDQUFDLENBQUMsSUFBeEIsRUFBOEIsZUFBOUIsQ0FGZ0I7QUFHMUIsTUFBQSxLQUFLLEVBQUssa0NBQXNCLENBQUMsQ0FBQyxJQUF4QixFQUE4QixhQUE5QixDQUhnQjtBQUkxQixNQUFBLEVBQUUsRUFBUSxrQ0FBc0IsQ0FBQyxDQUFDLElBQXhCLEVBQThCLFVBQTlCLENBSmdCO0FBSzFCLE1BQUEsTUFBTSxFQUFJLGtDQUFzQixDQUFDLENBQUMsSUFBeEIsRUFBOEIsY0FBOUI7QUFMZ0IsS0FBbEIsR0FNUixTQU5KLENBekI4QyxDQWdDOUM7QUFFQTs7QUFDQSxRQUFJLElBQUksR0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQVQsR0FBa0Isa0NBQXNCLENBQUMsQ0FBQyxJQUF4QixFQUE4QixZQUE5QixDQUFsQixHQUFnRSxTQUEzRTtBQUVBLElBQUEsTUFBTSxDQUFDLFdBQUQsRUFBYztBQUFDLE1BQUEsTUFBTSxFQUFOO0FBQUQsS0FBZCxDQUFOO0FBQ0EsSUFBQSxNQUFNLENBQUMsVUFBRCxFQUFjO0FBQUMsTUFBQSxLQUFLLEVBQUw7QUFBRCxLQUFkLENBQU47QUFDQSxJQUFBLE1BQU0sQ0FBQyxTQUFELEVBQWM7QUFBQyxNQUFBLElBQUksRUFBSjtBQUFELEtBQWQsQ0FBTixDQXZDOEMsQ0F5QzlDOztBQUNBLElBQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxxQ0FBWixFQUFtRCxPQUFPLENBQUMsZ0JBQVIsQ0FBeUIsT0FBekIsQ0FBbkQ7QUFDQSxJQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVkscUNBQVosRUFBbUQsT0FBTyxDQUFDLGdCQUFSLENBQXlCLE9BQXpCLENBQW5EO0FBQ0QsR0F6UFk7QUEwUGIsRUFBQSxNQTFQYSwwQkEwUEc7QUFBQSxRQUFSLE1BQVEsVUFBUixNQUFRO0FBQ2QsSUFBQSxNQUFNLENBQUMsV0FBRCxFQUFjLEVBQWQsQ0FBTjtBQUNBLElBQUEsTUFBTSxDQUFDLFVBQUQsRUFBYyxFQUFkLENBQU47QUFDQSxJQUFBLE1BQU0sQ0FBQyxTQUFELEVBQWMsRUFBZCxDQUFOO0FBQ0QsR0E5UFk7QUFpUWI7QUFDQSxFQUFBLHVCQWxRYSxtREFrUTBDO0FBQUEsUUFBOUIsTUFBOEIsVUFBOUIsTUFBOEI7QUFBQSxRQUF2QixPQUF1QixVQUF2QixPQUF1QjtBQUFBLFFBQWYsS0FBZSxVQUFmLEtBQWU7QUFBQSxRQUFQLElBQU8sVUFBUCxJQUFPO0FBRXJELFFBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxxQkFBUixDQUE4QixJQUE5QixDQUFsQjtBQUVBLElBQUEsTUFBTSxDQUFDLGdCQUFELEVBQWtCO0FBQUMsTUFBQSxJQUFJLEVBQUMsb0JBQU47QUFBNEIsTUFBQSxNQUFNLEVBQUM7QUFBbkMsS0FBbEIsQ0FBTjtBQUNBLElBQUEsTUFBTSxDQUFDLGdCQUFELEVBQWtCO0FBQUMsTUFBQSxJQUFJLEVBQUMsYUFBTjtBQUFxQixNQUFBLE1BQU0sRUFBQyxXQUFXLENBQUM7QUFBeEMsS0FBbEIsQ0FBTjtBQUNBLElBQUEsTUFBTSxDQUFDLGdCQUFELEVBQWtCO0FBQUMsTUFBQSxJQUFJLEVBQUMsZUFBTjtBQUF1QixNQUFBLE1BQU0sRUFBQyxXQUFXLENBQUM7QUFBMUMsS0FBbEIsQ0FBTjtBQUVBLFFBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyxpQkFBN0I7QUFDQSxJQUFBLE1BQU0sQ0FBQyxnQkFBRCxFQUFrQjtBQUFDLE1BQUEsSUFBSSxFQUFDLFVBQU47QUFBaUIsTUFBQSxNQUFNLEVBQUM7QUFBeEIsS0FBbEIsQ0FBTjtBQUVEO0FBN1FZLEM7Ozs7Ozs7Ozs7O0FDVmY7O0FBR0EsSUFBTSwwQkFBMEIsR0FBRyxTQUE3QiwwQkFBNkIsQ0FBQSxLQUFLO0FBQUEsU0FBSSxLQUFLLENBQUMsTUFBTixDQUFhLE1BQWIsQ0FBb0IsT0FBcEIsQ0FBNEIsV0FBaEM7QUFBQSxDQUF4Qzs7QUFDQSxJQUFNLCtCQUErQixHQUFHLFNBQWxDLCtCQUFrQyxDQUFBLEtBQUs7QUFBQSxTQUFJLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFBYixDQUFvQixPQUFwQixDQUE0QixnQkFBaEM7QUFBQSxDQUE3Qzs7QUFDQSxJQUFNLHVDQUF1QyxHQUFHLFNBQTFDLHVDQUEwQyxDQUFBLEtBQUs7QUFBQSxTQUFJLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFBYixDQUFvQixPQUFwQixDQUE0Qix3QkFBaEM7QUFBQSxDQUFyRDs7QUFDQSxJQUFNLHdDQUF3QyxHQUFHLFNBQTNDLHdDQUEyQyxDQUFBLEtBQUs7QUFBQSxTQUFJLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFBYixDQUFvQixPQUFwQixDQUE0Qix5QkFBaEM7QUFBQSxDQUF0RCxDLENBRUE7QUFDQTs7O0FBQ0UsSUFBTSxjQUFjLEdBQUcsU0FBakIsY0FBaUIsQ0FBQyxLQUFEO0FBQUEsU0FBVyxVQUFDLFNBQUQsRUFBZTtBQUMvQyxRQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBckI7QUFDQSxRQUFNLFNBQVMsR0FBRyxNQUFsQixDQUYrQyxDQUcvQzs7QUFDQSxXQUFPLDJCQUFnQixTQUFTLENBQUMsS0FBMUIsRUFBaUMsTUFBakMsRUFBeUMsU0FBekMsQ0FBUDtBQUNELEdBTHNCO0FBQUEsQ0FBdkIsQyxDQU9GOzs7QUFDRSxJQUFNLG1CQUFtQixHQUFHLFNBQXRCLG1CQUFzQixDQUFBLEtBQUssRUFBSTtBQUNuQyxTQUFPLEtBQUssQ0FBQyxPQUFiO0FBQ0QsQ0FGRCxDLENBSUY7QUFDQTs7O0FBQ0UsSUFBTSxrQkFBa0IsR0FBRyxTQUFyQixrQkFBcUIsQ0FBQSxLQUFLLEVBQUk7QUFDbEMsRUFBQSxPQUFPLENBQUMsR0FBUixDQUFhLHVCQUFiLEVBQXNDLEtBQUssQ0FBQyxlQUE1QztBQUNBLFNBQU8sS0FBSyxDQUFDLGVBQWI7QUFDRCxDQUhEOztBQUlBLElBQU0sVUFBVSxHQUFHLFNBQWIsVUFBYSxDQUFBLEtBQUssRUFBSTtBQUMxQixTQUFPLEtBQUssQ0FBQyxPQUFiO0FBQ0QsQ0FGRDs7QUFHQSxJQUFNLGlCQUFpQixHQUFHLFNBQXBCLGlCQUFvQixDQUFBLEtBQUssRUFBSTtBQUNqQyxFQUFBLE9BQU8sQ0FBQyxHQUFSLENBQWEsbUJBQWIsRUFBa0MsS0FBSyxDQUFDLGNBQXhDO0FBQ0EsU0FBTyxLQUFLLENBQUMsY0FBYjtBQUNELENBSEQ7O0FBSUEsSUFBTSxjQUFjLEdBQUcsU0FBakIsY0FBaUIsQ0FBQSxLQUFLLEVBQUk7QUFDOUIsU0FBTyxLQUFLLENBQUMsV0FBYjtBQUNELENBRkQsQyxDQUdBO0FBQ0E7QUFDQTs7O0FBRUEsSUFBTSxlQUFlLEdBQUcsU0FBbEIsZUFBa0IsQ0FBQSxLQUFLLEVBQUk7QUFDL0I7QUFDQSxNQUFJLENBQUMsS0FBSyxDQUFDLE1BQVAsSUFDQyxDQUFDLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFEbkIsRUFFSSxDQUNBO0FBQ0g7O0FBQ0QsU0FBTyxLQUFLLENBQUMsTUFBTixDQUFhLE1BQXBCO0FBQ0QsQ0FSRDs7QUFTQSxJQUFNLGVBQWUsR0FBRyxTQUFsQixlQUFrQixDQUFBLEtBQUssRUFBSTtBQUMvQjtBQUNBLE1BQUksQ0FBQyxLQUFLLENBQUMsTUFBUCxJQUNDLENBQUMsS0FBSyxDQUFDLE1BQU4sQ0FBYSxNQURuQixFQUVJLENBQ0E7QUFDSDs7QUFDRCxTQUFPLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFBcEI7QUFDRCxDQVJEOztBQVNBLElBQU0sZ0JBQWdCLEdBQUcsU0FBbkIsZ0JBQW1CLENBQUEsS0FBSyxFQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxPQUFwQjtBQUNELENBUkQ7O0FBU0EsSUFBTSxlQUFlLEdBQUcsU0FBbEIsZUFBa0IsQ0FBQSxLQUFLLEVBQUk7QUFDL0I7QUFDQSxNQUFJLENBQUMsS0FBSyxDQUFDLE1BQVAsSUFDQyxDQUFDLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFEbkIsRUFFSSxDQUNBO0FBQ0g7O0FBQ0QsU0FBTyxLQUFLLENBQUMsTUFBTixDQUFhLE1BQWIsQ0FBb0IsVUFBM0I7QUFDRCxDQVJEOztBQVNBLElBQU0sZUFBZSxHQUFHLFNBQWxCLGVBQWtCLENBQUEsS0FBSyxFQUFJO0FBQy9CO0FBQ0EsTUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFQLElBQ0MsQ0FBQyxLQUFLLENBQUMsTUFBTixDQUFhLE1BRG5CLEVBRUksQ0FDQTtBQUNIOztBQUNELFNBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxNQUFiLENBQW9CLFVBQTNCO0FBQ0QsQ0FSRCxDLENBVUY7QUFDQTs7O0FBQ0UsSUFBTSxxQkFBcUIsR0FBRyxTQUF4QixxQkFBd0IsQ0FBQyxLQUFEO0FBQUEsU0FBVyxVQUFDLFlBQUQsRUFBa0I7QUFDekQ7QUFDQTtBQUNBLFFBQUk7QUFDRixhQUFPLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFBYixDQUFvQixJQUFwQixDQUF5QixVQUFTLENBQVQsRUFBWTtBQUMxQyxlQUFPLENBQUMsQ0FBQyxJQUFGLENBQU8sT0FBUCxDQUFlLFlBQWYsTUFBaUMsQ0FBQyxDQUF6QztBQUNELE9BRk0sQ0FBUDtBQUdELEtBSkQsQ0FJRSxPQUFPLENBQVAsRUFBVTtBQUNWLE1BQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxLQUFaLEVBQWtCLENBQWxCO0FBQ0EsYUFBTyxTQUFQO0FBQ0Q7QUFDRixHQVg2QjtBQUFBLENBQTlCOztBQVlBLElBQU0sNEJBQTRCLEdBQUcsU0FBL0IsNEJBQStCLENBQUEsS0FBSyxFQUFJO0FBQzVDLFNBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxNQUFiLENBQW9CLElBQXBCLENBQXlCLFVBQVMsQ0FBVCxFQUFZO0FBQzFDLFdBQU8sQ0FBQyxDQUFDLGFBQUYsS0FBb0IsTUFBcEIsSUFDSixDQUFDLENBQUMsV0FBRixLQUFrQixLQUFLLENBQUMsTUFBTixDQUFhLFdBRGxDO0FBRUQsR0FITSxDQUFQO0FBSUQsQ0FMRDs7QUFNQSxJQUFNLDJCQUEyQixHQUFHLFNBQTlCLDJCQUE4QixDQUFBLEtBQUssRUFBSTtBQUMzQyxTQUFPLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFBYixDQUFvQixJQUFwQixDQUF5QixVQUFTLENBQVQsRUFBWTtBQUMxQyxXQUFPLENBQUMsQ0FBQyxhQUFGLEtBQW9CLEtBQXBCLElBQ0osQ0FBQyxDQUFDLFdBQUYsS0FBa0IsS0FBSyxDQUFDLE1BQU4sQ0FBYSxXQURsQztBQUVELEdBSE0sQ0FBUDtBQUlELENBTEQ7O0FBTUEsSUFBTSw0QkFBNEIsR0FBRyxTQUEvQiw0QkFBK0IsQ0FBQSxLQUFLLEVBQUk7QUFDNUMsU0FBTyxLQUFLLENBQUMsTUFBTixDQUFhLE1BQWIsQ0FBb0IsSUFBcEIsQ0FBeUIsVUFBUyxDQUFULEVBQVk7QUFDMUMsV0FBTyxDQUFDLENBQUMsYUFBRixLQUFvQixNQUFwQixJQUNKLENBQUMsQ0FBQyxXQUFGLEtBQWtCLEtBQUssQ0FBQyxNQUFOLENBQWEsV0FEbEM7QUFFRCxHQUhNLENBQVA7QUFJRCxDQUxEOztBQU1BLElBQU0sa0NBQWtDLEdBQUcsU0FBckMsa0NBQXFDLENBQUEsS0FBSyxFQUFJO0FBQ2xELFNBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxNQUFiLENBQW9CLDhCQUFwQixDQUFtRCxXQUFuRCxDQUErRCxJQUEvRCxDQUFvRSxVQUFTLENBQVQsRUFBWTtBQUNyRixXQUFPLENBQUMsQ0FBQyxXQUFGLEtBQWtCLEtBQUssQ0FBQyxNQUFOLENBQWEsV0FBdEM7QUFDRCxHQUZNLENBQVA7QUFHRCxDQUpEOztBQUtBLElBQU0sbUJBQW1CLEdBQUcsU0FBdEIsbUJBQXNCLENBQUEsS0FBSyxFQUFJO0FBQ25DLFNBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxXQUFwQjtBQUNELENBRkQsQyxDQUlGO0FBQ0E7OztBQUNFLElBQU0sV0FBVyxHQUFHLFNBQWQsV0FBYyxDQUFDLEtBQUQ7QUFBQSxTQUFXLFVBQUMsS0FBRCxFQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFoQjtBQUNBLFFBQU0sY0FBYyxHQUFHLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFBYixDQUFvQixjQUFwQixDQUFtQyxDQUFuQyxDQUF2QjtBQUNBLFFBQUksSUFBSSxHQUFHLGNBQWMsQ0FBQyxJQUFmLENBQW9CLFVBQUEsQ0FBQztBQUFBLGFBQUUsQ0FBQyxDQUFDLE1BQUYsSUFBWSxLQUFLLENBQUMsTUFBcEI7QUFBQSxLQUFyQixDQUFYO0FBQ0EsV0FBTyxJQUFJLENBQUMsSUFBWjtBQUNELEdBUm1CO0FBQUEsQ0FBcEIsQyxDQVVGO0FBQ0E7OztBQUNFLElBQU0sZ0JBQWdCLEdBQUcsU0FBbkIsZ0JBQW1CLENBQUMsS0FBRDtBQUFBLFNBQVcsVUFBQyxRQUFELEVBQWM7QUFDaEQsUUFBSTtBQUNGLGFBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxrQkFBYixDQUFnQyxlQUFoQyxDQUFnRCxJQUFoRCxDQUFzRCxVQUFTLENBQVQsRUFBWTtBQUFHLGVBQU8sQ0FBQyxDQUFDLFFBQUYsS0FBZSxRQUF0QjtBQUFpQyxPQUF0RyxDQUFQO0FBQ0QsS0FGRCxDQUdBLE9BQU8sQ0FBUCxFQUFVO0FBQ1IsTUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLEtBQVosRUFBa0IsQ0FBbEI7QUFDQSxhQUFPLFNBQVA7QUFDRDtBQUNGLEdBUndCO0FBQUEsQ0FBekI7O0FBU0EsSUFBTSx1QkFBdUIsR0FBRyxTQUExQix1QkFBMEIsQ0FBQyxLQUFELEVBQVEsT0FBUjtBQUFBLFNBQW9CLFVBQUMsUUFBRCxFQUFjO0FBQ2hFO0FBQ0EsUUFBSSxHQUFHLEdBQUcsRUFBVjtBQUNBLFFBQU0sU0FBUyxHQUFHLENBQUMsSUFBRCxFQUFNLE9BQU4sRUFBYyxPQUFkLEVBQXNCLFNBQXRCLEVBQWdDLE1BQWhDLENBQWxCO0FBQ0EsSUFBQSxTQUFTLENBQUMsT0FBVixDQUFtQixVQUFTLFFBQVQsRUFBa0I7QUFDbkMsVUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLGdCQUFSLENBQXlCLFdBQVMsUUFBbEMsQ0FBZjtBQUNBLE1BQUEsR0FBRyxDQUFDLFFBQUQsQ0FBSCxHQUFpQixRQUFRLElBQUksUUFBUSxDQUFDLEtBQXRCLEdBQStCLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBVixDQUF2QyxHQUEwRCxTQUExRTtBQUNELEtBSEQ7QUFJQSxJQUFBLEdBQUcsQ0FBQyxLQUFKLEdBQVksT0FBTyxDQUFDLFNBQVIsQ0FBa0IsR0FBbEIsQ0FBWjtBQUNBLElBQUEsR0FBRyxDQUFDLFFBQUosR0FBZSxRQUFmO0FBQ0EsV0FBTyxHQUFQO0FBQ0QsR0FYK0I7QUFBQSxDQUFoQzs7QUFZQSxJQUFNLFVBQVUsR0FBRyxTQUFiLFVBQWEsQ0FBQyxLQUFELEVBQVc7QUFDNUIsU0FBTyxLQUFLLENBQUMsTUFBTixDQUFhLE1BQWIsQ0FBb0IsTUFBcEIsSUFBOEIsS0FBSyxDQUFDLE1BQU4sQ0FBYSxNQUFiLENBQW9CLE1BQXBCLENBQTJCLFFBQWhFO0FBQ0QsQ0FGRDs7QUFHQSxJQUFNLGFBQWEsR0FBRyxTQUFoQixhQUFnQixDQUFDLEtBQUQsRUFBUSxPQUFSLEVBQW9CO0FBQ3hDLE1BQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxVQUF6QixDQUR3QyxDQUV4Qzs7QUFDQSxNQUFJLE9BQU8sVUFBUCxLQUFzQixXQUExQixFQUFzQztBQUNwQyxRQUFJLFFBQVEsR0FBRyxVQUFVLENBQUMsTUFBWCxDQUFrQixVQUFBLENBQUM7QUFBQSxhQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUgsSUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFqQjtBQUFBLEtBQW5CLENBQWYsQ0FEb0MsQ0FFcEM7O0FBQ0EsV0FBTyxRQUFQO0FBQ0QsR0FKRCxNQUlPO0FBQ0wsV0FBTyxTQUFQO0FBQ0Q7QUFDRixDQVZELEMsQ0FhRjtBQUNBOzs7QUFDRSxJQUFNLFNBQVMsR0FBRyxTQUFaLFNBQVksQ0FBQyxLQUFELEVBQVEsT0FBUjtBQUFBLFNBQW9CLFVBQUMsR0FBRCxFQUFTO0FBQzdDO0FBQ0EsUUFBSSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQWhCOztBQUVBLFFBQUcsQ0FBQyxLQUFKLEVBQVU7QUFDUixVQUFJLFVBQVUsR0FBRyxTQUFqQjs7QUFDQSxVQUFJLEtBQUssQ0FBQyxNQUFOLENBQWEsV0FBYixJQUNDLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFEZCxJQUVDLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFBYixDQUFvQiw4QkFGckIsSUFHQyxLQUFLLENBQUMsTUFBTixDQUFhLE1BQWIsQ0FBb0IsOEJBQXBCLENBQW1ELFdBSHhELEVBR3FFO0FBQ25FLFlBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFBYixDQUFvQiw4QkFBcEIsQ0FBbUQsV0FBbkQsQ0FBK0QsSUFBL0QsQ0FBb0UsVUFBUyxDQUFULEVBQVc7QUFDckYsaUJBQU8sQ0FBQyxDQUFDLFdBQUYsS0FBa0IsS0FBSyxDQUFDLE1BQU4sQ0FBYSxXQUF0QztBQUNELFNBRk8sQ0FBUjtBQUdBLFFBQUEsVUFBVSxHQUFLLENBQUQsR0FBTSxDQUFDLENBQUMsVUFBUixHQUFxQixTQUFuQztBQUNEOztBQUVELFVBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQyxNQUFYLEdBQW9CLENBQXRDLEVBQXlDO0FBQ3ZDLFlBQU0sYUFBWSxHQUFHLFVBQVUsQ0FBQyxNQUFYLEdBQW9CLENBQXpDOztBQUNBLFlBQUksR0FBRSxHQUFJLEdBQUcsQ0FBQyxFQUFMLEdBQVcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFKLENBQU8sTUFBUCxDQUFjLEdBQUcsQ0FBQyxFQUFKLENBQU8sTUFBUCxHQUFnQixDQUE5QixDQUFELEVBQW1DLEVBQW5DLENBQVIsR0FBaUQsYUFBNUQsR0FBMkUsa0JBQXBGOztBQUNBLFlBQUksS0FBSyxHQUFHLEdBQUUsR0FBRyxVQUFVLENBQUMsTUFBaEIsR0FBeUIsQ0FBckM7QUFDQSxZQUFJLFFBQVEsR0FBRyxVQUFVLENBQUMsSUFBWCxDQUFnQixVQUFTLENBQVQsRUFBVztBQUN4QyxpQkFBTyxDQUFDLENBQUMsUUFBRixLQUFlLFNBQU8sS0FBN0I7QUFDRCxTQUZjLENBQWY7QUFHQSxRQUFBLEtBQUssR0FBRyxRQUFRLENBQUMsU0FBakI7QUFDRCxPQVJELE1BUU07QUFDSixZQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLElBQUksQ0FBQyxNQUFMLE1BQWlCLElBQUksQ0FBckIsSUFBMEIsQ0FBckMsQ0FBYjtBQUNBLFFBQUEsS0FBSyx5REFBb0QsUUFBUSxDQUFDLEVBQUUsQ0FBQyxNQUFILENBQVUsRUFBRSxDQUFDLE1BQUgsR0FBWSxDQUF0QixDQUFELEVBQTJCLEVBQTNCLENBQVIsR0FBdUMsWUFBeEMsR0FBd0QsQ0FBM0csU0FBTDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBTyxLQUFQO0FBQ0QsR0E5QmlCO0FBQUEsQ0FBbEI7O0FBK0JBLElBQU0sV0FBVyxHQUFHLFNBQWQsV0FBYyxDQUFDLEtBQUQsRUFBUSxPQUFSO0FBQUEsU0FBb0IsVUFBQyxHQUFELEVBQVM7QUFFL0M7QUFDQSxRQUFNLElBQUksR0FBRyxHQUFHLENBQUMsSUFBakI7QUFDQSxJQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksdUJBQVosRUFBcUMsSUFBckM7QUFFQSxRQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsUUFBckI7QUFDQSxJQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksMkJBQVosRUFBeUMsUUFBekM7QUFFQSxRQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsa0NBQTlCLENBVCtDLENBVS9DOztBQUVBLElBQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxrREFBWixFQUFnRSxLQUFLLENBQUMsTUFBTixDQUFhLGtCQUE3RTtBQUNBLFFBQU0sd0JBQXdCLEdBQUcsS0FBSyxDQUFDLE1BQU4sQ0FBYSxrQkFBYixDQUFnQyxhQUFqRSxDQWIrQyxDQWMvQzs7QUFFQSxRQUFJLFVBQVUsR0FBRyx3QkFBd0IsQ0FBQyxRQUFELENBQXpDO0FBQ0EsUUFBSSxVQUFVLEdBQUcsVUFBVSxDQUFDLEtBQTVCLENBakIrQyxDQWtCL0M7O0FBRUEsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQUQsQ0FBaEI7QUFDQSxJQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksNEJBQVosRUFBMEMsS0FBMUM7O0FBRUEsUUFBRyxDQUFDLEtBQUosRUFBVTtBQUNSLFVBQUksQ0FBQyxHQUFHLGFBQVI7QUFDQSxVQUFJLFVBQVUsR0FBSyxDQUFELEdBQU0sQ0FBQyxDQUFDLFVBQVIsR0FBcUIsU0FBdkM7O0FBRUEsVUFBSSxVQUFVLElBQUksVUFBVSxDQUFDLE1BQVgsR0FBb0IsQ0FBdEMsRUFBeUM7QUFDdkMsWUFBTSxjQUFZLEdBQUcsVUFBVSxDQUFDLE1BQVgsR0FBb0IsQ0FBekM7O0FBQ0EsWUFBSSxJQUFFLEdBQUksSUFBSSxDQUFDLEVBQU4sR0FBWSxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUwsQ0FBUSxNQUFSLENBQWUsSUFBSSxDQUFDLEVBQUwsQ0FBUSxNQUFSLEdBQWlCLENBQWhDLENBQUQsRUFBcUMsRUFBckMsQ0FBUixHQUFtRCxjQUEvRCxHQUE4RSxrQkFBdkY7O0FBQ0EsWUFBSSxJQUFJLEdBQUcsSUFBRSxHQUFHLFVBQVUsQ0FBQyxNQUFoQixHQUF5QixDQUFwQztBQUNBLFlBQUksUUFBUSxHQUFHLFVBQVUsQ0FBQyxJQUFYLENBQWdCLFVBQVMsQ0FBVCxFQUFXO0FBQ3hDLGlCQUFPLENBQUMsQ0FBQyxRQUFGLEtBQWUsU0FBTyxJQUE3QjtBQUNELFNBRmMsQ0FBZjtBQUdBLFFBQUEsS0FBSyxHQUFHLFFBQVEsQ0FBQyxTQUFqQjtBQUNELE9BUkQsTUFRTztBQUNMLFFBQUEsS0FBSyx5REFBb0QsUUFBUSxDQUFDLEVBQUUsQ0FBQyxNQUFILENBQVUsRUFBRSxDQUFDLE1BQUgsR0FBWSxDQUF0QixDQUFELEVBQTJCLEVBQTNCLENBQVIsR0FBdUMsWUFBeEMsR0FBd0QsQ0FBM0csU0FBTDtBQUNEO0FBQ0Y7O0FBQ0QsSUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLDRCQUFaLEVBQTBDLEtBQTFDO0FBQ0EsV0FBTyxLQUFQO0FBQ0QsR0F6Q21CO0FBQUEsQ0FBcEIsQyxDQTJDRjtBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDRSxJQUFNLHFCQUFxQixHQUFHLFNBQXhCLHFCQUF3QixDQUFDLEtBQUQsRUFBVztBQUN2QyxTQUFPLEtBQUssQ0FBQyxNQUFOLENBQWEsU0FBYixDQUF1QixJQUF2QixDQUE0QixVQUFTLENBQVQsRUFBWTtBQUM3QyxXQUFPLENBQUMsQ0FBQyxLQUFGLEtBQVksd0JBQW5CO0FBQ0QsR0FGTSxDQUFQO0FBR0QsQ0FKRDs7QUFLQSxJQUFNLGdCQUFnQixHQUFHLFNBQW5CLGdCQUFtQixDQUFDLEtBQUQsRUFBUSxPQUFSO0FBQUEsU0FBb0IsVUFBQyxXQUFELEVBQWlCO0FBQzVELFFBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFuQjtBQUNBLFFBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUF0QixDQUY0RCxDQUVqQzs7QUFDM0IsUUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLHFCQUEzQjtBQUNBLFFBQU0sZUFBZSxHQUFHLFVBQVUsQ0FBQyxLQUFYLENBQWlCLFdBQWpCLEVBQThCLFdBQTlCLENBQXhCLENBSjRELENBSU87O0FBQ25FLFdBQU8sZUFBZSxLQUFLLFFBQTNCO0FBQ0QsR0FOd0I7QUFBQSxDQUF6Qjs7QUFPQSxJQUFNLDBCQUEwQixHQUFHLFNBQTdCLDBCQUE2QixDQUFBLEtBQUssRUFBSTtBQUMxQztBQUNBLFNBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxTQUFiLENBQXVCLE1BQXZCLENBQThCLFVBQVMsQ0FBVCxFQUFZO0FBQy9DLFdBQU8sQ0FBQyxDQUFDLFNBQUYsS0FBZ0IsTUFBdkI7QUFDRCxHQUZNLENBQVA7QUFHRCxDQUxEOztBQU1BLElBQU0sNkJBQTZCLEdBQUcsU0FBaEMsNkJBQWdDLENBQUMsS0FBRCxFQUFRLE9BQVI7QUFBQSxTQUFvQixVQUFDLFlBQUQsRUFBa0I7QUFDMUU7QUFDQSxRQUFJLGdCQUFnQixHQUFJLE9BQU8sQ0FBQywwQkFBaEMsQ0FGMEUsQ0FHMUU7O0FBQ0EsV0FBTyxnQkFBZ0IsQ0FBQyxJQUFqQixDQUFzQixVQUFTLENBQVQsRUFBWTtBQUN2QyxhQUFPLENBQUMsQ0FBQyxhQUFGLEtBQW9CLFlBQTNCO0FBQ0QsS0FGTSxDQUFQO0FBR0QsR0FQcUM7QUFBQSxDQUF0Qzs7QUFRQSxJQUFNLGlCQUFpQixHQUFHLFNBQXBCLGlCQUFvQixDQUFBLEtBQUssRUFBSTtBQUNqQyxTQUFPLEtBQUssQ0FBQyxNQUFOLENBQWEsU0FBYixDQUF1QixJQUF2QixDQUE0QixVQUFTLENBQVQsRUFBWTtBQUM3QyxXQUFPLENBQUMsQ0FBQyxhQUFGLEtBQW9CLEtBQUssQ0FBQyxNQUFOLENBQWEsYUFBakMsSUFDSixDQUFDLENBQUMsV0FBRixLQUFrQixLQUFLLENBQUMsTUFBTixDQUFhLFdBRGxDO0FBRUQsR0FITSxDQUFQO0FBSUQsQ0FMRDs7QUFNQSxJQUFNLHdCQUF3QixHQUFHLFNBQTNCLHdCQUEyQixDQUFBLEtBQUssRUFBSTtBQUN4QztBQUNBLFNBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxTQUFiLENBQXVCLElBQXZCLENBQTRCLFVBQVMsQ0FBVCxFQUFZO0FBQzdDLFdBQU8sQ0FBQyxDQUFDLGFBQUYsS0FBb0IsU0FBcEIsSUFDSixDQUFDLENBQUMsV0FBRixLQUFrQixLQUFLLENBQUMsTUFBTixDQUFhLFdBRGxDO0FBRUQsR0FITSxDQUFQO0FBSUQsQ0FORDs7QUFPQSxJQUFNLHFCQUFxQixHQUFHLFNBQXhCLHFCQUF3QixDQUFBLEtBQUssRUFBSTtBQUNyQztBQUNBLFNBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxTQUFiLENBQXVCLElBQXZCLENBQTRCLFVBQVMsQ0FBVCxFQUFZO0FBQzdDLFdBQU8sQ0FBQyxDQUFDLGFBQUYsS0FBb0IsTUFBcEIsSUFDSixDQUFDLENBQUMsV0FBRixLQUFrQixLQUFLLENBQUMsTUFBTixDQUFhLFdBRGxDO0FBRUQsR0FITSxDQUFQO0FBSUQsQ0FORDs7QUFPQSxJQUFNLG9CQUFvQixHQUFHLFNBQXZCLG9CQUF1QixDQUFBLEtBQUssRUFBSTtBQUNwQztBQUNBLFNBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxTQUFiLENBQXVCLElBQXZCLENBQTRCLFVBQVMsQ0FBVCxFQUFZO0FBQzdDLFdBQU8sQ0FBQyxDQUFDLGFBQUYsS0FBb0IsS0FBcEIsSUFDSixDQUFDLENBQUMsV0FBRixLQUFrQixLQUFLLENBQUMsTUFBTixDQUFhLFdBRGxDO0FBRUQsR0FITSxDQUFQO0FBSUQsQ0FORDs7QUFPQSxJQUFNLHVCQUF1QixHQUFHLFNBQTFCLHVCQUEwQixDQUFBLEtBQUssRUFBSTtBQUN2QztBQUNBLFNBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxTQUFiLENBQXVCLElBQXZCLENBQTRCLFVBQVMsQ0FBVCxFQUFZO0FBQzdDLFdBQU8sQ0FBQyxDQUFDLGFBQUYsS0FBb0IsUUFBcEIsSUFDSixDQUFDLENBQUMsV0FBRixLQUFrQixLQUFLLENBQUMsTUFBTixDQUFhLFdBRGxDO0FBRUQsR0FITSxDQUFQO0FBSUQsQ0FORDs7QUFPQSxJQUFNLHFCQUFxQixHQUFHLFNBQXhCLHFCQUF3QixDQUFBLEtBQUssRUFBSTtBQUNyQztBQUNBLFNBQU8sS0FBSyxDQUFDLE1BQU4sQ0FBYSxTQUFiLENBQXVCLElBQXZCLENBQTRCLFVBQVMsQ0FBVCxFQUFZO0FBQzdDLFdBQU8sQ0FBQyxDQUFDLGFBQUYsS0FBb0IsTUFBcEIsSUFDSixDQUFDLENBQUMsV0FBRixLQUFrQixLQUFLLENBQUMsTUFBTixDQUFhLFdBRGxDO0FBRUQsR0FITSxDQUFQO0FBSUQsQ0FORDs7QUFPQSxJQUFNLGtCQUFrQixHQUFHLFNBQXJCLGtCQUFxQixDQUFBLEtBQUssRUFBSTtBQUNsQyxTQUFPLEtBQUssQ0FBQyxNQUFOLENBQWEsUUFBYixDQUFzQixlQUE3QjtBQUNELENBRkQsQyxDQUlGO0FBQ0E7QUFDQTs7O2VBQ2lCO0FBQ2IsRUFBQSxjQUFjLEVBQWQsY0FEYTtBQUViLEVBQUEsbUJBQW1CLEVBQW5CLG1CQUZhO0FBSWIsRUFBQSxrQkFBa0IsRUFBbEIsa0JBSmE7QUFLYixFQUFBLFVBQVUsRUFBVixVQUxhO0FBTWIsRUFBQSxpQkFBaUIsRUFBakIsaUJBTmE7QUFPYixFQUFBLGNBQWMsRUFBZCxjQVBhO0FBUWI7QUFFQSxFQUFBLDBCQUEwQixFQUExQiwwQkFWYTtBQVdiLEVBQUEsK0JBQStCLEVBQS9CLCtCQVhhO0FBWWIsRUFBQSx1Q0FBdUMsRUFBdkMsdUNBWmE7QUFhYixFQUFBLHdDQUF3QyxFQUF4Qyx3Q0FiYTtBQWViLEVBQUEsZUFBZSxFQUFmLGVBZmE7QUFnQmIsRUFBQSxlQUFlLEVBQWYsZUFoQmE7QUFpQmIsRUFBQSxnQkFBZ0IsRUFBaEIsZ0JBakJhO0FBbUJiLEVBQUEsZUFBZSxFQUFmLGVBbkJhO0FBb0JiLEVBQUEsZUFBZSxFQUFmLGVBcEJhO0FBc0JiLEVBQUEsaUJBQWlCLEVBQWpCLGlCQXRCYTtBQXVCYixFQUFBLHFCQUFxQixFQUFyQixxQkF2QmE7QUF3QmIsRUFBQSw0QkFBNEIsRUFBNUIsNEJBeEJhO0FBeUJiLEVBQUEsMkJBQTJCLEVBQTNCLDJCQXpCYTtBQTBCYixFQUFBLDRCQUE0QixFQUE1Qiw0QkExQmE7QUEyQmIsRUFBQSxrQ0FBa0MsRUFBbEMsa0NBM0JhO0FBNEJiLEVBQUEsbUJBQW1CLEVBQW5CLG1CQTVCYTtBQThCYixFQUFBLHFCQUFxQixFQUFyQixxQkE5QmE7QUErQmIsRUFBQSxnQkFBZ0IsRUFBaEIsZ0JBL0JhO0FBaUNiLEVBQUEsMEJBQTBCLEVBQTFCLDBCQWpDYTtBQWtDYixFQUFBLDZCQUE2QixFQUE3Qiw2QkFsQ2E7QUFvQ2IsRUFBQSx3QkFBd0IsRUFBeEIsd0JBcENhO0FBcUNiLEVBQUEscUJBQXFCLEVBQXJCLHFCQXJDYTtBQXNDYixFQUFBLG9CQUFvQixFQUFwQixvQkF0Q2E7QUF1Q2IsRUFBQSx1QkFBdUIsRUFBdkIsdUJBdkNhO0FBd0NiLEVBQUEscUJBQXFCLEVBQXJCLHFCQXhDYTtBQTBDYixFQUFBLFdBQVcsRUFBWCxXQTFDYTtBQTRDYixFQUFBLFVBQVUsRUFBVixVQTVDYTtBQTZDYixFQUFBLGFBQWEsRUFBYixhQTdDYTtBQThDYixFQUFBLGdCQUFnQixFQUFoQixnQkE5Q2E7QUErQ2IsRUFBQSx1QkFBdUIsRUFBdkIsdUJBL0NhO0FBZ0RiLEVBQUEsU0FBUyxFQUFULFNBaERhO0FBaURiLEVBQUEsV0FBVyxFQUFYLFdBakRhO0FBbURiLEVBQUEsa0JBQWtCLEVBQWxCO0FBbkRhLEM7Ozs7Ozs7Ozs7O0FDbFZqQjs7QUFDQTs7Ozs7Ozs7OztlQUVlO0FBRWI7QUFFQSxFQUFBLGtCQUphLDhCQUlPLEtBSlAsRUFJYTtBQUN4QjtBQUNBLElBQUEsS0FBSyxDQUFDLGVBQU4sR0FBd0IscUJBQWdCLGlCQUF4QztBQUNELEdBUFk7QUFTYixFQUFBLFVBVGEsc0JBU0QsS0FUQyxFQVNNLE9BVE4sRUFTZTtBQUMxQjtBQUNBLElBQUEsS0FBSyxDQUFDLE9BQU4sR0FBZ0IsT0FBaEIsQ0FGMEIsQ0FHMUI7O0FBQ0EsUUFBTSxLQUFLLEdBQUcsZUFBVSxPQUFWLENBQWQ7QUFDQSxJQUFBLEtBQUssQ0FBQyxjQUFOLEdBQXVCLEtBQUssQ0FBQyxPQUE3QixDQUwwQixDQU8xQjtBQUNBO0FBQ0E7QUFDRCxHQW5CWTtBQW9CYixFQUFBLGNBcEJhLDBCQW9CRyxLQXBCSCxFQW9CVSxPQXBCVixFQW9CbUI7QUFDOUIsSUFBQSxLQUFLLENBQUMsV0FBTixHQUFvQixPQUFwQjtBQUNELEdBdEJZO0FBd0JiO0FBQ0EsRUFBQSxjQXpCYSwwQkF5QkUsS0F6QkYsRUF5QlE7QUFDbkIsSUFBQSxLQUFLLENBQUMsYUFBTixHQUFzQixLQUF0QjtBQUNELEdBM0JZO0FBNEJiLEVBQUEsZ0JBNUJhLDRCQTRCSSxLQTVCSixFQTRCVTtBQUNyQixJQUFBLEtBQUssQ0FBQyxPQUFOLEdBQWdCLENBQUMsS0FBSyxDQUFDLE9BQXZCO0FBQ0QsR0E5Qlk7QUFnQ2I7QUFDQSxFQUFBLGlCQWpDYSw2QkFpQ0ssS0FqQ0wsRUFpQ1ksYUFqQ1osRUFpQzJCO0FBQ3RDO0FBQ0EsUUFBTSxhQUFhLEdBQUcsYUFBYSxDQUFDLGNBQXBDLENBRnNDLENBR3RDOztBQUNBLElBQUEsS0FBSyxDQUFDLGNBQU4sR0FBdUIsYUFBdkI7QUFDRCxHQXRDWTtBQXdDYjtBQUNBLEVBQUEsYUF6Q2EseUJBeUNDLEtBekNELEVBeUNRLFVBekNSLEVBeUNtQjtBQUM5QixJQUFBLEtBQUssQ0FBQyxNQUFOLENBQWEsV0FBYixHQUEyQixVQUEzQjtBQUNELEdBM0NZO0FBNENiLEVBQUEsY0E1Q2EsMEJBNENHLEtBNUNILEVBNENVLFdBNUNWLEVBNEN1QjtBQUNsQztBQUNBLElBQUEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxRQUFiLENBQXNCLE1BQXRCLEdBQWlDLFdBQVcsQ0FBQyxnQkFBWixLQUFpQyxZQUFuQyxHQUFvRCxJQUFwRCxHQUEyRCxLQUExRixDQUZrQyxDQUdsQztBQUNELEdBaERZO0FBaURiLEVBQUEsZUFqRGEsMkJBaURJLEtBakRKLFFBaUQyQjtBQUFBLFFBQWYsWUFBZSxRQUFmLFlBQWU7QUFDdEMsSUFBQSxLQUFLLENBQUMsTUFBTixDQUFhLFFBQWIsQ0FBc0IsS0FBdEIsR0FBOEIsWUFBOUI7QUFDRCxHQW5EWTtBQW9EYixFQUFBLGtCQXBEYSw4QkFvRE8sS0FwRFAsU0FvRGlDO0FBQUEsUUFBbEIsZUFBa0IsU0FBbEIsZUFBa0I7QUFDNUM7QUFDQSxJQUFBLEtBQUssQ0FBQyxNQUFOLENBQWEsUUFBYixDQUFzQixlQUF0QixHQUF3QyxJQUFJLEdBQUosQ0FBUSxlQUFSLENBQXhDO0FBQ0QsR0F2RFk7QUF3RGIsRUFBQSxxQkF4RGEsaUNBd0RVLEtBeERWLEVBd0RpQixrQkF4RGpCLEVBd0RxQztBQUNoRCxJQUFBLEtBQUssQ0FBQyxrQkFBTixHQUEyQixrQkFBM0I7QUFDRCxHQTFEWTtBQTJEYixFQUFBLGNBM0RhLDBCQTJERyxLQTNESCxTQTJEb0I7QUFBQSxRQUFULE1BQVMsU0FBVCxNQUFTO0FBQy9CLElBQUEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxRQUFiLENBQXNCLGVBQXRCLENBQXNDLEdBQXRDLENBQTBDLE1BQTFDLEVBQWtELElBQUksR0FBSixFQUFsRCxFQUQrQixDQUcvQjs7QUFDQSxJQUFBLEtBQUssQ0FBQyxNQUFOLENBQWEsUUFBYixDQUFzQixlQUF0QixHQUF3QyxJQUFJLEdBQUosQ0FBUSxLQUFLLENBQUMsTUFBTixDQUFhLFFBQWIsQ0FBc0IsZUFBOUIsQ0FBeEM7QUFDRCxHQWhFWTtBQWlFYixFQUFBLGVBakVhLDJCQWlFRyxLQWpFSCxFQWlFUztBQUNwQixJQUFBLEtBQUssQ0FBQyxNQUFOLENBQWEsUUFBYixDQUFzQixlQUF0QixHQUF3QyxxQ0FBeUIsS0FBSyxDQUFDLGtCQUEvQixDQUF4QztBQUNELEdBbkVZO0FBb0ViLEVBQUEsY0FwRWEsMEJBb0VFLEtBcEVGLFNBb0VzQjtBQUFBLFFBQWIsSUFBYSxTQUFiLElBQWE7QUFBQSxRQUFSLE1BQVEsU0FBUixNQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLElBQUEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxJQUFiLElBQXFCLE1BQXJCO0FBQ0QsR0F6RVk7QUEwRWIsRUFBQSxlQTFFYSwyQkEwRUcsS0ExRUgsU0EwRXlCO0FBQUEsUUFBZCxJQUFjLFNBQWQsSUFBYztBQUFBLFFBQVQsTUFBUyxTQUFULE1BQVM7QUFDcEMsSUFBQSxLQUFLLENBQUMsTUFBTixDQUFhLE1BQWIsQ0FBb0IsSUFBcEIsSUFBNEIsTUFBNUI7QUFDRCxHQTVFWTtBQThFYjtBQUNBLEVBQUEsZUEvRWEsMkJBK0VHLEtBL0VILFNBK0VtQjtBQUFBLFFBQVIsTUFBUSxTQUFSLE1BQVE7QUFDOUI7QUFDQSxJQUFBLEtBQUssQ0FBQyxNQUFOLENBQWEsTUFBYixHQUFzQjtBQUNwQixNQUFBLFlBQVksRUFBRSxTQURNO0FBRXBCLE1BQUEsTUFBTSxFQUFOLE1BRm9CO0FBR3BCO0FBQ0EsTUFBQSxLQUFLLEVBQUU7QUFKYSxLQUF0QjtBQU1ELEdBdkZZO0FBd0ZiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUEsZ0JBakdhLDRCQWlHSSxLQWpHSixTQWlHMEI7QUFBQSxRQUFkLFlBQWMsU0FBZCxZQUFjO0FBQ3JDLElBQUEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxNQUFiLEdBQXNCO0FBQ3BCLE1BQUEsWUFBWSxFQUFaLFlBRG9CO0FBRXBCLE1BQUEsTUFBTSxFQUFFLFNBRlk7QUFHcEI7QUFDQSxNQUFBLEtBQUssRUFBRTtBQUphLEtBQXRCO0FBTUQsR0F4R1k7QUF5R2IsRUFBQSxjQXpHYSwwQkF5R0UsS0F6R0YsU0F5R2lCO0FBQUEsUUFBUCxLQUFPLFNBQVAsS0FBTztBQUM1QixJQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsY0FBZCxFQUE4QixLQUE5QjtBQUNBLElBQUEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxNQUFiLEdBQXNCO0FBQ3BCLE1BQUEsWUFBWSxFQUFFLFNBRE07QUFFcEIsTUFBQSxNQUFNLEVBQUUsU0FGWTtBQUdwQjtBQUNBLE1BQUEsS0FBSyxFQUFMO0FBSm9CLEtBQXRCO0FBTUQsR0FqSFk7QUFtSGIsRUFBQSxtQkFuSGEsK0JBbUhPLEtBbkhQLFNBbUh3QjtBQUFBLFFBQVQsT0FBUyxTQUFULE9BQVM7QUFDbkMsSUFBQSxLQUFLLENBQUMsZ0JBQU4sR0FBeUIsT0FBekI7QUFDRCxHQXJIWTtBQXdIYjtBQUNBLEVBQUEsVUF6SGEsc0JBeUhGLEtBekhFLFVBeUh5QjtBQUFBLFFBQW5CLGlCQUFtQixVQUFuQixpQkFBbUI7QUFDcEMsSUFBQSxLQUFLLENBQUMsaUJBQU4sR0FBMEIsSUFBSSxHQUFKLDhCQUFZLEtBQUssQ0FBQyxpQkFBbEIsc0JBQXdDLGlCQUF4QyxHQUExQjtBQUNELEdBM0hZO0FBNkhiO0FBQ0EsRUFBQSxTQTlIYSxxQkE4SEgsS0E5SEcsVUE4SG1CO0FBQUEsUUFBZCxJQUFjLFVBQWQsSUFBYztBQUFBLFFBQVQsTUFBUyxVQUFULE1BQVM7QUFDOUI7QUFDQSxJQUFBLEtBQUssQ0FBQyxNQUFOLENBQWEsSUFBYixJQUFxQixNQUFyQjtBQUNELEdBaklZO0FBbUliO0FBQ0EsRUFBQSxTQXBJYSxxQkFvSUYsS0FwSUUsVUFvSWdCO0FBQUEsUUFBVixNQUFVLFVBQVYsTUFBVTtBQUMzQixJQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksV0FBWixFQUF5QixNQUF6QixFQUQyQixDQUUzQjs7QUFDQSxJQUFBLEtBQUssQ0FBQyxHQUFOLEdBQVksTUFBWjtBQUNBLElBQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxjQUFaLEVBQTRCLEtBQUssQ0FBQyxHQUFsQztBQUNELEdBeklZO0FBMEliLEVBQUEsUUExSWEsb0JBMElILEtBMUlHLFVBMElhO0FBQUEsUUFBUixLQUFRLFVBQVIsS0FBUTtBQUN4QixJQUFBLEtBQUssQ0FBQyxJQUFOLENBQVcsS0FBWCxHQUFvQixLQUFLLElBQUksS0FBSyxDQUFDLEtBQWhCLEdBQXlCLEtBQXpCLEdBQWlDLFNBQXBEO0FBQ0EsSUFBQSxLQUFLLENBQUMsSUFBTixDQUFXLFVBQVgsR0FBeUIsS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFoQixHQUF5QixJQUF6QixHQUFnQyxLQUF4RDtBQUNELEdBN0lZO0FBOEliLEVBQUEsT0E5SWEsbUJBOElKLEtBOUlJLFVBOElXO0FBQUEsUUFBUCxJQUFPLFVBQVAsSUFBTztBQUN0QixJQUFBLEtBQUssQ0FBQyxJQUFOLENBQVcsSUFBWCxHQUFtQixPQUFPLElBQVAsS0FBZ0IsUUFBakIsR0FBNkIsSUFBN0IsR0FBb0MsU0FBdEQ7QUFDRDtBQWhKWSxDOzs7Ozs7Ozs7OztBQ0hmOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOzs7O0FBRUEsYUFBSSxHQUFKLENBQVEsYUFBUixFLENBRUE7OztBQUNBLElBQU0sY0FBYyxHQUFHLElBQUksY0FBSyxLQUFULENBQWU7QUFDcEMsRUFBQSxNQUFNLEVBQUUsSUFENEI7QUFHcEMsRUFBQSxLQUFLLEVBQUU7QUFFTDtBQUNBLElBQUEsZUFBZSxFQUFHLFNBSGI7QUFLTDtBQUNBLElBQUEsT0FBTyxFQUFHLFNBTkw7QUFPTCxJQUFBLGNBQWMsRUFBRyxTQVBaO0FBUUwsSUFBQSxXQUFXLEVBQUcsU0FSVDtBQVNMO0FBRUE7QUFDQSxJQUFBLE9BQU8sRUFBRyxLQVpMO0FBYUwsSUFBQSxhQUFhLEVBQUcsSUFiWDtBQWVMO0FBQ0EsSUFBQSxNQUFNLEVBQUUsSUFoQkg7QUFrQkw7QUFDQSxJQUFBLElBQUksRUFBRztBQUNMLE1BQUEsS0FBSyxFQUFFLFNBREY7QUFFTCxNQUFBLElBQUksRUFBRSxTQUZEO0FBR0wsTUFBQSxVQUFVLEVBQUU7QUFIUCxLQW5CRjtBQXdCTCxJQUFBLEdBQUcsRUFBRyxTQXhCRDtBQTBCTDtBQUNBLElBQUEsaUJBQWlCLEVBQUUsSUFBSSxHQUFKLEVBM0JkO0FBNkJMO0FBQ0EsSUFBQSxnQkFBZ0IsRUFBRSxTQTlCYjtBQWdDTDtBQUNBLElBQUEsa0JBQWtCLEVBQUUsU0FqQ2Y7QUFrQ0wsSUFBQSxjQUFjLEVBQUUsU0FsQ1g7QUFvQ0w7QUFDQSxJQUFBLE1BQU0sRUFBRSxFQXJDSDtBQXVDTDtBQUNBLElBQUEsTUFBTSxFQUFFO0FBRU47QUFDQSxNQUFBLFdBQVcsRUFBRSxTQUhQO0FBSU4sTUFBQSxhQUFhLEVBQUUsU0FKVDtBQUtOLE1BQUEsUUFBUSxFQUFFLFNBTEo7QUFPTjtBQUNBLE1BQUEsUUFBUSxFQUFFO0FBQ1IsUUFBQSxLQUFLLEVBQUUsSUFBSSxHQUFKLENBQVEsUUFBUixFQUFrQixZQUFsQixDQUErQixHQUEvQixDQUFtQyxNQUFuQyxLQUE4QyxFQUQ3QztBQUVSLFFBQUEsTUFBTSxFQUFHLEtBRkQ7QUFHUixRQUFBLFlBQVksRUFBRyxJQUhQO0FBSVIsUUFBQSxXQUFXLEVBQUcsSUFKTjtBQUtSLFFBQUEsSUFBSSxFQUFDLENBTEc7QUFNUixRQUFBLE9BQU8sRUFBQyxHQU5BO0FBT1IsUUFBQSxzQkFBc0IsRUFBRSxTQVBoQjtBQVFSLFFBQUEsZUFBZSxFQUFFLElBQUksR0FBSjtBQVJULE9BUko7QUFrQk47QUFDQSxNQUFBLE1BQU0sRUFBRTtBQUNOLFFBQUEsWUFBWSxFQUFFLFNBRFI7QUFDbUI7QUFDekIsUUFBQSxNQUFNLEVBQUUsU0FGRjtBQUVhO0FBQ25CO0FBQ0EsUUFBQSxLQUFLLEVBQUUsU0FKRCxDQUlXOztBQUpYLE9BbkJGO0FBeUJOO0FBQ0EsTUFBQSxNQUFNLEVBQUM7QUFDTCxRQUFBLE9BQU8sRUFBRTtBQUNQLFVBQUEsV0FBVyxFQUFHLFNBRFA7QUFFUCxVQUFBLGdCQUFnQixFQUFHLFNBRlo7QUFHUCxVQUFBLHdCQUF3QixFQUFHLFNBSHBCO0FBSVAsVUFBQSx5QkFBeUIsRUFBRztBQUpyQjtBQURKO0FBMUJEO0FBeENILEdBSDZCO0FBaUZsQztBQUNBLEVBQUEsT0FBTyxFQUFQLGdCQWxGa0M7QUFtRmxDLEVBQUEsU0FBUyxFQUFULGtCQW5Ga0M7QUFvRmxDLEVBQUEsT0FBTyxFQUFQO0FBcEZrQyxDQUFmLENBQXZCO2VBdUZlLGM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqR2Y7QUFDQSxJQUFJLHVCQUF1QixHQUFHLEtBQTlCOztBQUVBLElBQUc7QUFDRCxNQUFNLEVBQUUsR0FBRyxJQUFJLGVBQUosRUFBWDtBQUVBLEVBQUEsS0FBSyxDQUFDLEdBQUQsRUFBTTtBQUFDLElBQUEsTUFBTSxFQUFFLEVBQUUsQ0FBQztBQUFaLEdBQU4sQ0FBTCxDQUNDLElBREQsQ0FDTSxVQUFBLENBQUM7QUFBQSxXQUFJLENBQUMsQ0FBQyxJQUFGLEVBQUo7QUFBQSxHQURQLEVBRUMsSUFGRCxDQUVNLFVBQUEsTUFBTSxFQUFJO0FBQ2QsSUFBQSx1QkFBdUIsR0FBRyxLQUExQjtBQUNELEdBSkQsRUFLQyxLQUxELENBS08sVUFBQSxHQUFHLEVBQUk7QUFDWixJQUFBLHVCQUF1QixHQUFHLEdBQUcsQ0FBQyxJQUFKLEtBQWEsWUFBdkM7QUFDRCxHQVBEO0FBU0EsRUFBQSxFQUFFLENBQUMsS0FBSDtBQUNELENBYkQsQ0FjQSxPQUFNLENBQU4sRUFBUTtBQUNOLEVBQUEsdUJBQXVCLEdBQUcsS0FBMUI7QUFDRCxDLENBRUQ7OztBQUNPLFNBQVMscUJBQVQsQ0FBK0IsR0FBL0IsRUFBb0MsSUFBcEMsRUFBd0Q7QUFBQSxNQUFkLFFBQWMsdUVBQUwsR0FBSztBQUM3RCxNQUFJLE9BQU8sR0FBRyxHQUFkLENBRDZELENBRTdEOztBQUNBLE1BQUk7QUFDRixRQUFJLFlBQVksR0FBRyxPQUFuQjtBQUNBLElBQUEsSUFBSSxDQUFDLEtBQUwsQ0FBVyxRQUFYLEVBQXFCLE9BQXJCLENBQThCLFVBQVMsQ0FBVCxFQUFZO0FBQ3hDLE1BQUEsWUFBWSxHQUFHLFlBQVksQ0FBQyxDQUFELENBQTNCO0FBQ0QsS0FGRCxFQUZFLENBS0Y7O0FBQ0EsV0FBTyxZQUFQO0FBQ0QsR0FQRCxDQU9FLE9BQU8sQ0FBUCxFQUFVO0FBQ1YsV0FBTyxFQUFQO0FBQ0Q7QUFDRixDLENBRUQ7OztBQUNPLFNBQVMsYUFBVCxDQUF1QixRQUF2QixFQUFpQztBQUV0QyxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsb0JBQVQsQ0FBOEIsTUFBOUIsQ0FBZDs7QUFDQSxPQUFLLElBQUksQ0FBQyxHQUFHLENBQWIsRUFBZ0IsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUExQixFQUFrQyxDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLFFBQUksS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTLFlBQVQsQ0FBc0IsTUFBdEIsTUFBa0MsUUFBdEMsRUFBZ0Q7QUFDOUMsYUFBTyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVMsWUFBVCxDQUFzQixTQUF0QixDQUFQO0FBQ0Q7QUFDRjs7QUFDRCxTQUFPLEVBQVA7QUFDRCxDLENBR0Q7OztBQUNPLFNBQVMsV0FBVCxDQUFxQixFQUFyQixFQUF3QixjQUF4QixFQUF1QztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxNQUFNLEdBQUcsR0FBRyx1QkFBdUIsQ0FBQztBQUNsQyxJQUFBLGNBQWMsRUFBRyxjQURpQjtBQUVsQyxJQUFBLGNBQWMsRUFBRztBQUFFLE1BQUEsTUFBTSxFQUFHO0FBQVgsS0FGaUI7QUFHbEMsSUFBQSxlQUFlLEVBQUc7QUFIZ0IsR0FBRCxDQUFuQztBQU1BLFNBQU8sS0FBSyxDQUFDLEdBQUQsQ0FBTCxDQUNOLElBRE0sQ0FDRCxVQUFBLENBQUM7QUFBQSxXQUFJLENBQUMsQ0FBQyxJQUFGLEVBQUo7QUFBQSxHQURBLEVBRU4sSUFGTSxDQUVEO0FBQUEsUUFBRSxJQUFGLFFBQUUsSUFBRjtBQUFBLFFBQVEsS0FBUixRQUFRLEtBQVI7QUFBQSxXQUNKLElBQUksSUFBSSxJQUFJLENBQUMsUUFBYixJQUF5QixJQUFJLENBQUMsUUFBTCxDQUFjLE1BQXZDLElBQWtELEtBQUssQ0FBQyxPQUFOLENBQWMsSUFBSSxDQUFDLFFBQUwsQ0FBYyxNQUE1QixDQUFsRCxHQUNJLElBQUksQ0FBQyxRQUFMLENBQWMsTUFBZCxDQUFxQixDQUFyQixDQURKLEdBRUksU0FIQTtBQUFBLEdBRkMsQ0FBUDtBQU9EOztBQUdNLFNBQVMsV0FBVCxHQUFxQztBQUFBLE1BQWhCLEdBQWdCLHVFQUFWLFNBQVU7QUFFMUM7QUFFQTtBQUNBO0FBQ0EsTUFBTSxFQUFFLEdBQUcsdUJBQXVCLEdBQUcsSUFBSSxlQUFKLEVBQUgsR0FBMkIsU0FBN0Q7QUFDQSxNQUFJLGFBQWEsR0FBRyxLQUFwQjtBQUVBLFNBQU87QUFDTCxJQUFBLEtBREssbUJBQ0U7QUFDTCxNQUFBLGFBQWEsR0FBRyxJQUFoQjtBQUNBLFVBQUcsRUFBSCxFQUNJLEVBQUUsQ0FBQyxLQUFIO0FBQ0wsS0FMSTtBQU1MLElBQUEsT0FBTyxFQUFFLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQyxHQUFELEVBQU07QUFBQyxNQUFBLE1BQU0sRUFBRSxFQUFFLENBQUM7QUFBWixLQUFOLENBQVIsR0FBc0MsS0FBSyxDQUFDLEdBQUQsQ0FBOUMsRUFDUixJQURRLENBQ0gsVUFBQSxDQUFDO0FBQUEsYUFBSSxDQUFDLENBQUMsSUFBRixFQUFKO0FBQUEsS0FERSxFQUVSLElBRlEsQ0FFSCxpQkFBbUI7QUFBQSxVQUFqQixJQUFpQixTQUFqQixJQUFpQjtBQUFBLFVBQVgsS0FBVyxTQUFYLEtBQVc7O0FBQ3ZCLFVBQUcsYUFBSCxFQUFpQjtBQUNmLFlBQU0sS0FBSyxHQUFHLElBQUksS0FBSixDQUFVLGdCQUFWLENBQWQ7QUFDQSxRQUFBLEtBQUssQ0FBQyxJQUFOLEdBQWEsWUFBYjtBQUNBLGNBQU0sS0FBTjtBQUNELE9BSkQsTUFLSTtBQUNGO0FBQ0EsZUFBTztBQUNMLFVBQUEsUUFBUSxFQUFFLElBQUksSUFDWCxJQUFJLENBQUMsUUFERSxJQUVQLElBQUksQ0FBQyxRQUFMLENBQWMsTUFGUCxJQUdQLEtBQUssQ0FBQyxPQUFOLENBQWMsSUFBSSxDQUFDLFFBQUwsQ0FBYyxNQUE1QixDQUhPLEdBSVIsSUFBSSxDQUFDLFFBQUwsQ0FBYyxNQUpOLEdBS1IsRUFORztBQU9MLFVBQUEsS0FBSyxFQUFHLElBQUksSUFBSSxJQUFJLENBQUMsUUFBYixJQUF5QixJQUFJLENBQUMsUUFBTCxDQUFjLFlBQXhDLEdBQXdELElBQUksQ0FBQyxRQUFMLENBQWMsWUFBdEUsR0FBcUY7QUFQdkYsU0FBUDtBQVNEO0FBQ0YsS0FwQlE7QUFOSixHQUFQO0FBOEJEOztBQUVNLFNBQVMsdUJBQVQsQ0FBaUMsR0FBakMsRUFBc0M7QUFDM0MsTUFBSSxDQUFDLEdBQUwsRUFBVTtBQUFFLFVBQU0sd0RBQU47QUFBZ0UsR0FEakMsQ0FHM0M7QUFDQTtBQUVBOzs7QUFDQSxNQUFNLGNBQWMsR0FBRyxHQUFHLENBQUMsY0FBM0I7QUFDQSxNQUFNLGtCQUFrQixHQUFHLGNBQWMsQ0FBQyxZQUExQyxDQVIyQyxDQVUzQzs7QUFDQSxNQUFNLGNBQWMsR0FBRyxHQUFHLENBQUMsY0FBM0I7QUFDQSxNQUFNLGVBQWUsR0FBRyxHQUFHLENBQUMsZUFBNUIsQ0FaMkMsQ0FjM0M7O0FBQ0EsTUFBSSxTQUFTLEdBQUcsY0FBYyxDQUFDLFFBQWYsR0FBMEIsR0FBMUM7QUFFQSxNQUFNLE9BQU8sR0FBRyxDQUFDLE9BQUQsRUFBVSxRQUFWLEVBQW9CLE1BQXBCLEVBQTRCLFNBQTVCLEVBQXVDLGNBQXZDLEVBQXVELFFBQXZELEVBQWlFLGFBQWpFLENBQWhCLENBakIyQyxDQW1CM0M7O0FBQ0EsTUFBSSxTQUFTLEdBQUcsRUFBaEI7O0FBQ0EsT0FBSyxJQUFJLEdBQVQsSUFBZ0Isa0JBQWhCLEVBQXFDO0FBQ25DLFFBQU0sV0FBVyxHQUFHLGtCQUFrQixDQUFDLEdBQUQsQ0FBdEMsQ0FEbUMsQ0FFbkM7O0FBQ0EsUUFBSyxDQUFDLFdBQVcsQ0FBQyxRQUFiLElBQXlCLE9BQU8sQ0FBQyxPQUFSLENBQWdCLFdBQVcsQ0FBQyxPQUE1QixNQUF5QyxDQUFDLENBQXhFLEVBQTJFO0FBQ3pFLFVBQUssY0FBYyxDQUFDLFdBQVcsQ0FBQyxPQUFiLENBQW5CLEVBQTJDO0FBQ3pDLFlBQUksU0FBUyxHQUFHLFdBQVcsQ0FBQyxHQUFaLEdBQWtCLEdBQWxCLEdBQXdCLGNBQWMsQ0FBQyxXQUFXLENBQUMsT0FBYixDQUF0RDtBQUNBLFFBQUEsU0FBUyxDQUFDLElBQVYsQ0FBZSxTQUFmO0FBQ0Q7QUFDRjtBQUNGLEdBOUIwQyxDQWdDM0M7QUFDQTs7O0FBQ0EsTUFBTSxZQUFZLEdBQUcsa0JBQWtCLENBQUMsSUFBbkIsQ0FBeUIsVUFBQSxDQUFDO0FBQUEsV0FBSSxDQUFDLENBQUMsT0FBRixLQUFjLFNBQWxCO0FBQUEsR0FBMUIsQ0FBckIsQ0FsQzJDLENBbUMzQzs7QUFDQSxNQUFJLFlBQVksSUFBSSxlQUFlLENBQUMsTUFBaEIsR0FBeUIsQ0FBN0MsRUFBZ0Q7QUFDOUMsUUFBTSxZQUFXLEdBQUcsWUFBWSxDQUFDLEdBQWpDOztBQUNBLFNBQUssSUFBSSxLQUFULElBQWtCLGVBQWxCLEVBQW1DO0FBQ2pDLFVBQUksZUFBZSxHQUFHLFlBQVcsR0FBRyxHQUFkLEdBQW9CLGVBQWUsQ0FBQyxLQUFELENBQXpEO0FBQ0EsTUFBQSxTQUFTLENBQUMsSUFBVixDQUFlLGVBQWY7QUFDRDtBQUNGOztBQUVELE1BQUksY0FBYyxHQUFHLFNBQVMsQ0FBQyxJQUFWLENBQWUsR0FBZixDQUFyQjtBQUNBLEVBQUEsU0FBUyxJQUFJLGNBQWIsQ0E3QzJDLENBZ0QzQzs7QUFFQSxTQUFPLFNBQVA7QUFDRCxDLENBRUQ7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUlPLFNBQVMsd0JBQVQsQ0FBa0Msa0JBQWxDLEVBQXFEO0FBQzFEO0FBQ0EsTUFBTSxlQUFlLEdBQUcsSUFBSSxHQUFKLEVBQXhCO0FBRjBEO0FBQUE7QUFBQTs7QUFBQTtBQUcxRCx5QkFBZSxrQkFBZiw4SEFBa0M7QUFBQSxVQUF4QixDQUF3QjtBQUNoQyxNQUFBLGVBQWUsQ0FBQyxHQUFoQixDQUFvQixDQUFDLENBQUMsSUFBdEIsRUFBNEIsSUFBSSxHQUFKLEVBQTVCO0FBQ0Q7QUFMeUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNMUQsU0FBTyxlQUFQO0FBQ0Q7O0FBRU0sU0FBUyxjQUFULENBQXdCLFNBQXhCLEVBQW1DLE1BQW5DLEVBQTJDLEtBQTNDLEVBQWlEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLE1BQUksVUFBVSxHQUFHLFNBQVMsQ0FBQyxJQUFWLENBQWUsVUFBQSxDQUFDO0FBQUEsV0FBSSxDQUFDLENBQUMsTUFBRixJQUFZLE1BQWhCO0FBQUEsR0FBaEIsQ0FBakI7QUFDQSxNQUFJLE9BQU8sR0FBRyxVQUFVLENBQUMsS0FBRCxDQUF4QixDQUxzRCxDQU10RDs7QUFDQSxTQUFPLE9BQVA7QUFDRDs7QUFFTSxTQUFTLDhCQUFULENBQXdDLGtCQUF4QyxFQUEyRDtBQUNoRSxNQUFJLFVBQVUsR0FBRyxFQUFqQjtBQUNBLEVBQUEsa0JBQWtCLENBQUMsT0FBbkIsQ0FBNEIsVUFBQyxHQUFELEVBQUssR0FBTCxFQUFTLEdBQVQsRUFBaUI7QUFDM0M7QUFDQSxJQUFBLEdBQUcsQ0FBQyxPQUFKLENBQWEsVUFBQyxDQUFELEVBQU87QUFDbEIsTUFBQSxVQUFVLENBQUMsSUFBWCxDQUFnQixHQUFHLEdBQUcsQ0FBdEI7QUFDRCxLQUZEO0FBR0QsR0FMRCxFQUZnRSxDQVFoRTs7QUFDQSxTQUFPLFVBQVA7QUFDRCxDLENBR0Q7OztBQUNPLFNBQVMsVUFBVCxDQUFvQixHQUFwQixFQUF5QixRQUF6QixFQUFrQztBQUN2QyxFQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVkscUJBQVosRUFBbUMsR0FBbkM7QUFDQSxNQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixRQUF2QixDQUFiO0FBQ0EsRUFBQSxNQUFNLENBQUMsSUFBUCxHQUFjLGlCQUFkO0FBQ0EsRUFBQSxNQUFNLENBQUMsR0FBUCxHQUFhLEdBQWI7QUFFQSxFQUFBLE1BQU0sQ0FBQyxrQkFBUCxHQUE0QixRQUE1QjtBQUNBLEVBQUEsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsUUFBaEI7QUFFQSxFQUFBLFFBQVEsQ0FBQyxJQUFULENBQWMsV0FBZCxDQUEwQixNQUExQjtBQUNELEMsQ0FFRDs7O0FBQ08sU0FBUyxnQkFBVCxHQUErRTtBQUFBLE1BQXJELFlBQXFELHVFQUF4QyxDQUF3QztBQUFBLE1BQXJDLFVBQXFDLHVFQUExQixJQUEwQjtBQUFBLE1BQXBCLGFBQW9CLHVFQUFOLEtBQU07QUFDcEYsRUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLDhCQUFaO0FBQ0EsTUFBSSxTQUFTLEdBQUcsYUFBYSxDQUFDLE1BQWQsQ0FBcUIsV0FBckIsRUFBa0M7QUFDaEQ7QUFDQSxJQUFBLFlBQVksRUFBRSxDQUZrQztBQUdoRCxJQUFBLFFBQVEsRUFBRSxJQUhzQztBQUloRCxJQUFBLFVBQVUsRUFBRSxLQUpvQyxDQU1oRDtBQUNBO0FBQ0E7O0FBUmdELEdBQWxDLENBQWhCLENBRm9GLENBYWxGOztBQUNGLEVBQUEsUUFBUSxDQUFDLHNCQUFULENBQWdDLDRCQUFoQyxFQUE4RCxDQUE5RCxFQUFpRSxVQUFqRSxDQUE0RSxDQUE1RSxFQUErRSxNQUEvRTtBQUNBLEVBQUEsUUFBUSxDQUFDLHNCQUFULENBQWdDLHdCQUFoQyxFQUEwRCxDQUExRCxFQUE2RCxVQUE3RCxDQUF3RSxDQUF4RSxFQUEyRSxNQUEzRTtBQUNEOzs7OztBQ3pSRCxJQUFJLFNBQVMsR0FBSSxVQUFRLFNBQUssU0FBZCxJQUE2QixZQUFZO0FBQ3ZELE1BQUksYUFBYSxHQUFHLE1BQU0sQ0FBQyxjQUFQLElBQ2Y7QUFBRSxJQUFBLFNBQVMsRUFBRTtBQUFiLGVBQTZCLEtBQTdCLElBQXNDLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFBRSxJQUFBLENBQUMsQ0FBQyxTQUFGLEdBQWMsQ0FBZDtBQUFrQixHQUQzRCxJQUVoQixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQUUsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFVBQUksQ0FBQyxDQUFDLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixDQUFDLENBQUMsQ0FBRCxDQUFELEdBQU8sQ0FBQyxDQUFDLENBQUQsQ0FBUjtBQUExQztBQUF3RCxHQUY5RTs7QUFHQSxTQUFPLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDbkIsSUFBQSxhQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBYjs7QUFDQSxhQUFTLEVBQVQsR0FBYztBQUFFLFdBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1Qjs7QUFDdkMsSUFBQSxDQUFDLENBQUMsU0FBRixHQUFjLENBQUMsS0FBSyxJQUFOLEdBQWEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsRUFBRSxDQUFDLFNBQUgsR0FBZSxDQUFDLENBQUMsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxHQUpEO0FBS0QsQ0FUMkMsRUFBNUM7O0FBVUEsSUFBSSxZQUFKOztBQUNBLENBQUMsVUFBVSxjQUFWLEVBQTBCO0FBQ3pCLE1BQUksS0FBSyxHQUFJLFlBQVk7QUFDckIsYUFBUyxLQUFULEdBQWlCLENBQ2hCOztBQUNELFdBQU8sS0FBUDtBQUNILEdBSlksRUFBYjs7QUFLQSxFQUFBLGNBQWMsQ0FBQyxLQUFmLEdBQXVCLEtBQXZCOztBQUNBLE1BQUksYUFBYSxHQUFJLFlBQVk7QUFDN0IsYUFBUyxhQUFULEdBQXlCLENBQ3hCOztBQUNELFdBQU8sYUFBUDtBQUNILEdBSm9CLEVBQXJCOztBQUtBLEVBQUEsY0FBYyxDQUFDLGFBQWYsR0FBK0IsYUFBL0I7QUFDQSxNQUFJLGVBQWUsR0FBRyxDQUF0QjtBQUNBLE1BQUksZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLEdBQUwsQ0FBUyxDQUFULEVBQVksRUFBWixJQUFrQixDQUF6Qzs7QUFDQSxNQUFJLE1BQU0sR0FBSSxVQUFVLE1BQVYsRUFBa0I7QUFDNUIsSUFBQSxTQUFTLENBQUMsTUFBRCxFQUFTLE1BQVQsQ0FBVDs7QUFDQSxhQUFTLE1BQVQsQ0FBZ0IsR0FBaEIsRUFBcUIsR0FBckIsRUFBMEIsSUFBMUIsRUFBZ0MsUUFBaEMsRUFBMEMsTUFBMUMsRUFBa0QsUUFBbEQsRUFBNEQ7QUFDeEQsVUFBSSxJQUFJLEtBQUssS0FBSyxDQUFsQixFQUFxQjtBQUFFLFFBQUEsSUFBSSxHQUFHLEVBQVA7QUFBWTs7QUFDbkMsVUFBSSxNQUFNLEtBQUssS0FBSyxDQUFwQixFQUF1QjtBQUFFLFFBQUEsTUFBTSxHQUFHLENBQVQ7QUFBYTs7QUFDdEMsVUFBSSxRQUFRLEtBQUssS0FBSyxDQUF0QixFQUF5QjtBQUFFLFFBQUEsUUFBUSxHQUFHLEtBQVg7QUFBbUI7O0FBQzlDLFVBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksSUFBWixLQUFxQixJQUFqQzs7QUFDQSxNQUFBLEtBQUssQ0FBQyxJQUFOLEdBQWEsSUFBYjtBQUNBLE1BQUEsS0FBSyxDQUFDLFFBQU4sR0FBaUI7QUFBRSxRQUFBLEdBQUcsRUFBRSxDQUFDLEdBQVI7QUFBYSxRQUFBLEdBQUcsRUFBRSxDQUFDO0FBQW5CLE9BQWpCO0FBQ0EsTUFBQSxLQUFLLENBQUMsTUFBTixHQUFlLE1BQWY7QUFDQSxNQUFBLEtBQUssQ0FBQyxRQUFOLEdBQWlCLFFBQWpCO0FBQ0EsTUFBQSxLQUFLLENBQUMsUUFBTixHQUFpQixRQUFqQjtBQUNBLE1BQUEsS0FBSyxDQUFDLFFBQU4sR0FBaUIsZUFBZSxFQUFoQztBQUNBLGFBQU8sS0FBUDtBQUNIOztBQUNELElBQUEsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsSUFBakIsR0FBd0IsVUFBVSxHQUFWLEVBQWUsR0FBZixFQUFvQjtBQUN4QyxXQUFLLFFBQUwsQ0FBYyxHQUFkLEdBQW9CLENBQUMsR0FBckI7QUFDQSxXQUFLLFFBQUwsQ0FBYyxHQUFkLEdBQW9CLENBQUMsR0FBckI7QUFDSCxLQUhEOztBQUlBLElBQUEsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsT0FBakIsR0FBMkIsVUFBVSxJQUFWLEVBQWdCO0FBQ3ZDLFdBQUssSUFBSSxHQUFULElBQWdCLElBQWhCLEVBQXNCO0FBQ2xCLGFBQUssSUFBTCxDQUFVLEdBQVYsSUFBaUIsSUFBSSxDQUFDLEdBQUQsQ0FBckI7QUFDSDtBQUNKLEtBSkQ7O0FBS0EsV0FBTyxNQUFQO0FBQ0gsR0F6QmEsQ0F5QlosYUF6QlksQ0FBZDs7QUEwQkEsRUFBQSxjQUFjLENBQUMsTUFBZixHQUF3QixNQUF4Qjs7QUFDQSxNQUFJLE9BQU8sR0FBSSxVQUFVLE1BQVYsRUFBa0I7QUFDN0IsSUFBQSxTQUFTLENBQUMsT0FBRCxFQUFVLE1BQVYsQ0FBVDs7QUFDQSxhQUFTLE9BQVQsQ0FBaUIsTUFBakIsRUFBeUI7QUFDckIsVUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUFaLEtBQXFCLElBQWpDOztBQUNBLE1BQUEsS0FBSyxDQUFDLEtBQU4sR0FBYyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLENBQWQ7QUFDQSxNQUFBLEtBQUssQ0FBQyxJQUFOLEdBQWEsRUFBYjs7QUFDQSxVQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1QsUUFBQSxLQUFLLENBQUMsUUFBTixHQUFpQixDQUFqQjs7QUFDQSxZQUFJLE9BQU8sQ0FBQyxtQkFBWixFQUFpQztBQUM3QixVQUFBLEtBQUssQ0FBQyxlQUFOLEdBQXdCLEVBQXhCO0FBQ0g7O0FBQ0QsZUFBTyxLQUFQO0FBQ0g7O0FBQ0QsVUFBSSxPQUFPLENBQUMsbUJBQVosRUFBaUM7QUFDN0IsUUFBQSxLQUFLLENBQUMsZUFBTixHQUF3QixDQUFDLE1BQUQsQ0FBeEI7QUFDSDs7QUFDRCxNQUFBLEtBQUssQ0FBQyxVQUFOLEdBQW1CLE1BQW5CO0FBQ0EsTUFBQSxLQUFLLENBQUMsUUFBTixHQUFpQixLQUFLLE1BQU0sQ0FBQyxRQUE3QjtBQUNBLE1BQUEsS0FBSyxDQUFDLFVBQU4sR0FBbUIsQ0FBbkI7O0FBQ0EsVUFBSSxNQUFNLENBQUMsUUFBUCxLQUFvQixTQUF4QixFQUFtQztBQUMvQixRQUFBLEtBQUssQ0FBQyxLQUFOLENBQVksTUFBTSxDQUFDLFFBQW5CLElBQStCLENBQS9CO0FBQ0g7O0FBQ0QsTUFBQSxLQUFLLENBQUMsV0FBTixHQUFvQixNQUFNLENBQUMsTUFBM0I7QUFDQSxNQUFBLEtBQUssQ0FBQyxRQUFOLEdBQWlCO0FBQ2IsUUFBQSxHQUFHLEVBQUUsTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsR0FEUjtBQUViLFFBQUEsR0FBRyxFQUFFLE1BQU0sQ0FBQyxRQUFQLENBQWdCO0FBRlIsT0FBakI7QUFJQSxNQUFBLEtBQUssQ0FBQyxlQUFOLEdBQXdCO0FBQ3BCLFFBQUEsR0FBRyxFQUFFLE1BQU0sQ0FBQyxRQUFQLENBQWdCLEdBREQ7QUFFcEIsUUFBQSxHQUFHLEVBQUUsTUFBTSxDQUFDLFFBQVAsQ0FBZ0I7QUFGRCxPQUF4QjtBQUlBLGFBQU8sS0FBUDtBQUNIOztBQUNELElBQUEsT0FBTyxDQUFDLFNBQVIsQ0FBa0IsU0FBbEIsR0FBOEIsVUFBVSxNQUFWLEVBQWtCO0FBQzVDLFVBQUksT0FBTyxDQUFDLG1CQUFaLEVBQWlDO0FBQzdCLGFBQUssZUFBTCxDQUFxQixJQUFyQixDQUEwQixNQUExQjtBQUNIOztBQUNELFVBQUksQ0FBQyxHQUFHLEtBQUssUUFBYjtBQUNBLE1BQUEsQ0FBQyxHQUFJLENBQUMsQ0FBQyxJQUFJLENBQU4sSUFBVyxDQUFaLEdBQWlCLE1BQU0sQ0FBQyxRQUE1Qjs7QUFDQSxVQUFJLENBQUMsSUFBSSxnQkFBVCxFQUEyQjtBQUN2QixhQUFLLFFBQUwsR0FBZ0IsQ0FBQyxHQUFHLGdCQUFwQjtBQUNILE9BRkQsTUFHSztBQUNELGFBQUssUUFBTCxHQUFnQixDQUFoQjtBQUNIOztBQUNELFdBQUssVUFBTCxHQUFrQixNQUFsQjtBQUNBLFVBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFwQjtBQUFBLFVBQTRCLGtCQUFrQixHQUFHLEtBQUssV0FBdEQ7QUFBQSxVQUFtRSxTQUFTLEdBQUcsTUFBTSxHQUFHLGtCQUF4RjtBQUNBLFdBQUssZUFBTCxDQUFxQixHQUFyQixHQUNJLENBQUMsS0FBSyxlQUFMLENBQXFCLEdBQXJCLEdBQTJCLGtCQUEzQixHQUNHLE1BQU0sQ0FBQyxRQUFQLENBQWdCLEdBQWhCLEdBQXNCLE1BRDFCLElBQ29DLFNBRnhDO0FBR0EsV0FBSyxlQUFMLENBQXFCLEdBQXJCLEdBQ0ksQ0FBQyxLQUFLLGVBQUwsQ0FBcUIsR0FBckIsR0FBMkIsa0JBQTNCLEdBQ0csTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsR0FBaEIsR0FBc0IsTUFEMUIsSUFDb0MsU0FGeEM7QUFHQSxRQUFFLEtBQUssVUFBUDtBQUNBLFdBQUssV0FBTCxHQUFtQixTQUFuQjs7QUFDQSxVQUFJLE1BQU0sQ0FBQyxRQUFQLEtBQW9CLFNBQXhCLEVBQW1DO0FBQy9CLGFBQUssS0FBTCxDQUFXLE1BQU0sQ0FBQyxRQUFsQixJQUErQixLQUFLLEtBQUwsQ0FBVyxNQUFNLENBQUMsUUFBbEIsSUFBOEIsQ0FBL0IsSUFBcUMsQ0FBbkU7QUFDSDtBQUNKLEtBekJEOztBQTBCQSxJQUFBLE9BQU8sQ0FBQyxTQUFSLENBQWtCLEtBQWxCLEdBQTBCLFlBQVk7QUFDbEMsV0FBSyxRQUFMLEdBQWdCLENBQWhCO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLFNBQWxCO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLENBQWxCO0FBQ0EsV0FBSyxXQUFMLEdBQW1CLENBQW5CO0FBQ0EsV0FBSyxLQUFMLEdBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixDQUFiOztBQUNBLFVBQUksT0FBTyxDQUFDLG1CQUFaLEVBQWlDO0FBQzdCLGFBQUssZUFBTCxHQUF1QixFQUF2QjtBQUNIO0FBQ0osS0FURDs7QUFVQSxJQUFBLE9BQU8sQ0FBQyxTQUFSLENBQWtCLGFBQWxCLEdBQWtDLFVBQVUsT0FBVixFQUFtQjtBQUNqRCxVQUFJLElBQUksR0FBRyxPQUFPLENBQUMsT0FBUixDQUFnQixLQUFLLFFBQUwsQ0FBYyxHQUE5QixFQUFtQyxLQUFLLFFBQUwsQ0FBYyxHQUFqRCxDQUFYO0FBQ0EsVUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQW5CO0FBQ0EsVUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxJQUFJLENBQUMsQ0FBTCxHQUFTLElBQXBCLENBQVY7QUFBQSxVQUFxQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxJQUFJLENBQUMsQ0FBTCxHQUFTLElBQXBCLENBQTNDO0FBQUEsVUFBc0UsTUFBTSxHQUFHLEdBQUcsR0FBRyxJQUFyRjtBQUFBLFVBQTJGLE1BQU0sR0FBRyxHQUFHLEdBQUcsSUFBMUc7QUFDQSxVQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsU0FBUixDQUFrQixNQUFsQixFQUEwQixNQUExQixDQUFSO0FBQUEsVUFBMkMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxTQUFSLENBQWtCLE1BQU0sR0FBRyxJQUEzQixFQUFpQyxNQUFNLEdBQUcsSUFBMUMsQ0FBL0M7QUFDQSxXQUFLLE1BQUwsR0FBYztBQUNWLFFBQUEsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQURBO0FBRVYsUUFBQSxNQUFNLEVBQUUsQ0FBQyxDQUFDLEdBRkE7QUFHVixRQUFBLE1BQU0sRUFBRSxDQUFDLENBQUMsR0FIQTtBQUlWLFFBQUEsTUFBTSxFQUFFLENBQUMsQ0FBQztBQUpBLE9BQWQ7QUFNSCxLQVhEOztBQVlBLElBQUEsT0FBTyxDQUFDLFNBQVIsQ0FBa0IsaUJBQWxCLEdBQXNDLFlBQVk7QUFDOUMsYUFBTyxLQUFLLGVBQVo7QUFDSCxLQUZEOztBQUdBLElBQUEsT0FBTyxDQUFDLFNBQVIsQ0FBa0IsWUFBbEIsR0FBaUMsVUFBVSxVQUFWLEVBQXNCO0FBQ25ELFdBQUssUUFBTCxHQUFnQixLQUFLLFFBQUwsR0FBZ0IsRUFBaEIsR0FBcUIsVUFBVSxDQUFDLFFBQVgsR0FBc0IsRUFBM0Q7O0FBQ0EsVUFBSSxLQUFLLFFBQUwsR0FBZ0IsZ0JBQXBCLEVBQXNDO0FBQ2xDLGFBQUssUUFBTCxHQUFnQixLQUFLLFFBQUwsR0FBZ0IsZ0JBQWhDO0FBQ0g7O0FBQ0QsVUFBSSxNQUFNLEdBQUcsVUFBVSxDQUFDLFdBQXhCO0FBQUEsVUFBcUMsa0JBQWtCLEdBQUcsS0FBSyxXQUEvRDtBQUFBLFVBQTRFLFNBQVMsR0FBRyxNQUFNLEdBQUcsa0JBQWpHO0FBQ0EsV0FBSyxlQUFMLENBQXFCLEdBQXJCLEdBQ0ksQ0FBQyxLQUFLLGVBQUwsQ0FBcUIsR0FBckIsR0FBMkIsa0JBQTNCLEdBQ0csVUFBVSxDQUFDLGVBQVgsQ0FBMkIsR0FBM0IsR0FBaUMsTUFEckMsSUFDK0MsU0FGbkQ7QUFHQSxXQUFLLGVBQUwsQ0FBcUIsR0FBckIsR0FDSSxDQUFDLEtBQUssZUFBTCxDQUFxQixHQUFyQixHQUEyQixrQkFBM0IsR0FDRyxVQUFVLENBQUMsZUFBWCxDQUEyQixHQUEzQixHQUFpQyxNQURyQyxJQUMrQyxTQUZuRDtBQUdBLFdBQUssVUFBTCxJQUFtQixVQUFVLENBQUMsVUFBOUI7QUFDQSxXQUFLLFdBQUwsR0FBbUIsU0FBbkI7QUFDQSxXQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLElBQUksQ0FBQyxHQUFMLENBQVMsS0FBSyxNQUFMLENBQVksTUFBckIsRUFBNkIsVUFBVSxDQUFDLE1BQVgsQ0FBa0IsTUFBL0MsQ0FBckI7QUFDQSxXQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLElBQUksQ0FBQyxHQUFMLENBQVMsS0FBSyxNQUFMLENBQVksTUFBckIsRUFBNkIsVUFBVSxDQUFDLE1BQVgsQ0FBa0IsTUFBL0MsQ0FBckI7QUFDQSxXQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLElBQUksQ0FBQyxHQUFMLENBQVMsS0FBSyxNQUFMLENBQVksTUFBckIsRUFBNkIsVUFBVSxDQUFDLE1BQVgsQ0FBa0IsTUFBL0MsQ0FBckI7QUFDQSxXQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLElBQUksQ0FBQyxHQUFMLENBQVMsS0FBSyxNQUFMLENBQVksTUFBckIsRUFBNkIsVUFBVSxDQUFDLE1BQVgsQ0FBa0IsTUFBL0MsQ0FBckI7O0FBQ0EsV0FBSyxJQUFJLFFBQVQsSUFBcUIsVUFBVSxDQUFDLEtBQWhDLEVBQXVDO0FBQ25DLFlBQUksVUFBVSxDQUFDLEtBQVgsQ0FBaUIsY0FBakIsQ0FBZ0MsUUFBaEMsQ0FBSixFQUErQztBQUMzQyxjQUFJLEtBQUssS0FBTCxDQUFXLGNBQVgsQ0FBMEIsUUFBMUIsQ0FBSixFQUF5QztBQUNyQyxpQkFBSyxLQUFMLENBQVcsUUFBWCxLQUF3QixVQUFVLENBQUMsS0FBWCxDQUFpQixRQUFqQixDQUF4QjtBQUNILFdBRkQsTUFHSztBQUNELGlCQUFLLEtBQUwsQ0FBVyxRQUFYLElBQXVCLFVBQVUsQ0FBQyxLQUFYLENBQWlCLFFBQWpCLENBQXZCO0FBQ0g7QUFDSjtBQUNKOztBQUNELFVBQUksT0FBTyxDQUFDLG1CQUFaLEVBQWlDO0FBQzdCLGFBQUssZUFBTCxHQUF1QixLQUFLLGVBQUwsQ0FBcUIsTUFBckIsQ0FBNEIsVUFBVSxDQUFDLGlCQUFYLEVBQTVCLENBQXZCO0FBQ0g7QUFDSixLQS9CRDs7QUFnQ0EsSUFBQSxPQUFPLENBQUMsbUJBQVIsR0FBOEIsS0FBOUI7QUFDQSxXQUFPLE9BQVA7QUFDSCxHQXRIYyxDQXNIYixhQXRIYSxDQUFmOztBQXVIQSxFQUFBLGNBQWMsQ0FBQyxPQUFmLEdBQXlCLE9BQXpCOztBQUNBLFdBQVMseUJBQVQsQ0FBbUMsQ0FBbkMsRUFBc0MsQ0FBdEMsRUFBeUM7QUFDckMsV0FBUSxDQUFDLENBQUMsR0FBRixJQUFTLENBQUMsQ0FBQyxNQUFYLElBQXFCLENBQUMsQ0FBQyxHQUFGLElBQVMsQ0FBQyxDQUFDLE1BQWpDLElBQ0gsQ0FBQyxDQUFDLEdBQUYsSUFBUyxDQUFDLENBQUMsTUFEUixJQUNrQixDQUFDLENBQUMsR0FBRixJQUFTLENBQUMsQ0FBQyxNQURwQztBQUVIOztBQUNELFdBQVMsYUFBVCxDQUF1QixJQUF2QixFQUE2QjtBQUN6QixTQUFLLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFYLEVBQWMsR0FBZCxFQUFtQixNQUFuQixFQUEyQixNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQTlDLEVBQXNELENBQUMsR0FBRyxNQUExRCxFQUFrRSxFQUFFLENBQXBFLEVBQXVFO0FBQ25FLE1BQUEsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFELENBQVY7QUFDQSxNQUFBLE1BQU0sR0FBRyxHQUFHLENBQUMsUUFBSixDQUFhLEdBQXRCOztBQUNBLFdBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsSUFBSSxDQUFMLElBQVUsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRLFFBQVIsQ0FBaUIsR0FBakIsR0FBdUIsTUFBakQsRUFBeUQsRUFBRSxDQUEzRCxFQUE4RDtBQUMxRCxRQUFBLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBTCxDQUFKLEdBQWMsSUFBSSxDQUFDLENBQUQsQ0FBbEI7QUFDSDs7QUFDRCxNQUFBLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBTCxDQUFKLEdBQWMsR0FBZDtBQUNIO0FBQ0o7O0FBQ0QsV0FBUyxzQkFBVCxDQUFnQyxLQUFoQyxFQUF1QyxTQUF2QyxFQUFrRDtBQUM5QyxRQUFJLFNBQVMsR0FBRyxHQUFoQixFQUFxQjtBQUNqQixhQUFPLEtBQVA7QUFDSCxLQUZELE1BR0s7QUFDRCxhQUFRLFNBQVMsR0FBRyxLQUFiLEdBQXNCLEdBQTdCO0FBQ0g7QUFDSjs7QUFDRCxNQUFJLFlBQVksR0FBSSxZQUFZO0FBQzVCLGFBQVMsWUFBVCxHQUF3QjtBQUNwQixXQUFLLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQSxXQUFLLFVBQUwsR0FBa0IsQ0FBbEI7QUFDQSxXQUFLLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxXQUFLLElBQUwsR0FBWSxHQUFaO0FBQ0EsV0FBSyxXQUFMLEdBQW1CLEdBQW5CO0FBQ0g7O0FBQ0QsSUFBQSxZQUFZLENBQUMsU0FBYixDQUF1QixjQUF2QixHQUF3QyxVQUFVLE1BQVYsRUFBa0I7QUFDdEQsVUFBSSxNQUFNLENBQUMsV0FBWCxFQUF3QjtBQUNwQixlQUFPLE1BQU0sQ0FBQyxXQUFkO0FBQ0g7O0FBQ0QsV0FBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixNQUFuQjs7QUFDQSxXQUFLLFVBQUwsSUFBbUIsQ0FBbkI7QUFDSCxLQU5EOztBQU9BLElBQUEsWUFBWSxDQUFDLFNBQWIsQ0FBdUIsZUFBdkIsR0FBeUMsVUFBVSxPQUFWLEVBQW1CO0FBQ3hELFVBQUksS0FBSyxHQUFHLElBQVo7O0FBQ0EsTUFBQSxPQUFPLENBQUMsT0FBUixDQUFnQixVQUFVLE1BQVYsRUFBa0I7QUFDOUIsUUFBQSxLQUFLLENBQUMsY0FBTixDQUFxQixNQUFyQjtBQUNILE9BRkQ7QUFHSCxLQUxEOztBQU1BLElBQUEsWUFBWSxDQUFDLFNBQWIsQ0FBdUIsWUFBdkIsR0FBc0MsWUFBWTtBQUM5QyxVQUFJLE9BQU8sR0FBRyxLQUFLLFFBQW5CO0FBQUEsVUFBNkIsTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUE5Qzs7QUFDQSxVQUFJLEtBQUssVUFBTCxJQUFtQixDQUFDLHNCQUFzQixDQUFDLE1BQUQsRUFBUyxLQUFLLFVBQWQsQ0FBOUMsRUFBeUU7QUFDckUsYUFBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQUUsaUJBQU8sQ0FBQyxDQUFDLFFBQUYsQ0FBVyxHQUFYLEdBQWlCLENBQUMsQ0FBQyxRQUFGLENBQVcsR0FBbkM7QUFBeUMsU0FBOUU7QUFDSCxPQUZELE1BR0s7QUFDRCxRQUFBLGFBQWEsQ0FBQyxPQUFELENBQWI7QUFDSDs7QUFDRCxXQUFLLFVBQUwsR0FBa0IsQ0FBbEI7QUFDSCxLQVREOztBQVVBLElBQUEsWUFBWSxDQUFDLFNBQWIsQ0FBdUIsYUFBdkIsR0FBdUMsWUFBWTtBQUMvQyxNQUFBLGFBQWEsQ0FBQyxLQUFLLFNBQU4sQ0FBYjtBQUNILEtBRkQ7O0FBR0EsSUFBQSxZQUFZLENBQUMsU0FBYixDQUF1QixtQkFBdkIsR0FBNkMsVUFBVSxHQUFWLEVBQWU7QUFDeEQsVUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFuQjtBQUFBLFVBQTZCLEVBQTdCO0FBQUEsVUFBaUMsSUFBakM7QUFBQSxVQUF1QyxLQUFLLEdBQUcsQ0FBL0M7QUFBQSxVQUFrRCxLQUFLLEdBQUcsT0FBTyxDQUFDLE1BQWxFOztBQUNBLGFBQU8sS0FBSyxHQUFHLENBQWYsRUFBa0I7QUFDZCxRQUFBLElBQUksR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLEtBQUssR0FBRyxDQUFuQixDQUFQO0FBQ0EsUUFBQSxFQUFFLEdBQUcsS0FBSyxHQUFHLElBQWI7O0FBQ0EsWUFBSSxPQUFPLENBQUMsRUFBRCxDQUFQLENBQVksUUFBWixDQUFxQixHQUFyQixHQUEyQixHQUEvQixFQUFvQztBQUNoQyxVQUFBLEtBQUssR0FBRyxFQUFFLEVBQVY7QUFDQSxVQUFBLEtBQUssSUFBSSxJQUFJLEdBQUcsQ0FBaEI7QUFDSCxTQUhELE1BSUs7QUFDRCxVQUFBLEtBQUssR0FBRyxJQUFSO0FBQ0g7QUFDSjs7QUFDRCxhQUFPLEtBQVA7QUFDSCxLQWREOztBQWVBLElBQUEsWUFBWSxDQUFDLFNBQWIsQ0FBdUIsa0JBQXZCLEdBQTRDLFlBQVk7QUFDcEQsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLEtBQUssU0FBTCxDQUFlLE1BQW5DLEVBQTJDLENBQUMsR0FBRyxDQUEvQyxFQUFrRCxFQUFFLENBQXBELEVBQXVEO0FBQ25ELFlBQUksT0FBTyxHQUFHLEtBQUssU0FBTCxDQUFlLENBQWYsQ0FBZDtBQUNBLFFBQUEsT0FBTyxDQUFDLEtBQVI7QUFDQSxRQUFBLE9BQU8sQ0FBQyxhQUFSLENBQXNCLElBQXRCO0FBQ0g7QUFDSixLQU5EOztBQU9BLElBQUEsWUFBWSxDQUFDLFNBQWIsQ0FBdUIsV0FBdkIsR0FBcUMsVUFBVSxNQUFWLEVBQWtCO0FBQ25ELFVBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsTUFBTSxDQUFDLE1BQWhDLElBQTBDLEtBQUssV0FBbEU7QUFBQSxVQUErRSxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUwsQ0FBUyxNQUFNLENBQUMsTUFBUCxHQUFnQixNQUFNLENBQUMsTUFBaEMsSUFBMEMsS0FBSyxXQUE1STtBQUNBLFVBQUksY0FBYyxHQUFHO0FBQ2pCLFFBQUEsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLFlBQWhCLEdBQStCLFlBRHRCO0FBRWpCLFFBQUEsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLFlBQWhCLEdBQStCLFlBRnRCO0FBR2pCLFFBQUEsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLFdBQWhCLEdBQThCLFdBSHJCO0FBSWpCLFFBQUEsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLFdBQWhCLEdBQThCO0FBSnJCLE9BQXJCOztBQU1BLFdBQUssWUFBTDs7QUFDQSxXQUFLLGtCQUFMOztBQUNBLFVBQUksVUFBVSxHQUFHLEtBQUssbUJBQUwsQ0FBeUIsY0FBYyxDQUFDLE1BQXhDLENBQWpCOztBQUNBLFVBQUksT0FBTyxHQUFHLEtBQUssUUFBbkI7QUFBQSxVQUE2QixRQUFRLEdBQUcsS0FBSyxTQUE3QztBQUNBLFVBQUksa0JBQWtCLEdBQUcsUUFBUSxDQUFDLEtBQVQsQ0FBZSxDQUFmLENBQXpCOztBQUNBLFdBQUssSUFBSSxDQUFDLEdBQUcsVUFBUixFQUFvQixDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQXJDLEVBQTZDLENBQUMsR0FBRyxDQUFqRCxFQUFvRCxFQUFFLENBQXRELEVBQXlEO0FBQ3JELFlBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFELENBQXBCO0FBQUEsWUFBeUIsY0FBYyxHQUFHLE1BQU0sQ0FBQyxRQUFqRDs7QUFDQSxZQUFJLGNBQWMsQ0FBQyxHQUFmLEdBQXFCLGNBQWMsQ0FBQyxNQUF4QyxFQUFnRDtBQUM1QztBQUNIOztBQUNELFlBQUksY0FBYyxDQUFDLEdBQWYsR0FBcUIsY0FBYyxDQUFDLE1BQXBDLElBQ0EsY0FBYyxDQUFDLEdBQWYsR0FBcUIsY0FBYyxDQUFDLE1BRHBDLElBRUEsQ0FBQyxNQUFNLENBQUMsUUFGWixFQUVzQjtBQUNsQixjQUFJLFlBQVksR0FBRyxLQUFuQjtBQUFBLGNBQTBCLE9BQTFCOztBQUNBLGVBQUssSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLEVBQUUsR0FBRyxrQkFBa0IsQ0FBQyxNQUF4QyxFQUFnRCxDQUFDLEdBQUcsRUFBcEQsRUFBd0QsRUFBRSxDQUExRCxFQUE2RDtBQUN6RCxZQUFBLE9BQU8sR0FBRyxrQkFBa0IsQ0FBQyxDQUFELENBQTVCOztBQUNBLGdCQUFJLE9BQU8sQ0FBQyxNQUFSLENBQWUsTUFBZixHQUF3QixNQUFNLENBQUMsUUFBUCxDQUFnQixHQUE1QyxFQUFpRDtBQUM3QyxjQUFBLGtCQUFrQixDQUFDLE1BQW5CLENBQTBCLENBQTFCLEVBQTZCLENBQTdCO0FBQ0EsZ0JBQUUsQ0FBRjtBQUNBLGdCQUFFLEVBQUY7QUFDQTtBQUNIOztBQUNELGdCQUFJLHlCQUF5QixDQUFDLGNBQUQsRUFBaUIsT0FBTyxDQUFDLE1BQXpCLENBQTdCLEVBQStEO0FBQzNELGNBQUEsT0FBTyxDQUFDLFNBQVIsQ0FBa0IsTUFBbEI7QUFDQSxjQUFBLFlBQVksR0FBRyxJQUFmO0FBQ0E7QUFDSDtBQUNKOztBQUNELGNBQUksQ0FBQyxZQUFMLEVBQW1CO0FBQ2YsWUFBQSxPQUFPLEdBQUcsSUFBSSxPQUFKLENBQVksTUFBWixDQUFWO0FBQ0EsWUFBQSxPQUFPLENBQUMsYUFBUixDQUFzQixJQUF0QjtBQUNBLFlBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxPQUFkO0FBQ0EsWUFBQSxrQkFBa0IsQ0FBQyxJQUFuQixDQUF3QixPQUF4QjtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxVQUFJLGVBQWUsR0FBRyxFQUF0Qjs7QUFDQSxXQUFLLENBQUMsR0FBRyxDQUFKLEVBQU8sQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUF6QixFQUFpQyxDQUFDLEdBQUcsQ0FBckMsRUFBd0MsRUFBRSxDQUExQyxFQUE2QztBQUN6QyxRQUFBLE9BQU8sR0FBRyxRQUFRLENBQUMsQ0FBRCxDQUFsQjs7QUFDQSxZQUFJLE9BQU8sQ0FBQyxVQUFSLEdBQXFCLENBQXpCLEVBQTRCO0FBQ3hCLFVBQUEsZUFBZSxDQUFDLElBQWhCLENBQXFCLE9BQXJCO0FBQ0g7QUFDSjs7QUFDRCxXQUFLLFNBQUwsR0FBaUIsZUFBakI7O0FBQ0EsV0FBSyxhQUFMOztBQUNBLGFBQU8sS0FBSyxTQUFaO0FBQ0gsS0F0REQ7O0FBdURBLElBQUEsWUFBWSxDQUFDLFNBQWIsQ0FBdUIsYUFBdkIsR0FBdUMsVUFBVSxPQUFWLEVBQW1CO0FBQ3RELFVBQUksQ0FBQyxPQUFMLEVBQWM7QUFDVixhQUFLLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQTtBQUNIOztBQUNELFdBQUssSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBNUIsRUFBb0MsQ0FBQyxHQUFHLENBQXhDLEVBQTJDLEVBQUUsQ0FBN0MsRUFBZ0Q7QUFDNUMsUUFBQSxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVcsV0FBWCxHQUF5QixJQUF6QjtBQUNIOztBQUNELFVBQUksY0FBYyxHQUFHLEVBQXJCOztBQUNBLFdBQUssQ0FBQyxHQUFHLENBQUosRUFBTyxDQUFDLEdBQUcsS0FBSyxRQUFMLENBQWMsTUFBOUIsRUFBc0MsQ0FBQyxHQUFHLENBQTFDLEVBQTZDLEVBQUUsQ0FBL0MsRUFBa0Q7QUFDOUMsWUFBSSxDQUFDLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsV0FBdEIsRUFBbUM7QUFDL0IsVUFBQSxjQUFjLENBQUMsSUFBZixDQUFvQixLQUFLLFFBQUwsQ0FBYyxDQUFkLENBQXBCO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsaUJBQU8sS0FBSyxRQUFMLENBQWMsQ0FBZCxFQUFpQixXQUF4QjtBQUNIO0FBQ0o7O0FBQ0QsV0FBSyxRQUFMLEdBQWdCLGNBQWhCO0FBQ0gsS0FsQkQ7O0FBbUJBLElBQUEsWUFBWSxDQUFDLFNBQWIsQ0FBdUIsaUJBQXZCLEdBQTJDLFVBQVUsSUFBVixFQUFnQjtBQUN2RCxVQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBbkI7QUFBQSxVQUEyQixPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQTFDO0FBQUEsVUFBa0QsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFqRTtBQUFBLFVBQXlFLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBeEY7QUFBQSxVQUFnRyxPQUFPLEdBQUcsS0FBSyxRQUEvRztBQUFBLFVBQXlILE1BQU0sR0FBRyxFQUFsSTs7QUFDQSxVQUFJLFVBQVUsR0FBRyxLQUFLLG1CQUFMLENBQXlCLE9BQXpCLENBQWpCOztBQUNBLFdBQUssSUFBSSxDQUFDLEdBQUcsVUFBUixFQUFvQixDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQXJDLEVBQTZDLENBQUMsR0FBRyxDQUFqRCxFQUFvRCxFQUFFLENBQXRELEVBQXlEO0FBQ3JELFlBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBVyxRQUFyQjs7QUFDQSxZQUFJLEdBQUcsQ0FBQyxHQUFKLEdBQVUsT0FBZCxFQUF1QjtBQUNuQjtBQUNIOztBQUNELFlBQUksR0FBRyxDQUFDLEdBQUosSUFBVyxPQUFYLElBQXNCLEdBQUcsQ0FBQyxHQUFKLElBQVcsT0FBakMsSUFDQSxHQUFHLENBQUMsR0FBSixJQUFXLE9BRGYsRUFDd0I7QUFDcEIsVUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQU8sQ0FBQyxDQUFELENBQW5CO0FBQ0g7QUFDSjs7QUFDRCxhQUFPLE1BQVA7QUFDSCxLQWREOztBQWVBLElBQUEsWUFBWSxDQUFDLFNBQWIsQ0FBdUIsYUFBdkIsR0FBdUMsVUFBVSxPQUFWLEVBQW1CLFlBQW5CLEVBQWlDO0FBQ3BFLFVBQUksWUFBWSxLQUFLLEtBQUssQ0FBMUIsRUFBNkI7QUFBRSxRQUFBLFlBQVksR0FBRyxJQUFmO0FBQXNCOztBQUNyRCxVQUFJLENBQUMsT0FBRCxJQUFZLENBQUMsT0FBTyxDQUFDLE1BQXpCLEVBQWlDO0FBQzdCLGVBQU8sSUFBUDtBQUNIOztBQUNELFVBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQyxTQUFyQjtBQUFBLFVBQWdDLE9BQU8sR0FBRyxDQUFDLE1BQU0sQ0FBQyxTQUFsRDtBQUFBLFVBQTZELE9BQU8sR0FBRyxNQUFNLENBQUMsU0FBOUU7QUFBQSxVQUF5RixPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBM0c7O0FBQ0EsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUE1QixFQUFvQyxDQUFDLEdBQUcsQ0FBeEMsRUFBMkMsRUFBRSxDQUE3QyxFQUFnRDtBQUM1QyxZQUFJLENBQUMsWUFBRCxJQUFpQixPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVcsUUFBaEMsRUFBMEM7QUFDdEM7QUFDSDs7QUFDRCxZQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVcsUUFBckI7QUFDQSxZQUFJLEdBQUcsQ0FBQyxHQUFKLEdBQVUsT0FBZCxFQUNJLE9BQU8sR0FBRyxHQUFHLENBQUMsR0FBZDtBQUNKLFlBQUksR0FBRyxDQUFDLEdBQUosR0FBVSxPQUFkLEVBQ0ksT0FBTyxHQUFHLEdBQUcsQ0FBQyxHQUFkO0FBQ0osWUFBSSxHQUFHLENBQUMsR0FBSixHQUFVLE9BQWQsRUFDSSxPQUFPLEdBQUcsR0FBRyxDQUFDLEdBQWQ7QUFDSixZQUFJLEdBQUcsQ0FBQyxHQUFKLEdBQVUsT0FBZCxFQUNJLE9BQU8sR0FBRyxHQUFHLENBQUMsR0FBZDtBQUNQOztBQUNELGFBQU87QUFDSCxRQUFBLE1BQU0sRUFBRSxPQURMO0FBRUgsUUFBQSxNQUFNLEVBQUUsT0FGTDtBQUdILFFBQUEsTUFBTSxFQUFFLE9BSEw7QUFJSCxRQUFBLE1BQU0sRUFBRTtBQUpMLE9BQVA7QUFNSCxLQTFCRDs7QUEyQkEsSUFBQSxZQUFZLENBQUMsU0FBYixDQUF1Qix1QkFBdkIsR0FBaUQsVUFBVSxJQUFWLEVBQWdCO0FBQzdELGFBQU8sS0FBSyxhQUFMLENBQW1CLEtBQUssaUJBQUwsQ0FBdUIsSUFBdkIsQ0FBbkIsQ0FBUDtBQUNILEtBRkQ7O0FBR0EsSUFBQSxZQUFZLENBQUMsU0FBYixDQUF1QixtQkFBdkIsR0FBNkMsVUFBVSxZQUFWLEVBQXdCO0FBQ2pFLFVBQUksWUFBWSxLQUFLLEtBQUssQ0FBMUIsRUFBNkI7QUFBRSxRQUFBLFlBQVksR0FBRyxJQUFmO0FBQXNCOztBQUNyRCxhQUFPLEtBQUssYUFBTCxDQUFtQixLQUFLLFFBQXhCLEVBQWtDLFlBQWxDLENBQVA7QUFDSCxLQUhEOztBQUlBLElBQUEsWUFBWSxDQUFDLFNBQWIsQ0FBdUIsVUFBdkIsR0FBb0MsWUFBWTtBQUM1QyxhQUFPLEtBQUssUUFBWjtBQUNILEtBRkQ7O0FBR0EsSUFBQSxZQUFZLENBQUMsU0FBYixDQUF1QixhQUF2QixHQUF1QyxZQUFZO0FBQy9DLGFBQU8sS0FBSyxRQUFMLENBQWMsTUFBckI7QUFDSCxLQUZEOztBQUdBLElBQUEsWUFBWSxDQUFDLFNBQWIsQ0FBdUIsYUFBdkIsR0FBdUMsWUFBWTtBQUMvQyxXQUFLLFNBQUwsR0FBaUIsRUFBakI7QUFDSCxLQUZEOztBQUdBLFdBQU8sWUFBUDtBQUNILEdBN0xtQixFQUFwQjs7QUE4TEEsRUFBQSxjQUFjLENBQUMsWUFBZixHQUE4QixZQUE5QjtBQUNELENBdlhELEVBdVhHLFlBQVksS0FBSyxZQUFZLEdBQUcsRUFBcEIsQ0F2WGYsRSxDQXlYQTtBQUNBO0FBQ0E7OztBQUVBLElBQUksc0JBQXNCLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBRixHQUFVLENBQUMsQ0FBQyxLQUFaLEdBQW9CLENBQUMsQ0FBQyxLQUF2QixFQUE4QixNQUE5QixDQUFxQztBQUNoRSxFQUFBLFVBQVUsRUFBRSxvQkFBVSxJQUFWLEVBQWdCLGFBQWhCLEVBQStCO0FBQ3ZDLFFBQUksS0FBSyxHQUFHLElBQVo7O0FBQ0EsUUFBSSxJQUFJLEtBQUssS0FBSyxDQUFsQixFQUFxQjtBQUFFLE1BQUEsSUFBSSxHQUFHLEdBQVA7QUFBYTs7QUFDcEMsUUFBSSxhQUFhLEtBQUssS0FBSyxDQUEzQixFQUE4QjtBQUFFLE1BQUEsYUFBYSxHQUFHLEVBQWhCO0FBQXFCOztBQUNyRCxTQUFLLE9BQUwsR0FBZSxJQUFJLFlBQVksQ0FBQyxZQUFqQixFQUFmO0FBQ0EsU0FBSyxPQUFMLENBQWEsSUFBYixHQUFvQixJQUFwQjtBQUNBLFNBQUssYUFBTCxHQUFxQixJQUFJLENBQUMsR0FBTCxDQUFTLGFBQVQsRUFBd0IsSUFBSSxHQUFHLENBQS9CLENBQXJCOztBQUNBLFNBQUssT0FBTCxDQUFhLE9BQWIsR0FBdUIsVUFBVSxHQUFWLEVBQWUsR0FBZixFQUFvQjtBQUN2QyxhQUFPLEtBQUssQ0FBQyxJQUFOLENBQVcsT0FBWCxDQUFtQixJQUFJLENBQUMsQ0FBQyxNQUFOLENBQWEsR0FBYixFQUFrQixHQUFsQixDQUFuQixFQUEyQyxJQUFJLENBQUMsS0FBTCxDQUFXLEtBQUssQ0FBQyxJQUFOLENBQVcsT0FBWCxFQUFYLENBQTNDLENBQVA7QUFDSCxLQUZEOztBQUdBLFNBQUssT0FBTCxDQUFhLFNBQWIsR0FBeUIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUNyQyxhQUFPLEtBQUssQ0FBQyxJQUFOLENBQVcsU0FBWCxDQUFxQixJQUFJLENBQUMsQ0FBQyxLQUFOLENBQVksQ0FBWixFQUFlLENBQWYsQ0FBckIsRUFBd0MsSUFBSSxDQUFDLEtBQUwsQ0FBVyxLQUFLLENBQUMsSUFBTixDQUFXLE9BQVgsRUFBWCxDQUF4QyxDQUFQO0FBQ0gsS0FGRDs7QUFHQSxTQUFLLGFBQUwsR0FBcUIsRUFBckI7QUFDQSxTQUFLLFVBQUwsR0FBa0IsSUFBSSw2QkFBSixDQUFrQyxJQUFsQyxDQUFsQjtBQUNBLFNBQUssU0FBTCxHQUFpQixLQUFqQjtBQUNBLFNBQUssV0FBTCxHQUFtQixLQUFuQjtBQUNBLFNBQUssZ0JBQUwsR0FBd0IsQ0FBeEI7QUFDQSxTQUFLLHlCQUFMLEdBQWlDLEVBQWpDO0FBQ0gsR0FwQitEO0FBcUJoRSxFQUFBLGNBQWMsRUFBRSx3QkFBVSxNQUFWLEVBQWtCO0FBQzlCLFNBQUssT0FBTCxDQUFhLGNBQWIsQ0FBNEIsTUFBNUI7QUFDSCxHQXZCK0Q7QUF3QmhFLEVBQUEsZUFBZSxFQUFFLHlCQUFVLE9BQVYsRUFBbUI7QUFDaEMsU0FBSyxPQUFMLENBQWEsZUFBYixDQUE2QixPQUE3QjtBQUNILEdBMUIrRDtBQTJCaEUsRUFBQSxhQUFhLEVBQUUsdUJBQVUsT0FBVixFQUFtQjtBQUM5QixTQUFLLE9BQUwsQ0FBYSxhQUFiLENBQTJCLE9BQTNCO0FBQ0gsR0E3QitEO0FBOEJoRSxFQUFBLG1CQUFtQixFQUFFLDZCQUFVLE9BQVYsRUFBbUIsUUFBbkIsRUFBNkI7QUFDOUMsUUFBSSxLQUFLLEdBQUcsSUFBWjs7QUFDQSxRQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxNQUFOLENBQWEsUUFBYixFQUF1QjtBQUMzQixNQUFBLElBQUksRUFBRSxLQUFLLHVCQUFMLENBQTZCLE9BQTdCO0FBRHFCLEtBQXZCLENBQVI7QUFHQSxJQUFBLENBQUMsQ0FBQyxxQkFBRixHQUEwQixPQUFPLENBQUMsTUFBbEM7QUFDQSxJQUFBLENBQUMsQ0FBQyxFQUFGLENBQUssT0FBTCxFQUFjLFlBQVk7QUFDdEIsVUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDLHFCQUFoQjs7QUFDQSxVQUFJLFdBQVcsR0FBRyxLQUFLLENBQUMsT0FBTixDQUFjLGlCQUFkLENBQWdDLE9BQWhDLENBQWxCOztBQUNBLFVBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFOLENBQWMsYUFBZCxDQUE0QixXQUE1QixDQUFSOztBQUNBLFVBQUksQ0FBSixFQUFPO0FBQ0gsWUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsWUFBTixDQUFtQixJQUFJLENBQUMsQ0FBQyxNQUFOLENBQWEsQ0FBQyxDQUFDLE1BQWYsRUFBdUIsQ0FBQyxDQUFDLE1BQXpCLENBQW5CLEVBQXFELElBQUksQ0FBQyxDQUFDLE1BQU4sQ0FBYSxDQUFDLENBQUMsTUFBZixFQUF1QixDQUFDLENBQUMsTUFBekIsQ0FBckQsQ0FBYjs7QUFDQSxZQUFJLGVBQWUsR0FBRyxLQUFLLENBQUMsSUFBTixDQUFXLE9BQVgsRUFBdEI7QUFBQSxZQUE0QyxjQUFjLEdBQUcsS0FBSyxDQUFDLElBQU4sQ0FBVyxhQUFYLENBQXlCLE1BQXpCLEVBQWlDLEtBQWpDLEVBQXdDLElBQUksQ0FBQyxDQUFDLEtBQU4sQ0FBWSxFQUFaLEVBQWdCLEVBQWhCLENBQXhDLENBQTdEOztBQUNBLFlBQUksY0FBYyxLQUFLLGVBQXZCLEVBQXdDO0FBQ3BDLGNBQUksY0FBYyxHQUFHLEVBQXJCOztBQUNBLGVBQUssSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLENBQUMsR0FBRyxLQUFLLENBQUMsYUFBTixDQUFvQixNQUF4QyxFQUFnRCxDQUFDLEdBQUcsQ0FBcEQsRUFBdUQsRUFBRSxDQUF6RCxFQUE0RDtBQUN4RCxnQkFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLGFBQU4sQ0FBb0IsQ0FBcEIsQ0FBUjs7QUFDQSxnQkFBSSxDQUFDLENBQUMsSUFBRixDQUFPLGNBQVAsS0FBMEIsQ0FBOUIsRUFBaUM7QUFDN0Isa0JBQUksQ0FBQyxDQUFDLE1BQUYsQ0FBUyxNQUFULElBQW1CLE9BQU8sQ0FBQyxNQUEzQixJQUNBLENBQUMsQ0FBQyxNQUFGLENBQVMsTUFBVCxJQUFtQixPQUFPLENBQUMsTUFEM0IsSUFFQSxDQUFDLENBQUMsTUFBRixDQUFTLE1BQVQsSUFBbUIsT0FBTyxDQUFDLE1BRjNCLElBR0EsQ0FBQyxDQUFDLE1BQUYsQ0FBUyxNQUFULElBQW1CLE9BQU8sQ0FBQyxNQUgvQixFQUd1QztBQUNuQyxnQkFBQSxjQUFjLENBQUMsSUFBZixDQUFvQixDQUFDLENBQUMsTUFBdEI7QUFDSDtBQUNKO0FBQ0o7O0FBQ0QsY0FBSSxjQUFjLENBQUMsTUFBZixHQUF3QixDQUE1QixFQUErQjtBQUMzQixnQkFBSSxjQUFjLEdBQUcsRUFBckI7QUFDQSxnQkFBSSxFQUFFLEdBQUcsY0FBYyxDQUFDLE1BQXhCOztBQUNBLGlCQUFLLENBQUMsR0FBRyxDQUFKLEVBQU8sQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUE1QixFQUFvQyxDQUFDLEdBQUcsQ0FBeEMsRUFBMkMsRUFBRSxDQUE3QyxFQUFnRDtBQUM1QyxrQkFBSSxTQUFTLEdBQUcsV0FBVyxDQUFDLENBQUQsQ0FBWCxDQUFlLFFBQS9CO0FBQ0Esa0JBQUksVUFBVSxHQUFHLEtBQWpCOztBQUNBLG1CQUFLLElBQUksQ0FBQyxHQUFHLENBQWIsRUFBZ0IsQ0FBQyxHQUFHLEVBQXBCLEVBQXdCLEVBQUUsQ0FBMUIsRUFBNkI7QUFDekIsb0JBQUkscUJBQXFCLEdBQUcsY0FBYyxDQUFDLENBQUQsQ0FBMUM7O0FBQ0Esb0JBQUksU0FBUyxDQUFDLEdBQVYsSUFBaUIscUJBQXFCLENBQUMsTUFBdkMsSUFDQSxTQUFTLENBQUMsR0FBVixJQUFpQixxQkFBcUIsQ0FBQyxNQUR2QyxJQUVBLFNBQVMsQ0FBQyxHQUFWLElBQWlCLHFCQUFxQixDQUFDLE1BRnZDLElBR0EsU0FBUyxDQUFDLEdBQVYsSUFBaUIscUJBQXFCLENBQUMsTUFIM0MsRUFHbUQ7QUFDL0Msa0JBQUEsVUFBVSxHQUFHLElBQWI7QUFDQTtBQUNIO0FBQ0o7O0FBQ0Qsa0JBQUksQ0FBQyxVQUFMLEVBQWlCO0FBQ2IsZ0JBQUEsY0FBYyxDQUFDLElBQWYsQ0FBb0IsV0FBVyxDQUFDLENBQUQsQ0FBL0I7QUFDSDtBQUNKOztBQUNELFlBQUEsV0FBVyxHQUFHLGNBQWQ7QUFDSDs7QUFDRCxjQUFJLFdBQVcsQ0FBQyxNQUFaLEdBQXFCLEdBQXJCLElBQTRCLGNBQWMsSUFBSSxLQUFLLENBQUMsSUFBTixDQUFXLFVBQVgsRUFBbEQsRUFBMkU7QUFDdkUsWUFBQSxLQUFLLENBQUMsSUFBTixDQUFXLElBQVgsQ0FBZ0Isb0JBQWhCLEVBQXNDO0FBQ2xDLGNBQUEsT0FBTyxFQUFFLEtBRHlCO0FBRWxDLGNBQUEsT0FBTyxFQUFFLFdBRnlCO0FBR2xDLGNBQUEsTUFBTSxFQUFFLENBQUMsQ0FBQyxTQUFGLEVBSDBCO0FBSWxDLGNBQUEsTUFBTSxFQUFFO0FBSjBCLGFBQXRDO0FBTUgsV0FQRCxNQVFLO0FBQ0QsWUFBQSxjQUFjO0FBQ2pCOztBQUNELFVBQUEsS0FBSyxDQUFDLElBQU4sQ0FBVyxPQUFYLENBQW1CLENBQUMsQ0FBQyxTQUFGLEVBQW5CLEVBQWtDLGNBQWxDO0FBQ0gsU0EvQ0QsTUFnREs7QUFDRCxVQUFBLEtBQUssQ0FBQyxJQUFOLENBQVcsU0FBWCxDQUFxQixNQUFyQjtBQUNIO0FBQ0o7QUFDSixLQTNERDtBQTREQSxXQUFPLENBQVA7QUFDSCxHQWpHK0Q7QUFrR2hFLEVBQUEsdUJBQXVCLEVBQUUsaUNBQVUsT0FBVixFQUFtQjtBQUN4QyxRQUFJLENBQUMsR0FBRyw0QkFBUjtBQUNBLFFBQUksUUFBUSxHQUFHLEVBQWY7QUFDQSxRQUFJLGFBQWEsR0FBRyxLQUFLLE9BQUwsQ0FBYSxhQUFiLEVBQXBCOztBQUNBLFFBQUksT0FBTyxDQUFDLFVBQVIsR0FBcUIsSUFBSSxDQUFDLEdBQUwsQ0FBUyxFQUFULEVBQWEsYUFBYSxHQUFHLElBQTdCLENBQXpCLEVBQTZEO0FBQ3pELE1BQUEsQ0FBQyxJQUFJLE9BQUw7QUFDSCxLQUZELE1BR0ssSUFBSSxPQUFPLENBQUMsVUFBUixHQUFxQixJQUFJLENBQUMsR0FBTCxDQUFTLEdBQVQsRUFBYyxhQUFhLEdBQUcsSUFBOUIsQ0FBekIsRUFBOEQ7QUFDL0QsTUFBQSxDQUFDLElBQUksUUFBTDtBQUNBLE1BQUEsUUFBUSxHQUFHLEVBQVg7QUFDSCxLQUhJLE1BSUE7QUFDRCxNQUFBLENBQUMsSUFBSSxPQUFMO0FBQ0EsTUFBQSxRQUFRLEdBQUcsRUFBWDtBQUNIOztBQUNELFdBQU8sSUFBSSxDQUFDLENBQUMsT0FBTixDQUFjO0FBQ2pCLE1BQUEsSUFBSSxFQUFFLGdCQUFnQixPQUFPLENBQUMsVUFBeEIsR0FBcUMsZUFEMUI7QUFFakIsTUFBQSxTQUFTLEVBQUUsQ0FGTTtBQUdqQixNQUFBLFFBQVEsRUFBRSxDQUFDLENBQUMsS0FBRixDQUFRLFFBQVIsRUFBa0IsUUFBbEI7QUFITyxLQUFkLENBQVA7QUFLSCxHQXRIK0Q7QUF1SGhFLEVBQUEsa0JBQWtCLEVBQUUsNEJBQVUsTUFBVixFQUFrQixRQUFsQixFQUE0QjtBQUM1QyxRQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxNQUFOLENBQWEsUUFBYixDQUFSO0FBQ0EsU0FBSyxvQkFBTCxDQUEwQixDQUExQixFQUE2QixNQUFNLENBQUMsSUFBcEMsRUFBMEMsTUFBTSxDQUFDLFFBQWpEO0FBQ0EsV0FBTyxDQUFQO0FBQ0gsR0EzSCtEO0FBNEhoRSxFQUFBLG9CQUFvQixFQUFFLDhCQUFVLE1BQVYsRUFBa0IsSUFBbEIsRUFBd0IsUUFBeEIsRUFBa0M7QUFDcEQsUUFBSSxJQUFJLENBQUMsSUFBVCxFQUFlO0FBQ1gsVUFBSSxPQUFPLElBQUksQ0FBQyxJQUFaLEtBQXFCLFVBQXpCLEVBQXFDO0FBQ2pDLFFBQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxJQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsRUFBZ0IsUUFBaEIsQ0FBZjtBQUNILE9BRkQsTUFHSztBQUNELFFBQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxJQUFJLENBQUMsSUFBcEI7QUFDSDtBQUNKOztBQUNELFFBQUksSUFBSSxDQUFDLEtBQVQsRUFBZ0I7QUFDWixVQUFJLE9BQU8sR0FBRyxPQUFPLElBQUksQ0FBQyxLQUFaLEtBQXNCLFVBQXRCLEdBQW1DLElBQUksQ0FBQyxLQUFMLENBQVcsSUFBWCxFQUFpQixRQUFqQixDQUFuQyxHQUFnRSxJQUFJLENBQUMsS0FBbkY7O0FBQ0EsVUFBSSxNQUFNLENBQUMsUUFBUCxFQUFKLEVBQXVCO0FBQ25CLFFBQUEsTUFBTSxDQUFDLGVBQVAsQ0FBdUIsT0FBdkIsRUFBZ0MsSUFBSSxDQUFDLFlBQXJDO0FBQ0gsT0FGRCxNQUdLO0FBQ0QsUUFBQSxNQUFNLENBQUMsU0FBUCxDQUFpQixPQUFqQixFQUEwQixJQUFJLENBQUMsWUFBL0I7QUFDSDtBQUNKO0FBQ0osR0E5SStEO0FBK0loRSxFQUFBLEtBQUssRUFBRSxlQUFVLEdBQVYsRUFBZTtBQUNsQixTQUFLLElBQUwsR0FBWSxHQUFaO0FBQ0EsSUFBQSxHQUFHLENBQUMsRUFBSixDQUFPLFdBQVAsRUFBb0IsS0FBSyxVQUF6QixFQUFxQyxJQUFyQztBQUNBLElBQUEsR0FBRyxDQUFDLEVBQUosQ0FBTyxTQUFQLEVBQWtCLEtBQUssUUFBdkIsRUFBaUMsSUFBakM7QUFDQSxJQUFBLEdBQUcsQ0FBQyxFQUFKLENBQU8sU0FBUCxFQUFrQixLQUFLLFVBQXZCLEVBQW1DLElBQW5DO0FBQ0EsSUFBQSxHQUFHLENBQUMsRUFBSixDQUFPLFNBQVAsRUFBa0IsS0FBSyxRQUF2QixFQUFpQyxJQUFqQztBQUNBLFNBQUssV0FBTDtBQUNBLElBQUEsR0FBRyxDQUFDLFFBQUosQ0FBYSxLQUFLLFVBQWxCO0FBQ0gsR0F2SitEO0FBd0poRSxFQUFBLFFBQVEsRUFBRSxrQkFBVSxHQUFWLEVBQWU7QUFDckIsSUFBQSxHQUFHLENBQUMsR0FBSixDQUFRLFdBQVIsRUFBcUIsS0FBSyxVQUExQixFQUFzQyxJQUF0QztBQUNBLElBQUEsR0FBRyxDQUFDLEdBQUosQ0FBUSxTQUFSLEVBQW1CLEtBQUssUUFBeEIsRUFBa0MsSUFBbEM7QUFDQSxJQUFBLEdBQUcsQ0FBQyxHQUFKLENBQVEsU0FBUixFQUFtQixLQUFLLFVBQXhCLEVBQW9DLElBQXBDO0FBQ0EsSUFBQSxHQUFHLENBQUMsR0FBSixDQUFRLFNBQVIsRUFBbUIsS0FBSyxRQUF4QixFQUFrQyxJQUFsQzs7QUFDQSxTQUFLLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsS0FBSyxhQUFMLENBQW1CLE1BQXZDLEVBQStDLENBQUMsR0FBRyxDQUFuRCxFQUFzRCxFQUFFLENBQXhELEVBQTJEO0FBQ3ZELE1BQUEsR0FBRyxDQUFDLFdBQUosQ0FBZ0IsS0FBSyxhQUFMLENBQW1CLENBQW5CLEVBQXNCLElBQXRCLENBQTJCLGNBQTNDO0FBQ0g7O0FBQ0QsU0FBSyxhQUFMLEdBQXFCLEVBQXJCO0FBQ0EsU0FBSyxPQUFMLENBQWEsYUFBYjtBQUNBLElBQUEsR0FBRyxDQUFDLFdBQUosQ0FBZ0IsS0FBSyxVQUFyQjtBQUNBLFNBQUssSUFBTCxHQUFZLElBQVo7QUFDSCxHQXBLK0Q7QUFxS2hFLEVBQUEsVUFBVSxFQUFFLHNCQUFZO0FBQ3BCLFNBQUssZUFBTCxHQUF1QixJQUF2QjtBQUNILEdBdksrRDtBQXdLaEUsRUFBQSxRQUFRLEVBQUUsa0JBQVUsQ0FBVixFQUFhO0FBQ25CLFNBQUssZUFBTCxHQUF1QixLQUF2QjtBQUNBLFNBQUssU0FBTCxHQUFpQixDQUFDLENBQUMsSUFBbkI7QUFDQSxTQUFLLFdBQUw7QUFDSCxHQTVLK0Q7QUE2S2hFLEVBQUEsVUFBVSxFQUFFLHNCQUFZO0FBQ3BCLFNBQUssZUFBTCxHQUF1QixJQUF2QjtBQUNILEdBL0srRDtBQWdMaEUsRUFBQSxRQUFRLEVBQUUsb0JBQVk7QUFDbEIsU0FBSyxlQUFMLEdBQXVCLEtBQXZCO0FBQ0EsU0FBSyxXQUFMO0FBQ0gsR0FuTCtEO0FBb0xoRSxFQUFBLFdBQVcsRUFBRSx1QkFBWTtBQUNyQixRQUFJLEtBQUssR0FBRyxJQUFaOztBQUNBLFFBQUksQ0FBQyxLQUFLLElBQU4sSUFBYyxLQUFLLGVBQW5CLElBQXNDLEtBQUssZUFBL0MsRUFBZ0U7QUFDNUQ7QUFDSDs7QUFDRCxRQUFJLEdBQUcsR0FBRyxLQUFLLElBQWY7QUFBQSxRQUFxQixNQUFNLEdBQUcsR0FBRyxDQUFDLFNBQUosRUFBOUI7QUFBQSxRQUErQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxHQUFHLENBQUMsT0FBSixFQUFYLENBQXREO0FBQUEsUUFBaUYsV0FBVyxHQUFHLEtBQUssYUFBTCxHQUFxQixLQUFLLE9BQUwsQ0FBYSxJQUFqSTtBQUFBLFFBQXVJLFVBQVUsR0FBRyxLQUFLLFdBQXpKO0FBQ0EsUUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLFlBQVAsRUFBaEI7QUFBQSxRQUF1QyxTQUFTLEdBQUcsTUFBTSxDQUFDLFlBQVAsRUFBbkQ7QUFDQSxRQUFJLFFBQVEsR0FBRyxLQUFLLE9BQUwsQ0FBYSxXQUFiLENBQXlCO0FBQ3BDLE1BQUEsTUFBTSxFQUFFLFNBQVMsQ0FBQyxHQURrQjtBQUVwQyxNQUFBLE1BQU0sRUFBRSxTQUFTLENBQUMsR0FGa0I7QUFHcEMsTUFBQSxNQUFNLEVBQUUsU0FBUyxDQUFDLEdBSGtCO0FBSXBDLE1BQUEsTUFBTSxFQUFFLFNBQVMsQ0FBQztBQUprQixLQUF6QixDQUFmO0FBTUEsUUFBSSxZQUFZLEdBQUcsS0FBSyxhQUF4QjtBQUFBLFFBQXVDLGVBQWUsR0FBRyxFQUF6RDtBQUFBLFFBQTZELFlBQVksR0FBRyxJQUFJLEtBQUosQ0FBVSxZQUFZLENBQUMsTUFBdkIsQ0FBNUU7O0FBQ0EsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsQ0FBQyxHQUFHLFlBQVksQ0FBQyxNQUFqQyxFQUF5QyxDQUFDLEdBQUcsQ0FBN0MsRUFBZ0QsRUFBRSxDQUFsRCxFQUFxRDtBQUNqRCxVQUFJLE1BQU0sR0FBRyxZQUFZLENBQUMsQ0FBRCxDQUFaLENBQWdCLElBQWhCLENBQXFCLGNBQWxDO0FBQ0EsTUFBQSxZQUFZLENBQUMsQ0FBRCxDQUFaLEdBQWtCLE1BQWxCO0FBQ0EsTUFBQSxNQUFNLENBQUMsY0FBUCxHQUF3QixJQUF4QjtBQUNIOztBQUNELFFBQUksbUJBQW1CLEdBQUcsRUFBMUI7QUFDQSxRQUFJLHlCQUF5QixHQUFHLEVBQWhDO0FBQ0EsUUFBSSxpQkFBaUIsR0FBRyxFQUF4QjtBQUNBLFFBQUksV0FBVyxHQUFHLEVBQWxCOztBQUNBLFNBQUssQ0FBQyxHQUFHLENBQUosRUFBTyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQXpCLEVBQWlDLENBQUMsR0FBRyxDQUFyQyxFQUF3QyxFQUFFLENBQTFDLEVBQTZDO0FBQ3pDLFVBQUksUUFBUSxHQUFHLFFBQVEsQ0FBQyxDQUFELENBQXZCO0FBQUEsVUFBNEIsWUFBWSxHQUFHLFFBQVEsQ0FBQyxJQUFwRDtBQUNBLFVBQUksU0FBUyxHQUFHLENBQUMsUUFBUSxDQUFDLE1BQVQsQ0FBZ0IsTUFBaEIsR0FBeUIsUUFBUSxDQUFDLE1BQVQsQ0FBZ0IsTUFBMUMsSUFBb0QsV0FBcEU7QUFBQSxVQUFpRixTQUFTLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBVCxDQUFnQixNQUFoQixHQUF5QixRQUFRLENBQUMsTUFBVCxDQUFnQixNQUExQyxJQUFvRCxXQUFqSjs7QUFDQSxXQUFLLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsV0FBVyxDQUFDLE1BQWpDLEVBQXlDLENBQUMsR0FBRyxFQUE3QyxFQUFpRCxFQUFFLENBQW5ELEVBQXNEO0FBQ2xELFlBQUksQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFELENBQW5COztBQUNBLFlBQUksQ0FBQyxDQUFDLE1BQUYsQ0FBUyxNQUFULEdBQWtCLFFBQVEsQ0FBQyxNQUFULENBQWdCLE1BQXRDLEVBQThDO0FBQzFDLFVBQUEsV0FBVyxDQUFDLE1BQVosQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEI7QUFDQSxZQUFFLENBQUY7QUFDQSxZQUFFLEVBQUY7QUFDQTtBQUNIOztBQUNELFlBQUksU0FBUyxHQUFHLENBQUMsQ0FBQyxlQUFGLENBQWtCLEdBQWxCLEdBQXdCLFNBQXhDO0FBQUEsWUFBbUQsU0FBUyxHQUFHLENBQUMsQ0FBQyxlQUFGLENBQWtCLEdBQWxCLEdBQXdCLFNBQXZGO0FBQUEsWUFBa0csU0FBUyxHQUFHLENBQUMsQ0FBQyxlQUFGLENBQWtCLEdBQWxCLEdBQXdCLFNBQXRJO0FBQUEsWUFBaUosU0FBUyxHQUFHLFFBQVEsQ0FBQyxlQUFULENBQXlCLEdBQXpCLEdBQStCLFNBQTVMO0FBQUEsWUFBdU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxlQUFULENBQXlCLEdBQXpCLEdBQStCLFNBQWxQO0FBQUEsWUFBNlAsU0FBUyxHQUFHLFFBQVEsQ0FBQyxlQUFULENBQXlCLEdBQXpCLEdBQStCLFNBQXhTOztBQUNBLFlBQUksU0FBUyxHQUFHLFNBQVosSUFBeUIsU0FBUyxHQUFHLFNBQXJDLElBQWtELFNBQVMsR0FBRyxTQUFsRSxFQUE2RTtBQUN6RSxVQUFBLFlBQVksQ0FBQyxpQkFBYixHQUFpQyxJQUFqQztBQUNBLFVBQUEsQ0FBQyxDQUFDLFlBQUYsQ0FBZSxRQUFmO0FBQ0E7QUFDSDtBQUNKOztBQUNELFVBQUksQ0FBQyxZQUFZLENBQUMsaUJBQWxCLEVBQXFDO0FBQ2pDLFFBQUEsV0FBVyxDQUFDLElBQVosQ0FBaUIsUUFBakI7QUFDSDtBQUNKOztBQUNELElBQUEsUUFBUSxDQUFDLE9BQVQsQ0FBaUIsVUFBVSxPQUFWLEVBQW1CO0FBQ2hDLFVBQUksQ0FBQyxHQUFHLFNBQVI7QUFDQSxVQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBbkI7O0FBQ0EsVUFBSSxJQUFJLENBQUMsaUJBQVQsRUFBNEI7QUFDeEIsUUFBQSxJQUFJLENBQUMsaUJBQUwsR0FBeUIsS0FBekI7QUFDQSxRQUFBLElBQUksQ0FBQyxxQkFBTCxHQUE2QixDQUE3QjtBQUNBLFFBQUEsSUFBSSxDQUFDLG1CQUFMLEdBQTJCLENBQTNCO0FBQ0E7QUFDSDs7QUFDRCxVQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQyxNQUFOLENBQWEsT0FBTyxDQUFDLGVBQVIsQ0FBd0IsR0FBckMsRUFBMEMsT0FBTyxDQUFDLGVBQVIsQ0FBd0IsR0FBbEUsQ0FBZjtBQUNBLFVBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxjQUFyQjs7QUFDQSxVQUFJLFNBQUosRUFBZTtBQUNYLFlBQUksT0FBTyxDQUFDLFVBQVIsS0FBdUIsQ0FBdkIsSUFBNEIsSUFBSSxDQUFDLHFCQUFMLEtBQStCLENBQTNELElBQWdFLE9BQU8sQ0FBQyxRQUFSLEtBQXFCLFNBQVMsQ0FBQyxTQUFuRyxFQUE4RztBQUMxRyxjQUFJLFVBQVUsSUFBSSxTQUFTLENBQUMsVUFBVixLQUF5QixJQUF2QyxJQUErQyxPQUFPLENBQUMsVUFBUixDQUFtQixJQUFuQixDQUF3QixlQUEzRSxFQUE0RjtBQUN4RixZQUFBLEtBQUssQ0FBQyxvQkFBTixDQUEyQixTQUEzQixFQUFzQyxPQUFPLENBQUMsVUFBUixDQUFtQixJQUF6RCxFQUErRCxPQUFPLENBQUMsVUFBUixDQUFtQixRQUFsRjs7QUFDQSxnQkFBSSxPQUFPLENBQUMsVUFBUixDQUFtQixJQUFuQixDQUF3QixlQUE1QixFQUE2QztBQUN6QyxjQUFBLE9BQU8sQ0FBQyxVQUFSLENBQW1CLElBQW5CLENBQXdCLGVBQXhCLEdBQTBDLEtBQTFDO0FBQ0g7QUFDSjs7QUFDRCxVQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLFFBQXBCO0FBQ0EsVUFBQSxDQUFDLEdBQUcsU0FBSjtBQUNILFNBVEQsTUFVSyxJQUFJLE9BQU8sQ0FBQyxVQUFSLEdBQXFCLENBQXJCLElBQTBCLElBQUksQ0FBQyxxQkFBTCxHQUE2QixDQUF2RCxLQUE2RCxTQUFTLENBQUMsVUFBVixLQUF5QixJQUF6QixJQUNsRSxJQUFJLENBQUMsZ0JBQUwsQ0FBc0IsTUFBdEIsQ0FBNkIsUUFBN0IsQ0FESyxDQUFKLEVBQ3dDO0FBQ3pDLFVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsUUFBcEI7O0FBQ0EsY0FBSSxVQUFVLElBQUksT0FBTyxDQUFDLFVBQVIsSUFBc0IsSUFBSSxDQUFDLHFCQUF6QyxJQUNBLE9BQU8sQ0FBQyxRQUFSLEtBQXFCLElBQUksQ0FBQyxtQkFEOUIsRUFDbUQ7QUFDL0MsZ0JBQUksVUFBVSxHQUFHLEVBQWpCO0FBQ0EsWUFBQSxDQUFDLENBQUMsSUFBRixDQUFPLE1BQVAsQ0FBYyxVQUFkLEVBQTBCLE9BQU8sQ0FBQyxNQUFsQztBQUNBLFlBQUEsU0FBUyxDQUFDLHFCQUFWLEdBQWtDLFVBQWxDO0FBQ0EsWUFBQSxTQUFTLENBQUMsT0FBVixDQUFrQixLQUFLLENBQUMsdUJBQU4sQ0FBOEIsT0FBOUIsQ0FBbEI7QUFDSDs7QUFDRCxVQUFBLElBQUksQ0FBQyxxQkFBTCxHQUE2QixPQUFPLENBQUMsVUFBckM7QUFDQSxVQUFBLElBQUksQ0FBQyxtQkFBTCxHQUEyQixPQUFPLENBQUMsUUFBbkM7QUFDQSxVQUFBLENBQUMsR0FBRyxTQUFKO0FBQ0g7QUFDSjs7QUFDRCxVQUFJLENBQUMsQ0FBTCxFQUFRO0FBQ0osWUFBSSxPQUFPLENBQUMsVUFBUixLQUF1QixDQUEzQixFQUE4QjtBQUMxQixVQUFBLHlCQUF5QixDQUFDLElBQTFCLENBQStCLE9BQS9CO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsVUFBQSxtQkFBbUIsQ0FBQyxJQUFwQixDQUF5QixPQUF6QjtBQUNIOztBQUNELFFBQUEsSUFBSSxDQUFDLGdCQUFMLEdBQXdCLFFBQXhCO0FBQ0EsUUFBQSxJQUFJLENBQUMscUJBQUwsR0FBNkIsT0FBTyxDQUFDLFVBQXJDO0FBQ0EsUUFBQSxJQUFJLENBQUMsbUJBQUwsR0FBMkIsT0FBTyxDQUFDLFFBQW5DO0FBQ0gsT0FWRCxNQVdLO0FBQ0QsUUFBQSxDQUFDLENBQUMsY0FBRixHQUFtQixLQUFuQjtBQUNBLFFBQUEsZUFBZSxDQUFDLElBQWhCLENBQXFCLE9BQXJCO0FBQ0EsUUFBQSxDQUFDLENBQUMsVUFBRixHQUFlLElBQWY7QUFDQSxRQUFBLENBQUMsQ0FBQyxTQUFGLEdBQWMsT0FBTyxDQUFDLFFBQXRCO0FBQ0EsUUFBQSxDQUFDLENBQUMsV0FBRixHQUFnQixPQUFPLENBQUMsVUFBeEI7QUFDQSxRQUFBLElBQUksQ0FBQyxjQUFMLEdBQXNCLENBQXRCO0FBQ0EsUUFBQSxJQUFJLENBQUMsZ0JBQUwsR0FBd0IsUUFBeEI7QUFDSDtBQUNKLEtBekREO0FBMERBLElBQUEsbUJBQW1CLEdBQUcseUJBQXlCLENBQUMsTUFBMUIsQ0FBaUMsbUJBQWpDLENBQXRCOztBQUNBLFNBQUssQ0FBQyxHQUFHLENBQUosRUFBTyxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQTdCLEVBQXFDLENBQUMsR0FBRyxDQUF6QyxFQUE0QyxFQUFFLENBQTlDLEVBQWlEO0FBQzdDLE1BQUEsUUFBUSxHQUFHLFlBQVksQ0FBQyxDQUFELENBQXZCO0FBQ0EsVUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLElBQXJCO0FBQ0EsTUFBQSxNQUFNLEdBQUcsS0FBSyxDQUFDLGNBQWY7O0FBQ0EsVUFBSSxLQUFLLENBQUMsY0FBTixDQUFxQixjQUF6QixFQUF5QztBQUNyQyxZQUFJLE1BQU0sR0FBRyxJQUFiOztBQUNBLFlBQUksTUFBTSxDQUFDLFVBQVAsS0FBc0IsSUFBMUIsRUFBZ0M7QUFDNUIsY0FBSSxFQUFFLEdBQUcsUUFBUSxDQUFDLGVBQWxCO0FBQ0EsVUFBQSxTQUFTLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBVCxDQUFnQixNQUFoQixHQUF5QixRQUFRLENBQUMsTUFBVCxDQUFnQixNQUExQyxJQUFvRCxXQUFoRSxFQUNJLFNBQVMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFULENBQWdCLE1BQWhCLEdBQXlCLFFBQVEsQ0FBQyxNQUFULENBQWdCLE1BQTFDLElBQW9ELFdBRHBFOztBQUVBLGVBQUssQ0FBQyxHQUFHLENBQUosRUFBTyxFQUFFLEdBQUcsbUJBQW1CLENBQUMsTUFBckMsRUFBNkMsQ0FBQyxHQUFHLEVBQWpELEVBQXFELEVBQUUsQ0FBdkQsRUFBMEQ7QUFDdEQsZ0JBQUksUUFBUSxHQUFHLG1CQUFtQixDQUFDLENBQUQsQ0FBbEM7QUFBQSxnQkFBdUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxJQUF4RDs7QUFDQSxnQkFBSSxNQUFNLENBQUMsV0FBUCxLQUF1QixDQUF2QixJQUE0QixRQUFRLENBQUMsVUFBVCxLQUF3QixDQUFwRCxJQUNBLE1BQU0sQ0FBQyxTQUFQLEtBQXFCLFFBQVEsQ0FBQyxRQURsQyxFQUM0QztBQUN4QyxrQkFBSSxVQUFVLElBQUksUUFBUSxDQUFDLFVBQVQsQ0FBb0IsSUFBcEIsQ0FBeUIsZUFBM0MsRUFBNEQ7QUFDeEQscUJBQUssb0JBQUwsQ0FBMEIsTUFBMUIsRUFBa0MsUUFBUSxDQUFDLFVBQVQsQ0FBb0IsSUFBdEQsRUFBNEQsUUFBUSxDQUFDLFVBQVQsQ0FBb0IsUUFBaEY7O0FBQ0Esb0JBQUksUUFBUSxDQUFDLFVBQVQsQ0FBb0IsSUFBcEIsQ0FBeUIsZUFBN0IsRUFBOEM7QUFDMUMsa0JBQUEsUUFBUSxDQUFDLFVBQVQsQ0FBb0IsSUFBcEIsQ0FBeUIsZUFBekIsR0FBMkMsS0FBM0M7QUFDSDtBQUNKOztBQUNELGNBQUEsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsS0FBSyxDQUFDLGdCQUF2QjtBQUNBLGNBQUEsTUFBTSxHQUFHLEtBQVQ7QUFDSCxhQVZELE1BV0s7QUFDRCxrQkFBSSxFQUFFLEdBQUcsUUFBUSxDQUFDLGVBQWxCO0FBQ0Esa0JBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFILEdBQVMsU0FBekI7QUFBQSxrQkFBb0MsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFILEdBQVMsU0FBekQ7QUFDQSxjQUFBLFNBQVMsR0FBRyxFQUFFLENBQUMsR0FBSCxHQUFTLFNBQXJCO0FBQ0EsY0FBQSxTQUFTLEdBQUcsRUFBRSxDQUFDLEdBQUgsR0FBUyxTQUFyQjtBQUNBLGNBQUEsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFILEdBQVMsU0FBckI7QUFDQSxjQUFBLFNBQVMsR0FBRyxFQUFFLENBQUMsR0FBSCxHQUFTLFNBQXJCO0FBQ0EsY0FBQSxTQUFTLEdBQUcsRUFBRSxDQUFDLEdBQUgsR0FBUyxTQUFyQjtBQUNBLGNBQUEsU0FBUyxHQUFHLEVBQUUsQ0FBQyxHQUFILEdBQVMsU0FBckI7O0FBQ0Esa0JBQUssTUFBTSxDQUFDLFdBQVAsR0FBcUIsQ0FBckIsSUFBMEIsUUFBUSxDQUFDLFVBQVQsR0FBc0IsQ0FBakQsSUFDQyxTQUFTLEdBQUcsU0FBWixJQUF5QixTQUFTLEdBQUcsU0FBckMsSUFBa0QsU0FBUyxHQUFHLFNBQTlELElBQTJFLFNBQVMsR0FBRyxTQUQ1RixFQUN3RztBQUNwRyxnQkFBQSxNQUFNLENBQUMsU0FBUCxDQUFpQixLQUFLLENBQUMsZ0JBQXZCO0FBQ0EsZ0JBQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxLQUFLLHVCQUFMLENBQTZCLFFBQTdCLENBQWY7QUFDQSxvQkFBSSxPQUFPLEdBQUcsRUFBZDtBQUNBLGdCQUFBLENBQUMsQ0FBQyxJQUFGLENBQU8sTUFBUCxDQUFjLE9BQWQsRUFBdUIsUUFBUSxDQUFDLE1BQWhDO0FBQ0EsZ0JBQUEsTUFBTSxDQUFDLHFCQUFQLEdBQStCLE9BQS9CO0FBQ0EsZ0JBQUEsS0FBSyxDQUFDLHFCQUFOLEdBQThCLFFBQVEsQ0FBQyxVQUF2QztBQUNBLGdCQUFBLEtBQUssQ0FBQyxtQkFBTixHQUE0QixRQUFRLENBQUMsUUFBckM7QUFDQSxnQkFBQSxNQUFNLENBQUMsV0FBUCxHQUFxQixRQUFRLENBQUMsVUFBOUI7QUFDQSxnQkFBQSxNQUFNLEdBQUcsS0FBVDtBQUNIO0FBQ0o7O0FBQ0QsZ0JBQUksQ0FBQyxNQUFMLEVBQWE7QUFDVCxjQUFBLEtBQUssQ0FBQyxjQUFOLEdBQXVCLE1BQXZCO0FBQ0EsY0FBQSxNQUFNLENBQUMsY0FBUCxHQUF3QixLQUF4QjtBQUNBLGNBQUEsZUFBZSxDQUFDLElBQWhCLENBQXFCLFFBQXJCO0FBQ0EsY0FBQSxtQkFBbUIsQ0FBQyxNQUFwQixDQUEyQixDQUEzQixFQUE4QixDQUE5QjtBQUNBLGdCQUFFLENBQUY7QUFDQSxnQkFBRSxFQUFGO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBQ0QsWUFBSSxNQUFKLEVBQVk7QUFDUixjQUFJLENBQUMsTUFBTSxDQUFDLGNBQVosRUFDSSxPQUFPLENBQUMsS0FBUixDQUFjLEtBQWQ7QUFDUDtBQUNKO0FBQ0o7O0FBQ0QsU0FBSyxDQUFDLEdBQUcsQ0FBSixFQUFPLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxNQUFwQyxFQUE0QyxDQUFDLEdBQUcsQ0FBaEQsRUFBbUQsRUFBRSxDQUFyRCxFQUF3RDtBQUNwRCxNQUFBLFFBQVEsR0FBRyxtQkFBbUIsQ0FBQyxDQUFELENBQTlCLEVBQ0ksS0FBSyxHQUFHLFFBQVEsQ0FBQyxJQURyQjtBQUVBLFVBQUksU0FBUyxHQUFHLEtBQUssQ0FBQyxnQkFBdEI7QUFDQSxVQUFJLGNBQUo7O0FBQ0EsVUFBSSxRQUFRLENBQUMsVUFBVCxLQUF3QixDQUE1QixFQUErQjtBQUMzQixRQUFBLGNBQWMsR0FBRyxLQUFLLGtCQUFMLENBQXdCLFFBQVEsQ0FBQyxVQUFqQyxFQUE2QyxTQUE3QyxDQUFqQjtBQUNILE9BRkQsTUFHSztBQUNELFFBQUEsY0FBYyxHQUFHLEtBQUssbUJBQUwsQ0FBeUIsUUFBekIsRUFBbUMsU0FBbkMsQ0FBakI7QUFDSDs7QUFDRCxNQUFBLGNBQWMsQ0FBQyxLQUFmLENBQXFCLEdBQXJCO0FBQ0EsTUFBQSxjQUFjLENBQUMsVUFBZixDQUEwQixDQUExQjtBQUNBLE1BQUEsaUJBQWlCLENBQUMsSUFBbEIsQ0FBdUIsY0FBdkI7QUFDQSxNQUFBLEtBQUssQ0FBQyxjQUFOLEdBQXVCLGNBQXZCO0FBQ0EsTUFBQSxjQUFjLENBQUMsVUFBZixHQUE0QixJQUE1QjtBQUNBLE1BQUEsY0FBYyxDQUFDLFNBQWYsR0FBMkIsUUFBUSxDQUFDLFFBQXBDO0FBQ0EsTUFBQSxjQUFjLENBQUMsV0FBZixHQUE2QixRQUFRLENBQUMsVUFBdEM7QUFDQSxNQUFBLGVBQWUsQ0FBQyxJQUFoQixDQUFxQixRQUFyQjtBQUNIOztBQUNELElBQUEsTUFBTSxDQUFDLFVBQVAsQ0FBa0IsWUFBWTtBQUMxQixXQUFLLENBQUMsR0FBRyxDQUFKLEVBQU8sQ0FBQyxHQUFHLGlCQUFpQixDQUFDLE1BQWxDLEVBQTBDLENBQUMsR0FBRyxDQUE5QyxFQUFpRCxFQUFFLENBQW5ELEVBQXNEO0FBQ2xELFlBQUksQ0FBQyxHQUFHLGlCQUFpQixDQUFDLENBQUQsQ0FBekI7QUFDQSxZQUFJLENBQUMsQ0FBQyxLQUFOLEVBQ0ksQ0FBQyxDQUFDLE9BQUYsQ0FBVSxRQUFWLENBQW1CLENBQUMsQ0FBQyxLQUFyQixFQUE0QixtQkFBNUI7QUFDSixZQUFJLENBQUMsQ0FBQyxPQUFOLEVBQ0ksQ0FBQyxDQUFDLE9BQUYsQ0FBVSxRQUFWLENBQW1CLENBQUMsQ0FBQyxPQUFyQixFQUE4QixtQkFBOUI7QUFDSixRQUFBLENBQUMsQ0FBQyxVQUFGLENBQWEsQ0FBYjtBQUNIO0FBQ0osS0FURCxFQVNHLENBVEg7O0FBVUEsUUFBSSxLQUFLLFNBQVQsRUFBb0I7QUFDaEIsV0FBSyxDQUFDLEdBQUcsQ0FBSixFQUFPLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBN0IsRUFBcUMsQ0FBQyxHQUFHLENBQXpDLEVBQTRDLEVBQUUsQ0FBOUMsRUFBaUQ7QUFDN0MsUUFBQSxNQUFNLEdBQUcsWUFBWSxDQUFDLENBQUQsQ0FBckI7O0FBQ0EsWUFBSSxNQUFNLENBQUMsY0FBWCxFQUEyQjtBQUN2QixVQUFBLEdBQUcsQ0FBQyxXQUFKLENBQWdCLE1BQWhCO0FBQ0g7QUFDSjtBQUNKLEtBUEQsTUFRSztBQUNELFVBQUksS0FBSyxnQkFBTCxLQUEwQixDQUE5QixFQUFpQztBQUM3QixRQUFBLE1BQU0sQ0FBQyxZQUFQLENBQW9CLEtBQUssZ0JBQXpCOztBQUNBLGFBQUssQ0FBQyxHQUFHLENBQUosRUFBTyxDQUFDLEdBQUcsS0FBSyx5QkFBTCxDQUErQixNQUEvQyxFQUF1RCxDQUFDLEdBQUcsQ0FBM0QsRUFBOEQsRUFBRSxDQUFoRSxFQUFtRTtBQUMvRCxVQUFBLEdBQUcsQ0FBQyxXQUFKLENBQWdCLEtBQUsseUJBQUwsQ0FBK0IsQ0FBL0IsQ0FBaEI7QUFDSDtBQUNKOztBQUNELFVBQUksUUFBUSxHQUFHLEVBQWY7O0FBQ0EsV0FBSyxDQUFDLEdBQUcsQ0FBSixFQUFPLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBN0IsRUFBcUMsQ0FBQyxHQUFHLENBQXpDLEVBQTRDLEVBQUUsQ0FBOUMsRUFBaUQ7QUFDN0MsUUFBQSxNQUFNLEdBQUcsWUFBWSxDQUFDLENBQUQsQ0FBckI7O0FBQ0EsWUFBSSxNQUFNLENBQUMsY0FBWCxFQUEyQjtBQUN2QixVQUFBLE1BQU0sQ0FBQyxVQUFQLENBQWtCLENBQWxCO0FBQ0EsVUFBQSxRQUFRLENBQUMsSUFBVCxDQUFjLE1BQWQ7QUFDSDtBQUNKOztBQUNELFVBQUksUUFBUSxDQUFDLE1BQVQsR0FBa0IsQ0FBdEIsRUFBeUI7QUFDckIsYUFBSyxnQkFBTCxHQUF3QixNQUFNLENBQUMsVUFBUCxDQUFrQixZQUFZO0FBQ2xELGVBQUssQ0FBQyxHQUFHLENBQUosRUFBTyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQXpCLEVBQWlDLENBQUMsR0FBRyxDQUFyQyxFQUF3QyxFQUFFLENBQTFDLEVBQTZDO0FBQ3pDLFlBQUEsR0FBRyxDQUFDLFdBQUosQ0FBZ0IsUUFBUSxDQUFDLENBQUQsQ0FBeEI7QUFDSDs7QUFDRCxVQUFBLEtBQUssQ0FBQyxnQkFBTixHQUF5QixDQUF6QjtBQUNILFNBTHVCLEVBS3JCLEdBTHFCLENBQXhCO0FBTUg7O0FBQ0QsV0FBSyx5QkFBTCxHQUFpQyxRQUFqQztBQUNIOztBQUNELFNBQUssYUFBTCxHQUFxQixlQUFyQjtBQUNBLFNBQUssU0FBTCxHQUFpQixLQUFqQjtBQUNBLFNBQUssV0FBTCxHQUFtQixLQUFuQjtBQUNILEdBNVorRDtBQTZaaEUsRUFBQSxTQUFTLEVBQUUsbUJBQVUsWUFBVixFQUF3QjtBQUMvQixRQUFJLFlBQVksS0FBSyxLQUFLLENBQTFCLEVBQTZCO0FBQUUsTUFBQSxZQUFZLEdBQUcsSUFBZjtBQUFzQjs7QUFDckQsUUFBSSxNQUFNLEdBQUcsS0FBSyxPQUFMLENBQWEsbUJBQWIsQ0FBaUMsWUFBakMsQ0FBYjs7QUFDQSxRQUFJLE1BQUosRUFBWTtBQUNSLFdBQUssSUFBTCxDQUFVLFNBQVYsQ0FBb0IsSUFBSSxDQUFDLENBQUMsWUFBTixDQUFtQixJQUFJLENBQUMsQ0FBQyxNQUFOLENBQWEsTUFBTSxDQUFDLE1BQXBCLEVBQTRCLE1BQU0sQ0FBQyxNQUFuQyxDQUFuQixFQUErRCxJQUFJLENBQUMsQ0FBQyxNQUFOLENBQWEsTUFBTSxDQUFDLE1BQXBCLEVBQTRCLE1BQU0sQ0FBQyxNQUFuQyxDQUEvRCxDQUFwQjtBQUNIO0FBQ0osR0FuYStEO0FBb2FoRSxFQUFBLFVBQVUsRUFBRSxzQkFBWTtBQUNwQixXQUFPLEtBQUssT0FBTCxDQUFhLFVBQWIsRUFBUDtBQUNILEdBdGErRDtBQXVhaEUsRUFBQSxXQUFXLEVBQUUscUJBQVUsV0FBVixFQUF1QjtBQUNoQyxRQUFJLFdBQVcsS0FBSyxLQUFLLENBQXpCLEVBQTRCO0FBQUUsTUFBQSxXQUFXLEdBQUcsSUFBZDtBQUFxQjs7QUFDbkQsU0FBSyxXQUFMLEdBQW1CLElBQW5COztBQUNBLFFBQUksV0FBSixFQUFpQjtBQUNiLFdBQUssV0FBTDtBQUNIO0FBQ0o7QUE3YStELENBQXJDLENBQTdCO0FBK2FBLElBQUksNkJBQTZCLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBRixHQUFVLENBQUMsQ0FBQyxLQUFaLEdBQW9CLENBQUMsQ0FBQyxLQUF2QixFQUE4QixNQUE5QixDQUFxQztBQUN2RSxFQUFBLElBQUksRUFBRSxJQUFJLENBQUMsRUFBTCxHQUFVLENBRHVEO0FBRXZFLEVBQUEscUJBQXFCLEVBQUUsRUFGZ0Q7QUFHdkUsRUFBQSxpQkFBaUIsRUFBRSxJQUFJLENBQUMsRUFBTCxHQUFVLENBSDBDO0FBSXZFLEVBQUEscUJBQXFCLEVBQUUsRUFKZ0Q7QUFLdkUsRUFBQSxrQkFBa0IsRUFBRSxFQUxtRDtBQU12RSxFQUFBLG1CQUFtQixFQUFFLENBTmtEO0FBT3ZFLEVBQUEsbUJBQW1CLEVBQUUsQ0FQa0Q7QUFRdkUsRUFBQSwwQkFBMEIsRUFBRSxDQVIyQztBQVN2RSxFQUFBLFVBQVUsRUFBRSxvQkFBVSxPQUFWLEVBQW1CO0FBQzNCLFNBQUssUUFBTCxHQUFnQixPQUFoQjtBQUNBLFNBQUssZUFBTCxHQUF1QixFQUF2QjtBQUNBLFNBQUssV0FBTCxHQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQXZCO0FBQ0EsU0FBSyxNQUFMLEdBQWMsS0FBSyxXQUFMLEdBQ1YsQ0FBQyxDQUFDLGFBQUYsQ0FBZ0IsRUFBaEIsRUFBb0I7QUFBRSxNQUFBLE1BQU0sRUFBRSxHQUFWO0FBQWUsTUFBQSxLQUFLLEVBQUU7QUFBdEIsS0FBcEIsQ0FEVSxHQUVWLENBQUMsQ0FBQyxRQUFGLENBQVcsRUFBWCxFQUFlO0FBQUUsTUFBQSxNQUFNLEVBQUUsR0FBVjtBQUFlLE1BQUEsS0FBSyxFQUFFO0FBQXRCLEtBQWYsQ0FGSjtBQUdILEdBaEJzRTtBQWlCdkUsRUFBQSxLQUFLLEVBQUUsZUFBVSxHQUFWLEVBQWU7QUFDbEIsU0FBSyxJQUFMLEdBQVksR0FBWjs7QUFDQSxTQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsb0JBQWIsRUFBbUMsS0FBSyxRQUF4QyxFQUFrRCxJQUFsRDs7QUFDQSxTQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsT0FBYixFQUFzQixLQUFLLFVBQTNCLEVBQXVDLElBQXZDOztBQUNBLFNBQUssSUFBTCxDQUFVLEVBQVYsQ0FBYSxTQUFiLEVBQXdCLEtBQUssVUFBN0IsRUFBeUMsSUFBekM7QUFDSCxHQXRCc0U7QUF1QnZFLEVBQUEsUUFBUSxFQUFFLGtCQUFVLElBQVYsRUFBZ0I7QUFDdEIsUUFBSSxLQUFLLEdBQUcsSUFBWjs7QUFDQSxRQUFJLElBQUksQ0FBQyxPQUFMLEtBQWlCLEtBQUssUUFBMUIsRUFBb0M7QUFDaEM7QUFDSDs7QUFDRCxTQUFLLFVBQUw7QUFDQSxRQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTCxDQUFhLE1BQWIsQ0FBb0IsVUFBVSxNQUFWLEVBQWtCO0FBQ2hELGFBQU8sQ0FBQyxNQUFNLENBQUMsUUFBZjtBQUNILEtBRmEsQ0FBZDtBQUdBLFNBQUssY0FBTCxHQUFzQixJQUFJLENBQUMsTUFBM0I7O0FBQ0EsUUFBSSxXQUFXLEdBQUcsS0FBSyxJQUFMLENBQVUsa0JBQVYsQ0FBNkIsSUFBSSxDQUFDLE1BQWxDLENBQWxCOztBQUNBLFFBQUksTUFBSjs7QUFDQSxRQUFJLE9BQU8sQ0FBQyxNQUFSLElBQWtCLEtBQUssbUJBQTNCLEVBQWdEO0FBQzVDLE1BQUEsTUFBTSxHQUFHLEtBQUsscUJBQUwsQ0FBMkIsT0FBTyxDQUFDLE1BQW5DLEVBQTJDLFdBQTNDLENBQVQ7QUFDSCxLQUZELE1BR0s7QUFDRCxVQUFJLEtBQUssV0FBVCxFQUFzQjtBQUNsQixRQUFBLFdBQVcsQ0FBQyxDQUFaLElBQWlCLEVBQWpCO0FBQ0g7O0FBQ0QsTUFBQSxNQUFNLEdBQUcsS0FBSyxxQkFBTCxDQUEyQixPQUFPLENBQUMsTUFBbkMsRUFBMkMsV0FBM0MsQ0FBVDtBQUNIOztBQUNELFFBQUksU0FBUyxHQUFHLEVBQWhCO0FBQ0EsUUFBSSxjQUFjLEdBQUcsRUFBckI7QUFDQSxRQUFJLGVBQWUsR0FBRyxFQUF0Qjs7QUFDQSxTQUFLLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQTNCLEVBQW1DLENBQUMsR0FBRyxDQUF2QyxFQUEwQyxFQUFFLENBQTVDLEVBQStDO0FBQzNDLFVBQUksR0FBRyxHQUFHLEtBQUssSUFBTCxDQUFVLGtCQUFWLENBQTZCLE1BQU0sQ0FBQyxDQUFELENBQW5DLENBQVY7O0FBQ0EsVUFBSSxDQUFDLEdBQUcsS0FBSyxRQUFMLENBQWMsa0JBQWQsQ0FBaUMsT0FBTyxDQUFDLENBQUQsQ0FBeEMsRUFBNkMsSUFBSSxDQUFDLE1BQWxELENBQVI7O0FBQ0EsTUFBQSxDQUFDLENBQUMsZUFBRixDQUFrQixJQUFsQjtBQUNBLE1BQUEsQ0FBQyxDQUFDLFVBQUYsQ0FBYSxDQUFiOztBQUNBLFdBQUssZUFBTCxDQUFxQixJQUFyQixDQUEwQixDQUExQjs7QUFDQSxXQUFLLElBQUwsQ0FBVSxRQUFWLENBQW1CLENBQW5COztBQUNBLE1BQUEsY0FBYyxDQUFDLElBQWYsQ0FBb0IsQ0FBcEI7QUFDQSxNQUFBLGVBQWUsQ0FBQyxJQUFoQixDQUFxQixHQUFyQjtBQUNIOztBQUNELElBQUEsTUFBTSxDQUFDLFVBQVAsQ0FBa0IsWUFBWTtBQUMxQixXQUFLLENBQUMsR0FBRyxDQUFKLEVBQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUF2QixFQUErQixDQUFDLEdBQUcsQ0FBbkMsRUFBc0MsRUFBRSxDQUF4QyxFQUEyQztBQUN2QyxRQUFBLGNBQWMsQ0FBQyxDQUFELENBQWQsQ0FBa0IsU0FBbEIsQ0FBNEIsZUFBZSxDQUFDLENBQUQsQ0FBM0MsRUFDSyxVQURMLENBQ2dCLENBRGhCO0FBRUg7O0FBQ0QsVUFBSSxTQUFTLEdBQUcsQ0FBQyxJQUFJLElBQUosRUFBakI7QUFDQSxVQUFJLFFBQVEsR0FBRyxFQUFmO0FBQUEsVUFBbUIsUUFBUSxHQUFHLEdBQTlCO0FBQ0EsVUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLFdBQVAsQ0FBbUIsWUFBWTtBQUN0QyxRQUFBLFNBQVMsR0FBRyxFQUFaO0FBQ0EsWUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLElBQUosRUFBWDtBQUNBLFlBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxTQUFkOztBQUNBLFlBQUksQ0FBQyxJQUFJLFFBQVQsRUFBbUI7QUFDZixVQUFBLE1BQU0sQ0FBQyxhQUFQLENBQXFCLElBQXJCO0FBQ0EsVUFBQSxTQUFTLEdBQUcsR0FBWjtBQUNILFNBSEQsTUFJSztBQUNELGNBQUksU0FBUyxHQUFHLENBQUMsR0FBRyxRQUFwQjtBQUNIOztBQUNELFlBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFsQjs7QUFDQSxhQUFLLENBQUMsR0FBRyxDQUFKLEVBQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUF2QixFQUErQixDQUFDLEdBQUcsQ0FBbkMsRUFBc0MsRUFBRSxDQUF4QyxFQUEyQztBQUN2QyxjQUFJLENBQUMsR0FBRyxlQUFlLENBQUMsQ0FBRCxDQUF2QjtBQUFBLGNBQTRCLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRixHQUFRLE1BQU0sQ0FBQyxHQUFyRDtBQUFBLGNBQTBELE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRixHQUFRLE1BQU0sQ0FBQyxHQUFuRjtBQUNBLFVBQUEsU0FBUyxDQUFDLElBQVYsQ0FBZSxDQUFDLE1BQUQsRUFBUyxJQUFJLENBQUMsQ0FBQyxNQUFOLENBQWEsTUFBTSxDQUFDLEdBQVAsR0FBYSxPQUFPLEdBQUcsU0FBcEMsRUFBK0MsTUFBTSxDQUFDLEdBQVAsR0FBYSxPQUFPLEdBQUcsU0FBdEUsQ0FBVCxDQUFmO0FBQ0g7O0FBQ0QsUUFBQSxLQUFLLENBQUMsTUFBTixDQUFhLFVBQWIsQ0FBd0IsU0FBeEI7QUFDSCxPQWpCVSxFQWlCUixRQWpCUSxDQUFYO0FBa0JILEtBekJELEVBeUJHLENBekJIOztBQTBCQSxTQUFLLE1BQUwsQ0FBWSxVQUFaLENBQXVCLFNBQXZCOztBQUNBLFNBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUIsS0FBSyxNQUF4Qjs7QUFDQSxRQUFJLElBQUksQ0FBQyxNQUFULEVBQWlCO0FBQ2IsV0FBSyxjQUFMLEdBQXNCLElBQUksQ0FBQyxNQUFMLENBQVksVUFBWixDQUF1QixHQUF2QixDQUF0QjtBQUNIO0FBQ0osR0F4RnNFO0FBeUZ2RSxFQUFBLHFCQUFxQixFQUFFLCtCQUFVLEtBQVYsRUFBaUIsUUFBakIsRUFBMkI7QUFDOUMsUUFBSSxhQUFhLEdBQUcsS0FBSywwQkFBTCxHQUFrQyxLQUFLLHFCQUF2QyxJQUFnRSxJQUFJLEtBQXBFLENBQXBCO0FBQUEsUUFBZ0csU0FBUyxHQUFHLGFBQWEsR0FBRyxLQUFLLElBQWpJO0FBQUEsUUFBdUksU0FBUyxHQUFHLEtBQUssSUFBTCxHQUFZLEtBQS9KO0FBQUEsUUFBc0ssR0FBRyxHQUFHLEVBQTVLO0FBQUEsUUFBZ0wsQ0FBaEw7QUFBQSxRQUFtTCxLQUFuTDtBQUNBLElBQUEsR0FBRyxDQUFDLE1BQUosR0FBYSxLQUFiOztBQUNBLFNBQUssQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFqQixFQUFvQixDQUFDLElBQUksQ0FBekIsRUFBNEIsQ0FBQyxFQUE3QixFQUFpQztBQUM3QixNQUFBLEtBQUssR0FBRyxLQUFLLGlCQUFMLEdBQXlCLENBQUMsR0FBRyxTQUFyQztBQUNBLE1BQUEsR0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTLElBQUksQ0FBQyxDQUFDLEtBQU4sQ0FBWSxJQUFJLENBQUMsS0FBTCxDQUFXLFFBQVEsQ0FBQyxDQUFULEdBQWEsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsS0FBVCxDQUFwQyxDQUFaLEVBQWtFLElBQUksQ0FBQyxLQUFMLENBQVcsUUFBUSxDQUFDLENBQVQsR0FBYSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUwsQ0FBUyxLQUFULENBQXBDLENBQWxFLENBQVQ7QUFDSDs7QUFDRCxXQUFPLEdBQVA7QUFDSCxHQWpHc0U7QUFrR3ZFLEVBQUEscUJBQXFCLEVBQUUsK0JBQVUsS0FBVixFQUFpQixRQUFqQixFQUEyQjtBQUM5QyxRQUFJLFNBQVMsR0FBRyxLQUFLLDBCQUFMLEdBQWtDLEtBQUssa0JBQXZEO0FBQUEsUUFBMkUsVUFBVSxHQUFHLEtBQUssMEJBQUwsR0FBa0MsS0FBSyxxQkFBL0g7QUFBQSxRQUFzSixZQUFZLEdBQUcsS0FBSywwQkFBTCxHQUFrQyxLQUFLLG1CQUE1TTtBQUFBLFFBQWlPLEtBQUssR0FBRyxDQUF6TztBQUFBLFFBQTRPLEdBQUcsR0FBRyxFQUFsUDtBQUFBLFFBQXNQLENBQXRQO0FBQ0EsSUFBQSxHQUFHLENBQUMsTUFBSixHQUFhLEtBQWI7O0FBQ0EsU0FBSyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQWpCLEVBQW9CLENBQUMsSUFBSSxDQUF6QixFQUE0QixDQUFDLEVBQTdCLEVBQWlDO0FBQzdCLE1BQUEsS0FBSyxJQUFJLFVBQVUsR0FBRyxTQUFiLEdBQXlCLENBQUMsR0FBRyxNQUF0QztBQUNBLE1BQUEsR0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTLElBQUksQ0FBQyxDQUFDLEtBQU4sQ0FBWSxJQUFJLENBQUMsS0FBTCxDQUFXLFFBQVEsQ0FBQyxDQUFULEdBQWEsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsS0FBVCxDQUFwQyxDQUFaLEVBQWtFLElBQUksQ0FBQyxLQUFMLENBQVcsUUFBUSxDQUFDLENBQVQsR0FBYSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUwsQ0FBUyxLQUFULENBQXBDLENBQWxFLENBQVQ7QUFDQSxNQUFBLFNBQVMsSUFBSSxLQUFLLElBQUwsR0FBWSxZQUFaLEdBQTJCLEtBQXhDO0FBQ0g7O0FBQ0QsV0FBTyxHQUFQO0FBQ0gsR0EzR3NFO0FBNEd2RSxFQUFBLFVBQVUsRUFBRSxzQkFBWTtBQUNwQixRQUFJLEtBQUssR0FBRyxJQUFaOztBQUNBLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLENBQUMsR0FBRyxLQUFLLGVBQUwsQ0FBcUIsTUFBekMsRUFBaUQsQ0FBQyxHQUFHLENBQXJELEVBQXdELEVBQUUsQ0FBMUQsRUFBNkQ7QUFDekQsV0FBSyxlQUFMLENBQXFCLENBQXJCLEVBQXdCLFNBQXhCLENBQWtDLEtBQUssY0FBdkMsRUFBdUQsVUFBdkQsQ0FBa0UsQ0FBbEU7QUFDSDs7QUFDRCxRQUFJLE9BQU8sR0FBRyxLQUFLLGVBQW5CO0FBQ0EsSUFBQSxNQUFNLENBQUMsVUFBUCxDQUFrQixZQUFZO0FBQzFCLFdBQUssQ0FBQyxHQUFHLENBQUosRUFBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQXhCLEVBQWdDLENBQUMsR0FBRyxDQUFwQyxFQUF1QyxFQUFFLENBQXpDLEVBQTRDO0FBQ3hDLFFBQUEsS0FBSyxDQUFDLElBQU4sQ0FBVyxXQUFYLENBQXVCLE9BQU8sQ0FBQyxDQUFELENBQTlCO0FBQ0g7QUFDSixLQUpELEVBSUcsR0FKSDtBQUtBLFNBQUssZUFBTCxHQUF1QixFQUF2Qjs7QUFDQSxTQUFLLElBQUwsQ0FBVSxXQUFWLENBQXNCLEtBQUssTUFBM0I7O0FBQ0EsUUFBSSxLQUFLLGNBQVQsRUFBeUI7QUFDckIsV0FBSyxjQUFMLENBQW9CLFVBQXBCLENBQStCLENBQS9CO0FBQ0g7QUFDSixHQTVIc0U7QUE2SHZFLEVBQUEsUUFBUSxFQUFFLGtCQUFVLEdBQVYsRUFBZTtBQUNyQixTQUFLLFVBQUw7QUFDQSxJQUFBLEdBQUcsQ0FBQyxHQUFKLENBQVEsb0JBQVIsRUFBOEIsS0FBSyxRQUFuQyxFQUE2QyxJQUE3QztBQUNBLElBQUEsR0FBRyxDQUFDLEdBQUosQ0FBUSxPQUFSLEVBQWlCLEtBQUssVUFBdEIsRUFBa0MsSUFBbEM7QUFDQSxJQUFBLEdBQUcsQ0FBQyxHQUFKLENBQVEsU0FBUixFQUFtQixLQUFLLFVBQXhCLEVBQW9DLElBQXBDO0FBQ0g7QUFsSXNFLENBQXJDLENBQXBDO0FBc0lBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCO0FBQUMsRUFBQSxZQUFZLEVBQVosWUFBRDtBQUFlLEVBQUEsc0JBQXNCLEVBQXRCO0FBQWYsQ0FBakIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGluc2VydGVkID0gZXhwb3J0cy5jYWNoZSA9IHt9XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZXhwb3J0cy5pbnNlcnQgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIGlmIChpbnNlcnRlZFtjc3NdKSByZXR1cm4gbm9vcFxuICBpbnNlcnRlZFtjc3NdID0gdHJ1ZVxuXG4gIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBlbGVtLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpXG5cbiAgaWYgKCd0ZXh0Q29udGVudCcgaW4gZWxlbSkge1xuICAgIGVsZW0udGV4dENvbnRlbnQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICBlbGVtLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9XG5cbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChlbGVtKVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0ucmVtb3ZlQ2hpbGQoZWxlbSlcbiAgICBpbnNlcnRlZFtjc3NdID0gZmFsc2VcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG52YXIgYnRvYSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYnRvYSAmJiB3aW5kb3cuYnRvYS5iaW5kKHdpbmRvdykpIHx8IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idG9hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIGxvYWRFdmVudCA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xuICAgIHZhciB4RG9tYWluID0gZmFsc2U7XG5cbiAgICAvLyBGb3IgSUUgOC85IENPUlMgc3VwcG9ydFxuICAgIC8vIE9ubHkgc3VwcG9ydHMgUE9TVCBhbmQgR0VUIGNhbGxzIGFuZCBkb2Vzbid0IHJldHVybnMgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgLy8gRE9OJ1QgZG8gdGhpcyBmb3IgdGVzdGluZyBiL2MgWE1MSHR0cFJlcXVlc3QgaXMgbW9ja2VkLCBub3QgWERvbWFpblJlcXVlc3QuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkgJiZcbiAgICAgICAgIWlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkge1xuICAgICAgcmVxdWVzdCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIGxvYWRFdmVudCA9ICdvbmxvYWQnO1xuICAgICAgeERvbWFpbiA9IHRydWU7XG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcygpIHt9O1xuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge307XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdFtsb2FkRXZlbnRdID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0ICYmICF4RG9tYWluKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAvLyBJRSBzZW5kcyAxMjIzIGluc3RlYWQgb2YgMjA0IChodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzLzIwMSlcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgdmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xuXG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLndpdGhDcmVkZW50aWFscykge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeHBlY3RlZCBET01FeGNlcHRpb24gdGhyb3duIGJ5IGJyb3dzZXJzIG5vdCBjb21wYXRpYmxlIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIuXG4gICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG4gICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3REYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UodXRpbHMubWVyZ2UoZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gdXRpbHMubWVyZ2Uoe1xuICAgICAgdXJsOiBhcmd1bWVudHNbMF1cbiAgICB9LCBhcmd1bWVudHNbMV0pO1xuICB9XG5cbiAgY29uZmlnID0gdXRpbHMubWVyZ2UoZGVmYXVsdHMsIHttZXRob2Q6ICdnZXQnfSwgdGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gU3VwcG9ydCBiYXNlVVJMIGNvbmZpZ1xuICBpZiAoY29uZmlnLmJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwoY29uZmlnLnVybCkpIHtcbiAgICBjb25maWcudXJsID0gY29tYmluZVVSTHMoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICB9XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVycyB8fCB7fVxuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICByZXR1cm4gZXJyb3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGJ0b2EgcG9seWZpbGwgZm9yIElFPDEwIGNvdXJ0ZXN5IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGNoYW1iZXJzL0Jhc2U2NC5qc1xuXG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG5mdW5jdGlvbiBFKCkge1xuICB0aGlzLm1lc3NhZ2UgPSAnU3RyaW5nIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcmFjdGVyJztcbn1cbkUucHJvdG90eXBlID0gbmV3IEVycm9yO1xuRS5wcm90b3R5cGUuY29kZSA9IDU7XG5FLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cbmZ1bmN0aW9uIGJ0b2EoaW5wdXQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhpbnB1dCk7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgZm9yIChcbiAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlclxuICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzO1xuICAgIC8vIGlmIHRoZSBuZXh0IHN0ciBpbmRleCBkb2VzIG5vdCBleGlzdDpcbiAgICAvLyAgIGNoYW5nZSB0aGUgbWFwcGluZyB0YWJsZSB0byBcIj1cIlxuICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICBzdHIuY2hhckF0KGlkeCB8IDApIHx8IChtYXAgPSAnPScsIGlkeCAlIDEpO1xuICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG4gICkge1xuICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaWR4ICs9IDMgLyA0KTtcbiAgICBpZiAoY2hhckNvZGUgPiAweEZGKSB7XG4gICAgICB0aHJvdyBuZXcgRSgpO1xuICAgIH1cbiAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ0b2E7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTQwL2dpLCAnQCcpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgIH1cblxuICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgfTtcbiAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltXG59O1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1kc3YvIFZlcnNpb24gMS4wLjcuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIEVPTCA9IHt9O1xudmFyIEVPRiA9IHt9O1xudmFyIFFVT1RFID0gMzQ7XG52YXIgTkVXTElORSA9IDEwO1xudmFyIFJFVFVSTiA9IDEzO1xuXG5mdW5jdGlvbiBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucykge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyBjb2x1bW5zLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdXCI7XG4gIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xufVxuXG5mdW5jdGlvbiBjdXN0b21Db252ZXJ0ZXIoY29sdW1ucywgZikge1xuICB2YXIgb2JqZWN0ID0gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpO1xuICByZXR1cm4gZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgcmV0dXJuIGYob2JqZWN0KHJvdyksIGksIGNvbHVtbnMpO1xuICB9O1xufVxuXG4vLyBDb21wdXRlIHVuaXF1ZSBjb2x1bW5zIGluIG9yZGVyIG9mIGRpc2NvdmVyeS5cbmZ1bmN0aW9uIGluZmVyQ29sdW1ucyhyb3dzKSB7XG4gIHZhciBjb2x1bW5TZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgY29sdW1ucyA9IFtdO1xuXG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICBmb3IgKHZhciBjb2x1bW4gaW4gcm93KSB7XG4gICAgICBpZiAoIShjb2x1bW4gaW4gY29sdW1uU2V0KSkge1xuICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uU2V0W2NvbHVtbl0gPSBjb2x1bW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbHVtbnM7XG59XG5cbnZhciBkc3YgPSBmdW5jdGlvbihkZWxpbWl0ZXIpIHtcbiAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cChcIltcXFwiXCIgKyBkZWxpbWl0ZXIgKyBcIlxcblxccl1cIiksXG4gICAgICBERUxJTUlURVIgPSBkZWxpbWl0ZXIuY2hhckNvZGVBdCgwKTtcblxuICBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmKSB7XG4gICAgdmFyIGNvbnZlcnQsIGNvbHVtbnMsIHJvd3MgPSBwYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICBpZiAoY29udmVydCkgcmV0dXJuIGNvbnZlcnQocm93LCBpIC0gMSk7XG4gICAgICBjb2x1bW5zID0gcm93LCBjb252ZXJ0ID0gZiA/IGN1c3RvbUNvbnZlcnRlcihyb3csIGYpIDogb2JqZWN0Q29udmVydGVyKHJvdyk7XG4gICAgfSk7XG4gICAgcm93cy5jb2x1bW5zID0gY29sdW1ucztcbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUm93cyh0ZXh0LCBmKSB7XG4gICAgdmFyIHJvd3MgPSBbXSwgLy8gb3V0cHV0IHJvd3NcbiAgICAgICAgTiA9IHRleHQubGVuZ3RoLFxuICAgICAgICBJID0gMCwgLy8gY3VycmVudCBjaGFyYWN0ZXIgaW5kZXhcbiAgICAgICAgbiA9IDAsIC8vIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgdCwgLy8gY3VycmVudCB0b2tlblxuICAgICAgICBlb2YgPSBOIDw9IDAsIC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9GP1xuICAgICAgICBlb2wgPSBmYWxzZTsgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0w/XG5cbiAgICAvLyBTdHJpcCB0aGUgdHJhaWxpbmcgbmV3bGluZS5cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gTkVXTElORSkgLS1OO1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBSRVRVUk4pIC0tTjtcblxuICAgIGZ1bmN0aW9uIHRva2VuKCkge1xuICAgICAgaWYgKGVvZikgcmV0dXJuIEVPRjtcbiAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xuXG4gICAgICAvLyBVbmVzY2FwZSBxdW90ZXMuXG4gICAgICB2YXIgaSwgaiA9IEksIGM7XG4gICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGopID09PSBRVU9URSkge1xuICAgICAgICB3aGlsZSAoSSsrIDwgTiAmJiB0ZXh0LmNoYXJDb2RlQXQoSSkgIT09IFFVT1RFIHx8IHRleHQuY2hhckNvZGVBdCgrK0kpID09PSBRVU9URSk7XG4gICAgICAgIGlmICgoaSA9IEkpID49IE4pIGVvZiA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpIC0gMSkucmVwbGFjZSgvXCJcIi9nLCBcIlxcXCJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgbmV4dCBkZWxpbWl0ZXIgb3IgbmV3bGluZS5cbiAgICAgIHdoaWxlIChJIDwgTikge1xuICAgICAgICBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSA9IEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IERFTElNSVRFUikgY29udGludWU7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGosIGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gbGFzdCB0b2tlbiBiZWZvcmUgRU9GLlxuICAgICAgcmV0dXJuIGVvZiA9IHRydWUsIHRleHQuc2xpY2UoaiwgTik7XG4gICAgfVxuXG4gICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xuICAgICAgdmFyIHJvdyA9IFtdO1xuICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpIHJvdy5wdXNoKHQpLCB0ID0gdG9rZW4oKTtcbiAgICAgIGlmIChmICYmIChyb3cgPSBmKHJvdywgbisrKSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICByb3dzLnB1c2gocm93KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdChyb3dzLCBjb2x1bW5zKSB7XG4gICAgaWYgKGNvbHVtbnMgPT0gbnVsbCkgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICByZXR1cm4gW2NvbHVtbnMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcildLmNvbmNhdChyb3dzLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHJvd1tjb2x1bW5dKTtcbiAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICB9KSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvd3Mocm93cykge1xuICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgcmV0dXJuIHJvdy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dCA9PSBudWxsID8gXCJcIlxuICAgICAgICA6IHJlRm9ybWF0LnRlc3QodGV4dCArPSBcIlwiKSA/IFwiXFxcIlwiICsgdGV4dC5yZXBsYWNlKC9cIi9nLCBcIlxcXCJcXFwiXCIpICsgXCJcXFwiXCJcbiAgICAgICAgOiB0ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgcGFyc2VSb3dzOiBwYXJzZVJvd3MsXG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgZm9ybWF0Um93czogZm9ybWF0Um93c1xuICB9O1xufTtcblxudmFyIGNzdiA9IGRzdihcIixcIik7XG5cbnZhciBjc3ZQYXJzZSA9IGNzdi5wYXJzZTtcbnZhciBjc3ZQYXJzZVJvd3MgPSBjc3YucGFyc2VSb3dzO1xudmFyIGNzdkZvcm1hdCA9IGNzdi5mb3JtYXQ7XG52YXIgY3N2Rm9ybWF0Um93cyA9IGNzdi5mb3JtYXRSb3dzO1xuXG52YXIgdHN2ID0gZHN2KFwiXFx0XCIpO1xuXG52YXIgdHN2UGFyc2UgPSB0c3YucGFyc2U7XG52YXIgdHN2UGFyc2VSb3dzID0gdHN2LnBhcnNlUm93cztcbnZhciB0c3ZGb3JtYXQgPSB0c3YuZm9ybWF0O1xudmFyIHRzdkZvcm1hdFJvd3MgPSB0c3YuZm9ybWF0Um93cztcblxuZXhwb3J0cy5kc3ZGb3JtYXQgPSBkc3Y7XG5leHBvcnRzLmNzdlBhcnNlID0gY3N2UGFyc2U7XG5leHBvcnRzLmNzdlBhcnNlUm93cyA9IGNzdlBhcnNlUm93cztcbmV4cG9ydHMuY3N2Rm9ybWF0ID0gY3N2Rm9ybWF0O1xuZXhwb3J0cy5jc3ZGb3JtYXRSb3dzID0gY3N2Rm9ybWF0Um93cztcbmV4cG9ydHMudHN2UGFyc2UgPSB0c3ZQYXJzZTtcbmV4cG9ydHMudHN2UGFyc2VSb3dzID0gdHN2UGFyc2VSb3dzO1xuZXhwb3J0cy50c3ZGb3JtYXQgPSB0c3ZGb3JtYXQ7XG5leHBvcnRzLnRzdkZvcm1hdFJvd3MgPSB0c3ZGb3JtYXRSb3dzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCIvKlxuICogTGVhZmxldC5tYXJrZXJjbHVzdGVyIDEuNC4xK21hc3Rlci45NGY5ODE1LFxuICogUHJvdmlkZXMgQmVhdXRpZnVsIEFuaW1hdGVkIE1hcmtlciBDbHVzdGVyaW5nIGZ1bmN0aW9uYWxpdHkgZm9yIExlYWZsZXQsIGEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwcy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQubWFya2VyY2x1c3RlclxuICogKGMpIDIwMTItMjAxNywgRGF2ZSBMZWF2ZXIsIHNtYXJ0cmFrXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5MZWFmbGV0ID0gZ2xvYmFsLkxlYWZsZXQgfHwge30sIGdsb2JhbC5MZWFmbGV0Lm1hcmtlcmNsdXN0ZXIgPSBnbG9iYWwuTGVhZmxldC5tYXJrZXJjbHVzdGVyIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKlxyXG4gKiBMLk1hcmtlckNsdXN0ZXJHcm91cCBleHRlbmRzIEwuRmVhdHVyZUdyb3VwIGJ5IGNsdXN0ZXJpbmcgdGhlIG1hcmtlcnMgY29udGFpbmVkIHdpdGhpblxyXG4gKi9cclxuXHJcbnZhciBNYXJrZXJDbHVzdGVyR3JvdXAgPSBMLk1hcmtlckNsdXN0ZXJHcm91cCA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdG1heENsdXN0ZXJSYWRpdXM6IDgwLCAvL0EgY2x1c3RlciB3aWxsIGNvdmVyIGF0IG1vc3QgdGhpcyBtYW55IHBpeGVscyBmcm9tIGl0cyBjZW50ZXJcclxuXHRcdGljb25DcmVhdGVGdW5jdGlvbjogbnVsbCxcclxuXHRcdGNsdXN0ZXJQYW5lOiBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5wYW5lLFxyXG5cclxuXHRcdHNwaWRlcmZ5T25NYXhab29tOiB0cnVlLFxyXG5cdFx0c2hvd0NvdmVyYWdlT25Ib3ZlcjogdHJ1ZSxcclxuXHRcdHpvb21Ub0JvdW5kc09uQ2xpY2s6IHRydWUsXHJcblx0XHRzaW5nbGVNYXJrZXJNb2RlOiBmYWxzZSxcclxuXHJcblx0XHRkaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbTogbnVsbCxcclxuXHJcblx0XHQvLyBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgcHJldmVudHMgdGhlIHJlbW92YWwgb2YgYW55IGNsdXN0ZXJzIG91dHNpZGUgb2YgdGhlIHZpZXdwb2ludCwgd2hpY2hcclxuXHRcdC8vIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cclxuXHRcdHJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzOiB0cnVlLFxyXG5cclxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIGFsbCBhbmltYXRpb25zICh6b29tIGFuZCBzcGlkZXJmeSkuXHJcblx0XHQvLyBJZiBmYWxzZSwgb3B0aW9uIGFuaW1hdGVBZGRpbmdNYXJrZXJzIGJlbG93IGhhcyBubyBlZmZlY3QuXHJcblx0XHQvLyBJZiBMLkRvbVV0aWwuVFJBTlNJVElPTiBpcyBmYWxzeSwgdGhpcyBvcHRpb24gaGFzIG5vIGVmZmVjdC5cclxuXHRcdGFuaW1hdGU6IHRydWUsXHJcblxyXG5cdFx0Ly9XaGV0aGVyIHRvIGFuaW1hdGUgYWRkaW5nIG1hcmtlcnMgYWZ0ZXIgYWRkaW5nIHRoZSBNYXJrZXJDbHVzdGVyR3JvdXAgdG8gdGhlIG1hcFxyXG5cdFx0Ly8gSWYgeW91IGFyZSBhZGRpbmcgaW5kaXZpZHVhbCBtYXJrZXJzIHNldCB0byB0cnVlLCBpZiBhZGRpbmcgYnVsayBtYXJrZXJzIGxlYXZlIGZhbHNlIGZvciBtYXNzaXZlIHBlcmZvcm1hbmNlIGdhaW5zLlxyXG5cdFx0YW5pbWF0ZUFkZGluZ01hcmtlcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vSW5jcmVhc2UgdG8gaW5jcmVhc2UgdGhlIGRpc3RhbmNlIGF3YXkgdGhhdCBzcGlkZXJmaWVkIG1hcmtlcnMgYXBwZWFyIGZyb20gdGhlIGNlbnRlclxyXG5cdFx0c3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXI6IDEsXHJcblxyXG5cdFx0Ly8gTWFrZSBpdCBwb3NzaWJsZSB0byBzcGVjaWZ5IGEgcG9seWxpbmUgb3B0aW9ucyBvbiBhIHNwaWRlciBsZWdcclxuXHRcdHNwaWRlckxlZ1BvbHlsaW5lT3B0aW9uczogeyB3ZWlnaHQ6IDEuNSwgY29sb3I6ICcjMjIyJywgb3BhY2l0eTogMC41IH0sXHJcblxyXG5cdFx0Ly8gV2hlbiBidWxrIGFkZGluZyBsYXllcnMsIGFkZHMgbWFya2VycyBpbiBjaHVua3MuIE1lYW5zIGFkZExheWVycyBtYXkgbm90IGFkZCBhbGwgdGhlIGxheWVycyBpbiB0aGUgY2FsbCwgb3RoZXJzIHdpbGwgYmUgbG9hZGVkIGR1cmluZyBzZXRUaW1lb3V0c1xyXG5cdFx0Y2h1bmtlZExvYWRpbmc6IGZhbHNlLFxyXG5cdFx0Y2h1bmtJbnRlcnZhbDogMjAwLCAvLyBwcm9jZXNzIG1hcmtlcnMgZm9yIGEgbWF4aW11bSBvZiB+IG4gbWlsbGlzZWNvbmRzICh0aGVuIHRyaWdnZXIgdGhlIGNodW5rUHJvZ3Jlc3MgY2FsbGJhY2spXHJcblx0XHRjaHVua0RlbGF5OiA1MCwgLy8gYXQgdGhlIGVuZCBvZiBlYWNoIGludGVydmFsLCBnaXZlIG4gbWlsbGlzZWNvbmRzIGJhY2sgdG8gc3lzdGVtL2Jyb3dzZXJcclxuXHRcdGNodW5rUHJvZ3Jlc3M6IG51bGwsIC8vIHByb2dyZXNzIGNhbGxiYWNrOiBmdW5jdGlvbihwcm9jZXNzZWQsIHRvdGFsLCBlbGFwc2VkKSAoZS5nLiBmb3IgYSBwcm9ncmVzcyBpbmRpY2F0b3IpXHJcblxyXG5cdFx0Ly9PcHRpb25zIHRvIHBhc3MgdG8gdGhlIEwuUG9seWdvbiBjb25zdHJ1Y3RvclxyXG5cdFx0cG9seWdvbk9wdGlvbnM6IHt9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cCA9IEwuZmVhdHVyZUdyb3VwKCk7XHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cCA9IEwuZmVhdHVyZUdyb3VwKCk7XHJcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbiA9IDA7XHJcblx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcgPSBbXTtcclxuXHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTsgLy9NYXJrZXJzIHJlbW92ZWQgd2hpbGUgd2UgYXJlbid0IG9uIHRoZSBtYXAgbmVlZCB0byBiZSBrZXB0IHRyYWNrIG9mXHJcblx0XHQvL1RoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnRseSBzaG93biBhcmVhIChmcm9tIF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMpIFVwZGF0ZWQgb24gem9vbS9tb3ZlXHJcblx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuX3F1ZXVlID0gW107XHJcblxyXG5cdFx0dGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzID0ge1xyXG5cdFx0XHQnZHJhZ3N0YXJ0JzogdGhpcy5fY2hpbGRNYXJrZXJEcmFnU3RhcnQsXHJcblx0XHRcdCdtb3ZlJzogdGhpcy5fY2hpbGRNYXJrZXJNb3ZlZCxcclxuXHRcdFx0J2RyYWdlbmQnOiB0aGlzLl9jaGlsZE1hcmtlckRyYWdFbmQsXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEhvb2sgdGhlIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiBtZXRob2RzLlxyXG5cdFx0dmFyIGFuaW1hdGUgPSBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiB0aGlzLm9wdGlvbnMuYW5pbWF0ZTtcclxuXHRcdEwuZXh0ZW5kKHRoaXMsIGFuaW1hdGUgPyB0aGlzLl93aXRoQW5pbWF0aW9uIDogdGhpcy5fbm9BbmltYXRpb24pO1xyXG5cdFx0Ly8gUmVtZW1iZXIgd2hpY2ggTWFya2VyQ2x1c3RlciBjbGFzcyB0byBpbnN0YW50aWF0ZSAoYW5pbWF0ZWQgb3Igbm90KS5cclxuXHRcdHRoaXMuX21hcmtlckNsdXN0ZXIgPSBhbmltYXRlID8gTC5NYXJrZXJDbHVzdGVyIDogTC5NYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQ7XHJcblx0fSxcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcnMoW2xheWVyXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9Eb24ndCBjbHVzdGVyIG5vbiBwb2ludCBkYXRhXHJcblx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcucHVzaChsYXllcik7XHJcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvL0lmIHdlIGhhdmUgYWxyZWFkeSBjbHVzdGVyZWQgd2UnbGwgbmVlZCB0byBhZGQgdGhpcyBvbmUgdG8gYSBjbHVzdGVyXHJcblxyXG5cdFx0aWYgKHRoaXMuX3Vuc3BpZGVyZnkpIHtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCB0aGlzLl9tYXhab29tKTtcclxuXHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0Ly9Xb3JrIG91dCB3aGF0IGlzIHZpc2libGVcclxuXHRcdHZhciB2aXNpYmxlTGF5ZXIgPSBsYXllcixcclxuXHRcdCAgICBjdXJyZW50Wm9vbSA9IHRoaXMuX3pvb207XHJcblx0XHRpZiAobGF5ZXIuX19wYXJlbnQpIHtcclxuXHRcdFx0d2hpbGUgKHZpc2libGVMYXllci5fX3BhcmVudC5fem9vbSA+PSBjdXJyZW50Wm9vbSkge1xyXG5cdFx0XHRcdHZpc2libGVMYXllciA9IHZpc2libGVMYXllci5fX3BhcmVudDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMuY29udGFpbnModmlzaWJsZUxheWVyLmdldExhdExuZygpKSkge1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmFuaW1hdGVBZGRpbmdNYXJrZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXIobGF5ZXIsIHZpc2libGVMYXllcik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZChsYXllciwgdmlzaWJsZUxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYXllcnMoW2xheWVyXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9Ob24gcG9pbnQgbGF5ZXJzXHJcblx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuX2FycmF5U3BsaWNlKHRoaXMuX25lZWRzQ2x1c3RlcmluZywgbGF5ZXIpICYmIHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdFx0dGhpcy5fbmVlZHNSZW1vdmluZy5wdXNoKHsgbGF5ZXI6IGxheWVyLCBsYXRsbmc6IGxheWVyLl9sYXRsbmcgfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxheWVyLl9fcGFyZW50KSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl91bnNwaWRlcmZ5KSB7XHJcblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeUxheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1JlbW92ZSB0aGUgbWFya2VyIGZyb20gY2x1c3RlcnNcclxuXHRcdHRoaXMuX3JlbW92ZUxheWVyKGxheWVyLCB0cnVlKTtcclxuXHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0bGF5ZXIub2ZmKHRoaXMuX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycywgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ZlYXR1cmVHcm91cC5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHRcdFx0aWYgKGxheWVyLmNsdXN0ZXJTaG93KSB7XHJcblx0XHRcdFx0bGF5ZXIuY2x1c3RlclNob3coKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vVGFrZXMgYW4gYXJyYXkgb2YgbWFya2VycyBhbmQgYWRkcyB0aGVtIGluIGJ1bGtcclxuXHRhZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnNBcnJheSwgc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdGlmICghTC5VdGlsLmlzQXJyYXkobGF5ZXJzQXJyYXkpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyc0FycmF5KTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXHJcblx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcclxuXHRcdCAgICBjaHVua2VkID0gdGhpcy5vcHRpb25zLmNodW5rZWRMb2FkaW5nLFxyXG5cdFx0ICAgIGNodW5rSW50ZXJ2YWwgPSB0aGlzLm9wdGlvbnMuY2h1bmtJbnRlcnZhbCxcclxuXHRcdCAgICBjaHVua1Byb2dyZXNzID0gdGhpcy5vcHRpb25zLmNodW5rUHJvZ3Jlc3MsXHJcblx0XHQgICAgbCA9IGxheWVyc0FycmF5Lmxlbmd0aCxcclxuXHRcdCAgICBvZmZzZXQgPSAwLFxyXG5cdFx0ICAgIG9yaWdpbmFsQXJyYXkgPSB0cnVlLFxyXG5cdFx0ICAgIG07XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR2YXIgc3RhcnRlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcblx0XHRcdHZhciBwcm9jZXNzID0gTC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR2YXIgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG5cdFx0XHRcdGZvciAoOyBvZmZzZXQgPCBsOyBvZmZzZXQrKykge1xyXG5cdFx0XHRcdFx0aWYgKGNodW5rZWQgJiYgb2Zmc2V0ICUgMjAwID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdC8vIGV2ZXJ5IGNvdXBsZSBodW5kcmVkIG1hcmtlcnMsIGluc3RydW1lbnQgdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSBwcm9jZXNzaW5nIHN0YXJ0ZWQ6XHJcblx0XHRcdFx0XHRcdHZhciBlbGFwc2VkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0O1xyXG5cdFx0XHRcdFx0XHRpZiAoZWxhcHNlZCA+IGNodW5rSW50ZXJ2YWwpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhazsgLy8gYmVlbiB3b3JraW5nIHRvbyBoYXJkLCB0aW1lIHRvIHRha2UgYSBicmVhayA6LSlcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG0gPSBsYXllcnNBcnJheVtvZmZzZXRdO1xyXG5cclxuXHRcdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdFx0Ly8gU2lkZSBlZmZlY3RzOlxyXG5cdFx0XHRcdFx0Ly8gLSBUb3RhbCBpbmNyZWFzZXMsIHNvIGNodW5rUHJvZ3Jlc3MgcmF0aW8ganVtcHMgYmFja3dhcmQuXHJcblx0XHRcdFx0XHQvLyAtIEdyb3VwcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoaXMgZ3JvdXAsIG9ubHkgdGhlaXIgbm9uLWdyb3VwIGNoaWxkIGxheWVycyAoaGFzTGF5ZXIpLlxyXG5cdFx0XHRcdFx0Ly8gQ2hhbmdpbmcgYXJyYXkgbGVuZ3RoIHdoaWxlIGxvb3BpbmcgZG9lcyBub3QgYWZmZWN0IHBlcmZvcm1hbmNlIGluIGN1cnJlbnQgYnJvd3NlcnM6XHJcblx0XHRcdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9mb3ItbG9vcC1jaGFuZ2luZy1sZW5ndGgvNlxyXG5cdFx0XHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcclxuXHRcdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XHJcblx0XHRcdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XHJcblx0XHRcdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vTm90IHBvaW50IGRhdGEsIGNhbid0IGJlIGNsdXN0ZXJlZFxyXG5cdFx0XHRcdFx0aWYgKCFtLmdldExhdExuZykge1xyXG5cdFx0XHRcdFx0XHRucGcuYWRkTGF5ZXIobSk7XHJcblx0XHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbSB9KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5oYXNMYXllcihtKSkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLl9hZGRMYXllcihtLCB0aGlzLl9tYXhab29tKTtcclxuXHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IG0gfSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly9JZiB3ZSBqdXN0IG1hZGUgYSBjbHVzdGVyIG9mIHNpemUgMiB0aGVuIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBvdGhlciBtYXJrZXIgZnJvbSB0aGUgbWFwIChpZiBpdCBpcykgb3Igd2UgbmV2ZXIgd2lsbFxyXG5cdFx0XHRcdFx0aWYgKG0uX19wYXJlbnQpIHtcclxuXHRcdFx0XHRcdFx0aWYgKG0uX19wYXJlbnQuZ2V0Q2hpbGRDb3VudCgpID09PSAyKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG1hcmtlcnMgPSBtLl9fcGFyZW50LmdldEFsbENoaWxkTWFya2VycygpLFxyXG5cdFx0XHRcdFx0XHRcdCAgICBvdGhlck1hcmtlciA9IG1hcmtlcnNbMF0gPT09IG0gPyBtYXJrZXJzWzFdIDogbWFya2Vyc1swXTtcclxuXHRcdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihvdGhlck1hcmtlcik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjaHVua1Byb2dyZXNzKSB7XHJcblx0XHRcdFx0XHQvLyByZXBvcnQgcHJvZ3Jlc3MgYW5kIHRpbWUgZWxhcHNlZDpcclxuXHRcdFx0XHRcdGNodW5rUHJvZ3Jlc3Mob2Zmc2V0LCBsLCAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnRlZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBDb21wbGV0ZWQgcHJvY2Vzc2luZyBhbGwgbWFya2Vycy5cclxuXHRcdFx0XHRpZiAob2Zmc2V0ID09PSBsKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cclxuXHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHNldFRpbWVvdXQocHJvY2VzcywgdGhpcy5vcHRpb25zLmNodW5rRGVsYXkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHRwcm9jZXNzKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgbmVlZHNDbHVzdGVyaW5nID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nO1xyXG5cclxuXHRcdFx0Zm9yICg7IG9mZnNldCA8IGw7IG9mZnNldCsrKSB7XHJcblx0XHRcdFx0bSA9IGxheWVyc0FycmF5W29mZnNldF07XHJcblxyXG5cdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xyXG5cdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XHJcblx0XHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XHJcblx0XHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL05vdCBwb2ludCBkYXRhLCBjYW4ndCBiZSBjbHVzdGVyZWRcclxuXHRcdFx0XHRpZiAoIW0uZ2V0TGF0TG5nKSB7XHJcblx0XHRcdFx0XHRucGcuYWRkTGF5ZXIobSk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG5lZWRzQ2x1c3RlcmluZy5wdXNoKG0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvL1Rha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIHJlbW92ZXMgdGhlbSBpbiBidWxrXHJcblx0cmVtb3ZlTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzQXJyYXkpIHtcclxuXHRcdHZhciBpLCBtLFxyXG5cdFx0ICAgIGwgPSBsYXllcnNBcnJheS5sZW5ndGgsXHJcblx0XHQgICAgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXHJcblx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcclxuXHRcdCAgICBvcmlnaW5hbEFycmF5ID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdFx0bSA9IGxheWVyc0FycmF5W2ldO1xyXG5cclxuXHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cclxuXHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcclxuXHRcdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xyXG5cdFx0XHRcdFx0XHRvcmlnaW5hbEFycmF5ID0gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xyXG5cdFx0XHRcdFx0bCA9IGxheWVyc0FycmF5Lmxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fYXJyYXlTcGxpY2UodGhpcy5fbmVlZHNDbHVzdGVyaW5nLCBtKTtcclxuXHRcdFx0XHRucGcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcucHVzaCh7IGxheWVyOiBtLCBsYXRsbmc6IG0uX2xhdGxuZyB9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IG0gfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3Vuc3BpZGVyZnkpIHtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cclxuXHRcdFx0Ly8gV29yayBvbiBhIGNvcHkgb2YgdGhlIGFycmF5LCBzbyB0aGF0IG5leHQgbG9vcCBpcyBub3QgYWZmZWN0ZWQuXHJcblx0XHRcdHZhciBsYXllcnNBcnJheTIgPSBsYXllcnNBcnJheS5zbGljZSgpLFxyXG5cdFx0XHQgICAgbDIgPSBsO1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDI7IGkrKykge1xyXG5cdFx0XHRcdG0gPSBsYXllcnNBcnJheTJbaV07XHJcblxyXG5cdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkyKTtcclxuXHRcdFx0XHRcdGwyID0gbGF5ZXJzQXJyYXkyLmxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fdW5zcGlkZXJmeUxheWVyKG0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRtID0gbGF5ZXJzQXJyYXlbaV07XHJcblxyXG5cdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cclxuXHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xyXG5cdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xyXG5cdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xyXG5cdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghbS5fX3BhcmVudCkge1xyXG5cdFx0XHRcdG5wZy5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywgeyBsYXllcjogbSB9KTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobSwgdHJ1ZSwgdHJ1ZSk7XHJcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xyXG5cclxuXHRcdFx0aWYgKGZnLmhhc0xheWVyKG0pKSB7XHJcblx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0Ly9GaXggdXAgdGhlIGNsdXN0ZXJzIGFuZCBtYXJrZXJzIG9uIHRoZSBtYXBcclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly9SZW1vdmVzIGFsbCBsYXllcnMgZnJvbSB0aGUgTWFya2VyQ2x1c3Rlckdyb3VwXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vTmVlZCBvdXIgb3duIHNwZWNpYWwgaW1wbGVtZW50YXRpb24gYXMgdGhlIExheWVyR3JvdXAgb25lIGRvZXNuJ3Qgd29yayBmb3IgdXNcclxuXHJcblx0XHQvL0lmIHdlIGFyZW4ndCBvbiB0aGUgbWFwICh5ZXQpLCBibG93IGF3YXkgdGhlIG1hcmtlcnMgd2Uga25vdyBvZlxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nID0gW107XHJcblx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2dyaWRDbHVzdGVycztcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2dyaWRVbmNsdXN0ZXJlZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KSB7XHJcblx0XHRcdHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vUmVtb3ZlIGFsbCB0aGUgdmlzaWJsZSBsYXllcnNcclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5jbGVhckxheWVycygpO1xyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5jbGVhckxheWVycygpO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChtYXJrZXIpIHtcclxuXHRcdFx0bWFya2VyLm9mZih0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMsIHRoaXMpO1xyXG5cdFx0XHRkZWxldGUgbWFya2VyLl9fcGFyZW50O1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHQvL1Jlc2V0IF90b3BDbHVzdGVyTGV2ZWwgYW5kIHRoZSBEaXN0YW5jZUdyaWRzXHJcblx0XHRcdHRoaXMuX2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZSBGZWF0dXJlR3JvdXAuZ2V0Qm91bmRzIGFzIGl0IGRvZXNuJ3Qgd29ya1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl90b3BDbHVzdGVyTGV2ZWwpIHtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZCh0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX2JvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX25lZWRzQ2x1c3RlcmluZ1tpXS5nZXRMYXRMbmcoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ym91bmRzLmV4dGVuZCh0aGlzLl9ub25Qb2ludEdyb3VwLmdldEJvdW5kcygpKTtcclxuXHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGVzIExheWVyR3JvdXAuZWFjaExheWVyXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbWFya2VycyA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZy5zbGljZSgpLFxyXG5cdFx0XHRuZWVkc1JlbW92aW5nID0gdGhpcy5fbmVlZHNSZW1vdmluZyxcclxuXHRcdFx0dGhpc05lZWRzUmVtb3ZpbmcsIGksIGo7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3RvcENsdXN0ZXJMZXZlbCkge1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuZ2V0QWxsQ2hpbGRNYXJrZXJzKG1hcmtlcnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IG1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0dGhpc05lZWRzUmVtb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdFx0Zm9yIChqID0gbmVlZHNSZW1vdmluZy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG5cdFx0XHRcdGlmIChuZWVkc1JlbW92aW5nW2pdLmxheWVyID09PSBtYXJrZXJzW2ldKSB7XHJcblx0XHRcdFx0XHR0aGlzTmVlZHNSZW1vdmluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpc05lZWRzUmVtb3ZpbmcpIHtcclxuXHRcdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCBtYXJrZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX25vblBvaW50R3JvdXAuZWFjaExheWVyKG1ldGhvZCwgY29udGV4dCk7XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZXMgTGF5ZXJHcm91cC5nZXRMYXllcnNcclxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsKSB7XHJcblx0XHRcdGxheWVycy5wdXNoKGwpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGVzIExheWVyR3JvdXAuZ2V0TGF5ZXIsIFdBUk5JTkc6IFJlYWxseSBiYWQgcGVyZm9ybWFuY2VcclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gbnVsbDtcclxuXHJcblx0XHRpZCA9IHBhcnNlSW50KGlkLCAxMCk7XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGwpIHtcclxuXHRcdFx0aWYgKEwuc3RhbXAobCkgPT09IGlkKSB7XHJcblx0XHRcdFx0cmVzdWx0ID0gbDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9LFxyXG5cclxuXHQvL1JldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgaW4gdGhpcyBNYXJrZXJDbHVzdGVyR3JvdXBcclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIWxheWVyKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaSwgYW5BcnJheSA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcclxuXHJcblx0XHRmb3IgKGkgPSBhbkFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmIChhbkFycmF5W2ldID09PSBsYXllcikge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0YW5BcnJheSA9IHRoaXMuX25lZWRzUmVtb3Zpbmc7XHJcblx0XHRmb3IgKGkgPSBhbkFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmIChhbkFycmF5W2ldLmxheWVyID09PSBsYXllcikge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAhIShsYXllci5fX3BhcmVudCAmJiBsYXllci5fX3BhcmVudC5fZ3JvdXAgPT09IHRoaXMpIHx8IHRoaXMuX25vblBvaW50R3JvdXAuaGFzTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vWm9vbSBkb3duIHRvIHNob3cgdGhlIGdpdmVuIGxheWVyIChzcGlkZXJmeWluZyBpZiBuZWNlc3NhcnkpIHRoZW4gY2FsbHMgdGhlIGNhbGxiYWNrXHJcblx0em9vbVRvU2hvd0xheWVyOiBmdW5jdGlvbiAobGF5ZXIsIGNhbGxiYWNrKSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaG93TWFya2VyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoKGxheWVyLl9pY29uIHx8IGxheWVyLl9fcGFyZW50Ll9pY29uKSAmJiAhdGhpcy5faW5ab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLm9mZignbW92ZWVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xyXG5cdFx0XHRcdHRoaXMub2ZmKCdhbmltYXRpb25lbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcclxuXHJcblx0XHRcdFx0aWYgKGxheWVyLl9pY29uKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobGF5ZXIuX19wYXJlbnQuX2ljb24pIHtcclxuXHRcdFx0XHRcdHRoaXMub25jZSgnc3BpZGVyZmllZCcsIGNhbGxiYWNrLCB0aGlzKTtcclxuXHRcdFx0XHRcdGxheWVyLl9fcGFyZW50LnNwaWRlcmZ5KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChsYXllci5faWNvbiAmJiB0aGlzLl9tYXAuZ2V0Qm91bmRzKCkuY29udGFpbnMobGF5ZXIuZ2V0TGF0TG5nKCkpKSB7XHJcblx0XHRcdC8vTGF5ZXIgaXMgdmlzaWJsZSBvbmQgb24gc2NyZWVuLCBpbW1lZGlhdGUgcmV0dXJuXHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9IGVsc2UgaWYgKGxheWVyLl9fcGFyZW50Ll96b29tIDwgTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pKSB7XHJcblx0XHRcdC8vTGF5ZXIgc2hvdWxkIGJlIHZpc2libGUgYXQgdGhpcyB6b29tIGxldmVsLiBJdCBtdXN0IG5vdCBiZSBvbiBzY3JlZW4gc28ganVzdCBwYW4gb3ZlciB0byBpdFxyXG5cdFx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5fbWFwLnBhblRvKGxheWVyLmdldExhdExuZygpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLm9uKCdhbmltYXRpb25lbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcclxuXHRcdFx0bGF5ZXIuX19wYXJlbnQuem9vbVRvQm91bmRzKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZXMgRmVhdHVyZUdyb3VwLm9uQWRkXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdHZhciBpLCBsLCBsYXllcjtcclxuXHJcblx0XHRpZiAoIWlzRmluaXRlKHRoaXMuX21hcC5nZXRNYXhab29tKCkpKSB7XHJcblx0XHRcdHRocm93IFwiTWFwIGhhcyBubyBtYXhab29tIHNwZWNpZmllZFwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5hZGRUbyhtYXApO1xyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5hZGRUbyhtYXApO1xyXG5cclxuXHRcdGlmICghdGhpcy5fZ3JpZENsdXN0ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWF4TGF0ID0gbWFwLm9wdGlvbnMuY3JzLnByb2plY3Rpb24uTUFYX0xBVElUVURFO1xyXG5cclxuXHRcdC8vUmVzdG9yZSBhbGwgdGhlIHBvc2l0aW9ucyBhcyB0aGV5IGFyZSBpbiB0aGUgTUNHIGJlZm9yZSByZW1vdmluZyB0aGVtXHJcblx0XHRmb3IgKGkgPSAwLCBsID0gdGhpcy5fbmVlZHNSZW1vdmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9uZWVkc1JlbW92aW5nW2ldO1xyXG5cdFx0XHRsYXllci5uZXdsYXRsbmcgPSBsYXllci5sYXllci5fbGF0bG5nO1xyXG5cdFx0XHRsYXllci5sYXllci5fbGF0bG5nID0gbGF5ZXIubGF0bG5nO1xyXG5cdFx0fVxyXG5cdFx0Ly9SZW1vdmUgdGhlbSwgdGhlbiByZXN0b3JlIHRoZWlyIG5ldyBwb3NpdGlvbnNcclxuXHRcdGZvciAoaSA9IDAsIGwgPSB0aGlzLl9uZWVkc1JlbW92aW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX25lZWRzUmVtb3ZpbmdbaV07XHJcblx0XHRcdHRoaXMuX3JlbW92ZUxheWVyKGxheWVyLmxheWVyLCB0cnVlKTtcclxuXHRcdFx0bGF5ZXIubGF5ZXIuX2xhdGxuZyA9IGxheWVyLm5ld2xhdGxuZztcclxuXHRcdH1cclxuXHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTtcclxuXHJcblx0XHQvL1JlbWVtYmVyIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgYW5kIGJvdW5kc1xyXG5cdFx0dGhpcy5fem9vbSA9IE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKTtcclxuXHRcdHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX21hcC5vbignem9vbWVuZCcsIHRoaXMuX3pvb21FbmQsIHRoaXMpO1xyXG5cdFx0dGhpcy5fbWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5fbW92ZUVuZCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NwaWRlcmZpZXJPbkFkZCkgeyAvL1RPRE8gRklYTUU6IE5vdCBzdXJlIGhvdyB0byBoYXZlIHNwaWRlcmZpZXIgYWRkIHNvbWV0aGluZyBvbiBoZXJlIG5pY2VseVxyXG5cdFx0XHR0aGlzLl9zcGlkZXJmaWVyT25BZGQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iaW5kRXZlbnRzKCk7XHJcblxyXG5cdFx0Ly9BY3R1YWxseSBhZGQgb3VyIG1hcmtlcnMgdG8gdGhlIG1hcDpcclxuXHRcdGwgPSB0aGlzLl9uZWVkc0NsdXN0ZXJpbmc7XHJcblx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcgPSBbXTtcclxuXHRcdHRoaXMuYWRkTGF5ZXJzKGwsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGVzIEZlYXR1cmVHcm91cC5vblJlbW92ZVxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fem9vbUVuZCwgdGhpcyk7XHJcblx0XHRtYXAub2ZmKCdtb3ZlZW5kJywgdGhpcy5fbW92ZUVuZCwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fdW5iaW5kRXZlbnRzKCk7XHJcblxyXG5cdFx0Ly9JbiBjYXNlIHdlIGFyZSBpbiBhIGNsdXN0ZXIgYW5pbWF0aW9uXHJcblx0XHR0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lID0gdGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZS5yZXBsYWNlKCcgbGVhZmxldC1jbHVzdGVyLWFuaW0nLCAnJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NwaWRlcmZpZXJPblJlbW92ZSkgeyAvL1RPRE8gRklYTUU6IE5vdCBzdXJlIGhvdyB0byBoYXZlIHNwaWRlcmZpZXIgYWRkIHNvbWV0aGluZyBvbiBoZXJlIG5pY2VseVxyXG5cdFx0XHR0aGlzLl9zcGlkZXJmaWVyT25SZW1vdmUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgdGhpcy5fbWF4TGF0O1xyXG5cclxuXHRcdC8vQ2xlYW4gdXAgYWxsIHRoZSBsYXllcnMgd2UgYWRkZWQgdG8gdGhlIG1hcFxyXG5cdFx0dGhpcy5faGlkZUNvdmVyYWdlKCk7XHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlKCk7XHJcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLnJlbW92ZSgpO1xyXG5cclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5jbGVhckxheWVycygpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0Z2V0VmlzaWJsZVBhcmVudDogZnVuY3Rpb24gKG1hcmtlcikge1xyXG5cdFx0dmFyIHZNYXJrZXIgPSBtYXJrZXI7XHJcblx0XHR3aGlsZSAodk1hcmtlciAmJiAhdk1hcmtlci5faWNvbikge1xyXG5cdFx0XHR2TWFya2VyID0gdk1hcmtlci5fX3BhcmVudDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB2TWFya2VyIHx8IG51bGw7XHJcblx0fSxcclxuXHJcblx0Ly9SZW1vdmUgdGhlIGdpdmVuIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheVxyXG5cdF9hcnJheVNwbGljZTogZnVuY3Rpb24gKGFuQXJyYXksIG9iaikge1xyXG5cdFx0Zm9yICh2YXIgaSA9IGFuQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYgKGFuQXJyYXlbaV0gPT09IG9iaikge1xyXG5cdFx0XHRcdGFuQXJyYXkuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhIG1hcmtlciBmcm9tIGFsbCBfZ3JpZFVuY2x1c3RlcmVkIHpvb20gbGV2ZWxzLCBzdGFydGluZyBhdCB0aGUgc3VwcGxpZWQgem9vbS5cclxuXHQgKiBAcGFyYW0gbWFya2VyIHRvIGJlIHJlbW92ZWQgZnJvbSBfZ3JpZFVuY2x1c3RlcmVkLlxyXG5cdCAqIEBwYXJhbSB6IGludGVnZXIgYm90dG9tIHN0YXJ0IHpvb20gbGV2ZWwgKGluY2x1ZGVkKVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQ6IGZ1bmN0aW9uIChtYXJrZXIsIHopIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgZ3JpZFVuY2x1c3RlcmVkID0gdGhpcy5fZ3JpZFVuY2x1c3RlcmVkLFxyXG5cdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKTtcclxuXHJcblx0XHRmb3IgKDsgeiA+PSBtaW5ab29tOyB6LS0pIHtcclxuXHRcdFx0aWYgKCFncmlkVW5jbHVzdGVyZWRbel0ucmVtb3ZlT2JqZWN0KG1hcmtlciwgbWFwLnByb2plY3QobWFya2VyLmdldExhdExuZygpLCB6KSkpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGlsZE1hcmtlckRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0ID0gZS50YXJnZXQuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHRfY2hpbGRNYXJrZXJNb3ZlZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faWdub3JlTW92ZSAmJiAhZS50YXJnZXQuX19kcmFnU3RhcnQpIHtcclxuXHRcdFx0dmFyIGlzUG9wdXBPcGVuID0gZS50YXJnZXQuX3BvcHVwICYmIGUudGFyZ2V0Ll9wb3B1cC5pc09wZW4oKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVDaGlsZChlLnRhcmdldCwgZS5vbGRMYXRMbmcsIGUubGF0bG5nKTtcclxuXHJcblx0XHRcdGlmIChpc1BvcHVwT3Blbikge1xyXG5cdFx0XHRcdGUudGFyZ2V0Lm9wZW5Qb3B1cCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVDaGlsZDogZnVuY3Rpb24gKGxheWVyLCBmcm9tLCB0bykge1xyXG5cdFx0bGF5ZXIuX2xhdGxuZyA9IGZyb207XHJcblx0XHR0aGlzLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHJcblx0XHRsYXllci5fbGF0bG5nID0gdG87XHJcblx0XHR0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHRfY2hpbGRNYXJrZXJEcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIGRyYWdTdGFydCA9IGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0O1xyXG5cdFx0ZGVsZXRlIGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0O1xyXG5cdFx0aWYgKGRyYWdTdGFydCkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlQ2hpbGQoZS50YXJnZXQsIGRyYWdTdGFydCwgZS50YXJnZXQuX2xhdGxuZyk7XHJcblx0XHR9XHRcdFxyXG5cdH0sXHJcblxyXG5cclxuXHQvL0ludGVybmFsIGZ1bmN0aW9uIGZvciByZW1vdmluZyBhIG1hcmtlciBmcm9tIGV2ZXJ5dGhpbmcuXHJcblx0Ly9kb250VXBkYXRlTWFwOiBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2lsbCBoYW5kbGUgdXBkYXRpbmcgdGhlIG1hcCBtYW51YWxseSAoZm9yIGJ1bGsgZnVuY3Rpb25zKVxyXG5cdF9yZW1vdmVMYXllcjogZnVuY3Rpb24gKG1hcmtlciwgcmVtb3ZlRnJvbURpc3RhbmNlR3JpZCwgZG9udFVwZGF0ZU1hcCkge1xyXG5cdFx0dmFyIGdyaWRDbHVzdGVycyA9IHRoaXMuX2dyaWRDbHVzdGVycyxcclxuXHRcdFx0Z3JpZFVuY2x1c3RlcmVkID0gdGhpcy5fZ3JpZFVuY2x1c3RlcmVkLFxyXG5cdFx0XHRmZyA9IHRoaXMuX2ZlYXR1cmVHcm91cCxcclxuXHRcdFx0bWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKTtcclxuXHJcblx0XHQvL1JlbW92ZSB0aGUgbWFya2VyIGZyb20gZGlzdGFuY2UgY2x1c3RlcnMgaXQgbWlnaHQgYmUgaW5cclxuXHRcdGlmIChyZW1vdmVGcm9tRGlzdGFuY2VHcmlkKSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQobWFya2VyLCB0aGlzLl9tYXhab29tKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1dvcmsgb3VyIHdheSB1cCB0aGUgY2x1c3RlcnMgcmVtb3ZpbmcgdGhlbSBhcyB3ZSBnbyBpZiByZXF1aXJlZFxyXG5cdFx0dmFyIGNsdXN0ZXIgPSBtYXJrZXIuX19wYXJlbnQsXHJcblx0XHRcdG1hcmtlcnMgPSBjbHVzdGVyLl9tYXJrZXJzLFxyXG5cdFx0XHRvdGhlck1hcmtlcjtcclxuXHJcblx0XHQvL1JlbW92ZSB0aGUgbWFya2VyIGZyb20gdGhlIGltbWVkaWF0ZSBwYXJlbnRzIG1hcmtlciBsaXN0XHJcblx0XHR0aGlzLl9hcnJheVNwbGljZShtYXJrZXJzLCBtYXJrZXIpO1xyXG5cclxuXHRcdHdoaWxlIChjbHVzdGVyKSB7XHJcblx0XHRcdGNsdXN0ZXIuX2NoaWxkQ291bnQtLTtcclxuXHRcdFx0Y2x1c3Rlci5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAoY2x1c3Rlci5fem9vbSA8IG1pblpvb20pIHtcclxuXHRcdFx0XHQvL1RvcCBsZXZlbCwgZG8gbm90aGluZ1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHJlbW92ZUZyb21EaXN0YW5jZUdyaWQgJiYgY2x1c3Rlci5fY2hpbGRDb3VudCA8PSAxKSB7IC8vQ2x1c3RlciBubyBsb25nZXIgcmVxdWlyZWRcclxuXHRcdFx0XHQvL1dlIG5lZWQgdG8gcHVzaCB0aGUgb3RoZXIgbWFya2VyIHVwIHRvIHRoZSBwYXJlbnRcclxuXHRcdFx0XHRvdGhlck1hcmtlciA9IGNsdXN0ZXIuX21hcmtlcnNbMF0gPT09IG1hcmtlciA/IGNsdXN0ZXIuX21hcmtlcnNbMV0gOiBjbHVzdGVyLl9tYXJrZXJzWzBdO1xyXG5cclxuXHRcdFx0XHQvL1VwZGF0ZSBkaXN0YW5jZSBncmlkXHJcblx0XHRcdFx0Z3JpZENsdXN0ZXJzW2NsdXN0ZXIuX3pvb21dLnJlbW92ZU9iamVjdChjbHVzdGVyLCBtYXAucHJvamVjdChjbHVzdGVyLl9jTGF0TG5nLCBjbHVzdGVyLl96b29tKSk7XHJcblx0XHRcdFx0Z3JpZFVuY2x1c3RlcmVkW2NsdXN0ZXIuX3pvb21dLmFkZE9iamVjdChvdGhlck1hcmtlciwgbWFwLnByb2plY3Qob3RoZXJNYXJrZXIuZ2V0TGF0TG5nKCksIGNsdXN0ZXIuX3pvb20pKTtcclxuXHJcblx0XHRcdFx0Ly9Nb3ZlIG90aGVyTWFya2VyIHVwIHRvIHBhcmVudFxyXG5cdFx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKGNsdXN0ZXIuX19wYXJlbnQuX2NoaWxkQ2x1c3RlcnMsIGNsdXN0ZXIpO1xyXG5cdFx0XHRcdGNsdXN0ZXIuX19wYXJlbnQuX21hcmtlcnMucHVzaChvdGhlck1hcmtlcik7XHJcblx0XHRcdFx0b3RoZXJNYXJrZXIuX19wYXJlbnQgPSBjbHVzdGVyLl9fcGFyZW50O1xyXG5cclxuXHRcdFx0XHRpZiAoY2x1c3Rlci5faWNvbikge1xyXG5cdFx0XHRcdFx0Ly9DbHVzdGVyIGlzIGN1cnJlbnRseSBvbiB0aGUgbWFwLCBuZWVkIHRvIHB1dCB0aGUgbWFya2VyIG9uIHRoZSBtYXAgaW5zdGVhZFxyXG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIoY2x1c3Rlcik7XHJcblx0XHRcdFx0XHRpZiAoIWRvbnRVcGRhdGVNYXApIHtcclxuXHRcdFx0XHRcdFx0ZmcuYWRkTGF5ZXIob3RoZXJNYXJrZXIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjbHVzdGVyLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjbHVzdGVyID0gY2x1c3Rlci5fX3BhcmVudDtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgbWFya2VyLl9fcGFyZW50O1xyXG5cdH0sXHJcblxyXG5cdF9pc09ySXNQYXJlbnQ6IGZ1bmN0aW9uIChlbCwgb2VsKSB7XHJcblx0XHR3aGlsZSAob2VsKSB7XHJcblx0XHRcdGlmIChlbCA9PT0gb2VsKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0b2VsID0gb2VsLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZSBMLkV2ZW50ZWQuZmlyZVxyXG5cdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmIChkYXRhICYmIGRhdGEubGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpIHtcclxuXHRcdFx0Ly9QcmV2ZW50IG11bHRpcGxlIGNsdXN0ZXJtb3VzZW92ZXIvb2ZmIGV2ZW50cyBpZiB0aGUgaWNvbiBpcyBtYWRlIHVwIG9mIHN0YWNrZWQgZGl2cyAoRG9lc24ndCB3b3JrIGluIGllIDw9IDgsIG5vIHJlbGF0ZWRUYXJnZXQpXHJcblx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQgJiYgdGhpcy5faXNPcklzUGFyZW50KGRhdGEubGF5ZXIuX2ljb24sIGRhdGEub3JpZ2luYWxFdmVudC5yZWxhdGVkVGFyZ2V0KSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0eXBlID0gJ2NsdXN0ZXInICsgdHlwZTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkZlYXR1cmVHcm91cC5wcm90b3R5cGUuZmlyZS5jYWxsKHRoaXMsIHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSk7XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZSBMLkV2ZW50ZWQubGlzdGVuc1xyXG5cdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBwcm9wYWdhdGUpIHtcclxuXHRcdHJldHVybiBMLkZlYXR1cmVHcm91cC5wcm90b3R5cGUubGlzdGVucy5jYWxsKHRoaXMsIHR5cGUsIHByb3BhZ2F0ZSkgfHwgTC5GZWF0dXJlR3JvdXAucHJvdG90eXBlLmxpc3RlbnMuY2FsbCh0aGlzLCAnY2x1c3RlcicgKyB0eXBlLCBwcm9wYWdhdGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vRGVmYXVsdCBmdW5jdGlvbmFsaXR5XHJcblx0X2RlZmF1bHRJY29uQ3JlYXRlRnVuY3Rpb246IGZ1bmN0aW9uIChjbHVzdGVyKSB7XHJcblx0XHR2YXIgY2hpbGRDb3VudCA9IGNsdXN0ZXIuZ2V0Q2hpbGRDb3VudCgpO1xyXG5cclxuXHRcdHZhciBjID0gJyBtYXJrZXItY2x1c3Rlci0nO1xyXG5cdFx0aWYgKGNoaWxkQ291bnQgPCAxMCkge1xyXG5cdFx0XHRjICs9ICdzbWFsbCc7XHJcblx0XHR9IGVsc2UgaWYgKGNoaWxkQ291bnQgPCAxMDApIHtcclxuXHRcdFx0YyArPSAnbWVkaXVtJztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGMgKz0gJ2xhcmdlJztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuRGl2SWNvbih7IGh0bWw6ICc8ZGl2PjxzcGFuPicgKyBjaGlsZENvdW50ICsgJzwvc3Bhbj48L2Rpdj4nLCBjbGFzc05hbWU6ICdtYXJrZXItY2x1c3RlcicgKyBjLCBpY29uU2l6ZTogbmV3IEwuUG9pbnQoNDAsIDQwKSB9KTtcclxuXHR9LFxyXG5cclxuXHRfYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBzcGlkZXJmeU9uTWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uTWF4Wm9vbSxcclxuXHRcdCAgICBzaG93Q292ZXJhZ2VPbkhvdmVyID0gdGhpcy5vcHRpb25zLnNob3dDb3ZlcmFnZU9uSG92ZXIsXHJcblx0XHQgICAgem9vbVRvQm91bmRzT25DbGljayA9IHRoaXMub3B0aW9ucy56b29tVG9Cb3VuZHNPbkNsaWNrO1xyXG5cclxuXHRcdC8vWm9vbSBvbiBjbHVzdGVyIGNsaWNrIG9yIHNwaWRlcmZ5IGlmIHdlIGFyZSBhdCB0aGUgbG93ZXN0IGxldmVsXHJcblx0XHRpZiAoc3BpZGVyZnlPbk1heFpvb20gfHwgem9vbVRvQm91bmRzT25DbGljaykge1xyXG5cdFx0XHR0aGlzLm9uKCdjbHVzdGVyY2xpY2snLCB0aGlzLl96b29tT3JTcGlkZXJmeSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9TaG93IGNvbnZleCBodWxsIChib3VuZGFyeSkgcG9seWdvbiBvbiBtb3VzZSBvdmVyXHJcblx0XHRpZiAoc2hvd0NvdmVyYWdlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9uKCdjbHVzdGVybW91c2VvdmVyJywgdGhpcy5fc2hvd0NvdmVyYWdlLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5vbignY2x1c3Rlcm1vdXNlb3V0JywgdGhpcy5faGlkZUNvdmVyYWdlLCB0aGlzKTtcclxuXHRcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5faGlkZUNvdmVyYWdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU9yU3BpZGVyZnk6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgY2x1c3RlciA9IGUubGF5ZXIsXHJcblx0XHQgICAgYm90dG9tQ2x1c3RlciA9IGNsdXN0ZXI7XHJcblxyXG5cdFx0d2hpbGUgKGJvdHRvbUNsdXN0ZXIuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdGJvdHRvbUNsdXN0ZXIgPSBib3R0b21DbHVzdGVyLl9jaGlsZENsdXN0ZXJzWzBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChib3R0b21DbHVzdGVyLl96b29tID09PSB0aGlzLl9tYXhab29tICYmXHJcblx0XHRcdGJvdHRvbUNsdXN0ZXIuX2NoaWxkQ291bnQgPT09IGNsdXN0ZXIuX2NoaWxkQ291bnQgJiZcclxuXHRcdFx0dGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tKSB7XHJcblxyXG5cdFx0XHQvLyBBbGwgY2hpbGQgbWFya2VycyBhcmUgY29udGFpbmVkIGluIGEgc2luZ2xlIGNsdXN0ZXIgZnJvbSB0aGlzLl9tYXhab29tIHRvIHRoaXMgY2x1c3Rlci5cclxuXHRcdFx0Y2x1c3Rlci5zcGlkZXJmeSgpO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuem9vbVRvQm91bmRzT25DbGljaykge1xyXG5cdFx0XHRjbHVzdGVyLnpvb21Ub0JvdW5kcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZvY3VzIHRoZSBtYXAgYWdhaW4gZm9yIGtleWJvYXJkIHVzZXJzLlxyXG5cdFx0aWYgKGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfc2hvd0NvdmVyYWdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHRcdGlmICh0aGlzLl9pblpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3Nob3duUG9seWdvbikge1xyXG5cdFx0XHRtYXAucmVtb3ZlTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcclxuXHRcdH1cclxuXHRcdGlmIChlLmxheWVyLmdldENoaWxkQ291bnQoKSA+IDIgJiYgZS5sYXllciAhPT0gdGhpcy5fc3BpZGVyZmllZCkge1xyXG5cdFx0XHR0aGlzLl9zaG93blBvbHlnb24gPSBuZXcgTC5Qb2x5Z29uKGUubGF5ZXIuZ2V0Q29udmV4SHVsbCgpLCB0aGlzLm9wdGlvbnMucG9seWdvbk9wdGlvbnMpO1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaGlkZUNvdmVyYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hvd25Qb2x5Z29uKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9zaG93blBvbHlnb24pO1xyXG5cdFx0XHR0aGlzLl9zaG93blBvbHlnb24gPSBudWxsO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91bmJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzcGlkZXJmeU9uTWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uTWF4Wm9vbSxcclxuXHRcdFx0c2hvd0NvdmVyYWdlT25Ib3ZlciA9IHRoaXMub3B0aW9ucy5zaG93Q292ZXJhZ2VPbkhvdmVyLFxyXG5cdFx0XHR6b29tVG9Cb3VuZHNPbkNsaWNrID0gdGhpcy5vcHRpb25zLnpvb21Ub0JvdW5kc09uQ2xpY2ssXHJcblx0XHRcdG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAoc3BpZGVyZnlPbk1heFpvb20gfHwgem9vbVRvQm91bmRzT25DbGljaykge1xyXG5cdFx0XHR0aGlzLm9mZignY2x1c3RlcmNsaWNrJywgdGhpcy5fem9vbU9yU3BpZGVyZnksIHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHNob3dDb3ZlcmFnZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoJ2NsdXN0ZXJtb3VzZW92ZXInLCB0aGlzLl9zaG93Q292ZXJhZ2UsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLm9mZignY2x1c3Rlcm1vdXNlb3V0JywgdGhpcy5faGlkZUNvdmVyYWdlLCB0aGlzKTtcclxuXHRcdFx0bWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IC8vTWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1hcCBieSBhIHpvb21FbmQgaGFuZGxlclxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLl9tZXJnZVNwbGl0Q2x1c3RlcnMoKTtcclxuXHJcblx0XHR0aGlzLl96b29tID0gTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pO1xyXG5cdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCk7XHJcblx0fSxcclxuXHJcblx0X21vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9pblpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdCb3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcclxuXHJcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcywgTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSwgdGhpcy5fem9vbSwgbmV3Qm91bmRzKTtcclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKSwgbmV3Qm91bmRzKTtcclxuXHJcblx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSBuZXdCb3VuZHM7XHJcblx0XHRyZXR1cm47XHJcblx0fSxcclxuXHJcblx0X2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWF4Wm9vbSA9IE1hdGguY2VpbCh0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSxcclxuXHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksXHJcblx0XHRcdHJhZGl1cyA9IHRoaXMub3B0aW9ucy5tYXhDbHVzdGVyUmFkaXVzLFxyXG5cdFx0XHRyYWRpdXNGbiA9IHJhZGl1cztcclxuXHJcblx0XHQvL0lmIHdlIGp1c3Qgc2V0IG1heENsdXN0ZXJSYWRpdXMgdG8gYSBzaW5nbGUgbnVtYmVyLCB3ZSBuZWVkIHRvIGNyZWF0ZVxyXG5cdFx0Ly9hIHNpbXBsZSBmdW5jdGlvbiB0byByZXR1cm4gdGhhdCBudW1iZXIuIE90aGVyd2lzZSwgd2UganVzdCBoYXZlIHRvXHJcblx0XHQvL3VzZSB0aGUgZnVuY3Rpb24gd2UndmUgcGFzc2VkIGluLlxyXG5cdFx0aWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRyYWRpdXNGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhZGl1czsgfTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVDbHVzdGVyaW5nQXRab29tICE9PSBudWxsKSB7XHJcblx0XHRcdG1heFpvb20gPSB0aGlzLm9wdGlvbnMuZGlzYWJsZUNsdXN0ZXJpbmdBdFpvb20gLSAxO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fbWF4Wm9vbSA9IG1heFpvb207XHJcblx0XHR0aGlzLl9ncmlkQ2x1c3RlcnMgPSB7fTtcclxuXHRcdHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCA9IHt9O1xyXG5cclxuXHRcdC8vU2V0IHVwIERpc3RhbmNlR3JpZHMgZm9yIGVhY2ggem9vbVxyXG5cdFx0Zm9yICh2YXIgem9vbSA9IG1heFpvb207IHpvb20gPj0gbWluWm9vbTsgem9vbS0tKSB7XHJcblx0XHRcdHRoaXMuX2dyaWRDbHVzdGVyc1t6b29tXSA9IG5ldyBMLkRpc3RhbmNlR3JpZChyYWRpdXNGbih6b29tKSk7XHJcblx0XHRcdHRoaXMuX2dyaWRVbmNsdXN0ZXJlZFt6b29tXSA9IG5ldyBMLkRpc3RhbmNlR3JpZChyYWRpdXNGbih6b29tKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSW5zdGFudGlhdGUgdGhlIGFwcHJvcHJpYXRlIEwuTWFya2VyQ2x1c3RlciBjbGFzcyAoYW5pbWF0ZWQgb3Igbm90KS5cclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbCA9IG5ldyB0aGlzLl9tYXJrZXJDbHVzdGVyKHRoaXMsIG1pblpvb20gLSAxKTtcclxuXHR9LFxyXG5cclxuXHQvL1pvb206IFpvb20gdG8gc3RhcnQgYWRkaW5nIGF0IChQYXNzIHRoaXMuX21heFpvb20gdG8gc3RhcnQgYXQgdGhlIGJvdHRvbSlcclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgem9vbSkge1xyXG5cdFx0dmFyIGdyaWRDbHVzdGVycyA9IHRoaXMuX2dyaWRDbHVzdGVycyxcclxuXHRcdCAgICBncmlkVW5jbHVzdGVyZWQgPSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQsXHJcblx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLFxyXG5cdFx0ICAgIG1hcmtlclBvaW50LCB6O1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc2luZ2xlTWFya2VyTW9kZSkge1xyXG5cdFx0XHR0aGlzLl9vdmVycmlkZU1hcmtlckljb24obGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLm9uKHRoaXMuX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycywgdGhpcyk7XHJcblxyXG5cdFx0Ly9GaW5kIHRoZSBsb3dlc3Qgem9vbSBsZXZlbCB0byBzbG90IHRoaXMgb25lIGluXHJcblx0XHRmb3IgKDsgem9vbSA+PSBtaW5ab29tOyB6b29tLS0pIHtcclxuXHRcdFx0bWFya2VyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChsYXllci5nZXRMYXRMbmcoKSwgem9vbSk7IC8vIGNhbGN1bGF0ZSBwaXhlbCBwb3NpdGlvblxyXG5cclxuXHRcdFx0Ly9UcnkgZmluZCBhIGNsdXN0ZXIgY2xvc2UgYnlcclxuXHRcdFx0dmFyIGNsb3Nlc3QgPSBncmlkQ2x1c3RlcnNbem9vbV0uZ2V0TmVhck9iamVjdChtYXJrZXJQb2ludCk7XHJcblx0XHRcdGlmIChjbG9zZXN0KSB7XHJcblx0XHRcdFx0Y2xvc2VzdC5fYWRkQ2hpbGQobGF5ZXIpO1xyXG5cdFx0XHRcdGxheWVyLl9fcGFyZW50ID0gY2xvc2VzdDtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vVHJ5IGZpbmQgYSBtYXJrZXIgY2xvc2UgYnkgdG8gZm9ybSBhIG5ldyBjbHVzdGVyIHdpdGhcclxuXHRcdFx0Y2xvc2VzdCA9IGdyaWRVbmNsdXN0ZXJlZFt6b29tXS5nZXROZWFyT2JqZWN0KG1hcmtlclBvaW50KTtcclxuXHRcdFx0aWYgKGNsb3Nlc3QpIHtcclxuXHRcdFx0XHR2YXIgcGFyZW50ID0gY2xvc2VzdC5fX3BhcmVudDtcclxuXHRcdFx0XHRpZiAocGFyZW50KSB7XHJcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVMYXllcihjbG9zZXN0LCBmYWxzZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL0NyZWF0ZSBuZXcgY2x1c3RlciB3aXRoIHRoZXNlIDIgaW4gaXRcclxuXHJcblx0XHRcdFx0dmFyIG5ld0NsdXN0ZXIgPSBuZXcgdGhpcy5fbWFya2VyQ2x1c3Rlcih0aGlzLCB6b29tLCBjbG9zZXN0LCBsYXllcik7XHJcblx0XHRcdFx0Z3JpZENsdXN0ZXJzW3pvb21dLmFkZE9iamVjdChuZXdDbHVzdGVyLCB0aGlzLl9tYXAucHJvamVjdChuZXdDbHVzdGVyLl9jTGF0TG5nLCB6b29tKSk7XHJcblx0XHRcdFx0Y2xvc2VzdC5fX3BhcmVudCA9IG5ld0NsdXN0ZXI7XHJcblx0XHRcdFx0bGF5ZXIuX19wYXJlbnQgPSBuZXdDbHVzdGVyO1xyXG5cclxuXHRcdFx0XHQvL0ZpcnN0IGNyZWF0ZSBhbnkgbmV3IGludGVybWVkaWF0ZSBwYXJlbnQgY2x1c3RlcnMgdGhhdCBkb24ndCBleGlzdFxyXG5cdFx0XHRcdHZhciBsYXN0UGFyZW50ID0gbmV3Q2x1c3RlcjtcclxuXHRcdFx0XHRmb3IgKHogPSB6b29tIC0gMTsgeiA+IHBhcmVudC5fem9vbTsgei0tKSB7XHJcblx0XHRcdFx0XHRsYXN0UGFyZW50ID0gbmV3IHRoaXMuX21hcmtlckNsdXN0ZXIodGhpcywgeiwgbGFzdFBhcmVudCk7XHJcblx0XHRcdFx0XHRncmlkQ2x1c3RlcnNbel0uYWRkT2JqZWN0KGxhc3RQYXJlbnQsIHRoaXMuX21hcC5wcm9qZWN0KGNsb3Nlc3QuZ2V0TGF0TG5nKCksIHopKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cGFyZW50Ll9hZGRDaGlsZChsYXN0UGFyZW50KTtcclxuXHJcblx0XHRcdFx0Ly9SZW1vdmUgY2xvc2VzdCBmcm9tIHRoaXMgem9vbSBsZXZlbCBhbmQgYW55IGFib3ZlIHRoYXQgaXQgaXMgaW4sIHJlcGxhY2Ugd2l0aCBuZXdDbHVzdGVyXHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlRnJvbUdyaWRVbmNsdXN0ZXJlZChjbG9zZXN0LCB6b29tKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL0RpZG4ndCBtYW5hZ2UgdG8gY2x1c3RlciBpbiBhdCB0aGlzIHpvb20sIHJlY29yZCB1cyBhcyBhIG1hcmtlciBoZXJlIGFuZCBjb250aW51ZSB1cHdhcmRzXHJcblx0XHRcdGdyaWRVbmNsdXN0ZXJlZFt6b29tXS5hZGRPYmplY3QobGF5ZXIsIG1hcmtlclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHQvL0RpZG4ndCBnZXQgaW4gYW55dGhpbmcsIGFkZCB1cyB0byB0aGUgdG9wXHJcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX2FkZENoaWxkKGxheWVyKTtcclxuXHRcdGxheWVyLl9fcGFyZW50ID0gdGhpcy5fdG9wQ2x1c3RlckxldmVsO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZnJlc2hlcyB0aGUgaWNvbiBvZiBhbGwgXCJkaXJ0eVwiIHZpc2libGUgY2x1c3RlcnMuXHJcblx0ICogTm9uLXZpc2libGUgXCJkaXJ0eVwiIGNsdXN0ZXJzIHdpbGwgYmUgdXBkYXRlZCB3aGVuIHRoZXkgYXJlIGFkZGVkIHRvIHRoZSBtYXAuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVmcmVzaENsdXN0ZXJzSWNvbnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0aWYgKGMgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIgJiYgYy5faWNvbk5lZWRzVXBkYXRlKSB7XHJcblx0XHRcdFx0Yy5fdXBkYXRlSWNvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvL0VucXVldWUgY29kZSB0byBmaXJlIGFmdGVyIHRoZSBtYXJrZXIgZXhwYW5kL2NvbnRyYWN0IGhhcyBoYXBwZW5lZFxyXG5cdF9lbnF1ZXVlOiBmdW5jdGlvbiAoZm4pIHtcclxuXHRcdHRoaXMuX3F1ZXVlLnB1c2goZm4pO1xyXG5cdFx0aWYgKCF0aGlzLl9xdWV1ZVRpbWVvdXQpIHtcclxuXHRcdFx0dGhpcy5fcXVldWVUaW1lb3V0ID0gc2V0VGltZW91dChMLmJpbmQodGhpcy5fcHJvY2Vzc1F1ZXVlLCB0aGlzKSwgMzAwKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdF9wcm9jZXNzUXVldWU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcXVldWUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fcXVldWVbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3F1ZXVlLmxlbmd0aCA9IDA7XHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcXVldWVUaW1lb3V0KTtcclxuXHRcdHRoaXMuX3F1ZXVlVGltZW91dCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0Ly9NZXJnZSBhbmQgc3BsaXQgYW55IGV4aXN0aW5nIGNsdXN0ZXJzIHRoYXQgYXJlIHRvbyBiaWcgb3Igc21hbGxcclxuXHRfbWVyZ2VTcGxpdENsdXN0ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwWm9vbSA9IE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKTtcclxuXHJcblx0XHQvL0luIGNhc2Ugd2UgYXJlIHN0YXJ0aW5nIHRvIHNwbGl0IGJlZm9yZSB0aGUgYW5pbWF0aW9uIGZpbmlzaGVkXHJcblx0XHR0aGlzLl9wcm9jZXNzUXVldWUoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbSA8IG1hcFpvb20gJiYgdGhpcy5fY3VycmVudFNob3duQm91bmRzLmludGVyc2VjdHModGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpKSB7IC8vWm9vbSBpbiwgc3BsaXRcclxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uU3RhcnQoKTtcclxuXHRcdFx0Ly9SZW1vdmUgY2x1c3RlcnMgbm93IG9mZiBzY3JlZW5cclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHRoaXMuX3pvb20sIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcclxuXHJcblx0XHRcdHRoaXMuX2FuaW1hdGlvblpvb21Jbih0aGlzLl96b29tLCBtYXBab29tKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHRoaXMuX3pvb20gPiBtYXBab29tKSB7IC8vWm9vbSBvdXQsIG1lcmdlXHJcblx0XHRcdHRoaXMuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblxyXG5cdFx0XHR0aGlzLl9hbmltYXRpb25ab29tT3V0KHRoaXMuX3pvb20sIG1hcFpvb20pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fbW92ZUVuZCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vR2V0cyB0aGUgbWFwcyB2aXNpYmxlIGJvdW5kcyBleHBhbmRlZCBpbiBlYWNoIGRpcmVjdGlvbiBieSB0aGUgc2l6ZSBvZiB0aGUgc2NyZWVuIChzbyB0aGUgdXNlciBjYW5ub3Qgc2VlIGFuIGFyZWEgd2UgZG8gbm90IGNvdmVyIGluIG9uZSBwYW4pXHJcblx0X2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMucmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHMpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX21hcEJvdW5kc0luZmluaXRlO1xyXG5cdFx0fSBlbHNlIGlmIChMLkJyb3dzZXIubW9iaWxlKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9jaGVja0JvdW5kc01heExhdCh0aGlzLl9tYXAuZ2V0Qm91bmRzKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jaGVja0JvdW5kc01heExhdCh0aGlzLl9tYXAuZ2V0Qm91bmRzKCkucGFkKDEpKTsgLy8gUGFkZGluZyBleHBhbmRzIHRoZSBib3VuZHMgYnkgaXRzIG93biBkaW1lbnNpb25zIGJ1dCBzY2FsZWQgd2l0aCB0aGUgZ2l2ZW4gZmFjdG9yLlxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4cGFuZHMgdGhlIGxhdGl0dWRlIHRvIEluZmluaXR5IChvciAtSW5maW5pdHkpIGlmIHRoZSBpbnB1dCBib3VuZHMgcmVhY2ggdGhlIG1hcCBwcm9qZWN0aW9uIG1heGltdW0gZGVmaW5lZCBsYXRpdHVkZVxyXG5cdCAqIChpbiB0aGUgY2FzZSBvZiBXZWIvU3BoZXJpY2FsIE1lcmNhdG9yLCBpdCBpcyA4NS4wNTExMjg3Nzk4IC8gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NZXJjYXRvciNGb3JtdWxhcykuXHJcblx0ICogT3RoZXJ3aXNlLCB0aGUgcmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHMgb3B0aW9uIHdpbGwgcmVtb3ZlIG1hcmtlcnMgYmV5b25kIHRoYXQgbGltaXQsIHdoZXJlYXMgdGhlIHNhbWUgbWFya2VycyB3aXRob3V0XHJcblx0ICogdGhpcyBvcHRpb24gKG9yIG91dHNpZGUgTUNHKSB3aWxsIGhhdmUgdGhlaXIgcG9zaXRpb24gZmxvb3JlZCAoY2VpbGVkKSBieSB0aGUgcHJvamVjdGlvbiBhbmQgcmVuZGVyZWQgYXQgdGhhdCBsaW1pdCxcclxuXHQgKiBtYWtpbmcgdGhlIHVzZXIgdGhpbmsgdGhhdCBNQ0cgXCJlYXRzXCIgdGhlbSBhbmQgbmV2ZXIgZGlzcGxheXMgdGhlbSBhZ2Fpbi5cclxuXHQgKiBAcGFyYW0gYm91bmRzIEwuTGF0TG5nQm91bmRzXHJcblx0ICogQHJldHVybnMge0wuTGF0TG5nQm91bmRzfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2NoZWNrQm91bmRzTWF4TGF0OiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR2YXIgbWF4TGF0ID0gdGhpcy5fbWF4TGF0O1xyXG5cclxuXHRcdGlmIChtYXhMYXQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZiAoYm91bmRzLmdldE5vcnRoKCkgPj0gbWF4TGF0KSB7XHJcblx0XHRcdFx0Ym91bmRzLl9ub3J0aEVhc3QubGF0ID0gSW5maW5pdHk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGJvdW5kcy5nZXRTb3V0aCgpIDw9IC1tYXhMYXQpIHtcclxuXHRcdFx0XHRib3VuZHMuX3NvdXRoV2VzdC5sYXQgPSAtSW5maW5pdHk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vU2hhcmVkIGFuaW1hdGlvbiBjb2RlXHJcblx0X2FuaW1hdGlvbkFkZExheWVyTm9uQW5pbWF0ZWQ6IGZ1bmN0aW9uIChsYXllciwgbmV3Q2x1c3Rlcikge1xyXG5cdFx0aWYgKG5ld0NsdXN0ZXIgPT09IGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9IGVsc2UgaWYgKG5ld0NsdXN0ZXIuX2NoaWxkQ291bnQgPT09IDIpIHtcclxuXHRcdFx0bmV3Q2x1c3Rlci5fYWRkVG9NYXAoKTtcclxuXHJcblx0XHRcdHZhciBtYXJrZXJzID0gbmV3Q2x1c3Rlci5nZXRBbGxDaGlsZE1hcmtlcnMoKTtcclxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKG1hcmtlcnNbMF0pO1xyXG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobWFya2Vyc1sxXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuZXdDbHVzdGVyLl91cGRhdGVJY29uKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRXh0cmFjdHMgaW5kaXZpZHVhbCAoaS5lLiBub24tZ3JvdXApIGxheWVycyBmcm9tIGEgTGF5ZXIgR3JvdXAuXHJcblx0ICogQHBhcmFtIGdyb3VwIHRvIGV4dHJhY3QgbGF5ZXJzIGZyb20uXHJcblx0ICogQHBhcmFtIG91dHB1dCB7QXJyYXl9IGluIHdoaWNoIHRvIHN0b3JlIHRoZSBleHRyYWN0ZWQgbGF5ZXJzLlxyXG5cdCAqIEByZXR1cm5zIHsqfEFycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2V4dHJhY3ROb25Hcm91cExheWVyczogZnVuY3Rpb24gKGdyb3VwLCBvdXRwdXQpIHtcclxuXHRcdHZhciBsYXllcnMgPSBncm91cC5nZXRMYXllcnMoKSxcclxuXHRcdCAgICBpID0gMCxcclxuXHRcdCAgICBsYXllcjtcclxuXHJcblx0XHRvdXRwdXQgPSBvdXRwdXQgfHwgW107XHJcblxyXG5cdFx0Zm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGF5ZXIgPSBsYXllcnNbaV07XHJcblxyXG5cdFx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobGF5ZXIsIG91dHB1dCk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG91dHB1dC5wdXNoKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEltcGxlbWVudHMgdGhlIHNpbmdsZU1hcmtlck1vZGUgb3B0aW9uLlxyXG5cdCAqIEBwYXJhbSBsYXllciBNYXJrZXIgdG8gcmUtc3R5bGUgdXNpbmcgdGhlIENsdXN0ZXJzIGljb25DcmVhdGVGdW5jdGlvbi5cclxuXHQgKiBAcmV0dXJucyB7TC5JY29ufSBUaGUgbmV3bHkgY3JlYXRlZCBpY29uLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X292ZXJyaWRlTWFya2VySWNvbjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWNvbiA9IGxheWVyLm9wdGlvbnMuaWNvbiA9IHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24oe1xyXG5cdFx0XHRnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0cmV0dXJuIDE7XHJcblx0XHRcdH0sXHJcblx0XHRcdGdldEFsbENoaWxkTWFya2VyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHJldHVybiBbbGF5ZXJdO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gaWNvbjtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQ29uc3RhbnQgYm91bmRzIHVzZWQgaW4gY2FzZSBvcHRpb24gXCJyZW1vdmVPdXRzaWRlVmlzaWJsZUJvdW5kc1wiIGlzIHNldCB0byBmYWxzZS5cclxuTC5NYXJrZXJDbHVzdGVyR3JvdXAuaW5jbHVkZSh7XHJcblx0X21hcEJvdW5kc0luZmluaXRlOiBuZXcgTC5MYXRMbmdCb3VuZHMobmV3IEwuTGF0TG5nKC1JbmZpbml0eSwgLUluZmluaXR5KSwgbmV3IEwuTGF0TG5nKEluZmluaXR5LCBJbmZpbml0eSkpXHJcbn0pO1xyXG5cclxuTC5NYXJrZXJDbHVzdGVyR3JvdXAuaW5jbHVkZSh7XHJcblx0X25vQW5pbWF0aW9uOiB7XHJcblx0XHQvL05vbiBBbmltYXRlZCB2ZXJzaW9ucyBvZiBldmVyeXRoaW5nXHJcblx0XHRfYW5pbWF0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly9EbyBub3RoaW5nLi4uXHJcblx0XHR9LFxyXG5cdFx0X2FuaW1hdGlvblpvb21JbjogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHByZXZpb3VzWm9vbUxldmVsKTtcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XHJcblxyXG5cdFx0XHQvL1dlIGRpZG4ndCBhY3R1YWxseSBhbmltYXRlLCBidXQgd2UgdXNlIHRoaXMgZXZlbnQgdG8gbWVhbiBcImNsdXN0ZXJpbmcgYW5pbWF0aW9ucyBoYXZlIGZpbmlzaGVkXCJcclxuXHRcdFx0dGhpcy5maXJlKCdhbmltYXRpb25lbmQnKTtcclxuXHRcdH0sXHJcblx0XHRfYW5pbWF0aW9uWm9vbU91dDogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHByZXZpb3VzWm9vbUxldmVsKTtcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XHJcblxyXG5cdFx0XHQvL1dlIGRpZG4ndCBhY3R1YWxseSBhbmltYXRlLCBidXQgd2UgdXNlIHRoaXMgZXZlbnQgdG8gbWVhbiBcImNsdXN0ZXJpbmcgYW5pbWF0aW9ucyBoYXZlIGZpbmlzaGVkXCJcclxuXHRcdFx0dGhpcy5maXJlKCdhbmltYXRpb25lbmQnKTtcclxuXHRcdH0sXHJcblx0XHRfYW5pbWF0aW9uQWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmV3Q2x1c3Rlcikge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpb25BZGRMYXllck5vbkFuaW1hdGVkKGxheWVyLCBuZXdDbHVzdGVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfd2l0aEFuaW1hdGlvbjoge1xyXG5cdFx0Ly9BbmltYXRlZCB2ZXJzaW9ucyBoZXJlXHJcblx0XHRfYW5pbWF0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZSArPSAnIGxlYWZsZXQtY2x1c3Rlci1hbmltJztcclxuXHRcdFx0dGhpcy5faW5ab29tQW5pbWF0aW9uKys7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9hbmltYXRpb25ab29tSW46IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XHJcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSxcclxuXHRcdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxyXG5cdFx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLFxyXG5cdFx0XHQgICAgaTtcclxuXHJcblx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cclxuXHRcdFx0Ly9BZGQgYWxsIGNoaWxkcmVuIG9mIGN1cnJlbnQgY2x1c3RlcnMgdG8gbWFwIGFuZCByZW1vdmUgdGhvc2UgY2x1c3RlcnMgZnJvbSBtYXBcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCBtaW5ab29tLCBmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdHZhciBzdGFydFBvcyA9IGMuX2xhdGxuZyxcclxuXHRcdFx0XHQgICAgbWFya2VycyAgPSBjLl9tYXJrZXJzLFxyXG5cdFx0XHRcdCAgICBtO1xyXG5cclxuXHRcdFx0XHRpZiAoIWJvdW5kcy5jb250YWlucyhzdGFydFBvcykpIHtcclxuXHRcdFx0XHRcdHN0YXJ0UG9zID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjLl9pc1NpbmdsZVBhcmVudCgpICYmIHByZXZpb3VzWm9vbUxldmVsICsgMSA9PT0gbmV3Wm9vbUxldmVsKSB7IC8vSW1tZWRpYXRlbHkgYWRkIHRoZSBuZXcgY2hpbGQgYW5kIHJlbW92ZSB1c1xyXG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIoYyk7XHJcblx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCBib3VuZHMpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvL0ZhZGUgb3V0IG9sZCBjbHVzdGVyXHJcblx0XHRcdFx0XHRjLmNsdXN0ZXJIaWRlKCk7XHJcblx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAoc3RhcnRQb3MsIG5ld1pvb21MZXZlbCwgYm91bmRzKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vUmVtb3ZlIGFsbCBtYXJrZXJzIHRoYXQgYXJlbid0IHZpc2libGUgYW55IG1vcmVcclxuXHRcdFx0XHQvL1RPRE86IERvIHdlIGFjdHVhbGx5IG5lZWQgdG8gZG8gdGhpcyBvbiB0aGUgaGlnaGVyIGxldmVscyB0b28/XHJcblx0XHRcdFx0Zm9yIChpID0gbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdFx0bSA9IG1hcmtlcnNbaV07XHJcblx0XHRcdFx0XHRpZiAoIWJvdW5kcy5jb250YWlucyhtLl9sYXRsbmcpKSB7XHJcblx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0dGhpcy5fZm9yY2VMYXlvdXQoKTtcclxuXHJcblx0XHRcdC8vVXBkYXRlIG9wYWNpdGllc1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QmVjb21lVmlzaWJsZShib3VuZHMsIG5ld1pvb21MZXZlbCk7XHJcblx0XHRcdC8vVE9ETyBNYXliZT8gVXBkYXRlIG1hcmtlcnMgaW4gX3JlY3Vyc2l2ZWx5QmVjb21lVmlzaWJsZVxyXG5cdFx0XHRmZy5lYWNoTGF5ZXIoZnVuY3Rpb24gKG4pIHtcclxuXHRcdFx0XHRpZiAoIShuIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyKSAmJiBuLl9pY29uKSB7XHJcblx0XHRcdFx0XHRuLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vdXBkYXRlIHRoZSBwb3NpdGlvbnMgb2YgdGhlIGp1c3QgYWRkZWQgY2x1c3RlcnMvbWFya2Vyc1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCwgZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHRjLl9yZWN1cnNpdmVseVJlc3RvcmVDaGlsZFBvc2l0aW9ucyhuZXdab29tTGV2ZWwpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHJcblx0XHRcdC8vUmVtb3ZlIHRoZSBvbGQgY2x1c3RlcnMgYW5kIGNsb3NlIHRoZSB6b29tIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHQvL3VwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIHRoZSBqdXN0IGFkZGVkIGNsdXN0ZXJzL21hcmtlcnNcclxuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG1pblpvb20sIGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihjKTtcclxuXHRcdFx0XHRcdGMuY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uRW5kKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfYW5pbWF0aW9uWm9vbU91dDogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uWm9vbU91dFNpbmdsZSh0aGlzLl90b3BDbHVzdGVyTGV2ZWwsIHByZXZpb3VzWm9vbUxldmVsIC0gMSwgbmV3Wm9vbUxldmVsKTtcclxuXHJcblx0XHRcdC8vTmVlZCB0byBhZGQgbWFya2VycyBmb3IgdGhvc2UgdGhhdCB3ZXJlbid0IG9uIHRoZSBtYXAgYmVmb3JlIGJ1dCBhcmUgbm93XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xyXG5cdFx0XHQvL1JlbW92ZSBtYXJrZXJzIHRoYXQgd2VyZSBvbiB0aGUgbWFwIGJlZm9yZSBidXQgd29uJ3QgYmUgbm93XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCBwcmV2aW91c1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfYW5pbWF0aW9uQWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmV3Q2x1c3Rlcikge1xyXG5cdFx0XHR2YXIgbWUgPSB0aGlzLFxyXG5cdFx0XHQgICAgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXA7XHJcblxyXG5cdFx0XHRmZy5hZGRMYXllcihsYXllcik7XHJcblx0XHRcdGlmIChuZXdDbHVzdGVyICE9PSBsYXllcikge1xyXG5cdFx0XHRcdGlmIChuZXdDbHVzdGVyLl9jaGlsZENvdW50ID4gMikgeyAvL1dhcyBhbHJlYWR5IGEgY2x1c3RlclxyXG5cclxuXHRcdFx0XHRcdG5ld0NsdXN0ZXIuX3VwZGF0ZUljb24oKTtcclxuXHRcdFx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XHJcblx0XHRcdFx0XHR0aGlzLl9hbmltYXRpb25TdGFydCgpO1xyXG5cclxuXHRcdFx0XHRcdGxheWVyLl9zZXRQb3ModGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChuZXdDbHVzdGVyLmdldExhdExuZygpKSk7XHJcblx0XHRcdFx0XHRsYXllci5jbHVzdGVySGlkZSgpO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX2VucXVldWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihsYXllcik7XHJcblx0XHRcdFx0XHRcdGxheWVyLmNsdXN0ZXJTaG93KCk7XHJcblxyXG5cdFx0XHRcdFx0XHRtZS5fYW5pbWF0aW9uRW5kKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHsgLy9KdXN0IGJlY2FtZSBhIGNsdXN0ZXJcclxuXHRcdFx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XHJcblxyXG5cdFx0XHRcdFx0bWUuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblx0XHRcdFx0XHRtZS5fYW5pbWF0aW9uWm9vbU91dFNpbmdsZShuZXdDbHVzdGVyLCB0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpLCB0aGlzLl96b29tKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBQcml2YXRlIG1ldGhvZHMgZm9yIGFuaW1hdGVkIHZlcnNpb25zLlxyXG5cdF9hbmltYXRpb25ab29tT3V0U2luZ2xlOiBmdW5jdGlvbiAoY2x1c3RlciwgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpLFxyXG5cdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKTtcclxuXHJcblx0XHQvL0FuaW1hdGUgYWxsIG9mIHRoZSBtYXJrZXJzIGluIHRoZSBjbHVzdGVycyB0byBtb3ZlIHRvIHRoZWlyIGNsdXN0ZXIgY2VudGVyIHBvaW50XHJcblx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluQW5kQWRkU2VsZlRvTWFwKGJvdW5kcywgbWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwgKyAxLCBuZXdab29tTGV2ZWwpO1xyXG5cclxuXHRcdHZhciBtZSA9IHRoaXM7XHJcblxyXG5cdFx0Ly9VcGRhdGUgdGhlIG9wYWNpdHkgKElmIHdlIGltbWVkaWF0ZWx5IHNldCBpdCB0aGV5IHdvbid0IGFuaW1hdGUpXHJcblx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xyXG5cdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlKGJvdW5kcywgbmV3Wm9vbUxldmVsKTtcclxuXHJcblx0XHQvL1RPRE86IE1heWJlIHVzZSB0aGUgdHJhbnNpdGlvbiB0aW1pbmcgc3R1ZmYgdG8gbWFrZSB0aGlzIG1vcmUgcmVsaWFibGVcclxuXHRcdC8vV2hlbiB0aGUgYW5pbWF0aW9ucyBhcmUgZG9uZSwgdGlkeSB1cFxyXG5cdFx0dGhpcy5fZW5xdWV1ZShmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvL1RoaXMgY2x1c3RlciBzdG9wcGVkIGJlaW5nIGEgY2x1c3RlciBiZWZvcmUgdGhlIHRpbWVvdXQgZmlyZWRcclxuXHRcdFx0aWYgKGNsdXN0ZXIuX2NoaWxkQ291bnQgPT09IDEpIHtcclxuXHRcdFx0XHR2YXIgbSA9IGNsdXN0ZXIuX21hcmtlcnNbMF07XHJcblx0XHRcdFx0Ly9JZiB3ZSB3ZXJlIGluIGEgY2x1c3RlciBhbmltYXRpb24gYXQgdGhlIHRpbWUgdGhlbiB0aGUgb3BhY2l0eSBhbmQgcG9zaXRpb24gb2Ygb3VyIGNoaWxkIGNvdWxkIGJlIHdyb25nIG5vdywgc28gZml4IGl0XHJcblx0XHRcdFx0dGhpcy5faWdub3JlTW92ZSA9IHRydWU7XHJcblx0XHRcdFx0bS5zZXRMYXRMbmcobS5nZXRMYXRMbmcoKSk7XHJcblx0XHRcdFx0dGhpcy5faWdub3JlTW92ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XHJcblx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNsdXN0ZXIuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgbmV3Wm9vbUxldmVsLCBtaW5ab29tLCBmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAoYm91bmRzLCBtaW5ab29tLCBwcmV2aW91c1pvb21MZXZlbCArIDEpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1lLl9hbmltYXRpb25FbmQoKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZSA9IHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUucmVwbGFjZSgnIGxlYWZsZXQtY2x1c3Rlci1hbmltJywgJycpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5faW5ab29tQW5pbWF0aW9uLS07XHJcblx0XHR0aGlzLmZpcmUoJ2FuaW1hdGlvbmVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vRm9yY2UgYSBicm93c2VyIGxheW91dCBvZiBzdHVmZiBpbiB0aGUgbWFwXHJcblx0Ly8gU2hvdWxkIGFwcGx5IHRoZSBjdXJyZW50IG9wYWNpdHkgYW5kIGxvY2F0aW9uIHRvIGFsbCBlbGVtZW50cyBzbyB3ZSBjYW4gdXBkYXRlIHRoZW0gYWdhaW4gZm9yIGFuIGFuaW1hdGlvblxyXG5cdF9mb3JjZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly9JbiBteSB0ZXN0aW5nIHRoaXMgd29ya3MsIGluZmFjdCBvZmZzZXRXaWR0aCBvZiBhbnkgZWxlbWVudCBzZWVtcyB0byB3b3JrLlxyXG5cdFx0Ly9Db3VsZCBsb29wIGFsbCB0aGlzLl9sYXllcnMgYW5kIGRvIHRoaXMgZm9yIGVhY2ggX2ljb24gaWYgaXQgc3RvcHMgd29ya2luZ1xyXG5cclxuXHRcdEwuVXRpbC5mYWxzZUZuKGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLm1hcmtlckNsdXN0ZXJHcm91cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLk1hcmtlckNsdXN0ZXJHcm91cChvcHRpb25zKTtcclxufTtcblxudmFyIE1hcmtlckNsdXN0ZXIgPSBMLk1hcmtlckNsdXN0ZXIgPSBMLk1hcmtlci5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IEwuSWNvbi5wcm90b3R5cGUub3B0aW9ucyxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdyb3VwLCB6b29tLCBhLCBiKSB7XHJcblxyXG5cdFx0TC5NYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhID8gKGEuX2NMYXRMbmcgfHwgYS5nZXRMYXRMbmcoKSkgOiBuZXcgTC5MYXRMbmcoMCwgMCksXHJcbiAgICAgICAgICAgIHsgaWNvbjogdGhpcywgcGFuZTogZ3JvdXAub3B0aW9ucy5jbHVzdGVyUGFuZSB9KTtcclxuXHJcblx0XHR0aGlzLl9ncm91cCA9IGdyb3VwO1xyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblxyXG5cdFx0dGhpcy5fbWFya2VycyA9IFtdO1xyXG5cdFx0dGhpcy5fY2hpbGRDbHVzdGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fY2hpbGRDb3VudCA9IDA7XHJcblx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0aWYgKGEpIHtcclxuXHRcdFx0dGhpcy5fYWRkQ2hpbGQoYSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYikge1xyXG5cdFx0XHR0aGlzLl9hZGRDaGlsZChiKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL1JlY3Vyc2l2ZWx5IHJldHJpZXZlIGFsbCBjaGlsZCBtYXJrZXJzIG9mIHRoaXMgY2x1c3RlclxyXG5cdGdldEFsbENoaWxkTWFya2VyczogZnVuY3Rpb24gKHN0b3JhZ2VBcnJheSwgaWdub3JlRHJhZ2dlZE1hcmtlcikge1xyXG5cdFx0c3RvcmFnZUFycmF5ID0gc3RvcmFnZUFycmF5IHx8IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNbaV0uZ2V0QWxsQ2hpbGRNYXJrZXJzKHN0b3JhZ2VBcnJheSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaiA9IHRoaXMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuXHRcdFx0aWYgKGlnbm9yZURyYWdnZWRNYXJrZXIgJiYgdGhpcy5fbWFya2Vyc1tqXS5fX2RyYWdTdGFydCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0b3JhZ2VBcnJheS5wdXNoKHRoaXMuX21hcmtlcnNbal0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdG9yYWdlQXJyYXk7XHJcblx0fSxcclxuXHJcblx0Ly9SZXR1cm5zIHRoZSBjb3VudCBvZiBob3cgbWFueSBjaGlsZCBtYXJrZXJzIHdlIGhhdmVcclxuXHRnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRDb3VudDtcclxuXHR9LFxyXG5cclxuXHQvL1pvb20gdG8gdGhlIG1pbmltdW0gb2Ygc2hvd2luZyBhbGwgb2YgdGhlIGNoaWxkIG1hcmtlcnMsIG9yIHRoZSBleHRlbnRzIG9mIHRoaXMgY2x1c3RlclxyXG5cdHpvb21Ub0JvdW5kczogZnVuY3Rpb24gKGZpdEJvdW5kc09wdGlvbnMpIHtcclxuXHRcdHZhciBjaGlsZENsdXN0ZXJzID0gdGhpcy5fY2hpbGRDbHVzdGVycy5zbGljZSgpLFxyXG5cdFx0XHRtYXAgPSB0aGlzLl9ncm91cC5fbWFwLFxyXG5cdFx0XHRib3VuZHNab29tID0gbWFwLmdldEJvdW5kc1pvb20odGhpcy5fYm91bmRzKSxcclxuXHRcdFx0em9vbSA9IHRoaXMuX3pvb20gKyAxLFxyXG5cdFx0XHRtYXBab29tID0gbWFwLmdldFpvb20oKSxcclxuXHRcdFx0aTtcclxuXHJcblx0XHQvL2NhbGN1bGF0ZSBob3cgZmFyIHdlIG5lZWQgdG8gem9vbSBkb3duIHRvIHNlZSBhbGwgb2YgdGhlIG1hcmtlcnNcclxuXHRcdHdoaWxlIChjaGlsZENsdXN0ZXJzLmxlbmd0aCA+IDAgJiYgYm91bmRzWm9vbSA+IHpvb20pIHtcclxuXHRcdFx0em9vbSsrO1xyXG5cdFx0XHR2YXIgbmV3Q2x1c3RlcnMgPSBbXTtcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkQ2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRuZXdDbHVzdGVycyA9IG5ld0NsdXN0ZXJzLmNvbmNhdChjaGlsZENsdXN0ZXJzW2ldLl9jaGlsZENsdXN0ZXJzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjaGlsZENsdXN0ZXJzID0gbmV3Q2x1c3RlcnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGJvdW5kc1pvb20gPiB6b29tKSB7XHJcblx0XHRcdHRoaXMuX2dyb3VwLl9tYXAuc2V0Vmlldyh0aGlzLl9sYXRsbmcsIHpvb20pO1xyXG5cdFx0fSBlbHNlIGlmIChib3VuZHNab29tIDw9IG1hcFpvb20pIHsgLy9JZiBmaXRCb3VuZHMgd291bGRuJ3Qgem9vbSB1cyBkb3duLCB6b29tIHVzIGRvd24gaW5zdGVhZFxyXG5cdFx0XHR0aGlzLl9ncm91cC5fbWFwLnNldFZpZXcodGhpcy5fbGF0bG5nLCBtYXBab29tICsgMSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9ncm91cC5fbWFwLmZpdEJvdW5kcyh0aGlzLl9ib3VuZHMsIGZpdEJvdW5kc09wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xyXG5cdFx0Ym91bmRzLmV4dGVuZCh0aGlzLl9ib3VuZHMpO1xyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHRoaXMuc2V0SWNvbih0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL0NsdWRnZSBmb3IgSWNvbiwgd2UgcHJldGVuZCB0byBiZSBhbiBpY29uIGZvciBwZXJmb3JtYW5jZVxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9pY29uTmVlZHNVcGRhdGUpIHtcclxuXHRcdFx0dGhpcy5faWNvbk9iaiA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKHRoaXMpO1xyXG5cdFx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9pY29uT2JqLmNyZWF0ZUljb24oKTtcclxuXHR9LFxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb25PYmouY3JlYXRlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblxyXG5cdF9hZGRDaGlsZDogZnVuY3Rpb24gKG5ldzEsIGlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XHJcblxyXG5cdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3NldENsdXN0ZXJDZW50ZXIobmV3MSk7XHJcblxyXG5cdFx0aWYgKG5ldzEgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpIHtcclxuXHRcdFx0aWYgKCFpc05vdGlmaWNhdGlvbkZyb21DaGlsZCkge1xyXG5cdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnMucHVzaChuZXcxKTtcclxuXHRcdFx0XHRuZXcxLl9fcGFyZW50ID0gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9jaGlsZENvdW50ICs9IG5ldzEuX2NoaWxkQ291bnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIWlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFya2Vycy5wdXNoKG5ldzEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX2NoaWxkQ291bnQrKztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fX3BhcmVudCkge1xyXG5cdFx0XHR0aGlzLl9fcGFyZW50Ll9hZGRDaGlsZChuZXcxLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBNYWtlcyBzdXJlIHRoZSBjbHVzdGVyIGNlbnRlciBpcyBzZXQuIElmIG5vdCwgdXNlcyB0aGUgY2hpbGQgY2VudGVyIGlmIGl0IGlzIGEgY2x1c3Rlciwgb3IgdGhlIG1hcmtlciBwb3NpdGlvbi5cclxuXHQgKiBAcGFyYW0gY2hpbGQgTC5NYXJrZXJDbHVzdGVyfEwuTWFya2VyIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGNsdXN0ZXIgY2VudGVyIGlmIG5vdCBkZWZpbmVkIHlldC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9zZXRDbHVzdGVyQ2VudGVyOiBmdW5jdGlvbiAoY2hpbGQpIHtcclxuXHRcdGlmICghdGhpcy5fY0xhdExuZykge1xyXG5cdFx0XHQvLyB3aGVuIGNsdXN0ZXJpbmcsIHRha2UgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGFzIHRoZSBjbHVzdGVyIGNlbnRlclxyXG5cdFx0XHR0aGlzLl9jTGF0TG5nID0gY2hpbGQuX2NMYXRMbmcgfHwgY2hpbGQuX2xhdGxuZztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBBc3NpZ25zIGltcG9zc2libGUgYm91bmRpbmcgdmFsdWVzIHNvIHRoYXQgdGhlIG5leHQgZXh0ZW5kIGVudGlyZWx5IGRldGVybWluZXMgdGhlIG5ldyBib3VuZHMuXHJcblx0ICogVGhpcyBtZXRob2QgYXZvaWRzIGhhdmluZyB0byB0cmFzaCB0aGUgcHJldmlvdXMgTC5MYXRMbmdCb3VuZHMgb2JqZWN0IGFuZCB0byBjcmVhdGUgYSBuZXcgb25lLCB3aGljaCBpcyBtdWNoIHNsb3dlciBmb3IgdGhpcyBjbGFzcy5cclxuXHQgKiBBcyBsb25nIGFzIHRoZSBib3VuZHMgYXJlIG5vdCBleHRlbmRlZCwgbW9zdCBvdGhlciBtZXRob2RzIHdvdWxkIHByb2JhYmx5IGZhaWwsIGFzIHRoZXkgd291bGQgd2l0aCBib3VuZHMgaW5pdGlhbGl6ZWQgYnV0IG5vdCBleHRlbmRlZC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZXNldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcclxuXHJcblx0XHRpZiAoYm91bmRzLl9zb3V0aFdlc3QpIHtcclxuXHRcdFx0Ym91bmRzLl9zb3V0aFdlc3QubGF0ID0gSW5maW5pdHk7XHJcblx0XHRcdGJvdW5kcy5fc291dGhXZXN0LmxuZyA9IEluZmluaXR5O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGJvdW5kcy5fbm9ydGhFYXN0KSB7XHJcblx0XHRcdGJvdW5kcy5fbm9ydGhFYXN0LmxhdCA9IC1JbmZpbml0eTtcclxuXHRcdFx0Ym91bmRzLl9ub3J0aEVhc3QubG5nID0gLUluZmluaXR5O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZWNhbGN1bGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcmtlcnMgPSB0aGlzLl9tYXJrZXJzLFxyXG5cdFx0ICAgIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLFxyXG5cdFx0ICAgIGxhdFN1bSA9IDAsXHJcblx0XHQgICAgbG5nU3VtID0gMCxcclxuXHRcdCAgICB0b3RhbENvdW50ID0gdGhpcy5fY2hpbGRDb3VudCxcclxuXHRcdCAgICBpLCBjaGlsZCwgY2hpbGRMYXRMbmcsIGNoaWxkQ291bnQ7XHJcblxyXG5cdFx0Ly8gQ2FzZSB3aGVyZSBhbGwgbWFya2VycyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgYW5kIHdlIGFyZSBsZWZ0IHdpdGgganVzdCBhbiBlbXB0eSBfdG9wQ2x1c3RlckxldmVsLlxyXG5cdFx0aWYgKHRvdGFsQ291bnQgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlc2V0IHJhdGhlciB0aGFuIGNyZWF0aW5nIGEgbmV3IG9iamVjdCwgZm9yIHBlcmZvcm1hbmNlLlxyXG5cdFx0dGhpcy5fcmVzZXRCb3VuZHMoKTtcclxuXHJcblx0XHQvLyBDaGlsZCBtYXJrZXJzLlxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Y2hpbGRMYXRMbmcgPSBtYXJrZXJzW2ldLl9sYXRsbmc7XHJcblxyXG5cdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGNoaWxkTGF0TG5nKTtcclxuXHJcblx0XHRcdGxhdFN1bSArPSBjaGlsZExhdExuZy5sYXQ7XHJcblx0XHRcdGxuZ1N1bSArPSBjaGlsZExhdExuZy5sbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hpbGQgY2x1c3RlcnMuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRDbHVzdGVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjaGlsZCA9IGNoaWxkQ2x1c3RlcnNbaV07XHJcblxyXG5cdFx0XHQvLyBSZS1jb21wdXRlIGNoaWxkIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb24gZmlyc3QgaWYgbmVjZXNzYXJ5LlxyXG5cdFx0XHRpZiAoY2hpbGQuX2JvdW5kc05lZWRVcGRhdGUpIHtcclxuXHRcdFx0XHRjaGlsZC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChjaGlsZC5fYm91bmRzKTtcclxuXHJcblx0XHRcdGNoaWxkTGF0TG5nID0gY2hpbGQuX3dMYXRMbmc7XHJcblx0XHRcdGNoaWxkQ291bnQgPSBjaGlsZC5fY2hpbGRDb3VudDtcclxuXHJcblx0XHRcdGxhdFN1bSArPSBjaGlsZExhdExuZy5sYXQgKiBjaGlsZENvdW50O1xyXG5cdFx0XHRsbmdTdW0gKz0gY2hpbGRMYXRMbmcubG5nICogY2hpbGRDb3VudDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXRsbmcgPSB0aGlzLl93TGF0TG5nID0gbmV3IEwuTGF0TG5nKGxhdFN1bSAvIHRvdGFsQ291bnQsIGxuZ1N1bSAvIHRvdGFsQ291bnQpO1xyXG5cclxuXHRcdC8vIFJlc2V0IGRpcnR5IGZsYWcuXHJcblx0XHR0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly9TZXQgb3VyIG1hcmtlcnMgcG9zaXRpb24gYXMgZ2l2ZW4gYW5kIGFkZCBpdCB0byB0aGUgbWFwXHJcblx0X2FkZFRvTWFwOiBmdW5jdGlvbiAoc3RhcnRQb3MpIHtcclxuXHRcdGlmIChzdGFydFBvcykge1xyXG5cdFx0XHR0aGlzLl9iYWNrdXBMYXRsbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHRcdHRoaXMuc2V0TGF0TG5nKHN0YXJ0UG9zKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2dyb3VwLl9mZWF0dXJlR3JvdXAuYWRkTGF5ZXIodGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW46IGZ1bmN0aW9uIChib3VuZHMsIGNlbnRlciwgbWF4Wm9vbSkge1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSwgbWF4Wm9vbSAtIDEsXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0dmFyIG1hcmtlcnMgPSBjLl9tYXJrZXJzLFxyXG5cdFx0XHRcdFx0aSwgbTtcclxuXHRcdFx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHRtID0gbWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdFx0XHQvL09ubHkgZG8gaXQgaWYgdGhlIGljb24gaXMgc3RpbGwgb24gdGhlIG1hcFxyXG5cdFx0XHRcdFx0aWYgKG0uX2ljb24pIHtcclxuXHRcdFx0XHRcdFx0bS5fc2V0UG9zKGNlbnRlcik7XHJcblx0XHRcdFx0XHRcdG0uY2x1c3RlckhpZGUoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSBjLl9jaGlsZENsdXN0ZXJzLFxyXG5cdFx0XHRcdFx0aiwgY207XHJcblx0XHRcdFx0Zm9yIChqID0gY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG5cdFx0XHRcdFx0Y20gPSBjaGlsZENsdXN0ZXJzW2pdO1xyXG5cdFx0XHRcdFx0aWYgKGNtLl9pY29uKSB7XHJcblx0XHRcdFx0XHRcdGNtLl9zZXRQb3MoY2VudGVyKTtcclxuXHRcdFx0XHRcdFx0Y20uY2x1c3RlckhpZGUoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0X3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW5BbmRBZGRTZWxmVG9NYXA6IGZ1bmN0aW9uIChib3VuZHMsIG1hcE1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgbmV3Wm9vbUxldmVsLCBtYXBNaW5ab29tLFxyXG5cdFx0XHRmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW4oYm91bmRzLCBjLl9ncm91cC5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChjLmdldExhdExuZygpKS5yb3VuZCgpLCBwcmV2aW91c1pvb21MZXZlbCk7XHJcblxyXG5cdFx0XHRcdC8vVE9ETzogZGVwdGhUb0FuaW1hdGVJbiBhZmZlY3RzIF9pc1NpbmdsZVBhcmVudCwgaWYgdGhlcmUgaXMgYSBtdWx0aXpvb20gd2UgbWF5L21heSBub3QgYmUuXHJcblx0XHRcdFx0Ly9BcyBhIGhhY2sgd2Ugb25seSBkbyBhIGFuaW1hdGlvbiBmcmVlIHpvb20gb24gYSBzaW5nbGUgbGV2ZWwgem9vbSwgaWYgc29tZW9uZSBkb2VzIG11bHRpcGxlIGxldmVscyB0aGVuIHdlIGFsd2F5cyBhbmltYXRlXHJcblx0XHRcdFx0aWYgKGMuX2lzU2luZ2xlUGFyZW50KCkgJiYgcHJldmlvdXNab29tTGV2ZWwgLSAxID09PSBuZXdab29tTGV2ZWwpIHtcclxuXHRcdFx0XHRcdGMuY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKGJvdW5kcywgbWFwTWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwpOyAvL0ltbWVkaWF0ZWx5IHJlbW92ZSBvdXIgY2hpbGRyZW4gYXMgd2UgYXJlIHJlcGxhY2luZyB0aGVtLiBUT0RPIHByZXZpb3VzQm91bmRzIG5vdCBib3VuZHNcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Yy5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Yy5fYWRkVG9NYXAoKTtcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlOiBmdW5jdGlvbiAoYm91bmRzLCB6b29tTGV2ZWwpIHtcclxuXHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgdGhpcy5fZ3JvdXAuX21hcC5nZXRNaW5ab29tKCksIHpvb21MZXZlbCwgbnVsbCwgZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0Yy5jbHVzdGVyU2hvdygpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcDogZnVuY3Rpb24gKHN0YXJ0UG9zLCB6b29tTGV2ZWwsIGJvdW5kcykge1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSAtIDEsIHpvb21MZXZlbCxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHRpZiAoem9vbUxldmVsID09PSBjLl96b29tKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL0FkZCBvdXIgY2hpbGQgbWFya2VycyBhdCBzdGFydFBvcyAoc28gdGhleSBjYW4gYmUgYW5pbWF0ZWQgb3V0KVxyXG5cdFx0XHRcdGZvciAodmFyIGkgPSBjLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHR2YXIgbm0gPSBjLl9tYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0XHRcdGlmICghYm91bmRzLmNvbnRhaW5zKG5tLl9sYXRsbmcpKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChzdGFydFBvcykge1xyXG5cdFx0XHRcdFx0XHRubS5fYmFja3VwTGF0bG5nID0gbm0uZ2V0TGF0TG5nKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRubS5zZXRMYXRMbmcoc3RhcnRQb3MpO1xyXG5cdFx0XHRcdFx0XHRpZiAobm0uY2x1c3RlckhpZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRubS5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihubSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdGMuX2FkZFRvTWFwKHN0YXJ0UG9zKTtcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnM6IGZ1bmN0aW9uICh6b29tTGV2ZWwpIHtcclxuXHRcdC8vRml4IHBvc2l0aW9ucyBvZiBjaGlsZCBtYXJrZXJzXHJcblx0XHRmb3IgKHZhciBpID0gdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHR2YXIgbm0gPSB0aGlzLl9tYXJrZXJzW2ldO1xyXG5cdFx0XHRpZiAobm0uX2JhY2t1cExhdGxuZykge1xyXG5cdFx0XHRcdG5tLnNldExhdExuZyhubS5fYmFja3VwTGF0bG5nKTtcclxuXHRcdFx0XHRkZWxldGUgbm0uX2JhY2t1cExhdGxuZztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh6b29tTGV2ZWwgLSAxID09PSB0aGlzLl96b29tKSB7XHJcblx0XHRcdC8vUmVwb3NpdGlvbiBjaGlsZCBjbHVzdGVyc1xyXG5cdFx0XHRmb3IgKHZhciBqID0gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG5cdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNbal0uX3Jlc3RvcmVQb3NpdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRmb3IgKHZhciBrID0gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBrID49IDA7IGstLSkge1xyXG5cdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNba10uX3JlY3Vyc2l2ZWx5UmVzdG9yZUNoaWxkUG9zaXRpb25zKHpvb21MZXZlbCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVzdG9yZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fYmFja3VwTGF0bG5nKSB7XHJcblx0XHRcdHRoaXMuc2V0TGF0TG5nKHRoaXMuX2JhY2t1cExhdGxuZyk7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9iYWNrdXBMYXRsbmc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9leGNlcHRCb3VuZHM6IElmIHNldCwgZG9uJ3QgcmVtb3ZlIGFueSBtYXJrZXJzL2NsdXN0ZXJzIGluIGl0XHJcblx0X3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwOiBmdW5jdGlvbiAocHJldmlvdXNCb3VuZHMsIG1hcE1pblpvb20sIHpvb21MZXZlbCwgZXhjZXB0Qm91bmRzKSB7XHJcblx0XHR2YXIgbSwgaTtcclxuXHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KHByZXZpb3VzQm91bmRzLCBtYXBNaW5ab29tIC0gMSwgem9vbUxldmVsIC0gMSxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHQvL1JlbW92ZSBtYXJrZXJzIGF0IGV2ZXJ5IGxldmVsXHJcblx0XHRcdFx0Zm9yIChpID0gYy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdFx0bSA9IGMuX21hcmtlcnNbaV07XHJcblx0XHRcdFx0XHRpZiAoIWV4Y2VwdEJvdW5kcyB8fCAhZXhjZXB0Qm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcclxuXHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0Ly9SZW1vdmUgY2hpbGQgY2x1c3RlcnMgYXQganVzdCB0aGUgYm90dG9tIGxldmVsXHJcblx0XHRcdFx0Zm9yIChpID0gYy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdFx0bSA9IGMuX2NoaWxkQ2x1c3RlcnNbaV07XHJcblx0XHRcdFx0XHRpZiAoIWV4Y2VwdEJvdW5kcyB8fCAhZXhjZXB0Qm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcclxuXHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0Ly9SdW4gdGhlIGdpdmVuIGZ1bmN0aW9ucyByZWN1cnNpdmVseSB0byB0aGlzIGFuZCBjaGlsZCBjbHVzdGVyc1xyXG5cdC8vIGJvdW5kc1RvQXBwbHlUbzogYSBMLkxhdExuZ0JvdW5kcyByZXByZXNlbnRpbmcgdGhlIGJvdW5kcyBvZiB3aGF0IGNsdXN0ZXJzIHRvIHJlY3Vyc2UgaW4gdG9cclxuXHQvLyB6b29tTGV2ZWxUb1N0YXJ0OiB6b29tIGxldmVsIHRvIHN0YXJ0IHJ1bm5pbmcgZnVuY3Rpb25zIChpbmNsdXNpdmUpXHJcblx0Ly8gem9vbUxldmVsVG9TdG9wOiB6b29tIGxldmVsIHRvIHN0b3AgcnVubmluZyBmdW5jdGlvbnMgKGluY2x1c2l2ZSlcclxuXHQvLyBydW5BdEV2ZXJ5TGV2ZWw6IGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gTC5NYXJrZXJDbHVzdGVyIGFzIGFuIGFyZ3VtZW50IHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgb24gZXZlcnkgbGV2ZWxcclxuXHQvLyBydW5BdEJvdHRvbUxldmVsOiBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIEwuTWFya2VyQ2x1c3RlciBhcyBhbiBhcmd1bWVudCB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIGF0IG9ubHkgdGhlIGJvdHRvbSBsZXZlbFxyXG5cdF9yZWN1cnNpdmVseTogZnVuY3Rpb24gKGJvdW5kc1RvQXBwbHlUbywgem9vbUxldmVsVG9TdGFydCwgem9vbUxldmVsVG9TdG9wLCBydW5BdEV2ZXJ5TGV2ZWwsIHJ1bkF0Qm90dG9tTGV2ZWwpIHtcclxuXHRcdHZhciBjaGlsZENsdXN0ZXJzID0gdGhpcy5fY2hpbGRDbHVzdGVycyxcclxuXHRcdCAgICB6b29tID0gdGhpcy5fem9vbSxcclxuXHRcdCAgICBpLCBjO1xyXG5cclxuXHRcdGlmICh6b29tTGV2ZWxUb1N0YXJ0IDw9IHpvb20pIHtcclxuXHRcdFx0aWYgKHJ1bkF0RXZlcnlMZXZlbCkge1xyXG5cdFx0XHRcdHJ1bkF0RXZlcnlMZXZlbCh0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAocnVuQXRCb3R0b21MZXZlbCAmJiB6b29tID09PSB6b29tTGV2ZWxUb1N0b3ApIHtcclxuXHRcdFx0XHRydW5BdEJvdHRvbUxldmVsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHpvb20gPCB6b29tTGV2ZWxUb1N0YXJ0IHx8IHpvb20gPCB6b29tTGV2ZWxUb1N0b3ApIHtcclxuXHRcdFx0Zm9yIChpID0gY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdGMgPSBjaGlsZENsdXN0ZXJzW2ldO1xyXG5cdFx0XHRcdGlmIChjLl9ib3VuZHNOZWVkVXBkYXRlKSB7XHJcblx0XHRcdFx0XHRjLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoYm91bmRzVG9BcHBseVRvLmludGVyc2VjdHMoYy5fYm91bmRzKSkge1xyXG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHkoYm91bmRzVG9BcHBseVRvLCB6b29tTGV2ZWxUb1N0YXJ0LCB6b29tTGV2ZWxUb1N0b3AsIHJ1bkF0RXZlcnlMZXZlbCwgcnVuQXRCb3R0b21MZXZlbCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9SZXR1cm5zIHRydWUgaWYgd2UgYXJlIHRoZSBwYXJlbnQgb2Ygb25seSBvbmUgY2x1c3RlciBhbmQgdGhhdCBjbHVzdGVyIGlzIHRoZSBzYW1lIGFzIHVzXHJcblx0X2lzU2luZ2xlUGFyZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvL0Rvbid0IG5lZWQgdG8gY2hlY2sgdGhpcy5fbWFya2VycyBhcyB0aGUgcmVzdCB3b24ndCB3b3JrIGlmIHRoZXJlIGFyZSBhbnlcclxuXHRcdHJldHVybiB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCA+IDAgJiYgdGhpcy5fY2hpbGRDbHVzdGVyc1swXS5fY2hpbGRDb3VudCA9PT0gdGhpcy5fY2hpbGRDb3VudDtcclxuXHR9XHJcbn0pO1xuXG4vKlxyXG4qIEV4dGVuZHMgTC5NYXJrZXIgdG8gaW5jbHVkZSB0d28gZXh0cmEgbWV0aG9kczogY2x1c3RlckhpZGUgYW5kIGNsdXN0ZXJTaG93LlxyXG4qIFxyXG4qIFRoZXkgd29yayBhcyBzZXRPcGFjaXR5KDApIGFuZCBzZXRPcGFjaXR5KDEpIHJlc3BlY3RpdmVseSwgYnV0XHJcbiogZG9uJ3Qgb3ZlcndyaXRlIHRoZSBvcHRpb25zLm9wYWNpdHlcclxuKiBcclxuKi9cclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoe1xyXG5cdGNsdXN0ZXJIaWRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYmFja3VwID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblx0XHR0aGlzLnNldE9wYWNpdHkoMCk7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IGJhY2t1cDtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblx0XHJcblx0Y2x1c3RlclNob3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdH1cclxufSk7XG5cbkwuRGlzdGFuY2VHcmlkID0gZnVuY3Rpb24gKGNlbGxTaXplKSB7XHJcblx0dGhpcy5fY2VsbFNpemUgPSBjZWxsU2l6ZTtcclxuXHR0aGlzLl9zcUNlbGxTaXplID0gY2VsbFNpemUgKiBjZWxsU2l6ZTtcclxuXHR0aGlzLl9ncmlkID0ge307XHJcblx0dGhpcy5fb2JqZWN0UG9pbnQgPSB7IH07XHJcbn07XHJcblxyXG5MLkRpc3RhbmNlR3JpZC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGFkZE9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcclxuXHRcdHZhciB4ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueCksXHJcblx0XHQgICAgeSA9IHRoaXMuX2dldENvb3JkKHBvaW50LnkpLFxyXG5cdFx0ICAgIGdyaWQgPSB0aGlzLl9ncmlkLFxyXG5cdFx0ICAgIHJvdyA9IGdyaWRbeV0gPSBncmlkW3ldIHx8IHt9LFxyXG5cdFx0ICAgIGNlbGwgPSByb3dbeF0gPSByb3dbeF0gfHwgW10sXHJcblx0XHQgICAgc3RhbXAgPSBMLlV0aWwuc3RhbXAob2JqKTtcclxuXHJcblx0XHR0aGlzLl9vYmplY3RQb2ludFtzdGFtcF0gPSBwb2ludDtcclxuXHJcblx0XHRjZWxsLnB1c2gob2JqKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVPYmplY3Q6IGZ1bmN0aW9uIChvYmosIHBvaW50KSB7XHJcblx0XHR0aGlzLnJlbW92ZU9iamVjdChvYmopO1xyXG5cdFx0dGhpcy5hZGRPYmplY3Qob2JqLCBwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly9SZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCB3YXMgZm91bmRcclxuXHRyZW1vdmVPYmplY3Q6IGZ1bmN0aW9uIChvYmosIHBvaW50KSB7XHJcblx0XHR2YXIgeCA9IHRoaXMuX2dldENvb3JkKHBvaW50LngpLFxyXG5cdFx0ICAgIHkgPSB0aGlzLl9nZXRDb29yZChwb2ludC55KSxcclxuXHRcdCAgICBncmlkID0gdGhpcy5fZ3JpZCxcclxuXHRcdCAgICByb3cgPSBncmlkW3ldID0gZ3JpZFt5XSB8fCB7fSxcclxuXHRcdCAgICBjZWxsID0gcm93W3hdID0gcm93W3hdIHx8IFtdLFxyXG5cdFx0ICAgIGksIGxlbjtcclxuXHJcblx0XHRkZWxldGUgdGhpcy5fb2JqZWN0UG9pbnRbTC5VdGlsLnN0YW1wKG9iaildO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKGNlbGxbaV0gPT09IG9iaikge1xyXG5cclxuXHRcdFx0XHRjZWxsLnNwbGljZShpLCAxKTtcclxuXHJcblx0XHRcdFx0aWYgKGxlbiA9PT0gMSkge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHJvd1t4XTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGVhY2hPYmplY3Q6IGZ1bmN0aW9uIChmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGksIGosIGssIGxlbiwgcm93LCBjZWxsLCByZW1vdmVkLFxyXG5cdFx0ICAgIGdyaWQgPSB0aGlzLl9ncmlkO1xyXG5cclxuXHRcdGZvciAoaSBpbiBncmlkKSB7XHJcblx0XHRcdHJvdyA9IGdyaWRbaV07XHJcblxyXG5cdFx0XHRmb3IgKGogaW4gcm93KSB7XHJcblx0XHRcdFx0Y2VsbCA9IHJvd1tqXTtcclxuXHJcblx0XHRcdFx0Zm9yIChrID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xyXG5cdFx0XHRcdFx0cmVtb3ZlZCA9IGZuLmNhbGwoY29udGV4dCwgY2VsbFtrXSk7XHJcblx0XHRcdFx0XHRpZiAocmVtb3ZlZCkge1xyXG5cdFx0XHRcdFx0XHRrLS07XHJcblx0XHRcdFx0XHRcdGxlbi0tO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldE5lYXJPYmplY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcclxuXHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXHJcblx0XHQgICAgaSwgaiwgaywgcm93LCBjZWxsLCBsZW4sIG9iaiwgZGlzdCxcclxuXHRcdCAgICBvYmplY3RQb2ludCA9IHRoaXMuX29iamVjdFBvaW50LFxyXG5cdFx0ICAgIGNsb3Nlc3REaXN0U3EgPSB0aGlzLl9zcUNlbGxTaXplLFxyXG5cdFx0ICAgIGNsb3Nlc3QgPSBudWxsO1xyXG5cclxuXHRcdGZvciAoaSA9IHkgLSAxOyBpIDw9IHkgKyAxOyBpKyspIHtcclxuXHRcdFx0cm93ID0gdGhpcy5fZ3JpZFtpXTtcclxuXHRcdFx0aWYgKHJvdykge1xyXG5cclxuXHRcdFx0XHRmb3IgKGogPSB4IC0gMTsgaiA8PSB4ICsgMTsgaisrKSB7XHJcblx0XHRcdFx0XHRjZWxsID0gcm93W2pdO1xyXG5cdFx0XHRcdFx0aWYgKGNlbGwpIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoayA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRvYmogPSBjZWxsW2tdO1xyXG5cdFx0XHRcdFx0XHRcdGRpc3QgPSB0aGlzLl9zcURpc3Qob2JqZWN0UG9pbnRbTC5VdGlsLnN0YW1wKG9iaildLCBwb2ludCk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGRpc3QgPCBjbG9zZXN0RGlzdFNxIHx8XHJcblx0XHRcdFx0XHRcdFx0XHRkaXN0IDw9IGNsb3Nlc3REaXN0U3EgJiYgY2xvc2VzdCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RTcSA9IGRpc3Q7XHJcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0ID0gb2JqO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNsb3Nlc3Q7XHJcblx0fSxcclxuXHJcblx0X2dldENvb3JkOiBmdW5jdGlvbiAoeCkge1xyXG5cdFx0dmFyIGNvb3JkID0gTWF0aC5mbG9vcih4IC8gdGhpcy5fY2VsbFNpemUpO1xyXG5cdFx0cmV0dXJuIGlzRmluaXRlKGNvb3JkKSA/IGNvb3JkIDogeDtcclxuXHR9LFxyXG5cclxuXHRfc3FEaXN0OiBmdW5jdGlvbiAocCwgcDIpIHtcclxuXHRcdHZhciBkeCA9IHAyLnggLSBwLngsXHJcblx0XHQgICAgZHkgPSBwMi55IC0gcC55O1xyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG5cdH1cclxufTtcblxuLyogQ29weXJpZ2h0IChjKSAyMDEyIHRoZSBhdXRob3JzIGxpc3RlZCBhdCB0aGUgZm9sbG93aW5nIFVSTCwgYW5kL29yXHJcbnRoZSBhdXRob3JzIG9mIHJlZmVyZW5jZWQgYXJ0aWNsZXMgb3IgaW5jb3Jwb3JhdGVkIGV4dGVybmFsIGNvZGU6XHJcbmh0dHA6Ly9lbi5saXRlcmF0ZXByb2dyYW1zLm9yZy9RdWlja2h1bGxfKEphdmFzY3JpcHQpP2FjdGlvbj1oaXN0b3J5Jm9mZnNldD0yMDEyMDQxMDE3NTI1NlxyXG5cclxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcclxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcclxuVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcclxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG5SZXRyaWV2ZWQgZnJvbTogaHR0cDovL2VuLmxpdGVyYXRlcHJvZ3JhbXMub3JnL1F1aWNraHVsbF8oSmF2YXNjcmlwdCk/b2xkaWQ9MTg0MzRcclxuKi9cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0TC5RdWlja0h1bGwgPSB7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjcHQgYSBwb2ludCB0byBiZSBtZWFzdXJlZCBmcm9tIHRoZSBiYXNlbGluZVxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYmwgdGhlIGJhc2VsaW5lLCBhcyByZXByZXNlbnRlZCBieSBhIHR3by1lbGVtZW50XHJcblx0XHQgKiAgIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzLlxyXG5cdFx0ICogQHJldHVybnMge051bWJlcn0gYW4gYXBwcm94aW1hdGUgZGlzdGFuY2UgbWVhc3VyZVxyXG5cdFx0ICovXHJcblx0XHRnZXREaXN0YW50OiBmdW5jdGlvbiAoY3B0LCBibCkge1xyXG5cdFx0XHR2YXIgdlkgPSBibFsxXS5sYXQgLSBibFswXS5sYXQsXHJcblx0XHRcdFx0dlggPSBibFswXS5sbmcgLSBibFsxXS5sbmc7XHJcblx0XHRcdHJldHVybiAodlggKiAoY3B0LmxhdCAtIGJsWzBdLmxhdCkgKyB2WSAqIChjcHQubG5nIC0gYmxbMF0ubG5nKSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBiYXNlTGluZSBhIHR3by1lbGVtZW50IGFycmF5IG9mIGxhdGxuZyBvYmplY3RzXHJcblx0XHQgKiAgIHJlcHJlc2VudGluZyB0aGUgYmFzZWxpbmUgdG8gcHJvamVjdCBmcm9tXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzIGFuIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzXHJcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgbWF4aW11bSBwb2ludCBhbmQgYWxsIG5ldyBwb2ludHMgdG8gc3RheVxyXG5cdFx0ICogICBpbiBjb25zaWRlcmF0aW9uIGZvciB0aGUgaHVsbC5cclxuXHRcdCAqL1xyXG5cdFx0ZmluZE1vc3REaXN0YW50UG9pbnRGcm9tQmFzZUxpbmU6IGZ1bmN0aW9uIChiYXNlTGluZSwgbGF0TG5ncykge1xyXG5cdFx0XHR2YXIgbWF4RCA9IDAsXHJcblx0XHRcdFx0bWF4UHQgPSBudWxsLFxyXG5cdFx0XHRcdG5ld1BvaW50cyA9IFtdLFxyXG5cdFx0XHRcdGksIHB0LCBkO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gbGF0TG5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdHB0ID0gbGF0TG5nc1tpXTtcclxuXHRcdFx0XHRkID0gdGhpcy5nZXREaXN0YW50KHB0LCBiYXNlTGluZSk7XHJcblxyXG5cdFx0XHRcdGlmIChkID4gMCkge1xyXG5cdFx0XHRcdFx0bmV3UG9pbnRzLnB1c2gocHQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChkID4gbWF4RCkge1xyXG5cdFx0XHRcdFx0bWF4RCA9IGQ7XHJcblx0XHRcdFx0XHRtYXhQdCA9IHB0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHsgbWF4UG9pbnQ6IG1heFB0LCBuZXdQb2ludHM6IG5ld1BvaW50cyB9O1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LypcclxuXHRcdCAqIEdpdmVuIGEgYmFzZWxpbmUsIGNvbXB1dGUgdGhlIGNvbnZleCBodWxsIG9mIGxhdExuZ3MgYXMgYW4gYXJyYXlcclxuXHRcdCAqIG9mIGxhdExuZ3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gbGF0TG5nc1xyXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdFx0ICovXHJcblx0XHRidWlsZENvbnZleEh1bGw6IGZ1bmN0aW9uIChiYXNlTGluZSwgbGF0TG5ncykge1xyXG5cdFx0XHR2YXIgY29udmV4SHVsbEJhc2VMaW5lcyA9IFtdLFxyXG5cdFx0XHRcdHQgPSB0aGlzLmZpbmRNb3N0RGlzdGFudFBvaW50RnJvbUJhc2VMaW5lKGJhc2VMaW5lLCBsYXRMbmdzKTtcclxuXHJcblx0XHRcdGlmICh0Lm1heFBvaW50KSB7IC8vIGlmIHRoZXJlIGlzIHN0aWxsIGEgcG9pbnQgXCJvdXRzaWRlXCIgdGhlIGJhc2UgbGluZVxyXG5cdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMgPVxyXG5cdFx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcy5jb25jYXQoXHJcblx0XHRcdFx0XHRcdHRoaXMuYnVpbGRDb252ZXhIdWxsKFtiYXNlTGluZVswXSwgdC5tYXhQb2ludF0sIHQubmV3UG9pbnRzKVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRjb252ZXhIdWxsQmFzZUxpbmVzID1cclxuXHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMuY29uY2F0KFxyXG5cdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbdC5tYXhQb2ludCwgYmFzZUxpbmVbMV1dLCB0Lm5ld1BvaW50cylcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0cmV0dXJuIGNvbnZleEh1bGxCYXNlTGluZXM7XHJcblx0XHRcdH0gZWxzZSB7ICAvLyBpZiB0aGVyZSBpcyBubyBtb3JlIHBvaW50IFwib3V0c2lkZVwiIHRoZSBiYXNlIGxpbmUsIHRoZSBjdXJyZW50IGJhc2UgbGluZSBpcyBwYXJ0IG9mIHRoZSBjb252ZXggaHVsbFxyXG5cdFx0XHRcdHJldHVybiBbYmFzZUxpbmVbMF1dO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBHaXZlbiBhbiBhcnJheSBvZiBsYXRsbmdzLCBjb21wdXRlIGEgY29udmV4IGh1bGwgYXMgYW4gYXJyYXlcclxuXHRcdCAqIG9mIGxhdGxuZ3NcclxuXHRcdCAqXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzXHJcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XHJcblx0XHQgKi9cclxuXHRcdGdldENvbnZleEh1bGw6IGZ1bmN0aW9uIChsYXRMbmdzKSB7XHJcblx0XHRcdC8vIGZpbmQgZmlyc3QgYmFzZWxpbmVcclxuXHRcdFx0dmFyIG1heExhdCA9IGZhbHNlLCBtaW5MYXQgPSBmYWxzZSxcclxuXHRcdFx0XHRtYXhMbmcgPSBmYWxzZSwgbWluTG5nID0gZmFsc2UsXHJcblx0XHRcdFx0bWF4TGF0UHQgPSBudWxsLCBtaW5MYXRQdCA9IG51bGwsXHJcblx0XHRcdFx0bWF4TG5nUHQgPSBudWxsLCBtaW5MbmdQdCA9IG51bGwsXHJcblx0XHRcdFx0bWF4UHQgPSBudWxsLCBtaW5QdCA9IG51bGwsXHJcblx0XHRcdFx0aTtcclxuXHJcblx0XHRcdGZvciAoaSA9IGxhdExuZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHR2YXIgcHQgPSBsYXRMbmdzW2ldO1xyXG5cdFx0XHRcdGlmIChtYXhMYXQgPT09IGZhbHNlIHx8IHB0LmxhdCA+IG1heExhdCkge1xyXG5cdFx0XHRcdFx0bWF4TGF0UHQgPSBwdDtcclxuXHRcdFx0XHRcdG1heExhdCA9IHB0LmxhdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG1pbkxhdCA9PT0gZmFsc2UgfHwgcHQubGF0IDwgbWluTGF0KSB7XHJcblx0XHRcdFx0XHRtaW5MYXRQdCA9IHB0O1xyXG5cdFx0XHRcdFx0bWluTGF0ID0gcHQubGF0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobWF4TG5nID09PSBmYWxzZSB8fCBwdC5sbmcgPiBtYXhMbmcpIHtcclxuXHRcdFx0XHRcdG1heExuZ1B0ID0gcHQ7XHJcblx0XHRcdFx0XHRtYXhMbmcgPSBwdC5sbmc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChtaW5MbmcgPT09IGZhbHNlIHx8IHB0LmxuZyA8IG1pbkxuZykge1xyXG5cdFx0XHRcdFx0bWluTG5nUHQgPSBwdDtcclxuXHRcdFx0XHRcdG1pbkxuZyA9IHB0LmxuZztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGlmIChtaW5MYXQgIT09IG1heExhdCkge1xyXG5cdFx0XHRcdG1pblB0ID0gbWluTGF0UHQ7XHJcblx0XHRcdFx0bWF4UHQgPSBtYXhMYXRQdDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRtaW5QdCA9IG1pbkxuZ1B0O1xyXG5cdFx0XHRcdG1heFB0ID0gbWF4TG5nUHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBjaCA9IFtdLmNvbmNhdCh0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWluUHQsIG1heFB0XSwgbGF0TG5ncyksXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWF4UHQsIG1pblB0XSwgbGF0TG5ncykpO1xyXG5cdFx0XHRyZXR1cm4gY2g7XHJcblx0XHR9XHJcblx0fTtcclxufSgpKTtcclxuXHJcbkwuTWFya2VyQ2x1c3Rlci5pbmNsdWRlKHtcclxuXHRnZXRDb252ZXhIdWxsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcclxuXHRcdFx0cG9pbnRzID0gW10sXHJcblx0XHRcdHAsIGk7XHJcblxyXG5cdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHAgPSBjaGlsZE1hcmtlcnNbaV0uZ2V0TGF0TG5nKCk7XHJcblx0XHRcdHBvaW50cy5wdXNoKHApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBMLlF1aWNrSHVsbC5nZXRDb252ZXhIdWxsKHBvaW50cyk7XHJcblx0fVxyXG59KTtcblxuLy9UaGlzIGNvZGUgaXMgMTAwJSBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vamF3ai9PdmVybGFwcGluZ01hcmtlclNwaWRlcmZpZXItTGVhZmxldFxyXG4vL0h1Z2UgdGhhbmtzIHRvIGphd2ogZm9yIGltcGxlbWVudGluZyBpdCBmaXJzdCB0byBtYWtlIG15IGpvYiBlYXN5IDotKVxyXG5cclxuTC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoe1xyXG5cclxuXHRfMlBJOiBNYXRoLlBJICogMixcclxuXHRfY2lyY2xlRm9vdFNlcGFyYXRpb246IDI1LCAvL3JlbGF0ZWQgdG8gY2lyY3VtZmVyZW5jZSBvZiBjaXJjbGVcclxuXHRfY2lyY2xlU3RhcnRBbmdsZTogMCxcclxuXHJcblx0X3NwaXJhbEZvb3RTZXBhcmF0aW9uOiAgMjgsIC8vcmVsYXRlZCB0byBzaXplIG9mIHNwaXJhbCAoZXhwZXJpbWVudCEpXHJcblx0X3NwaXJhbExlbmd0aFN0YXJ0OiAxMSxcclxuXHRfc3BpcmFsTGVuZ3RoRmFjdG9yOiA1LFxyXG5cclxuXHRfY2lyY2xlU3BpcmFsU3dpdGNob3ZlcjogOSwgLy9zaG93IHNwaXJhbCBpbnN0ZWFkIG9mIGNpcmNsZSBmcm9tIHRoaXMgbWFya2VyIGNvdW50IHVwd2FyZHMuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyAwIC0+IGFsd2F5cyBzcGlyYWw7IEluZmluaXR5IC0+IGFsd2F5cyBjaXJjbGVcclxuXHJcblx0c3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9PT0gdGhpcyB8fCB0aGlzLl9ncm91cC5faW5ab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMobnVsbCwgdHJ1ZSksXHJcblx0XHRcdGdyb3VwID0gdGhpcy5fZ3JvdXAsXHJcblx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXHJcblx0XHRcdGNlbnRlciA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdFx0cG9zaXRpb25zO1xyXG5cclxuXHRcdHRoaXMuX2dyb3VwLl91bnNwaWRlcmZ5KCk7XHJcblx0XHR0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9IHRoaXM7XHJcblxyXG5cdFx0Ly9UT0RPIE1heWJlOiBjaGlsZE1hcmtlcnMgb3JkZXIgYnkgZGlzdGFuY2UgdG8gY2VudGVyXHJcblxyXG5cdFx0aWYgKGNoaWxkTWFya2Vycy5sZW5ndGggPj0gdGhpcy5fY2lyY2xlU3BpcmFsU3dpdGNob3Zlcikge1xyXG5cdFx0XHRwb3NpdGlvbnMgPSB0aGlzLl9nZW5lcmF0ZVBvaW50c1NwaXJhbChjaGlsZE1hcmtlcnMubGVuZ3RoLCBjZW50ZXIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y2VudGVyLnkgKz0gMTA7IC8vIE90aGVyd2lzZSBjaXJjbGVzIGxvb2sgd3JvbmcgPT4gaGFjayBmb3Igc3RhbmRhcmQgYmx1ZSBpY29uLCByZW5kZXJzIGRpZmZlcmVudGx5IGZvciBvdGhlciBpY29ucy5cclxuXHRcdFx0cG9zaXRpb25zID0gdGhpcy5fZ2VuZXJhdGVQb2ludHNDaXJjbGUoY2hpbGRNYXJrZXJzLmxlbmd0aCwgY2VudGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hbmltYXRpb25TcGlkZXJmeShjaGlsZE1hcmtlcnMsIHBvc2l0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0dW5zcGlkZXJmeTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XHJcblx0XHQvLy8gPHBhcmFtIE5hbWU9XCJ6b29tRGV0YWlsc1wiPkFyZ3VtZW50IGZyb20gem9vbWFuaW0gaWYgYmVpbmcgY2FsbGVkIGluIGEgem9vbSBhbmltYXRpb24gb3IgbnVsbCBvdGhlcndpc2U8L3BhcmFtPlxyXG5cdFx0aWYgKHRoaXMuX2dyb3VwLl9pblpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fYW5pbWF0aW9uVW5zcGlkZXJmeSh6b29tRGV0YWlscyk7XHJcblxyXG5cdFx0dGhpcy5fZ3JvdXAuX3NwaWRlcmZpZWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZW5lcmF0ZVBvaW50c0NpcmNsZTogZnVuY3Rpb24gKGNvdW50LCBjZW50ZXJQdCkge1xyXG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyICogdGhpcy5fY2lyY2xlRm9vdFNlcGFyYXRpb24gKiAoMiArIGNvdW50KSxcclxuXHRcdFx0bGVnTGVuZ3RoID0gY2lyY3VtZmVyZW5jZSAvIHRoaXMuXzJQSSwgIC8vcmFkaXVzIGZyb20gY2lyY3VtZmVyZW5jZVxyXG5cdFx0XHRhbmdsZVN0ZXAgPSB0aGlzLl8yUEkgLyBjb3VudCxcclxuXHRcdFx0cmVzID0gW10sXHJcblx0XHRcdGksIGFuZ2xlO1xyXG5cclxuXHRcdGxlZ0xlbmd0aCA9IE1hdGgubWF4KGxlZ0xlbmd0aCwgMzUpOyAvLyBNaW5pbXVtIGRpc3RhbmNlIHRvIGdldCBvdXRzaWRlIHRoZSBjbHVzdGVyIGljb24uXHJcblxyXG5cdFx0cmVzLmxlbmd0aCA9IGNvdW50O1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7IC8vIENsb2Nrd2lzZSwgbGlrZSBzcGlyYWwuXHJcblx0XHRcdGFuZ2xlID0gdGhpcy5fY2lyY2xlU3RhcnRBbmdsZSArIGkgKiBhbmdsZVN0ZXA7XHJcblx0XHRcdHJlc1tpXSA9IG5ldyBMLlBvaW50KGNlbnRlclB0LnggKyBsZWdMZW5ndGggKiBNYXRoLmNvcyhhbmdsZSksIGNlbnRlclB0LnkgKyBsZWdMZW5ndGggKiBNYXRoLnNpbihhbmdsZSkpLl9yb3VuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXM7XHJcblx0fSxcclxuXHJcblx0X2dlbmVyYXRlUG9pbnRzU3BpcmFsOiBmdW5jdGlvbiAoY291bnQsIGNlbnRlclB0KSB7XHJcblx0XHR2YXIgc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgPSB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyLFxyXG5cdFx0XHRsZWdMZW5ndGggPSBzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbExlbmd0aFN0YXJ0LFxyXG5cdFx0XHRzZXBhcmF0aW9uID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxGb290U2VwYXJhdGlvbixcclxuXHRcdFx0bGVuZ3RoRmFjdG9yID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxMZW5ndGhGYWN0b3IgKiB0aGlzLl8yUEksXHJcblx0XHRcdGFuZ2xlID0gMCxcclxuXHRcdFx0cmVzID0gW10sXHJcblx0XHRcdGk7XHJcblxyXG5cdFx0cmVzLmxlbmd0aCA9IGNvdW50O1xyXG5cclxuXHRcdC8vIEhpZ2hlciBpbmRleCwgY2xvc2VyIHBvc2l0aW9uIHRvIGNsdXN0ZXIgY2VudGVyLlxyXG5cdFx0Zm9yIChpID0gY291bnQ7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdC8vIFNraXAgdGhlIGZpcnN0IHBvc2l0aW9uLCBzbyB0aGF0IHdlIGFyZSBhbHJlYWR5IGZhcnRoZXIgZnJvbSBjZW50ZXIgYW5kIHdlIGF2b2lkXHJcblx0XHRcdC8vIGJlaW5nIHVuZGVyIHRoZSBkZWZhdWx0IGNsdXN0ZXIgaWNvbiAoZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yIENpcmNsZSBNYXJrZXJzKS5cclxuXHRcdFx0aWYgKGkgPCBjb3VudCkge1xyXG5cdFx0XHRcdHJlc1tpXSA9IG5ldyBMLlBvaW50KGNlbnRlclB0LnggKyBsZWdMZW5ndGggKiBNYXRoLmNvcyhhbmdsZSksIGNlbnRlclB0LnkgKyBsZWdMZW5ndGggKiBNYXRoLnNpbihhbmdsZSkpLl9yb3VuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFuZ2xlICs9IHNlcGFyYXRpb24gLyBsZWdMZW5ndGggKyBpICogMC4wMDA1O1xyXG5cdFx0XHRsZWdMZW5ndGggKz0gbGVuZ3RoRmFjdG9yIC8gYW5nbGU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH0sXHJcblxyXG5cdF9ub2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBncm91cCA9IHRoaXMuX2dyb3VwLFxyXG5cdFx0XHRtYXAgPSBncm91cC5fbWFwLFxyXG5cdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKG51bGwsIHRydWUpLFxyXG5cdFx0XHRtLCBpO1xyXG5cclxuXHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnNldE9wYWNpdHkoMSk7XHJcblx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xyXG5cclxuXHRcdFx0aWYgKG0uX3ByZVNwaWRlcmZ5TGF0bG5nKSB7XHJcblx0XHRcdFx0bS5zZXRMYXRMbmcobS5fcHJlU3BpZGVyZnlMYXRsbmcpO1xyXG5cdFx0XHRcdGRlbGV0ZSBtLl9wcmVTcGlkZXJmeUxhdGxuZztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgwKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG0uX3NwaWRlckxlZykge1xyXG5cdFx0XHRcdG1hcC5yZW1vdmVMYXllcihtLl9zcGlkZXJMZWcpO1xyXG5cdFx0XHRcdGRlbGV0ZSBtLl9zcGlkZXJMZWc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRncm91cC5maXJlKCd1bnNwaWRlcmZpZWQnLCB7XHJcblx0XHRcdGNsdXN0ZXI6IHRoaXMsXHJcblx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xyXG5cdFx0fSk7XHJcblx0XHRncm91cC5faWdub3JlTW92ZSA9IGZhbHNlO1xyXG5cdFx0Z3JvdXAuX3NwaWRlcmZpZWQgPSBudWxsO1xyXG5cdH1cclxufSk7XHJcblxyXG4vL05vbiBBbmltYXRlZCB2ZXJzaW9ucyBvZiBldmVyeXRoaW5nXHJcbkwuTWFya2VyQ2x1c3Rlck5vbkFuaW1hdGVkID0gTC5NYXJrZXJDbHVzdGVyLmV4dGVuZCh7XHJcblx0X2FuaW1hdGlvblNwaWRlcmZ5OiBmdW5jdGlvbiAoY2hpbGRNYXJrZXJzLCBwb3NpdGlvbnMpIHtcclxuXHRcdHZhciBncm91cCA9IHRoaXMuX2dyb3VwLFxyXG5cdFx0XHRtYXAgPSBncm91cC5fbWFwLFxyXG5cdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdGxlZ09wdGlvbnMgPSB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucyxcclxuXHRcdFx0aSwgbSwgbGVnLCBuZXdQb3M7XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cclxuXHRcdC8vIFRyYXZlcnNlIGluIGFzY2VuZGluZyBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCBpbm5lciBjaXJjbGVNYXJrZXJzIGFyZSBvbiB0b3Agb2YgZnVydGhlciBsZWdzLiBOb3JtYWwgbWFya2VycyBhcmUgcmUtb3JkZXJlZCBieSBuZXdQb3NpdGlvbi5cclxuXHRcdC8vIFRoZSByZXZlcnNlIG9yZGVyIHRyaWNrIG5vIGxvbmdlciBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvbiBtb2Rlcm4gYnJvd3NlcnMuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRNYXJrZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcclxuXHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdC8vIEFkZCB0aGUgbGVnIGJlZm9yZSB0aGUgbWFya2VyLCBzbyB0aGF0IGluIGNhc2UgdGhlIGxhdHRlciBpcyBhIGNpcmNsZU1hcmtlciwgdGhlIGxlZyBpcyBiZWhpbmQgaXQuXHJcblx0XHRcdGxlZyA9IG5ldyBMLlBvbHlsaW5lKFt0aGlzLl9sYXRsbmcsIG5ld1Bvc10sIGxlZ09wdGlvbnMpO1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIobGVnKTtcclxuXHRcdFx0bS5fc3BpZGVyTGVnID0gbGVnO1xyXG5cclxuXHRcdFx0Ly8gTm93IGFkZCB0aGUgbWFya2VyLlxyXG5cdFx0XHRtLl9wcmVTcGlkZXJmeUxhdGxuZyA9IG0uX2xhdGxuZztcclxuXHRcdFx0bS5zZXRMYXRMbmcobmV3UG9zKTtcclxuXHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XHJcblx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMTAwMDAwMCk7IC8vTWFrZSB0aGVzZSBhcHBlYXIgb24gdG9wIG9mIEVWRVJZVEhJTkdcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZmcuYWRkTGF5ZXIobSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLnNldE9wYWNpdHkoMC4zKTtcclxuXHJcblx0XHRncm91cC5faWdub3JlTW92ZSA9IGZhbHNlO1xyXG5cdFx0Z3JvdXAuZmlyZSgnc3BpZGVyZmllZCcsIHtcclxuXHRcdFx0Y2x1c3RlcjogdGhpcyxcclxuXHRcdFx0bWFya2VyczogY2hpbGRNYXJrZXJzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vQW5pbWF0ZWQgdmVyc2lvbnMgaGVyZVxyXG5MLk1hcmtlckNsdXN0ZXIuaW5jbHVkZSh7XHJcblxyXG5cdF9hbmltYXRpb25TcGlkZXJmeTogZnVuY3Rpb24gKGNoaWxkTWFya2VycywgcG9zaXRpb25zKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzLFxyXG5cdFx0XHRncm91cCA9IHRoaXMuX2dyb3VwLFxyXG5cdFx0XHRtYXAgPSBncm91cC5fbWFwLFxyXG5cdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdHRoaXNMYXllckxhdExuZyA9IHRoaXMuX2xhdGxuZyxcclxuXHRcdFx0dGhpc0xheWVyUG9zID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzTGF5ZXJMYXRMbmcpLFxyXG5cdFx0XHRzdmcgPSBMLlBhdGguU1ZHLFxyXG5cdFx0XHRsZWdPcHRpb25zID0gTC5leHRlbmQoe30sIHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyTGVnUG9seWxpbmVPcHRpb25zKSwgLy8gQ29weSB0aGUgb3B0aW9ucyBzbyB0aGF0IHdlIGNhbiBtb2RpZnkgdGhlbSBmb3IgYW5pbWF0aW9uLlxyXG5cdFx0XHRmaW5hbExlZ09wYWNpdHkgPSBsZWdPcHRpb25zLm9wYWNpdHksXHJcblx0XHRcdGksIG0sIGxlZywgbGVnUGF0aCwgbGVnTGVuZ3RoLCBuZXdQb3M7XHJcblxyXG5cdFx0aWYgKGZpbmFsTGVnT3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGZpbmFsTGVnT3BhY2l0eSA9IEwuTWFya2VyQ2x1c3Rlckdyb3VwLnByb3RvdHlwZS5vcHRpb25zLnNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucy5vcGFjaXR5O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdmcpIHtcclxuXHRcdFx0Ly8gSWYgdGhlIGluaXRpYWwgb3BhY2l0eSBvZiB0aGUgc3BpZGVyIGxlZyBpcyBub3QgMCB0aGVuIGl0IGFwcGVhcnMgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzLlxyXG5cdFx0XHRsZWdPcHRpb25zLm9wYWNpdHkgPSAwO1xyXG5cclxuXHRcdFx0Ly8gQWRkIHRoZSBjbGFzcyBmb3IgQ1NTIHRyYW5zaXRpb25zLlxyXG5cdFx0XHRsZWdPcHRpb25zLmNsYXNzTmFtZSA9IChsZWdPcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtY2x1c3Rlci1zcGlkZXItbGVnJztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgZGVmaW5lZCBvcGFjaXR5LlxyXG5cdFx0XHRsZWdPcHRpb25zLm9wYWNpdHkgPSBmaW5hbExlZ09wYWNpdHk7XHJcblx0XHR9XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cclxuXHRcdC8vIEFkZCBtYXJrZXJzIGFuZCBzcGlkZXIgbGVncyB0byBtYXAsIGhpZGRlbiBhdCBvdXIgY2VudGVyIHBvaW50LlxyXG5cdFx0Ly8gVHJhdmVyc2UgaW4gYXNjZW5kaW5nIG9yZGVyIHRvIG1ha2Ugc3VyZSB0aGF0IGlubmVyIGNpcmNsZU1hcmtlcnMgYXJlIG9uIHRvcCBvZiBmdXJ0aGVyIGxlZ3MuIE5vcm1hbCBtYXJrZXJzIGFyZSByZS1vcmRlcmVkIGJ5IG5ld1Bvc2l0aW9uLlxyXG5cdFx0Ly8gVGhlIHJldmVyc2Ugb3JkZXIgdHJpY2sgbm8gbG9uZ2VyIGltcHJvdmVzIHBlcmZvcm1hbmNlIG9uIG1vZGVybiBicm93c2Vycy5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZE1hcmtlcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcclxuXHJcblx0XHRcdC8vIEFkZCB0aGUgbGVnIGJlZm9yZSB0aGUgbWFya2VyLCBzbyB0aGF0IGluIGNhc2UgdGhlIGxhdHRlciBpcyBhIGNpcmNsZU1hcmtlciwgdGhlIGxlZyBpcyBiZWhpbmQgaXQuXHJcblx0XHRcdGxlZyA9IG5ldyBMLlBvbHlsaW5lKFt0aGlzTGF5ZXJMYXRMbmcsIG5ld1Bvc10sIGxlZ09wdGlvbnMpO1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIobGVnKTtcclxuXHRcdFx0bS5fc3BpZGVyTGVnID0gbGVnO1xyXG5cclxuXHRcdFx0Ly8gRXhwbGFuYXRpb25zOiBodHRwczovL2pha2VhcmNoaWJhbGQuY29tLzIwMTMvYW5pbWF0ZWQtbGluZS1kcmF3aW5nLXN2Zy9cclxuXHRcdFx0Ly8gSW4gb3VyIGNhc2UgdGhlIHRyYW5zaXRpb24gcHJvcGVydHkgaXMgZGVjbGFyZWQgaW4gdGhlIENTUyBmaWxlLlxyXG5cdFx0XHRpZiAoc3ZnKSB7XHJcblx0XHRcdFx0bGVnUGF0aCA9IGxlZy5fcGF0aDtcclxuXHRcdFx0XHRsZWdMZW5ndGggPSBsZWdQYXRoLmdldFRvdGFsTGVuZ3RoKCkgKyAwLjE7IC8vIE5lZWQgYSBzbWFsbCBleHRyYSBsZW5ndGggdG8gYXZvaWQgcmVtYWluaW5nIGRvdCBpbiBGaXJlZm94LlxyXG5cdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaGFycmF5ID0gbGVnTGVuZ3RoOyAvLyBKdXN0IDEgbGVuZ3RoIGlzIGVub3VnaCwgaXQgd2lsbCBiZSBkdXBsaWNhdGVkLlxyXG5cdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IGxlZ0xlbmd0aDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgaXQgaXMgYSBtYXJrZXIsIGFkZCBpdCBub3cgYW5kIHdlJ2xsIGFuaW1hdGUgaXQgb3V0XHJcblx0XHRcdGlmIChtLnNldFpJbmRleE9mZnNldCkge1xyXG5cdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDEwMDAwMDApOyAvLyBNYWtlIG5vcm1hbCBtYXJrZXJzIGFwcGVhciBvbiB0b3Agb2YgRVZFUllUSElOR1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtLmNsdXN0ZXJIaWRlKSB7XHJcblx0XHRcdFx0bS5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBWZWN0b3JzIGp1c3QgZ2V0IGltbWVkaWF0ZWx5IGFkZGVkXHJcblx0XHRcdGZnLmFkZExheWVyKG0pO1xyXG5cclxuXHRcdFx0aWYgKG0uX3NldFBvcykge1xyXG5cdFx0XHRcdG0uX3NldFBvcyh0aGlzTGF5ZXJQb3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Z3JvdXAuX2ZvcmNlTGF5b3V0KCk7XHJcblx0XHRncm91cC5fYW5pbWF0aW9uU3RhcnQoKTtcclxuXHJcblx0XHQvLyBSZXZlYWwgbWFya2VycyBhbmQgc3BpZGVyIGxlZ3MuXHJcblx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0bmV3UG9zID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhwb3NpdGlvbnNbaV0pO1xyXG5cdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0Ly9Nb3ZlIG1hcmtlciB0byBuZXcgcG9zaXRpb25cclxuXHRcdFx0bS5fcHJlU3BpZGVyZnlMYXRsbmcgPSBtLl9sYXRsbmc7XHJcblx0XHRcdG0uc2V0TGF0TG5nKG5ld1Bvcyk7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQW5pbWF0ZSBsZWcgKGFuaW1hdGlvbiBpcyBhY3R1YWxseSBkZWxlZ2F0ZWQgdG8gQ1NTIHRyYW5zaXRpb24pLlxyXG5cdFx0XHRpZiAoc3ZnKSB7XHJcblx0XHRcdFx0bGVnID0gbS5fc3BpZGVyTGVnO1xyXG5cdFx0XHRcdGxlZ1BhdGggPSBsZWcuX3BhdGg7XHJcblx0XHRcdFx0bGVnUGF0aC5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gMDtcclxuXHRcdFx0XHQvL2xlZ1BhdGguc3R5bGUuc3Ryb2tlT3BhY2l0eSA9IGZpbmFsTGVnT3BhY2l0eTtcclxuXHRcdFx0XHRsZWcuc2V0U3R5bGUoe29wYWNpdHk6IGZpbmFsTGVnT3BhY2l0eX0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLnNldE9wYWNpdHkoMC4zKTtcclxuXHJcblx0XHRncm91cC5faWdub3JlTW92ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRncm91cC5fYW5pbWF0aW9uRW5kKCk7XHJcblx0XHRcdGdyb3VwLmZpcmUoJ3NwaWRlcmZpZWQnLCB7XHJcblx0XHRcdFx0Y2x1c3RlcjogbWUsXHJcblx0XHRcdFx0bWFya2VyczogY2hpbGRNYXJrZXJzXHJcblx0XHRcdH0pO1xyXG5cdFx0fSwgMjAwKTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XHJcblx0XHR2YXIgbWUgPSB0aGlzLFxyXG5cdFx0XHRncm91cCA9IHRoaXMuX2dyb3VwLFxyXG5cdFx0XHRtYXAgPSBncm91cC5fbWFwLFxyXG5cdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdHRoaXNMYXllclBvcyA9IHpvb21EZXRhaWxzID8gbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCB6b29tRGV0YWlscy56b29tLCB6b29tRGV0YWlscy5jZW50ZXIpIDogbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0XHRjaGlsZE1hcmtlcnMgPSB0aGlzLmdldEFsbENoaWxkTWFya2VycyhudWxsLCB0cnVlKSxcclxuXHRcdFx0c3ZnID0gTC5QYXRoLlNWRyxcclxuXHRcdFx0bSwgaSwgbGVnLCBsZWdQYXRoLCBsZWdMZW5ndGgsIG5vbkFuaW1hdGFibGU7XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cdFx0Z3JvdXAuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblxyXG5cdFx0Ly9NYWtlIHVzIHZpc2libGUgYW5kIGJyaW5nIHRoZSBjaGlsZCBtYXJrZXJzIGJhY2sgaW5cclxuXHRcdHRoaXMuc2V0T3BhY2l0eSgxKTtcclxuXHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0Ly9NYXJrZXIgd2FzIGFkZGVkIHRvIHVzIGFmdGVyIHdlIHdlcmUgc3BpZGVyZmllZFxyXG5cdFx0XHRpZiAoIW0uX3ByZVNwaWRlcmZ5TGF0bG5nKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vQ2xvc2UgYW55IHBvcHVwIG9uIHRoZSBtYXJrZXIgZmlyc3QsIG90aGVyd2lzZSBzZXR0aW5nIHRoZSBsb2NhdGlvbiBvZiB0aGUgbWFya2VyIHdpbGwgbWFrZSB0aGUgbWFwIHNjcm9sbFxyXG5cdFx0XHRtLmNsb3NlUG9wdXAoKTtcclxuXHJcblx0XHRcdC8vRml4IHVwIHRoZSBsb2NhdGlvbiB0byB0aGUgcmVhbCBvbmVcclxuXHRcdFx0bS5zZXRMYXRMbmcobS5fcHJlU3BpZGVyZnlMYXRsbmcpO1xyXG5cdFx0XHRkZWxldGUgbS5fcHJlU3BpZGVyZnlMYXRsbmc7XHJcblxyXG5cdFx0XHQvL0hhY2sgb3ZlcnJpZGUgdGhlIGxvY2F0aW9uIHRvIGJlIG91ciBjZW50ZXJcclxuXHRcdFx0bm9uQW5pbWF0YWJsZSA9IHRydWU7XHJcblx0XHRcdGlmIChtLl9zZXRQb3MpIHtcclxuXHRcdFx0XHRtLl9zZXRQb3ModGhpc0xheWVyUG9zKTtcclxuXHRcdFx0XHRub25BbmltYXRhYmxlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG0uY2x1c3RlckhpZGUpIHtcclxuXHRcdFx0XHRtLmNsdXN0ZXJIaWRlKCk7XHJcblx0XHRcdFx0bm9uQW5pbWF0YWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChub25BbmltYXRhYmxlKSB7XHJcblx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFuaW1hdGUgdGhlIHNwaWRlciBsZWcgYmFjayBpbiAoYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGRlbGVnYXRlZCB0byBDU1MgdHJhbnNpdGlvbikuXHJcblx0XHRcdGlmIChzdmcpIHtcclxuXHRcdFx0XHRsZWcgPSBtLl9zcGlkZXJMZWc7XHJcblx0XHRcdFx0bGVnUGF0aCA9IGxlZy5fcGF0aDtcclxuXHRcdFx0XHRsZWdMZW5ndGggPSBsZWdQYXRoLmdldFRvdGFsTGVuZ3RoKCkgKyAwLjE7XHJcblx0XHRcdFx0bGVnUGF0aC5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gbGVnTGVuZ3RoO1xyXG5cdFx0XHRcdGxlZy5zZXRTdHlsZSh7b3BhY2l0eTogMH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHJcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly9JZiB3ZSBoYXZlIG9ubHkgPD0gb25lIGNoaWxkIGxlZnQgdGhlbiB0aGF0IG1hcmtlciB3aWxsIGJlIHNob3duIG9uIHRoZSBtYXAgc28gZG9uJ3QgcmVtb3ZlIGl0IVxyXG5cdFx0XHR2YXIgc3RpbGxUaGVyZUNoaWxkQ291bnQgPSAwO1xyXG5cdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cdFx0XHRcdGlmIChtLl9zcGlkZXJMZWcpIHtcclxuXHRcdFx0XHRcdHN0aWxsVGhlcmVDaGlsZENvdW50Kys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdFx0aWYgKCFtLl9zcGlkZXJMZWcpIHsgLy9IYXMgYWxyZWFkeSBiZWVuIHVuc3BpZGVyZmllZFxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHN0aWxsVGhlcmVDaGlsZENvdW50ID4gMSkge1xyXG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtYXAucmVtb3ZlTGF5ZXIobS5fc3BpZGVyTGVnKTtcclxuXHRcdFx0XHRkZWxldGUgbS5fc3BpZGVyTGVnO1xyXG5cdFx0XHR9XHJcblx0XHRcdGdyb3VwLl9hbmltYXRpb25FbmQoKTtcclxuXHRcdFx0Z3JvdXAuZmlyZSgndW5zcGlkZXJmaWVkJywge1xyXG5cdFx0XHRcdGNsdXN0ZXI6IG1lLFxyXG5cdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sIDIwMCk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5MLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcclxuXHQvL1RoZSBNYXJrZXJDbHVzdGVyIGN1cnJlbnRseSBzcGlkZXJmaWVkIChpZiBhbnkpXHJcblx0X3NwaWRlcmZpZWQ6IG51bGwsXHJcblxyXG5cdHVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3Vuc3BpZGVyZnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHR9LFxyXG5cclxuXHRfc3BpZGVyZmllck9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fdW5zcGlkZXJmeVdyYXBwZXIsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignem9vbXN0YXJ0JywgdGhpcy5fdW5zcGlkZXJmeVpvb21TdGFydCwgdGhpcyk7XHJcblx0XHR9XHJcblx0XHQvL0Jyb3dzZXJzIHdpdGhvdXQgem9vbUFuaW1hdGlvbiBvciBhIGJpZyB6b29tIGRvbid0IGZpcmUgem9vbXN0YXJ0XHJcblx0XHR0aGlzLl9tYXAub24oJ3pvb21lbmQnLCB0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnksIHRoaXMpO1xyXG5cclxuXHRcdGlmICghTC5Ccm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRSZW5kZXJlcih0aGlzKTtcclxuXHRcdFx0Ly9OZWVkcyB0byBoYXBwZW4gaW4gdGhlIHBhZ2Vsb2FkLCBub3QgYWZ0ZXIsIG9yIGFuaW1hdGlvbnMgZG9uJ3Qgd29yayBpbiB3ZWJraXRcclxuXHRcdFx0Ly8gIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1NTIwMC9zdmctYW5pbWF0ZS13aXRoLWR5bmFtaWNhbGx5LWFkZGVkLWVsZW1lbnRzXHJcblx0XHRcdC8vRGlzYWJsZSBvbiB0b3VjaCBicm93c2VycyBhcyB0aGUgYW5pbWF0aW9uIG1lc3NlcyB1cCBvbiBhIHRvdWNoIHpvb20gYW5kIGlzbid0IHZlcnkgbm90aWNhYmxlXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3NwaWRlcmZpZXJPblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl91bnNwaWRlcmZ5V3JhcHBlciwgdGhpcyk7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tc3RhcnQnLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbVN0YXJ0LCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnksIHRoaXMpO1xyXG5cclxuXHRcdC8vRW5zdXJlIHRoYXQgbWFya2VycyBhcmUgYmFjayB3aGVyZSB0aGV5IHNob3VsZCBiZVxyXG5cdFx0Ly8gVXNlIG5vIGFuaW1hdGlvbiB0byBhdm9pZCBhIHN0aWNreSBsZWFmbGV0LWNsdXN0ZXItYW5pbSBjbGFzcyBvbiBtYXBQYW5lXHJcblx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcclxuXHR9LFxyXG5cclxuXHQvL09uIHpvb20gc3RhcnQgd2UgYWRkIGEgem9vbWFuaW0gaGFuZGxlciBzbyB0aGF0IHdlIGFyZSBndWFyYW50ZWVkIHRvIGJlIGxhc3QgKGFmdGVyIG1hcmtlcnMgYXJlIGFuaW1hdGVkKVxyXG5cdC8vVGhpcyBtZWFucyB3ZSBjYW4gZGVmaW5lIHRoZSBhbmltYXRpb24gdGhleSBkbyByYXRoZXIgdGhhbiBNYXJrZXJzIGRvaW5nIGFuIGFuaW1hdGlvbiB0byB0aGVpciBhY3R1YWwgbG9jYXRpb25cclxuXHRfdW5zcGlkZXJmeVpvb21TdGFydDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgLy9NYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGJ5IGEgem9vbUVuZCBoYW5kbGVyXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub24oJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfdW5zcGlkZXJmeVpvb21BbmltOiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcclxuXHRcdC8vV2FpdCB1bnRpbCB0aGUgZmlyc3Qgem9vbWFuaW0gYWZ0ZXIgdGhlIHVzZXIgaGFzIGZpbmlzaGVkIHRvdWNoLXpvb21pbmcgYmVmb3JlIHJ1bm5pbmcgdGhlIGFuaW1hdGlvblxyXG5cdFx0aWYgKEwuRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9tYXAuX21hcFBhbmUsICdsZWFmbGV0LXRvdWNoaW5nJykpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHRcdHRoaXMuX3Vuc3BpZGVyZnkoem9vbURldGFpbHMpO1xyXG5cdH0sXHJcblxyXG5cdF91bnNwaWRlcmZ5V3JhcHBlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8vIDxzdW1tYXJ5Pl91bnNwaWRlcmZ5IGJ1dCBwYXNzZXMgbm8gYXJndW1lbnRzPC9zdW1tYXJ5PlxyXG5cdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cdH0sXHJcblxyXG5cdF91bnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcclxuXHRcdGlmICh0aGlzLl9zcGlkZXJmaWVkKSB7XHJcblx0XHRcdHRoaXMuX3NwaWRlcmZpZWQudW5zcGlkZXJmeSh6b29tRGV0YWlscyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NwaWRlcmZpZWQpIHtcclxuXHRcdFx0dGhpcy5fc3BpZGVyZmllZC5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9JZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGJlaW5nIHNwaWRlcmZpZWQgdGhlbiB3ZSB1bnNwaWRlcmZ5IGl0IHNvIGl0IGlzbid0IG9uIHRoZSBtYXAgYW55bW9yZSBldGNcclxuXHRfdW5zcGlkZXJmeUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmIChsYXllci5fc3BpZGVyTGVnKSB7XHJcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihsYXllcik7XHJcblxyXG5cdFx0XHRpZiAobGF5ZXIuY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRsYXllci5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFx0Ly9Qb3NpdGlvbiB3aWxsIGJlIGZpeGVkIHVwIGltbWVkaWF0ZWx5IGluIF9hbmltYXRpb25VbnNwaWRlcmZ5XHJcblx0XHRcdGlmIChsYXllci5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRsYXllci5zZXRaSW5kZXhPZmZzZXQoMCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihsYXllci5fc3BpZGVyTGVnKTtcclxuXHRcdFx0ZGVsZXRlIGxheWVyLl9zcGlkZXJMZWc7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcblxuLyoqXHJcbiAqIEFkZHMgMSBwdWJsaWMgbWV0aG9kIHRvIE1DRyBhbmQgMSB0byBMLk1hcmtlciB0byBmYWNpbGl0YXRlIGNoYW5naW5nXHJcbiAqIG1hcmtlcnMnIGljb24gb3B0aW9ucyBhbmQgcmVmcmVzaGluZyB0aGVpciBpY29uIGFuZCB0aGVpciBwYXJlbnQgY2x1c3RlcnNcclxuICogYWNjb3JkaW5nbHkgKGNhc2Ugd2hlcmUgdGhlaXIgaWNvbkNyZWF0ZUZ1bmN0aW9uIHVzZXMgZGF0YSBvZiBjaGlsZE1hcmtlcnNcclxuICogdG8gbWFrZSB1cCB0aGUgY2x1c3RlciBpY29uKS5cclxuICovXHJcblxyXG5cclxuTC5NYXJrZXJDbHVzdGVyR3JvdXAuaW5jbHVkZSh7XHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGUgaWNvbiBvZiBhbGwgY2x1c3RlcnMgd2hpY2ggYXJlIHBhcmVudHMgb2YgdGhlIGdpdmVuIG1hcmtlcihzKS5cclxuXHQgKiBJbiBzaW5nbGVNYXJrZXJNb2RlLCBhbHNvIHVwZGF0ZXMgdGhlIGdpdmVuIG1hcmtlcihzKSBpY29uLlxyXG5cdCAqIEBwYXJhbSBsYXllcnMgTC5NYXJrZXJDbHVzdGVyR3JvdXB8TC5MYXllckdyb3VwfEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpfFxyXG5cdCAqIEwuTWFya2VyQ2x1c3RlcnxMLk1hcmtlciAob3B0aW9uYWwpIGxpc3Qgb2YgbWFya2VycyAob3Igc2luZ2xlIG1hcmtlcikgd2hvc2UgcGFyZW50XHJcblx0ICogY2x1c3RlcnMgbmVlZCB0byBiZSB1cGRhdGVkLiBJZiBub3QgcHJvdmlkZWQsIHJldHJpZXZlcyBhbGwgY2hpbGQgbWFya2VycyBvZiB0aGlzLlxyXG5cdCAqIEByZXR1cm5zIHtMLk1hcmtlckNsdXN0ZXJHcm91cH1cclxuXHQgKi9cclxuXHRyZWZyZXNoQ2x1c3RlcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRcdGlmICghbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVycyA9IHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5nZXRBbGxDaGlsZE1hcmtlcnMoKTtcclxuXHRcdH0gZWxzZSBpZiAobGF5ZXJzIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyR3JvdXApIHtcclxuXHRcdFx0bGF5ZXJzID0gbGF5ZXJzLl90b3BDbHVzdGVyTGV2ZWwuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XHJcblx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRsYXllcnMgPSBsYXllcnMuX2xheWVycztcclxuXHRcdH0gZWxzZSBpZiAobGF5ZXJzIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyKSB7XHJcblx0XHRcdGxheWVycyA9IGxheWVycy5nZXRBbGxDaGlsZE1hcmtlcnMoKTtcclxuXHRcdH0gZWxzZSBpZiAobGF5ZXJzIGluc3RhbmNlb2YgTC5NYXJrZXIpIHtcclxuXHRcdFx0bGF5ZXJzID0gW2xheWVyc107XHJcblx0XHR9IC8vIGVsc2U6IG11c3QgYmUgYW4gQXJyYXkoTC5NYXJrZXIpfE1hcChMLk1hcmtlcilcclxuXHRcdHRoaXMuX2ZsYWdQYXJlbnRzSWNvbnNOZWVkVXBkYXRlKGxheWVycyk7XHJcblx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xyXG5cclxuXHRcdC8vIEluIGNhc2Ugb2Ygc2luZ2xlTWFya2VyTW9kZSwgYWxzbyByZS1kcmF3IHRoZSBtYXJrZXJzLlxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVNYXJrZXJNb2RlKSB7XHJcblx0XHRcdHRoaXMuX3JlZnJlc2hTaW5nbGVNYXJrZXJNb2RlTWFya2VycyhsYXllcnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNpbXBseSBmbGFncyBhbGwgcGFyZW50IGNsdXN0ZXJzIG9mIHRoZSBnaXZlbiBtYXJrZXJzIGFzIGhhdmluZyBhIFwiZGlydHlcIiBpY29uLlxyXG5cdCAqIEBwYXJhbSBsYXllcnMgQXJyYXkoTC5NYXJrZXIpfE1hcChMLk1hcmtlcikgbGlzdCBvZiBtYXJrZXJzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2ZsYWdQYXJlbnRzSWNvbnNOZWVkVXBkYXRlOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHR2YXIgaWQsIHBhcmVudDtcclxuXHJcblx0XHQvLyBBc3N1bWVzIGxheWVycyBpcyBhbiBBcnJheSBvciBhbiBPYmplY3Qgd2hvc2UgcHJvdG90eXBlIGlzIG5vbi1lbnVtZXJhYmxlLlxyXG5cdFx0Zm9yIChpZCBpbiBsYXllcnMpIHtcclxuXHRcdFx0Ly8gRmxhZyBwYXJlbnQgY2x1c3RlcnMnIGljb24gYXMgXCJkaXJ0eVwiLCBhbGwgdGhlIHdheSB1cC5cclxuXHRcdFx0Ly8gRHVtYiBwcm9jZXNzIHRoYXQgZmxhZ3MgbXVsdGlwbGUgdGltZXMgdXBwZXIgcGFyZW50cywgYnV0IHN0aWxsXHJcblx0XHRcdC8vIG11Y2ggbW9yZSBlZmZpY2llbnQgdGhhbiB0cnlpbmcgdG8gYmUgc21hcnQgYW5kIG1ha2Ugc2hvcnQgbGlzdHMsXHJcblx0XHRcdC8vIGF0IGxlYXN0IGluIHRoZSBjYXNlIG9mIGEgaGllcmFyY2h5IGZvbGxvd2luZyBhIHBvd2VyIGxhdzpcclxuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vZmxhZy1ub2Rlcy1pbi1wb3dlci1oaWVyYXJjaHkvMlxyXG5cdFx0XHRwYXJlbnQgPSBsYXllcnNbaWRdLl9fcGFyZW50O1xyXG5cdFx0XHR3aGlsZSAocGFyZW50KSB7XHJcblx0XHRcdFx0cGFyZW50Ll9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdHBhcmVudCA9IHBhcmVudC5fX3BhcmVudDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlLWRyYXdzIHRoZSBpY29uIG9mIHRoZSBzdXBwbGllZCBtYXJrZXJzLlxyXG5cdCAqIFRvIGJlIHVzZWQgaW4gc2luZ2xlTWFya2VyTW9kZSBvbmx5LlxyXG5cdCAqIEBwYXJhbSBsYXllcnMgQXJyYXkoTC5NYXJrZXIpfE1hcChMLk1hcmtlcikgbGlzdCBvZiBtYXJrZXJzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3JlZnJlc2hTaW5nbGVNYXJrZXJNb2RlTWFya2VyczogZnVuY3Rpb24gKGxheWVycykge1xyXG5cdFx0dmFyIGlkLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGlkIGluIGxheWVycykge1xyXG5cdFx0XHRsYXllciA9IGxheWVyc1tpZF07XHJcblxyXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UgZG8gbm90IG92ZXJyaWRlIG1hcmtlcnMgdGhhdCBkbyBub3QgYmVsb25nIHRvIFRISVMgZ3JvdXAuXHJcblx0XHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRcdC8vIE5lZWQgdG8gcmUtY3JlYXRlIHRoZSBpY29uIGZpcnN0LCB0aGVuIHJlLWRyYXcgdGhlIG1hcmtlci5cclxuXHRcdFx0XHRsYXllci5zZXRJY29uKHRoaXMuX292ZXJyaWRlTWFya2VySWNvbihsYXllcikpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoe1xyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIGdpdmVuIG9wdGlvbnMgaW4gdGhlIG1hcmtlcidzIGljb24gYW5kIHJlZnJlc2hlcyB0aGUgbWFya2VyLlxyXG5cdCAqIEBwYXJhbSBvcHRpb25zIG1hcCBvYmplY3Qgb2YgaWNvbiBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSBkaXJlY3RseVJlZnJlc2hDbHVzdGVycyBib29sZWFuIChvcHRpb25hbCkgdHJ1ZSB0byB0cmlnZ2VyXHJcblx0ICogTUNHLnJlZnJlc2hDbHVzdGVyc09mKCkgcmlnaHQgYXdheSB3aXRoIHRoaXMgc2luZ2xlIG1hcmtlci5cclxuXHQgKiBAcmV0dXJucyB7TC5NYXJrZXJ9XHJcblx0ICovXHJcblx0cmVmcmVzaEljb25PcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucywgZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMpIHtcclxuXHRcdHZhciBpY29uID0gdGhpcy5vcHRpb25zLmljb247XHJcblxyXG5cdFx0TC5zZXRPcHRpb25zKGljb24sIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuc2V0SWNvbihpY29uKTtcclxuXHJcblx0XHQvLyBTaG9ydGN1dCB0byByZWZyZXNoIHRoZSBhc3NvY2lhdGVkIE1DRyBjbHVzdGVycyByaWdodCBhd2F5LlxyXG5cdFx0Ly8gVG8gYmUgdXNlZCB3aGVuIHJlZnJlc2hpbmcgYSBzaW5nbGUgbWFya2VyLlxyXG5cdFx0Ly8gT3RoZXJ3aXNlLCBiZXR0ZXIgdXNlIE1DRy5yZWZyZXNoQ2x1c3RlcnMoKSBvbmNlIGF0IHRoZSBlbmQgd2l0aFxyXG5cdFx0Ly8gdGhlIGxpc3Qgb2YgbW9kaWZpZWQgbWFya2Vycy5cclxuXHRcdGlmIChkaXJlY3RseVJlZnJlc2hDbHVzdGVycyAmJiB0aGlzLl9fcGFyZW50KSB7XHJcblx0XHRcdHRoaXMuX19wYXJlbnQuX2dyb3VwLnJlZnJlc2hDbHVzdGVycyh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xuXG5leHBvcnRzLk1hcmtlckNsdXN0ZXJHcm91cCA9IE1hcmtlckNsdXN0ZXJHcm91cDtcbmV4cG9ydHMuTWFya2VyQ2x1c3RlciA9IE1hcmtlckNsdXN0ZXI7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWFmbGV0Lm1hcmtlcmNsdXN0ZXItc3JjLmpzLm1hcFxuIiwiLyogQHByZXNlcnZlXG4gKiBMZWFmbGV0IDEuMy4xLCBhIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHMuIGh0dHA6Ly9sZWFmbGV0anMuY29tXG4gKiAoYykgMjAxMC0yMDE3IFZsYWRpbWlyIEFnYWZvbmtpbiwgKGMpIDIwMTAtMjAxMSBDbG91ZE1hZGVcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuTCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmVyc2lvbiA9IFwiMS4zLjFcIjtcblxuLypcclxuICogQG5hbWVzcGFjZSBVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbnZhciBmcmVlemUgPSBPYmplY3QuZnJlZXplO1xyXG5PYmplY3QuZnJlZXplID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqOyB9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGV4dGVuZChkZXN0OiBPYmplY3QsIHNyYz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGBzcmNgIG9iamVjdCAob3IgbXVsdGlwbGUgb2JqZWN0cykgaW50byBgZGVzdGAgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBsYXR0ZXIuIEhhcyBhbiBgTC5leHRlbmRgIHNob3J0Y3V0LlxyXG5mdW5jdGlvbiBleHRlbmQoZGVzdCkge1xyXG5cdHZhciBpLCBqLCBsZW4sIHNyYztcclxuXHJcblx0Zm9yIChqID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcblx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcblx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcblx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkZXN0O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW09iamVjdC5jcmVhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGUpXHJcbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gRigpIHt9XHJcblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG5cdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuXHRcdHJldHVybiBuZXcgRigpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG4vLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuLy8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuZnVuY3Rpb24gYmluZChmbiwgb2JqKSB7XHJcblx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuXHRpZiAoZm4uYmluZCkge1xyXG5cdFx0cmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcblx0fVxyXG5cclxuXHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XHJcblx0fTtcclxufVxyXG5cclxuLy8gQHByb3BlcnR5IGxhc3RJZDogTnVtYmVyXHJcbi8vIExhc3QgdW5pcXVlIElEIHVzZWQgYnkgW2BzdGFtcCgpYF0oI3V0aWwtc3RhbXApXHJcbnZhciBsYXN0SWQgPSAwO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBvZiBhbiBvYmplY3QsIGFzc2lnbmluZyBpdCBvbmUgaWYgaXQgZG9lc24ndCBoYXZlIGl0LlxyXG5mdW5jdGlvbiBzdGFtcChvYmopIHtcclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0b2JqLl9sZWFmbGV0X2lkID0gb2JqLl9sZWFmbGV0X2lkIHx8ICsrbGFzdElkO1xyXG5cdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4vLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4vLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbi8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbmZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcblx0dmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XHJcblxyXG5cdGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcclxuXHRcdGxvY2sgPSBmYWxzZTtcclxuXHRcdGlmIChhcmdzKSB7XHJcblx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdFx0YXJncyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChsb2NrKSB7XHJcblx0XHRcdC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxyXG5cdFx0XHRhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcclxuXHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuXHRcdFx0c2V0VGltZW91dChsYXRlciwgdGltZSk7XHJcblx0XHRcdGxvY2sgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiB3cmFwcGVyRm47XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB3cmFwTnVtKG51bTogTnVtYmVyLCByYW5nZTogTnVtYmVyW10sIGluY2x1ZGVNYXg/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXHJcbi8vIGByYW5nZVswXWAgYW5kIGByYW5nZVsxXWAuIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGFsd2F5cyBzbWFsbGVyIHRoYW5cclxuLy8gYHJhbmdlWzFdYCB1bmxlc3MgYGluY2x1ZGVNYXhgIGlzIHNldCB0byBgdHJ1ZWAuXHJcbmZ1bmN0aW9uIHdyYXBOdW0oeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcclxuXHR2YXIgbWF4ID0gcmFuZ2VbMV0sXHJcblx0ICAgIG1pbiA9IHJhbmdlWzBdLFxyXG5cdCAgICBkID0gbWF4IC0gbWluO1xyXG5cdHJldHVybiB4ID09PSBtYXggJiYgaW5jbHVkZU1heCA/IHggOiAoKHggLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZhbHNlRm4oKTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXHJcbmZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgZGlnaXRzPzogTnVtYmVyKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHRvIGBkaWdpdHNgIGRlY2ltYWxzLCBvciB0byA2IGRlY2ltYWxzIGJ5IGRlZmF1bHQuXHJcbmZ1bmN0aW9uIGZvcm1hdE51bShudW0sIGRpZ2l0cykge1xyXG5cdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgKGRpZ2l0cyA9PT0gdW5kZWZpbmVkID8gNiA6IGRpZ2l0cykpO1xyXG5cdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0cmltKHN0cjogU3RyaW5nKTogU3RyaW5nXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtTdHJpbmcucHJvdG90eXBlLnRyaW1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltKVxyXG5mdW5jdGlvbiB0cmltKHN0cikge1xyXG5cdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcbi8vIFRyaW1zIGFuZCBzcGxpdHMgdGhlIHN0cmluZyBvbiB3aGl0ZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJ0cy5cclxuZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuXHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG5mdW5jdGlvbiBzZXRPcHRpb25zKG9iaiwgb3B0aW9ucykge1xyXG5cdGlmICghb2JqLmhhc093blByb3BlcnR5KCdvcHRpb25zJykpIHtcclxuXHRcdG9iai5vcHRpb25zID0gb2JqLm9wdGlvbnMgPyBjcmVhdGUob2JqLm9wdGlvbnMpIDoge307XHJcblx0fVxyXG5cdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0b2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdH1cclxuXHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmo6IE9iamVjdCwgZXhpc3RpbmdVcmw/OiBTdHJpbmcsIHVwcGVyY2FzZT86IEJvb2xlYW4pOiBTdHJpbmdcclxuLy8gQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBwYXJhbWV0ZXIgVVJMIHN0cmluZywgZS5nLiBge2E6IFwiZm9vXCIsIGI6IFwiYmFyXCJ9YFxyXG4vLyB0cmFuc2xhdGVzIHRvIGAnP2E9Zm9vJmI9YmFyJ2AuIElmIGBleGlzdGluZ1VybGAgaXMgc2V0LCB0aGUgcGFyYW1ldGVycyB3aWxsXHJcbi8vIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQuIElmIGB1cHBlcmNhc2VgIGlzIGB0cnVlYCwgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsXHJcbi8vIGJlIHVwcGVyY2FzZWQgKGUuZy4gYCc/QT1mb28mQj1iYXInYClcclxuZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcblx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcblx0fVxyXG5cdHJldHVybiAoKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xyXG59XHJcblxyXG52YXIgdGVtcGxhdGVSZSA9IC9cXHsgKihbXFx3Xy1dKykgKlxcfS9nO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuLy8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcbi8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbi8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4vLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XHJcblx0cmV0dXJuIHN0ci5yZXBsYWNlKHRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG5cdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cclxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0FycmF5KG9iaik6IEJvb2xlYW5cclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcblx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gaW5kZXhPZihhcnJheTogQXJyYXksIGVsOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LnByb3RvdHlwZS5pbmRleE9mXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mKVxyXG5mdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbi8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4vLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG52YXIgZW1wdHlJbWFnZVVybCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG5mdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XHJcblx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcbn1cclxuXHJcbnZhciBsYXN0VGltZSA9IDA7XHJcblxyXG4vLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcbmZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG5cdHZhciB0aW1lID0gK25ldyBEYXRlKCksXHJcblx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcblx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuXHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xyXG59XHJcblxyXG52YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyO1xyXG52YXIgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gU2NoZWR1bGVzIGBmbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgYnJvd3NlciByZXBhaW50cy4gYGZuYCBpcyBib3VuZCB0b1xyXG4vLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4vLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXHJcbi8vIFtgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSxcclxuLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbmZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSkge1xyXG5cdGlmIChpbW1lZGlhdGUgJiYgcmVxdWVzdEZuID09PSB0aW1lb3V0RGVmZXIpIHtcclxuXHRcdGZuLmNhbGwoY29udGV4dCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiByZXF1ZXN0Rm4uY2FsbCh3aW5kb3csIGJpbmQoZm4sIGNvbnRleHQpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQ6IE51bWJlcik6IHVuZGVmaW5lZFxyXG4vLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkKSB7XHJcblx0aWYgKGlkKSB7XHJcblx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG5cdH1cclxufVxyXG5cblxudmFyIFV0aWwgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0ZnJlZXplOiBmcmVlemUsXG5cdGV4dGVuZDogZXh0ZW5kLFxuXHRjcmVhdGU6IGNyZWF0ZSxcblx0YmluZDogYmluZCxcblx0bGFzdElkOiBsYXN0SWQsXG5cdHN0YW1wOiBzdGFtcCxcblx0dGhyb3R0bGU6IHRocm90dGxlLFxuXHR3cmFwTnVtOiB3cmFwTnVtLFxuXHRmYWxzZUZuOiBmYWxzZUZuLFxuXHRmb3JtYXROdW06IGZvcm1hdE51bSxcblx0dHJpbTogdHJpbSxcblx0c3BsaXRXb3Jkczogc3BsaXRXb3Jkcyxcblx0c2V0T3B0aW9uczogc2V0T3B0aW9ucyxcblx0Z2V0UGFyYW1TdHJpbmc6IGdldFBhcmFtU3RyaW5nLFxuXHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdGlzQXJyYXk6IGlzQXJyYXksXG5cdGluZGV4T2Y6IGluZGV4T2YsXG5cdGVtcHR5SW1hZ2VVcmw6IGVtcHR5SW1hZ2VVcmwsXG5cdHJlcXVlc3RGbjogcmVxdWVzdEZuLFxuXHRjYW5jZWxGbjogY2FuY2VsRm4sXG5cdHJlcXVlc3RBbmltRnJhbWU6IHJlcXVlc3RBbmltRnJhbWUsXG5cdGNhbmNlbEFuaW1GcmFtZTogY2FuY2VsQW5pbUZyYW1lXG59KTtcblxuLy8gQGNsYXNzIENsYXNzXHJcbi8vIEBha2EgTC5DbGFzc1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gQHVuaW5oZXJpdGFibGVcclxuXHJcbi8vIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG5cclxuZnVuY3Rpb24gQ2xhc3MoKSB7fVxyXG5cclxuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBleHRlbmQocHJvcHM6IE9iamVjdCk6IEZ1bmN0aW9uXHJcblx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcblx0Ly8gUmV0dXJucyBhIEphdmFzY3JpcHQgZnVuY3Rpb24gdGhhdCBpcyBhIGNsYXNzIGNvbnN0cnVjdG9yICh0byBiZSBjYWxsZWQgd2l0aCBgbmV3YCkuXHJcblx0dmFyIE5ld0NsYXNzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGNhbGwgdGhlIGNvbnN0cnVjdG9yXHJcblx0XHRpZiAodGhpcy5pbml0aWFsaXplKSB7XHJcblx0XHRcdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNhbGwgYWxsIGNvbnN0cnVjdG9yIGhvb2tzXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgcGFyZW50UHJvdG8gPSBOZXdDbGFzcy5fX3N1cGVyX18gPSB0aGlzLnByb3RvdHlwZTtcclxuXHJcblx0dmFyIHByb3RvID0gY3JlYXRlKHBhcmVudFByb3RvKTtcclxuXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcblx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAncHJvdG90eXBlJyAmJiBpICE9PSAnX19zdXBlcl9fJykge1xyXG5cdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG5cdFx0ZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5zdGF0aWNzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0Y2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMocHJvcHMuaW5jbHVkZXMpO1xyXG5cdFx0ZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcblx0XHRkZWxldGUgcHJvcHMuaW5jbHVkZXM7XHJcblx0fVxyXG5cclxuXHQvLyBtZXJnZSBvcHRpb25zXHJcblx0aWYgKHByb3RvLm9wdGlvbnMpIHtcclxuXHRcdHByb3BzLm9wdGlvbnMgPSBleHRlbmQoY3JlYXRlKHByb3RvLm9wdGlvbnMpLCBwcm9wcy5vcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGV4dGVuZChwcm90bywgcHJvcHMpO1xyXG5cclxuXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG5cdC8vIGFkZCBtZXRob2QgZm9yIGNhbGxpbmcgYWxsIGhvb2tzXHJcblx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdEhvb2tzQ2FsbGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzKSB7XHJcblx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SG9va3NDYWxsZWQgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbn07XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4vLyBbSW5jbHVkZXMgYSBtaXhpbl0oI2NsYXNzLWluY2x1ZGVzKSBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLlxyXG5DbGFzcy5pbmNsdWRlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0ZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuLy8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXHJcbkNsYXNzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKGluY2x1ZGVzKSB7XHJcblx0aWYgKHR5cGVvZiBMID09PSAndW5kZWZpbmVkJyB8fCAhTCB8fCAhTC5NaXhpbikgeyByZXR1cm47IH1cclxuXHJcblx0aW5jbHVkZXMgPSBpc0FycmF5KGluY2x1ZGVzKSA/IGluY2x1ZGVzIDogW2luY2x1ZGVzXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmNsdWRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGluY2x1ZGVzW2ldID09PSBMLk1peGluLkV2ZW50cykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgaW5jbHVkZSBvZiBMLk1peGluLkV2ZW50czogJyArXHJcblx0XHRcdFx0J3RoaXMgcHJvcGVydHkgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcywgJyArXHJcblx0XHRcdFx0J3BsZWFzZSBpbmhlcml0IGZyb20gTC5FdmVudGVkIGluc3RlYWQuJywgbmV3IEVycm9yKCkuc3RhY2spO1xyXG5cdFx0fVxyXG5cdH1cclxufVxuXG4vKlxyXG4gKiBAY2xhc3MgRXZlbnRlZFxyXG4gKiBAYWthIEwuRXZlbnRlZFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICogfSApO1xyXG4gKiBgYGBcclxuICpcclxuICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gKlxyXG4gKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBFdmVudHMgPSB7XHJcblx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdCAqL1xyXG5cdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC5cclxuXHQgKi9cclxuXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAoIXR5cGVzKSB7XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIGF0dGFjaCBsaXN0ZW5lciAod2l0aG91dCBzeW50YWN0aWMgc3VnYXIgbm93KVxyXG5cdF9vbjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcblxyXG5cdFx0LyogZ2V0L2luaXQgbGlzdGVuZXJzIGZvciB0eXBlICovXHJcblx0XHR2YXIgdHlwZUxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmICghdHlwZUxpc3RlbmVycykge1xyXG5cdFx0XHR0eXBlTGlzdGVuZXJzID0gW107XHJcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IHR5cGVMaXN0ZW5lcnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdFx0dmFyIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fSxcclxuXHRcdCAgICBsaXN0ZW5lcnMgPSB0eXBlTGlzdGVuZXJzO1xyXG5cclxuXHRcdC8vIGNoZWNrIGlmIGZuIGFscmVhZHkgdGhlcmVcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4gJiYgbGlzdGVuZXJzW2ldLmN0eCA9PT0gY29udGV4dCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxpc3RlbmVycy5wdXNoKG5ld0xpc3RlbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfb2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMsXHJcblx0XHQgICAgaSxcclxuXHRcdCAgICBsZW47XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9ldmVudHMpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0bGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdGlmICghbGlzdGVuZXJzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWZuKSB7XHJcblx0XHRcdC8vIFNldCBhbGwgcmVtb3ZlZCBsaXN0ZW5lcnMgdG8gbm9vcCBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuID0gZmFsc2VGbjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHJcblx0XHRcdC8vIGZpbmQgZm4gYW5kIHJlbW92ZSBpdFxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRpZiAobC5jdHggIT09IGNvbnRleHQpIHsgY29udGludWU7IH1cclxuXHRcdFx0XHRpZiAobC5mbiA9PT0gZm4pIHtcclxuXHJcblx0XHRcdFx0XHQvLyBzZXQgdGhlIHJlbW92ZWQgbGlzdGVuZXIgdG8gbm9vcCBzbyB0aGF0J3Mgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdFx0XHRsLmZuID0gZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHRcdFx0LyogY29weSBhcnJheSBpbiBjYXNlIGV2ZW50cyBhcmUgYmVpbmcgZmlyZWQgKi9cclxuXHRcdFx0XHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYW4gZGF0YVxyXG5cdC8vIG9iamVjdCDigJQgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGNvbnRhaW4gaXRzXHJcblx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gZXh0ZW5kKHt9LCBkYXRhLCB7XHJcblx0XHRcdHR5cGU6IHR5cGUsXHJcblx0XHRcdHRhcmdldDogdGhpcyxcclxuXHRcdFx0c291cmNlVGFyZ2V0OiBkYXRhICYmIGRhdGEuc291cmNlVGFyZ2V0IHx8IHRoaXNcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcblx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudCA9ICh0aGlzLl9maXJpbmdDb3VudCArIDEpIHx8IDE7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0XHRsLmZuLmNhbGwobC5jdHggfHwgdGhpcywgZXZlbnQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQtLTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gcHJvcGFnYXRlIHRoZSBldmVudCB0byBwYXJlbnRzIChzZXQgd2l0aCBhZGRFdmVudFBhcmVudClcclxuXHRcdFx0dGhpcy5fcHJvcGFnYXRlRXZlbnQoZXZlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgaGFzIGFueSBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gaXQuXHJcblx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIHByb3BhZ2F0ZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVycy5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIGFsc28gY2hlY2sgcGFyZW50cyBmb3IgbGlzdGVuZXJzIGlmIGV2ZW50IHByb3BhZ2F0ZXNcclxuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50c1tpZF0ubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9uY2Uo4oCmKTogdGhpc1xyXG5cdC8vIEJlaGF2ZXMgYXMgW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pLCBleGNlcHQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBnZXQgZmlyZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxyXG5cdG9uY2U6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5vbmNlKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSBiaW5kKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHRcdCAgICAub2ZmKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdC8vIGFkZCBhIGxpc3RlbmVyIHRoYXQncyBleGVjdXRlZCBvbmNlIGFuZCByZW1vdmVkIGFmdGVyIHRoYXRcclxuXHRcdHJldHVybiB0aGlzXHJcblx0XHQgICAgLm9uKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdCAgICAub24odHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gZXZlbnQgcGFyZW50IC0gYW4gYEV2ZW50ZWRgIHRoYXQgd2lsbCByZWNlaXZlIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50cyA9IHRoaXMuX2V2ZW50UGFyZW50cyB8fCB7fTtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50c1tzdGFtcChvYmopXSA9IG9iajtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tzdGFtcChvYmopXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBleHRlbmQoe1xyXG5cdFx0XHRcdGxheWVyOiBlLnRhcmdldCxcclxuXHRcdFx0XHRwcm9wYWdhdGVkRnJvbTogZS50YXJnZXRcclxuXHRcdFx0fSwgZSksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8vIGFsaWFzZXM7IHdlIHNob3VsZCBkaXRjaCB0aG9zZSBldmVudHVhbGx5XHJcblxyXG4vLyBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxuRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudHMub247XHJcblxyXG4vLyBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuLy8gQG1ldGhvZCBjbGVhckFsbEV2ZW50TGlzdGVuZXJzKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYoKWBdKCNldmVudGVkLW9mZilcclxuRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMuY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IEV2ZW50cy5vZmY7XHJcblxyXG4vLyBAbWV0aG9kIGFkZE9uZVRpbWVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbmNlKOKApilgXSgjZXZlbnRlZC1vbmNlKVxyXG5FdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcclxuXHJcbi8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG5FdmVudHMuZmlyZUV2ZW50ID0gRXZlbnRzLmZpcmU7XHJcblxyXG4vLyBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJzKOKApik6IEJvb2xlYW5cclxuLy8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxyXG5FdmVudHMuaGFzRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMubGlzdGVucztcclxuXHJcbnZhciBFdmVudGVkID0gQ2xhc3MuZXh0ZW5kKEV2ZW50cyk7XG5cbi8qXHJcbiAqIEBjbGFzcyBQb2ludFxyXG4gKiBAYWthIEwuUG9pbnRcclxuICpcclxuICogUmVwcmVzZW50cyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9pbnQgPSBMLnBvaW50KDIwMCwgMzAwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgYW5kIG9wdGlvbnMgdGhhdCBhY2NlcHQgYFBvaW50YCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAucGFuQnkoWzIwMCwgMzAwXSk7XHJcbiAqIG1hcC5wYW5CeShMLnBvaW50KDIwMCwgMzAwKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYFBvaW50YCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5mdW5jdGlvbiBQb2ludCh4LCB5LCByb3VuZCkge1xyXG5cdC8vIEBwcm9wZXJ0eSB4OiBOdW1iZXI7IFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnggPSAocm91bmQgPyBNYXRoLnJvdW5kKHgpIDogeCk7XHJcblx0Ly8gQHByb3BlcnR5IHk6IE51bWJlcjsgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG5cdHRoaXMueSA9IChyb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5KTtcclxufVxyXG5cclxudmFyIHRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xyXG5cdHJldHVybiB2ID4gMCA/IE1hdGguZmxvb3IodikgOiBNYXRoLmNlaWwodik7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgY2xvbmUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludC5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG5cdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGUgY3VycmVudC5cclxuXHRzdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X3N1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG5cdFx0dGhpcy55IC09IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpdmlkZUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAvPSBudW07XHJcblx0XHR0aGlzLnkgLz0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtdWx0aXBseUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAqPSBudW07XHJcblx0XHR0aGlzLnkgKj0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gTXVsdGlwbHkgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IGVhY2ggY29vcmRpbmF0ZSBvZlxyXG5cdC8vIGBzY2FsZWAuIEluIGxpbmVhciBhbGdlYnJhIHRlcm1zLCBtdWx0aXBseSB0aGUgcG9pbnQgYnkgdGhlXHJcblx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuXHQvLyBkZWZpbmVkIGJ5IGBzY2FsZWAuXHJcblx0c2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5zY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGVCeWAuIERpdmlkZSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnlcclxuXHQvLyBlYWNoIGNvb3JkaW5hdGUgb2YgYHNjYWxlYC5cclxuXHR1bnNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJvdW5kKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCByb3VuZGVkIGNvb3JkaW5hdGVzLlxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9yb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggZmxvb3JlZCBjb29yZGluYXRlcyAocm91bmRlZCBkb3duKS5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuXHR9LFxyXG5cclxuXHRfZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2VpbCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggY2VpbGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHVwKS5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9jZWlsKCk7XHJcblx0fSxcclxuXHJcblx0X2NlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRydW5jKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCB0cnVuY2F0ZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdG93YXJkcyB6ZXJvKS5cclxuXHR0cnVuYzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fdHJ1bmMoKTtcclxuXHR9LFxyXG5cclxuXHRfdHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IHRydW5jKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSB0cnVuYyh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyUG9pbnQ6IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMueCxcclxuXHRcdCAgICB5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG5cdFx0ICAgICAgIHBvaW50LnkgPT09IHRoaXMueTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGJvdGggY29vcmRpbmF0ZXMgb2YgdGhlIGdpdmVuIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgY3VycmVudCBwb2ludCBjb29yZGluYXRlcyAoaW4gYWJzb2x1dGUgdmFsdWVzKS5cclxuXHRjb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyhwb2ludC54KSA8PSBNYXRoLmFicyh0aGlzLngpICYmXHJcblx0XHQgICAgICAgTWF0aC5hYnMocG9pbnQueSkgPD0gTWF0aC5hYnModGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAnUG9pbnQoJyArXHJcblx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLngpICsgJywgJyArXHJcblx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLnkpICsgJyknO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoeDogTnVtYmVyLCB5OiBOdW1iZXIsIHJvdW5kPzogQm9vbGVhbilcclxuLy8gQ3JlYXRlcyBhIFBvaW50IG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgeGAgYW5kIGB5YCBjb29yZGluYXRlcy4gSWYgb3B0aW9uYWwgYHJvdW5kYCBpcyBzZXQgdG8gdHJ1ZSwgcm91bmRzIHRoZSBgeGAgYW5kIGB5YCB2YWx1ZXMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE51bWJlcltdKVxyXG4vLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbeCwgeV1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE9iamVjdClcclxuLy8gRXhwZWN0cyBhIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge3g6IE51bWJlciwgeTogTnVtYmVyfWAgaW5zdGVhZC5cclxuZnVuY3Rpb24gdG9Qb2ludCh4LCB5LCByb3VuZCkge1xyXG5cdGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAoaXNBcnJheSh4KSkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4WzBdLCB4WzFdKTtcclxuXHR9XHJcblx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4LngsIHgueSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XG5cbi8qXHJcbiAqIEBjbGFzcyBCb3VuZHNcclxuICogQGFrYSBMLkJvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHAxID0gTC5wb2ludCgxMCwgMTApLFxyXG4gKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICogYm91bmRzID0gTC5ib3VuZHMocDEsIHAyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgYEJvdW5kc2Agb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG90aGVyQm91bmRzLmludGVyc2VjdHMoW1sxMCwgMTBdLCBbNDAsIDYwXV0pO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEJvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IHBvaW50LmNsb25lKCk7XHJcblx0XHRcdHRoaXMubWF4ID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihwb2ludC54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KHBvaW50LngsIHRoaXMubWF4LngpO1xyXG5cdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4ocG9pbnQueSwgdGhpcy5taW4ueSk7XHJcblx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChwb2ludC55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi54ICsgdGhpcy5tYXgueCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cclxuXHRnZXRUb3BMZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuXHRnZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMubWluICYmIHRoaXMubWF4KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMoY29ybmVyMTogUG9pbnQsIGNvcm5lcjI6IFBvaW50KVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cclxuZnVuY3Rpb24gdG9Cb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSB8fCBhIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBCb3VuZHMoYSwgYik7XHJcbn1cblxuLypcclxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGNvcm5lcjEgPSBMLmxhdExuZyg0MC43MTIsIC03NC4yMjcpLFxyXG4gKiBjb3JuZXIyID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogbWFwLmZpdEJvdW5kcyhbXHJcbiAqIFx0WzQwLjcxMiwgLTc0LjIyN10sXHJcbiAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICogXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5mdW5jdGlvbiBMYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMikgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIG9yIChMYXRMbmdbXSlcclxuXHRpZiAoIWNvcm5lcjEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBsYXRsbmdzID0gY29ybmVyMiA/IFtjb3JuZXIxLCBjb3JuZXIyXSA6IGNvcm5lcjE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50XHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0XHRzdzIgPSBvYmo7XHJcblx0XHRcdG5lMiA9IG9iajtcclxuXHJcblx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG5cdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKHRvTGF0TG5nKG9iaikgfHwgdG9MYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcblx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XHJcblx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG5cdFx0XHRzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xyXG5cdFx0XHRuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xyXG5cdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyBvciByZXRyYWN0aW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHJhdGlvIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cclxuXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxhdCAtIG5lLmxhdCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubG5nICsgdGhpcy5fbm9ydGhFYXN0LmxuZykgLyAyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRXZXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGVhc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyAobGF0bG5nOiBMYXRMbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIExhdExuZyB8fCAnbGF0JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG5cdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG5cdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRPdmVybGFwcyA9IChuZTIubGF0ID4gc3cubGF0KSAmJiAoc3cyLmxhdCA8IG5lLmxhdCksXHJcblx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRPdmVybGFwcyAmJiBsbmdPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIGluIGEgJ3NvdXRod2VzdF9sbmcsc291dGh3ZXN0X2xhdCxub3J0aGVhc3RfbG5nLG5vcnRoZWFzdF9sYXQnIGZvcm1hdC4gVXNlZnVsIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIHdlYiBzZXJ2aWNlcyB0aGF0IHJldHVybiBnZW8gZGF0YS5cclxuXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikgdG8gdGhlIGdpdmVuIGJvdW5kcy4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcywgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgbWF4TWFyZ2luKSAmJlxyXG5cdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpLCBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxOiBMYXRMbmcsIGNvcm5lcjI6IExhdExuZylcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuZnVuY3Rpb24gdG9MYXRMbmdCb3VuZHMoYSwgYikge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoYSwgYik7XHJcbn1cblxuLyogQGNsYXNzIExhdExuZ1xyXG4gKiBAYWthIEwuTGF0TG5nXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCBhIGNlcnRhaW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBgXHJcbiAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAqIG1hcC5wYW5Ubyh7bG9uOiAzMCwgbGF0OiA1MH0pO1xyXG4gKiBtYXAucGFuVG8oe2xhdDogNTAsIGxuZzogMzB9KTtcclxuICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMubGF0LCBwcmVjaXNpb24pICsgJywgJyArXHJcblx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbU3BoZXJpY2FsIExhdyBvZiBDb3NpbmVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfbGF3X29mX2Nvc2luZXMpLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG5cdFx0cmV0dXJuIEVhcnRoLmRpc3RhbmNlKHRoaXMsIHRvTGF0TG5nKG90aGVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG5cdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcblx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG5mdW5jdGlvbiB0b0xhdExuZyhhLCBiLCBjKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAoaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH1cclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbn1cblxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5CYXNlXHJcbiAqIE9iamVjdCB0aGF0IGRlZmluZXMgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtcyBmb3IgcHJvamVjdGluZ1xyXG4gKiBnZW9ncmFwaGljYWwgcG9pbnRzIGludG8gcGl4ZWwgKHNjcmVlbikgY29vcmRpbmF0ZXMgYW5kIGJhY2sgKGFuZCB0b1xyXG4gKiBjb29yZGluYXRlcyBpbiBvdGhlciB1bml0cyBmb3IgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuIFNlZVxyXG4gKiBbc3BhdGlhbCByZWZlcmVuY2Ugc3lzdGVtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nvb3JkaW5hdGVfcmVmZXJlbmNlX3N5c3RlbSkuXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAqIENSUyBub3QgZGVmaW5lZCBieSBkZWZhdWx0LCB0YWtlIGEgbG9vayBhdCB0aGVcclxuICogW1Byb2o0TGVhZmxldF0oaHR0cHM6Ly9naXRodWIuY29tL2thcnRlbmEvUHJvajRMZWFmbGV0KSBwbHVnaW4uXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgQ1JTIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcclxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxudmFyIENSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcblx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMobWluLCBtYXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG5cdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSAoaG9yaXpvbnRhbCkgY29vcmRpbmF0ZVxyXG5cdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcblx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG5cdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcblx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyB3cmFwTnVtKGxhdGxuZy5sbmcsIHRoaXMud3JhcExuZywgdHJ1ZSkgOiBsYXRsbmcubG5nLFxyXG5cdFx0ICAgIGxhdCA9IHRoaXMud3JhcExhdCA/IHdyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nXHJcblx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuXHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxyXG5cdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG5cdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBib3VuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG5cdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XHJcblx0fVxyXG59O1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuRWFydGhcbiAqXG4gKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogbWV0ZXJzLlxuICovXG5cbnZhciBFYXJ0aCA9IGV4dGVuZCh7fSwgQ1JTLCB7XG5cdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG5cdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG5cdC8vIHNlZSBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcblx0UjogNjM3MTAwMCxcblxuXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG5cdFx0ICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcblx0XHQgICAgc2luRExhdCA9IE1hdGguc2luKChsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0KSAqIHJhZCAvIDIpLFxuXHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG5cdFx0ICAgIGEgPSBzaW5ETGF0ICogc2luRExhdCArIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBzaW5ETG9uICogc2luRExvbixcblx0XHQgICAgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG5cdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAqXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBmb3Igb25saW5lIG1hcHMsXHJcbiAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICovXHJcblxyXG52YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IDYzNzgxMzcsXHJcblx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcblx0XHQgICAgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4obWF4LCBsYXRsbmcubGF0KSwgLW1heCksXHJcblx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdFx0dGhpcy5SICogbGF0bG5nLmxuZyAqIGQsXHJcblx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcblx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZCA9IDYzNzgxMzcgKiBNYXRoLlBJO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcblx0fSkoKVxyXG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRyYW5zZm9ybWF0aW9uID0gTC50cmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbmZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRpZiAoaXNBcnJheShhKSkge1xyXG5cdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG5cdFx0dGhpcy5fYiA9IGFbMV07XHJcblx0XHR0aGlzLl9jID0gYVsyXTtcclxuXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufVxyXG5cclxuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBUcmFuc2Zvcm1hdGlvbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbi8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbi8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG5mdW5jdGlvbiB0b1RyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRyZXR1cm4gbmV3IFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpO1xyXG59XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAqL1xyXG5cclxudmFyIEVQU0czODU3ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cdHByb2plY3Rpb246IFNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXHJcbnZhciBFUFNHOTAwOTEzID0gZXh0ZW5kKHt9LCBFUFNHMzg1Nywge1xyXG5cdGNvZGU6ICdFUFNHOjkwMDkxMydcclxufSk7XG5cbi8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4vLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcbi8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4vLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG5mdW5jdGlvbiBzdmdDcmVhdGUobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vLyBAZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzOiBQb2ludFtdLCBjbG9zZWQ6IEJvb2xlYW4pOiBTdHJpbmdcbi8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcbi8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcbmZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5ncywgY2xvc2VkKSB7XG5cdHZhciBzdHIgPSAnJyxcblx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cblx0Zm9yIChpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRwID0gcG9pbnRzW2pdO1xuXHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcblx0XHR9XG5cblx0XHQvLyBjbG9zZXMgdGhlIHJpbmcgZm9yIHBvbHlnb25zOyBcInhcIiBpcyBWTUwgc3ludGF4XG5cdFx0c3RyICs9IGNsb3NlZCA/IChzdmcgPyAneicgOiAneCcpIDogJyc7XG5cdH1cblxuXHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbn1cblxuLypcclxuICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAqIEBha2EgTC5Ccm93c2VyXHJcbiAqXHJcbiAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIHN0eWxlJDEgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgaWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIChub3QgRWRnZSkuXHJcbnZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3c7XHJcblxyXG4vLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbnZhciBpZWx0OSA9IGllICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyO1xyXG5cclxuLy8gQHByb3BlcnR5IGVkZ2U6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIEVkZ2Ugd2ViIGJyb3dzZXIuXHJcbnZhciBlZGdlID0gJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0OiBCb29sZWFuO1xyXG4vLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBsaWtlIENocm9tZSBhbmQgU2FmYXJpIChpbmNsdWRpbmcgbW9iaWxlIHZlcnNpb25zKS5cclxudmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG52YXIgYW5kcm9pZCA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxudmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4vKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3OTYxMjY2IGZvciBkZXRhaWxzIG9uIGRldGVjdGluZyBzdG9jayBBbmRyb2lkICovXHJcbnZhciB3ZWJraXRWZXIgPSBwYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwgMTApOyAvLyBhbHNvIG1hdGNoZXMgQXBwbGVXZWJLaXRcclxuLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQW5kcm9pZCBzdG9jayBicm93c2VyIChpLmUuIG5vdCBDaHJvbWUpXHJcbnZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyXHJcbnZhciBvcGVyYSA9ICEhd2luZG93Lm9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IGNocm9tZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQ2hyb21lIGJyb3dzZXIuXHJcbnZhciBjaHJvbWUgPSB1c2VyQWdlbnRDb250YWlucygnY2hyb21lJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG52YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4vLyBAcHJvcGVydHkgc2FmYXJpOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBTYWZhcmkgYnJvd3Nlci5cclxudmFyIHNhZmFyaSA9ICFjaHJvbWUgJiYgdXNlckFnZW50Q29udGFpbnMoJ3NhZmFyaScpO1xyXG5cclxudmFyIHBoYW50b20gPSB1c2VyQWdlbnRDb250YWlucygncGhhbnRvbScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhMTI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zICh2ZXJzaW9uIDEyIG9yIGxhdGVyKS5cclxudmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlJDE7XHJcblxyXG4vLyBAcHJvcGVydHkgd2luOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxyXG52YXIgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwO1xyXG5cclxuLy8gQHByb3BlcnR5IGllM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSQxKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjM7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGUkMTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbnkzZDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG52YXIgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1c2VyQWdlbnRDb250YWlucygnbW9iaWxlJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG52YXIgbW9iaWxlV2Via2l0ID0gbW9iaWxlICYmIHdlYmtpdDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQzZDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBtb2JpbGVXZWJraXQzZCA9IG1vYmlsZSAmJiB3ZWJraXQzZDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtc1BvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcbnZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4vLyBAcHJvcGVydHkgcG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcbnZhciBwb2ludGVyID0gISEod2luZG93LlBvaW50ZXJFdmVudCB8fCBtc1BvaW50ZXIpO1xyXG5cclxuLy8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3RvdWNoIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cykuXHJcbi8vIFRoaXMgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbiB0aGF0IHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBjb21wdXRlciB3aXRoXHJcbi8vIGEgdG91Y2hzY3JlZW4sIGl0IG9ubHkgbWVhbnMgdGhhdCB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIHVuZGVyc3RhbmRpbmdcclxuLy8gdG91Y2ggZXZlbnRzLlxyXG52YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHBvaW50ZXIgfHwgJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8XHJcblx0XHQod2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZU9wZXJhID0gbW9iaWxlICYmIG9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGVHZWNrbyA9IG1vYmlsZSAmJiBnZWNrbztcclxuXHJcbi8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbi5cclxudmFyIHJldGluYSA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkpID4gMTtcclxuXHJcblxyXG4vLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbnZhciBjYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbnZhciBzdmcgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgc3ZnQ3JlYXRlKCdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB2bWw6IEJvb2xlYW5cclxuLy8gYHRydWVgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLlxyXG52YXIgdm1sID0gIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSgpKTtcclxuXHJcblxyXG5mdW5jdGlvbiB1c2VyQWdlbnRDb250YWlucyhzdHIpIHtcclxuXHRyZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA+PSAwO1xyXG59XHJcblxuXG52YXIgQnJvd3NlciA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRpZTogaWUsXG5cdGllbHQ5OiBpZWx0OSxcblx0ZWRnZTogZWRnZSxcblx0d2Via2l0OiB3ZWJraXQsXG5cdGFuZHJvaWQ6IGFuZHJvaWQsXG5cdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxuXHRhbmRyb2lkU3RvY2s6IGFuZHJvaWRTdG9jayxcblx0b3BlcmE6IG9wZXJhLFxuXHRjaHJvbWU6IGNocm9tZSxcblx0Z2Vja286IGdlY2tvLFxuXHRzYWZhcmk6IHNhZmFyaSxcblx0cGhhbnRvbTogcGhhbnRvbSxcblx0b3BlcmExMjogb3BlcmExMixcblx0d2luOiB3aW4sXG5cdGllM2Q6IGllM2QsXG5cdHdlYmtpdDNkOiB3ZWJraXQzZCxcblx0Z2Vja28zZDogZ2Vja28zZCxcblx0YW55M2Q6IGFueTNkLFxuXHRtb2JpbGU6IG1vYmlsZSxcblx0bW9iaWxlV2Via2l0OiBtb2JpbGVXZWJraXQsXG5cdG1vYmlsZVdlYmtpdDNkOiBtb2JpbGVXZWJraXQzZCxcblx0bXNQb2ludGVyOiBtc1BvaW50ZXIsXG5cdHBvaW50ZXI6IHBvaW50ZXIsXG5cdHRvdWNoOiB0b3VjaCxcblx0bW9iaWxlT3BlcmE6IG1vYmlsZU9wZXJhLFxuXHRtb2JpbGVHZWNrbzogbW9iaWxlR2Vja28sXG5cdHJldGluYTogcmV0aW5hLFxuXHRjYW52YXM6IGNhbnZhcyxcblx0c3ZnOiBzdmcsXG5cdHZtbDogdm1sXG59KTtcblxuLypcbiAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gKi9cblxuXG52YXIgUE9JTlRFUl9ET1dOID0gICBtc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9NT1ZFID0gICBtc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgICA6ICdwb2ludGVybW92ZSc7XG52YXIgUE9JTlRFUl9VUCA9ICAgICBtc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnO1xudmFyIFBPSU5URVJfQ0FOQ0VMID0gbXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCc7XG52YXIgVEFHX1dISVRFX0xJU1QgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdPUFRJT04nXTtcblxudmFyIF9wb2ludGVycyA9IHt9O1xudmFyIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuLy8gRG9tRXZlbnQuRG91YmxlVGFwIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhpc1xudmFyIF9wb2ludGVyc0NvdW50ID0gMDtcblxuLy8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuLy8gcmVmIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvIGh0dHBzOi8vd3d3LnczLm9yZy9CdWdzL1B1YmxpYy9zaG93X2J1Zy5jZ2k/aWQ9MjI4OTBcblxuZnVuY3Rpb24gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdF9hZGRQb2ludGVyU3RhcnQob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRfYWRkUG9pbnRlckVuZChvYmosIGhhbmRsZXIsIGlkKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCkge1xuXHR2YXIgaGFuZGxlciA9IG9ialsnX2xlYWZsZXRfJyArIHR5cGUgKyBpZF07XG5cblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIGhhbmRsZXIsIGZhbHNlKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIGhhbmRsZXIsIGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uRG93biA9IGJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyAmJiBlLk1TUE9JTlRFUl9UWVBFX01PVVNFICYmIGUucG9pbnRlclR5cGUgIT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UpIHtcblx0XHRcdC8vIEluIElFMTEsIHNvbWUgdG91Y2ggZXZlbnRzIG5lZWRzIHRvIGZpcmUgZm9yIGZvcm0gY29udHJvbHMsIG9yXG5cdFx0XHQvLyB0aGUgY29udHJvbHMgd2lsbCBzdG9wIHdvcmtpbmcuIFdlIGtlZXAgYSB3aGl0ZWxpc3Qgb2YgdGFnIG5hbWVzIHRoYXRcblx0XHRcdC8vIG5lZWQgdGhlc2UgZXZlbnRzLiBGb3Igb3RoZXIgdGFyZ2V0IHRhZ3MsIHdlIHByZXZlbnQgZGVmYXVsdCBvbiB0aGUgZXZlbnQuXG5cdFx0XHRpZiAoVEFHX1dISVRFX0xJU1QuaW5kZXhPZihlLnRhcmdldC50YWdOYW1lKSA8IDApIHtcblx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH0pO1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2hzdGFydCcgKyBpZF0gPSBvbkRvd247XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgb25Eb3duLCBmYWxzZSk7XG5cblx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdGlmICghX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuXHRcdC8vIHdlIGxpc3RlbiBkb2N1bWVudEVsZW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBfZ2xvYmFsUG9pbnRlckRvd24sIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgX2dsb2JhbFBvaW50ZXJNb3ZlLCB0cnVlKTtcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cblx0XHRfcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlckRvd24oZSkge1xuXHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0X3BvaW50ZXJzQ291bnQrKztcbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJNb3ZlKGUpIHtcblx0aWYgKF9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcblx0XHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlclVwKGUpIHtcblx0ZGVsZXRlIF9wb2ludGVyc1tlLnBvaW50ZXJJZF07XG5cdF9wb2ludGVyc0NvdW50LS07XG59XG5cbmZ1bmN0aW9uIF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpIHtcblx0ZS50b3VjaGVzID0gW107XG5cdGZvciAodmFyIGkgaW4gX3BvaW50ZXJzKSB7XG5cdFx0ZS50b3VjaGVzLnB1c2goX3BvaW50ZXJzW2ldKTtcblx0fVxuXHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdGhhbmRsZXIoZSk7XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvbk1vdmUgPSBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIGRvbid0IGZpcmUgdG91Y2ggbW92ZXMgd2hlbiBtb3VzZSBpc24ndCBkb3duXG5cdFx0aWYgKChlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmIGUuYnV0dG9ucyA9PT0gMCkgeyByZXR1cm47IH1cblxuXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHR9O1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2htb3ZlJyArIGlkXSA9IG9uTW92ZTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBvbk1vdmUsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCkge1xuXHR2YXIgb25VcCA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH07XG5cblx0b2JqWydfbGVhZmxldF90b3VjaGVuZCcgKyBpZF0gPSBvblVwO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBvblVwLCBmYWxzZSk7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBvblVwLCBmYWxzZSk7XG59XG5cbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICovXHJcblxyXG52YXIgX3RvdWNoc3RhcnQgPSBtc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiBwb2ludGVyID8gJ3BvaW50ZXJkb3duJyA6ICd0b3VjaHN0YXJ0JztcclxudmFyIF90b3VjaGVuZCA9IG1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiBwb2ludGVyID8gJ3BvaW50ZXJ1cCcgOiAndG91Y2hlbmQnO1xyXG52YXIgX3ByZSA9ICdfbGVhZmxldF8nO1xyXG5cclxuLy8gaW5zcGlyZWQgYnkgWmVwdG8gdG91Y2ggY29kZSBieSBUaG9tYXMgRnVjaHNcclxuZnVuY3Rpb24gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCkge1xyXG5cdHZhciBsYXN0LCB0b3VjaCQkMSxcclxuXHQgICAgZG91YmxlVGFwID0gZmFsc2UsXHJcblx0ICAgIGRlbGF5ID0gMjUwO1xyXG5cclxuXHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xyXG5cdFx0dmFyIGNvdW50O1xyXG5cclxuXHRcdGlmIChwb2ludGVyKSB7XHJcblx0XHRcdGlmICgoIWVkZ2UpIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHsgcmV0dXJuOyB9XHJcblx0XHRcdGNvdW50ID0gX3BvaW50ZXJzQ291bnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3VudCA9IGUudG91Y2hlcy5sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvdW50ID4gMSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcclxuXHRcdCAgICBkZWx0YSA9IG5vdyAtIChsYXN0IHx8IG5vdyk7XHJcblxyXG5cdFx0dG91Y2gkJDEgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xyXG5cdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRsYXN0ID0gbm93O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XHJcblx0XHRpZiAoZG91YmxlVGFwICYmICF0b3VjaCQkMS5jYW5jZWxCdWJibGUpIHtcclxuXHRcdFx0aWYgKHBvaW50ZXIpIHtcclxuXHRcdFx0XHRpZiAoKCFlZGdlKSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7IHJldHVybjsgfVxyXG5cdFx0XHRcdC8vIHdvcmsgYXJvdW5kIC50eXBlIGJlaW5nIHJlYWRvbmx5IHdpdGggTVNQb2ludGVyKiBldmVudHNcclxuXHRcdFx0XHR2YXIgbmV3VG91Y2ggPSB7fSxcclxuXHRcdFx0XHQgICAgcHJvcCwgaTtcclxuXHJcblx0XHRcdFx0Zm9yIChpIGluIHRvdWNoJCQxKSB7XHJcblx0XHRcdFx0XHRwcm9wID0gdG91Y2gkJDFbaV07XHJcblx0XHRcdFx0XHRuZXdUb3VjaFtpXSA9IHByb3AgJiYgcHJvcC5iaW5kID8gcHJvcC5iaW5kKHRvdWNoJCQxKSA6IHByb3A7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRvdWNoJCQxID0gbmV3VG91Y2g7XHJcblx0XHRcdH1cclxuXHRcdFx0dG91Y2gkJDEudHlwZSA9ICdkYmxjbGljayc7XHJcblx0XHRcdGhhbmRsZXIodG91Y2gkJDEpO1xyXG5cdFx0XHRsYXN0ID0gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdG9ialtfcHJlICsgX3RvdWNoc3RhcnQgKyBpZF0gPSBvblRvdWNoU3RhcnQ7XHJcblx0b2JqW19wcmUgKyBfdG91Y2hlbmQgKyBpZF0gPSBvblRvdWNoRW5kO1xyXG5cdG9ialtfcHJlICsgJ2RibGNsaWNrJyArIGlkXSA9IGhhbmRsZXI7XHJcblxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKF90b3VjaHN0YXJ0LCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hlbmQsIG9uVG91Y2hFbmQsIGZhbHNlKTtcclxuXHJcblx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgKG5vdGFibHksIGNocm9tZTw1NSBvbiB3aW4xMCArIHRvdWNoc2NyZWVuICsgbW91c2UpLFxyXG5cdC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgZmlyZSB0b3VjaGVuZC9wb2ludGVydXAgZXZlbnRzIGJ1dCBkb2VzIGZpcmVcclxuXHQvLyBuYXRpdmUgZGJsY2xpY2tzLiBTZWUgIzQxMjcuXHJcblx0Ly8gRWRnZSAxNCBhbHNvIGZpcmVzIG5hdGl2ZSBkYmxjbGlja3MsIGJ1dCBvbmx5IGZvciBwb2ludGVyVHlwZSBtb3VzZSwgc2VlICM1MTgwLlxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaWQpIHtcclxuXHR2YXIgdG91Y2hzdGFydCA9IG9ialtfcHJlICsgX3RvdWNoc3RhcnQgKyBpZF0sXHJcblx0ICAgIHRvdWNoZW5kID0gb2JqW19wcmUgKyBfdG91Y2hlbmQgKyBpZF0sXHJcblx0ICAgIGRibGNsaWNrID0gb2JqW19wcmUgKyAnZGJsY2xpY2snICsgaWRdO1xyXG5cclxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdG91Y2hzdGFydCwgdG91Y2hzdGFydCwgZmFsc2UpO1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgdG91Y2hlbmQsIGZhbHNlKTtcclxuXHRpZiAoIWVkZ2UpIHtcclxuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGRibGNsaWNrLCBmYWxzZSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcbi8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcbi8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcbi8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZnVuY3Rpb24gb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG52YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi5cclxuLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4vLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZnVuY3Rpb24gb2ZmKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh0eXBlcykge1xyXG5cdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaiBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCBqLCBvYmpbZXZlbnRzS2V5XVtqXSk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHR2YXIgaWQgPSB0eXBlICsgc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBzdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcblx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG5cdH07XHJcblxyXG5cdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuXHRpZiAocG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuXHRcdGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICh0b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgYWRkRG91YmxlVGFwTGlzdGVuZXIgJiZcclxuXHQgICAgICAgICAgICEocG9pbnRlciAmJiBjaHJvbWUpKSB7XHJcblx0XHQvLyBDaHJvbWUgPjU1IGRvZXMgbm90IG5lZWQgdGhlIHN5bnRoZXRpYyBkYmxjbGlja3MgZnJvbSBhZGREb3VibGVUYXBMaXN0ZW5lclxyXG5cdFx0Ly8gU2VlICM1MTgwXHJcblx0XHRhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgfHwgKHR5cGUgPT09ICdtb3VzZWxlYXZlJykpIHtcclxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh0eXBlID09PSAnY2xpY2snICYmIGFuZHJvaWQpIHtcclxuXHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGZpbHRlckNsaWNrKGUsIG9yaWdpbmFsSGFuZGxlcik7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdHZhciBpZCA9IHR5cGUgKyBzdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIHN0YW1wKGNvbnRleHQpIDogJycpLFxyXG5cdCAgICBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0aWYgKHBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRyZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAodG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyICYmXHJcblx0ICAgICAgICAgICAhKHBvaW50ZXIgJiYgY2hyb21lKSkge1xyXG5cdFx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ud2hlZWwnIGluIG9iaiA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuXHRcdFx0XHR0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6XHJcblx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlbGVhdmUnID8gJ21vdXNlb3V0JyA6IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuLy8gYGBganNcclxuLy8gTC5Eb21FdmVudC5vbihkaXYsICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4vLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuLy8gfSk7XHJcbi8vIGBgYFxyXG5mdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZSkge1xyXG5cclxuXHRpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0fSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQpIHsgIC8vIEluIGNhc2Ugb2YgTGVhZmxldCBldmVudC5cclxuXHRcdGUub3JpZ2luYWxFdmVudC5fc3RvcHBlZCA9IHRydWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHR9XHJcblx0c2tpcHBlZChlKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdtb3VzZXdoZWVsJ2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5mdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcclxuXHRhZGRPbmUoZWwsICdtb3VzZXdoZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkb3VibGVjbGljaydgLFxyXG4vLyBgJ21vdXNlZG93bidgIGFuZCBgJ3RvdWNoc3RhcnQnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XHJcblx0b24oZWwsICdtb3VzZWRvd24gdG91Y2hzdGFydCBkYmxjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0YWRkT25lKGVsLCAnY2xpY2snLCBmYWtlU3RvcCk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuLy8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG4vLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG4vLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xyXG5cdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gRG9lcyBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBhdCB0aGUgc2FtZSB0aW1lLlxyXG5mdW5jdGlvbiBzdG9wKGUpIHtcclxuXHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHRzdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGV2OiBET01FdmVudCwgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuLy8gYGNvbnRhaW5lcmAgb3IgdG8gdGhlIHdob2xlIHBhZ2UgaWYgbm90IHNwZWNpZmllZC5cclxuZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlLCBjb250YWluZXIpIHtcclxuXHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblx0fVxyXG5cclxuXHR2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0dmFyIHNjYWxlWCA9IHJlY3Qud2lkdGggLyBjb250YWluZXIub2Zmc2V0V2lkdGggfHwgMTtcclxuXHR2YXIgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyBjb250YWluZXIub2Zmc2V0SGVpZ2h0IHx8IDE7XHJcblx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdGUuY2xpZW50WCAvIHNjYWxlWCAtIHJlY3QubGVmdCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0ZS5jbGllbnRZIC8gc2NhbGVZIC0gcmVjdC50b3AgLSBjb250YWluZXIuY2xpZW50VG9wKTtcclxufVxyXG5cclxuLy8gQ2hyb21lIG9uIFdpbiBzY3JvbGxzIGRvdWJsZSB0aGUgcGl4ZWxzIGFzIGluIG90aGVyIHBsYXRmb3JtcyAoc2VlICM0NTM4KSxcclxuLy8gYW5kIEZpcmVmb3ggc2Nyb2xscyBkZXZpY2UgcGl4ZWxzLCBub3QgQ1NTIHBpeGVsc1xyXG52YXIgd2hlZWxQeEZhY3RvciA9XHJcblx0KHdpbiAmJiBjaHJvbWUpID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuXHRnZWNrbyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNld2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG4vLyBwaXhlbHMgc2Nyb2xsZWQgKG5lZ2F0aXZlIGlmIHNjcm9sbGluZyBkb3duKS5cclxuLy8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuLy8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XHJcblx0cmV0dXJuIChlZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyB3aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcblx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuXHQgICAgICAgZS53aGVlbERlbHRhID8gKGUud2hlZWxEZWx0YVkgfHwgZS53aGVlbERlbHRhKSAvIDIgOiAvLyBMZWdhY3kgSUUgcGl4ZWxzXHJcblx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuXHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG5cdCAgICAgICAwO1xyXG59XHJcblxyXG52YXIgc2tpcEV2ZW50cyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZmFrZVN0b3AoZSkge1xyXG5cdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggc2tpcHBlZChlKVxyXG5cdHNraXBFdmVudHNbZS50eXBlXSA9IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNraXBwZWQoZSkge1xyXG5cdHZhciBldmVudHMgPSBza2lwRXZlbnRzW2UudHlwZV07XHJcblx0Ly8gcmVzZXQgd2hlbiBjaGVja2luZywgYXMgaXQncyBvbmx5IHVzZWQgaW4gbWFwIGNvbnRhaW5lciBhbmQgcHJvcGFnYXRlcyBvdXRzaWRlIG9mIHRoZSBtYXBcclxuXHRza2lwRXZlbnRzW2UudHlwZV0gPSBmYWxzZTtcclxuXHRyZXR1cm4gZXZlbnRzO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuZnVuY3Rpb24gaXNFeHRlcm5hbFRhcmdldChlbCwgZSkge1xyXG5cclxuXHR2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcclxuXHJcblx0aWYgKCFyZWxhdGVkKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdHRyeSB7XHJcblx0XHR3aGlsZSAocmVsYXRlZCAmJiAocmVsYXRlZCAhPT0gZWwpKSB7XHJcblx0XHRcdHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xyXG59XHJcblxyXG52YXIgbGFzdENsaWNrO1xyXG5cclxuLy8gdGhpcyBpcyBhIGhvcnJpYmxlIHdvcmthcm91bmQgZm9yIGEgYnVnIGluIEFuZHJvaWQgd2hlcmUgYSBzaW5nbGUgdG91Y2ggdHJpZ2dlcnMgdHdvIGNsaWNrIGV2ZW50c1xyXG5mdW5jdGlvbiBmaWx0ZXJDbGljayhlLCBoYW5kbGVyKSB7XHJcblx0dmFyIHRpbWVTdGFtcCA9IChlLnRpbWVTdGFtcCB8fCAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC50aW1lU3RhbXApKSxcclxuXHQgICAgZWxhcHNlZCA9IGxhc3RDbGljayAmJiAodGltZVN0YW1wIC0gbGFzdENsaWNrKTtcclxuXHJcblx0Ly8gYXJlIHRoZXkgY2xvc2VyIHRvZ2V0aGVyIHRoYW4gNTAwbXMgeWV0IG1vcmUgdGhhbiAxMDBtcz9cclxuXHQvLyBBbmRyb2lkIHR5cGljYWxseSB0cmlnZ2VycyB0aGVtIH4zMDBtcyBhcGFydCB3aGlsZSBtdWx0aXBsZSBsaXN0ZW5lcnNcclxuXHQvLyBvbiB0aGUgc2FtZSBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkIGZhciBmYXN0ZXI7XHJcblx0Ly8gb3IgY2hlY2sgaWYgY2xpY2sgaXMgc2ltdWxhdGVkIG9uIHRoZSBlbGVtZW50LCBhbmQgaWYgaXQgaXMsIHJlamVjdCBhbnkgbm9uLXNpbXVsYXRlZCBldmVudHNcclxuXHJcblx0aWYgKChlbGFwc2VkICYmIGVsYXBzZWQgPiAxMDAgJiYgZWxhcHNlZCA8IDUwMCkgfHwgKGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayAmJiAhZS5fc2ltdWxhdGVkKSkge1xyXG5cdFx0c3RvcChlKTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0bGFzdENsaWNrID0gdGltZVN0YW1wO1xyXG5cclxuXHRoYW5kbGVyKGUpO1xyXG59XHJcblxyXG5cclxuXG5cbnZhciBEb21FdmVudCA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRvbjogb24sXG5cdG9mZjogb2ZmLFxuXHRzdG9wUHJvcGFnYXRpb246IHN0b3BQcm9wYWdhdGlvbixcblx0ZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uOiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24sXG5cdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbixcblx0cHJldmVudERlZmF1bHQ6IHByZXZlbnREZWZhdWx0LFxuXHRzdG9wOiBzdG9wLFxuXHRnZXRNb3VzZVBvc2l0aW9uOiBnZXRNb3VzZVBvc2l0aW9uLFxuXHRnZXRXaGVlbERlbHRhOiBnZXRXaGVlbERlbHRhLFxuXHRmYWtlU3RvcDogZmFrZVN0b3AsXG5cdHNraXBwZWQ6IHNraXBwZWQsXG5cdGlzRXh0ZXJuYWxUYXJnZXQ6IGlzRXh0ZXJuYWxUYXJnZXQsXG5cdGFkZExpc3RlbmVyOiBvbixcblx0cmVtb3ZlTGlzdGVuZXI6IG9mZlxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICogaW4gSFRNTCBhbmQgU1ZHIGNsYXNzZXMgaW4gU1ZHLlxyXG4gKi9cclxuXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zZm9ybSBzdHlsZSBuYW1lIChlLmcuIGAnd2Via2l0VHJhbnNmb3JtJ2AgZm9yIFdlYktpdCkuXHJcbnZhciBUUkFOU0ZPUk0gPSB0ZXN0UHJvcChcclxuXHRbJ3RyYW5zZm9ybScsICdXZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4vLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcbi8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbiBzdHlsZSBuYW1lLlxyXG52YXIgVFJBTlNJVElPTiA9IHRlc3RQcm9wKFxyXG5cdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT05fRU5EOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cclxudmFyIFRSQU5TSVRJT05fRU5EID1cclxuXHRUUkFOU0lUSU9OID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgVFJBTlNJVElPTiA9PT0gJ09UcmFuc2l0aW9uJyA/IFRSQU5TSVRJT04gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0KGlkOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuLy8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuZnVuY3Rpb24gZ2V0KGlkKSB7XHJcblx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG4vLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcbmZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xyXG5cdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuXHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG5cdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZTogU3RyaW5nLCBjbGFzc05hbWU/OiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcbmZ1bmN0aW9uIGNyZWF0ZSQxKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG5cdGlmIChjb250YWluZXIpIHtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG5cdHJldHVybiBlbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG5mdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50KSB7XHJcblx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVtcHR5KGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG5mdW5jdGlvbiBlbXB0eShlbCkge1xyXG5cdHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcblx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZnVuY3Rpb24gdG9Gcm9udChlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQubGFzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBmaXJzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGJlaGluZCB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmZ1bmN0aW9uIHRvQmFjayhlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG5mdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHR9XHJcblx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dmFyIGNsYXNzZXMgPSBzcGxpdFdvcmRzKG5hbWUpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c2V0Q2xhc3MoZWwsIHRyaW0oKCcgJyArIGdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG5cdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldENsYXNzKGVsOiBIVE1MRWxlbWVudCk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XHJcblx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcbi8vIFNldCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgb2xkIElFIHN1cHBvcnQpLlxyXG4vLyBgb3BhY2l0eWAgbXVzdCBiZSBhIG51bWJlciBmcm9tIGAwYCB0byBgMWAuXHJcbmZ1bmN0aW9uIHNldE9wYWNpdHkoZWwsIHZhbHVlKSB7XHJcblx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuXHRcdF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKSB7XHJcblx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG5cdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcblx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcblx0dHJ5IHtcclxuXHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuXHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcblx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblx0fVxyXG5cclxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuXHRpZiAoZmlsdGVyKSB7XHJcblx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuXHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVzdFByb3AocHJvcHM6IFN0cmluZ1tdKTogU3RyaW5nfGZhbHNlXHJcbi8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuLy8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcclxuLy8gaXQgcmV0dXJucyBmYWxzZS4gVXNlZnVsIGZvciB2ZW5kb3ItcHJlZml4ZWQgc3R5bGVzIGxpa2UgYHRyYW5zZm9ybWAuXHJcbmZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XHJcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuLy8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuLy8gYW5kIG9wdGlvbmFsbHkgc2NhbGVkIGJ5IGBzY2FsZWAuIERvZXMgbm90IGhhdmUgYW4gZWZmZWN0IGlmIHRoZVxyXG4vLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsLCBvZmZzZXQsIHNjYWxlKSB7XHJcblx0dmFyIHBvcyA9IG9mZnNldCB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblxyXG5cdGVsLnN0eWxlW1RSQU5TRk9STV0gPVxyXG5cdFx0KGllM2QgP1xyXG5cdFx0XHQndHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyA6XHJcblx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG5cdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuLy8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcclxuLy8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuLy8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG5mdW5jdGlvbiBzZXRQb3NpdGlvbihlbCwgcG9pbnQpIHtcclxuXHJcblx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG5cdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcblx0aWYgKGFueTNkKSB7XHJcblx0XHRzZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUubGVmdCA9IHBvaW50LnggKyAncHgnO1xyXG5cdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZWxlbWVudCBwcmV2aW91c2x5IHBvc2l0aW9uZWQgd2l0aCBzZXRQb3NpdGlvbi5cclxuZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcclxuXHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuXHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zIHx8IG5ldyBQb2ludCgwLCAwKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuLy8gd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW91c2UgdGhyb3VnaCBhIHBhZ2Ugd2l0aCB0ZXh0LiBVc2VkIGludGVybmFsbHlcclxuLy8gYnkgTGVhZmxldCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3VyIG9mIGFueSBjbGljay1hbmQtZHJhZyBpbnRlcmFjdGlvbiBvblxyXG4vLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG52YXIgZGlzYWJsZVRleHRTZWxlY3Rpb247XHJcbnZhciBlbmFibGVUZXh0U2VsZWN0aW9uO1xyXG52YXIgX3VzZXJTZWxlY3Q7XHJcbmlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdG9uKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdG9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG59IGVsc2Uge1xyXG5cdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSB0ZXN0UHJvcChcclxuXHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcblx0XHRcdHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSAnbm9uZSc7XHJcblx0XHR9XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IF91c2VyU2VsZWN0O1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXHJcbi8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuLy8gZm9yIGBkcmFnc3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgYW4gaW1hZ2UuXHJcbmZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKSB7XHJcblx0b24od2luZG93LCAnZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpIHtcclxuXHRvZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG52YXIgX291dGxpbmVFbGVtZW50O1xudmFyIF9vdXRsaW5lU3R5bGU7XHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIHRoZSBbb3V0bGluZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL291dGxpbmUpXHJcbi8vIG9mIHRoZSBlbGVtZW50IGBlbGAgaW52aXNpYmxlLiBVc2VkIGludGVybmFsbHkgYnkgTGVhZmxldCB0byBwcmV2ZW50XHJcbi8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcclxuLy8gZHJhZyBpbnRlcmFjdGlvbiBvbiB0aGVtLlxyXG5mdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbGVtZW50KSB7XHJcblx0d2hpbGUgKGVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHRpZiAoIWVsZW1lbnQuc3R5bGUpIHsgcmV0dXJuOyB9XHJcblx0cmVzdG9yZU91dGxpbmUoKTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSBlbGVtZW50O1xyXG5cdF9vdXRsaW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLm91dGxpbmU7XHJcblx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xyXG5cdG9uKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZWBdKCkuXHJcbmZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG5cdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lID0gX291dGxpbmVTdHlsZTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcblx0X291dGxpbmVTdHlsZSA9IHVuZGVmaW5lZDtcclxuXHRvZmYod2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cblxudmFyIERvbVV0aWwgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0VFJBTlNGT1JNOiBUUkFOU0ZPUk0sXG5cdFRSQU5TSVRJT046IFRSQU5TSVRJT04sXG5cdFRSQU5TSVRJT05fRU5EOiBUUkFOU0lUSU9OX0VORCxcblx0Z2V0OiBnZXQsXG5cdGdldFN0eWxlOiBnZXRTdHlsZSxcblx0Y3JlYXRlOiBjcmVhdGUkMSxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGVtcHR5OiBlbXB0eSxcblx0dG9Gcm9udDogdG9Gcm9udCxcblx0dG9CYWNrOiB0b0JhY2ssXG5cdGhhc0NsYXNzOiBoYXNDbGFzcyxcblx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuXHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG5cdHNldENsYXNzOiBzZXRDbGFzcyxcblx0Z2V0Q2xhc3M6IGdldENsYXNzLFxuXHRzZXRPcGFjaXR5OiBzZXRPcGFjaXR5LFxuXHR0ZXN0UHJvcDogdGVzdFByb3AsXG5cdHNldFRyYW5zZm9ybTogc2V0VHJhbnNmb3JtLFxuXHRzZXRQb3NpdGlvbjogc2V0UG9zaXRpb24sXG5cdGdldFBvc2l0aW9uOiBnZXRQb3NpdGlvbixcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb246IGRpc2FibGVUZXh0U2VsZWN0aW9uLFxuXHRlbmFibGVUZXh0U2VsZWN0aW9uOiBlbmFibGVUZXh0U2VsZWN0aW9uLFxuXHRkaXNhYmxlSW1hZ2VEcmFnOiBkaXNhYmxlSW1hZ2VEcmFnLFxuXHRlbmFibGVJbWFnZURyYWc6IGVuYWJsZUltYWdlRHJhZyxcblx0cHJldmVudE91dGxpbmU6IHByZXZlbnRPdXRsaW5lLFxuXHRyZXN0b3JlT3V0bGluZTogcmVzdG9yZU91dGxpbmVcbn0pO1xuXG4vKlxuICogQGNsYXNzIFBvc0FuaW1hdGlvblxuICogQGFrYSBMLlBvc0FuaW1hdGlvblxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgcGFubmluZyBhbmltYXRpb25zLCB1dGlsaXppbmcgQ1NTMyBUcmFuc2l0aW9ucyBmb3IgbW9kZXJuIGJyb3dzZXJzIGFuZCBhIHRpbWVyIGZhbGxiYWNrIGZvciBJRTYtOS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBmeCA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuICogZngucnVuKGVsLCBbMzAwLCA1MDBdLCAwLjUpO1xuICogYGBgXG4gKlxuICogQGNvbnN0cnVjdG9yIEwuUG9zQW5pbWF0aW9uKClcbiAqIENyZWF0ZXMgYSBgUG9zQW5pbWF0aW9uYCBvYmplY3QuXG4gKlxuICovXG5cbnZhciBQb3NBbmltYXRpb24gPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQG1ldGhvZCBydW4oZWw6IEhUTUxFbGVtZW50LCBuZXdQb3M6IFBvaW50LCBkdXJhdGlvbj86IE51bWJlciwgZWFzZUxpbmVhcml0eT86IE51bWJlcilcblx0Ly8gUnVuIGFuIGFuaW1hdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQgdG8gYSBuZXcgcG9zaXRpb24sIG9wdGlvbmFsbHkgc2V0dGluZ1xuXHQvLyBkdXJhdGlvbiBpbiBzZWNvbmRzIChgMC4yNWAgYnkgZGVmYXVsdCkgYW5kIGVhc2luZyBsaW5lYXJpdHkgZmFjdG9yICgzcmRcblx0Ly8gYXJndW1lbnQgb2YgdGhlIFtjdWJpYyBiZXppZXIgY3VydmVdKGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLyMwLDAsLjUsMSksXG5cdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBnZXRQb3NpdGlvbihlbCk7XG5cdFx0dGhpcy5fb2Zmc2V0ID0gbmV3UG9zLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKTtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuXHRcdC8vIEBldmVudCBzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzXG5cdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG5cdFx0dGhpcy5fYW5pbWF0ZSgpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc3RvcCgpXG5cdC8vIFN0b3BzIHRoZSBhbmltYXRpb24gKGlmIGN1cnJlbnRseSBydW5uaW5nKS5cblx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3N0ZXAodHJ1ZSk7XG5cdFx0dGhpcy5fY29tcGxldGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGFuaW1hdGlvbiBsb29wXG5cdFx0dGhpcy5fYW5pbUlkID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcblx0XHR0aGlzLl9zdGVwKCk7XG5cdH0sXG5cblx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cblx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcywgcm91bmQpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKHRoaXMuX29mZnNldC5tdWx0aXBseUJ5KHByb2dyZXNzKSk7XG5cdFx0aWYgKHJvdW5kKSB7XG5cdFx0XHRwb3MuX3JvdW5kKCk7XG5cdFx0fVxuXHRcdHNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdC8vIEBldmVudCBlbmQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG5cdFx0dGhpcy5maXJlKCdlbmQnKTtcblx0fSxcblxuXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcblx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCB0aGlzLl9lYXNlT3V0UG93ZXIpO1xuXHR9XG59KTtcblxuLypcclxuICogQGNsYXNzIE1hcFxyXG4gKiBAYWthIEwuTWFwXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogLy8gaW5pdGlhbGl6ZSB0aGUgbWFwIG9uIHRoZSBcIm1hcFwiIGRpdiB3aXRoIGEgZ2l2ZW4gY2VudGVyIGFuZCB6b29tXHJcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gKiBcdGNlbnRlcjogWzUxLjUwNSwgLTAuMDldLFxyXG4gKiBcdHpvb206IDEzXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICovXHJcblxyXG52YXIgTWFwID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IEwuQ1JTLkVQU0czODU3XHJcblx0XHQvLyBUaGUgW0Nvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbV0oI2NycykgdG8gdXNlLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90XHJcblx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IEVQU0czODU3LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2VudGVyOiBMYXRMbmcgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG5cdFx0Y2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuXHRcdHpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgbG93ZXN0IG9mIHRoZWlyIGBtaW5ab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBoaWdoZXN0IG9mIHRoZWlyIGBtYXhab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuXHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcclxuXHRcdGxheWVyczogW10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuXHRcdC8vIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgbWFwIHJlc3RyaWN0cyB0aGUgdmlldyB0byB0aGUgZ2l2ZW5cclxuXHRcdC8vIGdlb2dyYXBoaWNhbCBib3VuZHMsIGJvdW5jaW5nIHRoZSB1c2VyIGJhY2sgaWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFuXHJcblx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuXHRcdC8vIFtgc2V0TWF4Qm91bmRzYF0oI21hcC1zZXRtYXhib3VuZHMpIG1ldGhvZC5cclxuXHRcdG1heEJvdW5kczogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBkcmF3aW5nIHZlY3RvciBsYXllcnMgb24gdGhlIG1hcC4gYEwuU1ZHYFxyXG5cdFx0Ly8gb3IgYEwuQ2FudmFzYCBieSBkZWZhdWx0IGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnQuXHJcblx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHR6b29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG5cdFx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB0aWxlIGZhZGUgYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWFya2VyWm9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgbWFya2VycyBhbmltYXRlIHRoZWlyIHpvb20gd2l0aCB0aGUgem9vbSBhbmltYXRpb24sIGlmIGRpc2FibGVkXHJcblx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG5cdFx0Ly8gZW5hYmxlZCBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG5cdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcclxuXHRcdC8vIHZhbHVlIHNob3VsZCBub3QgYmUgY2hhbmdlZCB1bmxlc3MgYSB3ZWIgYnJvd3NlciBwb3NpdGlvbnMgbGF5ZXJzIGluXHJcblx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG5cdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gRm9yY2VzIHRoZSBtYXAncyB6b29tIGxldmVsIHRvIGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIHRoaXMsIHBhcnRpY3VsYXJseVxyXG5cdFx0Ly8gcmlnaHQgYWZ0ZXIgYSBbYGZpdEJvdW5kcygpYF0oI21hcC1maXRib3VuZHMpIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG5cdFx0Ly8gKGUuZy4gYDAuNWAgb3IgYDAuMWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LiBBIHZhbHVlIG9mIGAwYFxyXG5cdFx0Ly8gbWVhbnMgdGhlIHpvb20gbGV2ZWwgd2lsbCBub3QgYmUgc25hcHBlZCBhZnRlciBgZml0Qm91bmRzYCBvciBhIHBpbmNoLXpvb20uXHJcblx0XHR6b29tU25hcDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21EZWx0YTogTnVtYmVyID0gMVxyXG5cdFx0Ly8gQ29udHJvbHMgaG93IG11Y2ggdGhlIG1hcCdzIHpvb20gbGV2ZWwgd2lsbCBjaGFuZ2UgYWZ0ZXIgYVxyXG5cdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuXHRcdC8vIG9yIGAtYCBvbiB0aGUga2V5Ym9hcmQsIG9yIHVzaW5nIHRoZSBbem9vbSBjb250cm9sc10oI2NvbnRyb2wtem9vbSkuXHJcblx0XHQvLyBWYWx1ZXMgc21hbGxlciB0aGFuIGAxYCAoZS5nLiBgMC41YCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuXHJcblx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgYnJvd3NlciB3aW5kb3cgcmVzaXplIHRvIHVwZGF0ZSBpdHNlbGYuXHJcblx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykgeyAvLyAoSFRNTEVsZW1lbnQgb3IgU3RyaW5nLCBPYmplY3QpXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHJcblx0XHQvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xOTgwXHJcblx0XHR0aGlzLl9vblJlc2l6ZSA9IGJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBUUkFOU0lUSU9OICYmIGFueTNkICYmICFtb2JpbGVPcGVyYSAmJlxyXG5cdFx0XHRcdHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xyXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xyXG5cdFx0XHRvbih0aGlzLl9wcm94eSwgVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcblx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIodG9MYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb20gPSBleHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XHJcblx0XHRcdFx0b3B0aW9ucy5wYW4gPSBleHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSwgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb259LCBvcHRpb25zLnBhbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG5cdFx0XHRpZiAobW92ZWQpIHtcclxuXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKGFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbU91dChkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBEZWNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tT3V0OiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKGFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcblx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0XHRcdHpvb206IHpvb21cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb21cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuXHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBQb3NBbmltYXRpb24oKTtcclxuXHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXHJcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG5cdFx0XHRhZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIWFueTNkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0dmFyIGZyb20gPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXHJcblx0XHQgICAgdG8gPSB0aGlzLnByb2plY3QodGFyZ2V0Q2VudGVyKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgc3RhcnRab29tID0gdGhpcy5fem9vbTtcclxuXHJcblx0XHR0YXJnZXRDZW50ZXIgPSB0b0xhdExuZyh0YXJnZXRDZW50ZXIpO1xyXG5cdFx0dGFyZ2V0Wm9vbSA9IHRhcmdldFpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHRhcmdldFpvb207XHJcblxyXG5cdFx0dmFyIHcwID0gTWF0aC5tYXgoc2l6ZS54LCBzaXplLnkpLFxyXG5cdFx0ICAgIHcxID0gdzAgKiB0aGlzLmdldFpvb21TY2FsZShzdGFydFpvb20sIHRhcmdldFpvb20pLFxyXG5cdFx0ICAgIHUxID0gKHRvLmRpc3RhbmNlVG8oZnJvbSkpIHx8IDEsXHJcblx0XHQgICAgcmhvID0gMS40MixcclxuXHRcdCAgICByaG8yID0gcmhvICogcmhvO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHIoaSkge1xyXG5cdFx0XHR2YXIgczEgPSBpID8gLTEgOiAxLFxyXG5cdFx0XHQgICAgczIgPSBpID8gdzEgOiB3MCxcclxuXHRcdFx0ICAgIHQxID0gdzEgKiB3MSAtIHcwICogdzAgKyBzMSAqIHJobzIgKiByaG8yICogdTEgKiB1MSxcclxuXHRcdFx0ICAgIGIxID0gMiAqIHMyICogcmhvMiAqIHUxLFxyXG5cdFx0XHQgICAgYiA9IHQxIC8gYjEsXHJcblx0XHRcdCAgICBzcSA9IE1hdGguc3FydChiICogYiArIDEpIC0gYjtcclxuXHJcblx0XHRcdCAgICAvLyB3b3JrYXJvdW5kIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gYnVnIHdoZW4gc3EgPSAwLCBsb2cgPSAtSW5maW5pdGUsXHJcblx0XHRcdCAgICAvLyB0aHVzIHRyaWdnZXJpbmcgYW4gaW5maW5pdGUgbG9vcCBpbiBmbHlUb1xyXG5cdFx0XHQgICAgdmFyIGxvZyA9IHNxIDwgMC4wMDAwMDAwMDEgPyAtMTggOiBNYXRoLmxvZyhzcSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gbG9nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuXHRcdGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuXHRcdGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cclxuXHJcblx0XHR2YXIgcjAgPSByKDApO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHcocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9XHJcblx0XHRmdW5jdGlvbiB1KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApICogdGFuaChyMCArIHJobyAqIHMpIC0gc2luaChyMCkpIC8gcmhvMjsgfVxyXG5cclxuXHRcdGZ1bmN0aW9uIGVhc2VPdXQodCkgeyByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCAxLjUpOyB9XHJcblxyXG5cdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcclxuXHRcdCAgICBTID0gKHIoMSkgLSByMCkgLyByaG8sXHJcblx0XHQgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gMTAwMCAqIG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwICogUyAqIDAuODtcclxuXHJcblx0XHRmdW5jdGlvbiBmcmFtZSgpIHtcclxuXHRcdFx0dmFyIHQgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIGR1cmF0aW9uLFxyXG5cdFx0XHQgICAgcyA9IGVhc2VPdXQodCkgKiBTO1xyXG5cclxuXHRcdFx0aWYgKHQgPD0gMSkge1xyXG5cdFx0XHRcdHRoaXMuX2ZseVRvRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fbW92ZShcclxuXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRmcmFtZS5jYWxsKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcblx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IG51bGw7XHJcblx0XHRcdHJldHVybiB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNaW5ab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBsb3dlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWluWm9vbV0oI21hcC1taW56b29tKSBvcHRpb24pLlxyXG5cdHNldE1pblpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdFx0dGhpcy5vcHRpb25zLm1pblpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZUJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxyXG5cdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgdG9MYXRMbmdCb3VuZHMoYm91bmRzKSk7XHJcblxyXG5cdFx0aWYgKCFjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHtcclxuXHRcdFx0dGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShvcHRpb25zOiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC4gSWYgYG9wdGlvbnMucGFuYCBpcyBgZmFsc2VgLCBwYW5uaW5nIHdpbGwgbm90IG9jY3VyLlxyXG5cdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xyXG5cdC8vIHRoYXQgaXQgZG9lc24ndCBoYXBwZW4gb2Z0ZW4gZXZlbiBpZiB0aGUgbWV0aG9kIGlzIGNhbGxlZCBtYW55XHJcblx0Ly8gdGltZXMgaW4gYSByb3cuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUoYW5pbWF0ZTogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuXHJcblx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBleHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcmVzaXplOiBSZXNpemVFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcblx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcblx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHQvLyBAbWV0aG9kIHN0b3AoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHRoZSBjdXJyZW50bHkgcnVubmluZyBgcGFuVG9gIG9yIGBmbHlUb2AgYW5pbWF0aW9uLCBpZiBhbnkuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy56b29tU25hcCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3N0b3AoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcblx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcblx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cclxuXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcblx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG5cdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcclxuXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IGV4dGVuZCh7XHJcblx0XHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG5cdFx0XHR3YXRjaDogZmFsc2VcclxuXHRcdFx0Ly8gc2V0VmlldzogZmFsc2VcclxuXHRcdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cclxuXHRcdFx0Ly8gbWF4aW11bUFnZTogMFxyXG5cdFx0XHQvLyBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcblx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoISgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikpIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcih7XHJcblx0XHRcdFx0Y29kZTogMCxcclxuXHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb25SZXNwb25zZSA9IGJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IGJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvciwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMud2F0Y2gpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRpb25XYXRjaElkID1cclxuXHRcdFx0ICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHdhdGNoaW5nIGxvY2F0aW9uIHByZXZpb3VzbHkgaW5pdGlhdGVkIGJ5IGBtYXAubG9jYXRlKHt3YXRjaDogdHJ1ZX0pYFxyXG5cdC8vIGFuZCBhYm9ydHMgcmVzZXR0aW5nIHRoZSBtYXAgdmlldyBpZiBtYXAubG9jYXRlIHdhcyBjYWxsZWQgd2l0aFxyXG5cdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxyXG5cdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24gJiYgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2gpIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG5cdFx0ICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBMb2NhdGlvbiBldmVudHNcclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKSBmYWlsZWQuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZXJyb3InLCB7XHJcblx0XHRcdGNvZGU6IGMsXHJcblx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHR2YXIgbGF0ID0gcG9zLmNvb3Jkcy5sYXRpdHVkZSxcclxuXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuXHRcdCAgICBsYXRsbmcgPSBuZXcgTGF0TG5nKGxhdCwgbG5nKSxcclxuXHRcdCAgICBib3VuZHMgPSBsYXRsbmcudG9Cb3VuZHMocG9zLmNvb3Jkcy5hY2N1cmFjeSksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBBcHByb3ByaWF0ZSBkb2NzIHNlY3Rpb24/XHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcblx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXJJZCAhPT0gdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVySWQ7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkID0gdW5kZWZpbmVkO1xyXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGlvbldhdGNoSWQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnN0b3BMb2NhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0cmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJIYW5kbGVycygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHVubG9hZDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGRlc3Ryb3llZCB3aXRoIFtyZW1vdmVdKCNtYXAtcmVtb3ZlKSBtZXRob2QuXHJcblx0XHRcdHRoaXMuZmlyZSgndW5sb2FkJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGk7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5yZW1vdmUoKTtcclxuXHRcdH1cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9wYW5lcykge1xyXG5cdFx0XHRyZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1pblpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLCBvciBgMGAgYnkgZGVmYXVsdC5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcblx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcblx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG5cdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cclxuXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuXHRcdCAgICBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcblx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcclxuXHRcdCAgICBzbmFwID0gYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxLFxyXG5cdFx0ICAgIHNjYWxleCA9IHNpemUueCAvIGJvdW5kc1NpemUueCxcclxuXHRcdCAgICBzY2FsZXkgPSBzaXplLnkgLyBib3VuZHNTaXplLnksXHJcblx0XHQgICAgc2NhbGUgPSBpbnNpZGUgPyBNYXRoLm1heChzY2FsZXgsIHNjYWxleSkgOiBNYXRoLm1pbihzY2FsZXgsIHNjYWxleSk7XHJcblxyXG5cdFx0em9vbSA9IHRoaXMuZ2V0U2NhbGVab29tKHNjYWxlLCB6b29tKTtcclxuXHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcblx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDAsXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAwKTtcclxuXHJcblx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxCb3VuZHMoKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3IGluIHByb2plY3RlZCBwaXhlbFxyXG5cdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE86IENoZWNrIHNlbWFudGljcyAtIGlzbid0IHRoZSBwaXhlbCBvcmlnaW4gdGhlIDAsMCBjb29yZCByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuXHQvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbmVnYXRpdmUgb2Zmc2V0cy5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsT3JpZ2luKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG5cdC8vIHRoZSBtYXAgbGF5ZXIgKHVzZWZ1bCBpbiBjdXN0b20gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsT3JpZ2luO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgd29ybGQncyBib3VuZHMgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIHpvb20gbGV2ZWwgYHpvb21gLlxyXG5cdC8vIElmIGB6b29tYCBpcyBvbWl0dGVkLCB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIHVzZWQuXHJcblx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lKHBhbmU6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhIFttYXAgcGFuZV0oI21hcC1wYW5lKSwgZ2l2ZW4gaXRzIG5hbWUgb3IgaXRzIEhUTUwgZWxlbWVudCAoaXRzIGlkZW50aXR5KS5cclxuXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIFtwYW5lc10oI21hcC1wYW5lKSBhcyBrZXlzIGFuZFxyXG5cdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXHJcblx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYW5lcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgbWFwLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgZmFjdG9yIHRvIGJlIGFwcGxpZWQgdG8gYSBtYXAgdHJhbnNpdGlvbiBmcm9tIHpvb20gbGV2ZWxcclxuXHQvLyBgZnJvbVpvb21gIHRvIGB0b1pvb21gLiBVc2VkIGludGVybmFsbHkgdG8gaGVscCB3aXRoIHpvb20gYW5pbWF0aW9ucy5cclxuXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcblx0XHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0cmV0dXJuIGNycy5zY2FsZSh0b1pvb20pIC8gY3JzLnNjYWxlKGZyb21ab29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXHJcblx0Ly8gbGV2ZWwgYW5kIGV2ZXJ5dGhpbmcgaXMgc2NhbGVkIGJ5IGEgZmFjdG9yIG9mIGBzY2FsZWAuIEludmVyc2Ugb2ZcclxuXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSwgZnJvbVpvb20pIHtcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0dmFyIHpvb20gPSBjcnMuem9vbShzY2FsZSAqIGNycy5zY2FsZShmcm9tWm9vbSkpO1xyXG5cdFx0cmV0dXJuIGlzTmFOKHpvb20pID8gSW5maW5pdHkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGBMYXRMbmdgIGFjY29yZGluZyB0byB0aGUgcHJvamVjdGlvblxyXG5cdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG5cdC8vIGBUcmFuc2Zvcm1hdGlvbmAuIFRoZSByZXN1bHQgaXMgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBDUlMgb3JpZ2luLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQodG9MYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBJbnZlcnNlIG9mIFtgcHJvamVjdGBdKCNtYXAtcHJvamVjdCkuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcodG9Qb2ludChwb2ludCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGxheWVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRsYXRMbmdUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuXHRcdHJldHVybiBwcm9qZWN0ZWRQb2ludC5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgYGxhdGAgYW5kIGBsbmdgIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIG1hcCdzIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlXHJcblx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcodG9MYXRMbmcobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZyB0aGF0XHJcblx0Ly8gaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLCBhbmQgdGhlIG1ham9yaXR5IG9mIHRoZSBib3VuZHNcclxuXHQvLyBvdmVybGFwcyB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHModG9MYXRMbmdCb3VuZHMobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG9cclxuXHQvLyB0aGUgbWFwJ3MgQ1JTLiBCeSBkZWZhdWx0IHRoaXMgbWVhc3VyZXMgZGlzdGFuY2UgaW4gbWV0ZXJzLlxyXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UodG9MYXRMbmcobGF0bG5nMSksIHRvTGF0TG5nKGxhdGxuZzIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG5cdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodG9Qb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQodG9MYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcblx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBnZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXllclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xhdExuZyhldjogTW91c2VFdmVudCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXHJcblx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBnZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHRvbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcblx0XHR0aGlzLl9jb250YWluZXJJZCA9IHN0YW1wKGNvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgYW55M2Q7XHJcblxyXG5cdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KHRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChyZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArXHJcblx0XHRcdChpZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQoc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IGdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdFBhbmVzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2luaXRDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBhbmVzID0gdGhpcy5fcGFuZXMgPSB7fTtcclxuXHRcdHRoaXMuX3BhbmVSZW5kZXJlcnMgPSB7fTtcclxuXHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly9cclxuXHRcdC8vIFBhbmVzIGFyZSBET00gZWxlbWVudHMgdXNlZCB0byBjb250cm9sIHRoZSBvcmRlcmluZyBvZiBsYXllcnMgb24gdGhlIG1hcC4gWW91XHJcblx0XHQvLyBjYW4gYWNjZXNzIHBhbmVzIHdpdGggW2BtYXAuZ2V0UGFuZWBdKCNtYXAtZ2V0cGFuZSkgb3JcclxuXHRcdC8vIFtgbWFwLmdldFBhbmVzYF0oI21hcC1nZXRwYW5lcykgbWV0aG9kcy4gTmV3IHBhbmVzIGNhbiBiZSBjcmVhdGVkIHdpdGggdGhlXHJcblx0XHQvLyBbYG1hcC5jcmVhdGVQYW5lYF0oI21hcC1jcmVhdGVwYW5lKSBtZXRob2QuXHJcblx0XHQvL1xyXG5cdFx0Ly8gRXZlcnkgbWFwIGhhcyB0aGUgZm9sbG93aW5nIGRlZmF1bHQgcGFuZXMgdGhhdCBkaWZmZXIgb25seSBpbiB6SW5kZXguXHJcblx0XHQvL1xyXG5cdFx0Ly8gQHBhbmUgbWFwUGFuZTogSFRNTEVsZW1lbnQgPSAnYXV0bydcclxuXHRcdC8vIFBhbmUgdGhhdCBjb250YWlucyBhbGwgb3RoZXIgbWFwIHBhbmVzXHJcblxyXG5cdFx0dGhpcy5fbWFwUGFuZSA9IHRoaXMuY3JlYXRlUGFuZSgnbWFwUGFuZScsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHRzZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHNoYWRvd1BhbmU6IEhUTUxFbGVtZW50ID0gNTAwXHJcblx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnb3ZlcmxheVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcblx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcblx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRhZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0YWRkQ2xhc3MocGFuZXMuc2hhZG93UGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyB0aGF0IG1vZGlmeSBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHRzZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XHJcblx0XHR6b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XHJcblxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHRcdHRoaXNcclxuXHRcdFx0Ll9tb3ZlU3RhcnQoem9vbUNoYW5nZWQsIGZhbHNlKVxyXG5cdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG5cdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG5cdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG5cdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuXHRcdGlmIChsb2FkaW5nKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBpcyBhYm91dCB0byBjaGFuZ2UgKGUuZy4gYmVmb3JlIHpvb20gYW5pbWF0aW9uKS5cclxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRpZiAoIW5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLCBpbmNsdWRpbmcgem9vbVxyXG5cdFx0Ly8gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLCBpbmNsdWRpbmcgcGFuIGFuZFxyXG5cdFx0Ly8gZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21lbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaGFzIGNoYW5nZWQsIGFmdGVyIGFueSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdG9wcGVkXHJcblx0XHQvLyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfc3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5zdG9wKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG5cdH0sXHJcblxyXG5cdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmTG9hZGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuXHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBldmVudHNcclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSQkMSkge1xyXG5cdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdGFyZ2V0c1tzdGFtcCh0aGlzLl9jb250YWluZXIpXSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlJCQxID8gb2ZmIDogb247XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuXHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cclxuXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcblx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHRvbk9mZih0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3MnLCB0aGlzLl9oYW5kbGVET01FdmVudCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdChyZW1vdmUkJDEgPyB0aGlzLm9mZiA6IHRoaXMub24pLmNhbGwodGhpcywgJ21vdmVlbmQnLCB0aGlzLl9vbk1vdmVFbmQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCAgPSAwO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMDM4NzMgYnV0IFdlYmtpdCBhbHNvIGhhdmVcclxuXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW3N0YW1wKHNyYyldO1xyXG5cdFx0XHRpZiAodGFyZ2V0ICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdwcmVjbGljaycpICYmICFlLl9zaW11bGF0ZWQgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIWlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBza2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJyB8fCB0eXBlID09PSAna2V5cHJlc3MnKSB7XHJcblx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG5cdFx0XHRwcmV2ZW50T3V0bGluZShlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuXHR9LFxyXG5cclxuXHRfbW91c2VFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J10sXHJcblxyXG5cdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCB0YXJnZXRzKSB7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcblx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxyXG5cdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG5cdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuXHRcdFx0dmFyIHN5bnRoID0gZXh0ZW5kKHt9LCBlKTtcclxuXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcblx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgdGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUuX3N0b3BwZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG5cdFx0dGFyZ2V0cyA9ICh0YXJnZXRzIHx8IFtdKS5jb25jYXQodGhpcy5fZmluZEV2ZW50VGFyZ2V0cyhlLCB0eXBlKSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycpIHtcclxuXHRcdFx0dmFyIGlzTWFya2VyID0gdGFyZ2V0LmdldExhdExuZyAmJiAoIXRhcmdldC5fcmFkaXVzIHx8IHRhcmdldC5fcmFkaXVzIDw9IDEwKTtcclxuXHRcdFx0ZGF0YS5jb250YWluZXJQb2ludCA9IGlzTWFya2VyID9cclxuXHRcdFx0XHR0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGFyZ2V0LmdldExhdExuZygpKSA6IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XHJcblx0XHRcdGRhdGEubGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoZGF0YS5jb250YWluZXJQb2ludCk7XHJcblx0XHRcdGRhdGEubGF0bG5nID0gaXNNYXJrZXIgPyB0YXJnZXQuZ2V0TGF0TG5nKCkgOiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhkYXRhLmxheWVyUG9pbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XHJcblx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMgPT09IGZhbHNlICYmIGluZGV4T2YodGhpcy5fbW91c2VFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRvYmogPSBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLmVuYWJsZWQoKSA/IG9iaiA6IHRoaXM7XHJcblx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIHdoZW5SZWFkeShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcblx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcblx0Ly8gaWYgaXQncyBhbHJlYWR5IGluaXRpYWxpemVkLCBvcHRpb25hbGx5IHBhc3NpbmcgYSBmdW5jdGlvbiBjb250ZXh0LlxyXG5cdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCB8fCB0aGlzLCB7dGFyZ2V0OiB0aGlzfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBnZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblx0fSxcclxuXHJcblx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0cmV0dXJuIHBvcyAmJiAhcG9zLmVxdWFscyhbMCwgMF0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciBwaXhlbE9yaWdpbiA9IGNlbnRlciAmJiB6b29tICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHR0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDpcclxuXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG5cdFx0cmV0dXJuIHBpeGVsT3JpZ2luLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ1RvTmV3TGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0b0JvdW5kcyhbXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KVxyXG5cdFx0XSk7XHJcblx0fSxcclxuXHJcblx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG5cdF9nZXRDZW50ZXJPZmZzZXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IGNlbnRlciBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuXHRcdHZhciBjZW50ZXJQb2ludCA9IHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRCb3VuZHNPZmZzZXQodmlld0JvdW5kcywgYm91bmRzLCB6b29tKTtcclxuXHJcblx0XHQvLyBJZiBvZmZzZXQgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIGlnbm9yZS5cclxuXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuXHRcdC8vIGFuIGluZmluaXRlIGxvb3Agb2YgdGlueSBvZmZzZXRzLlxyXG5cdFx0aWYgKG9mZnNldC5yb3VuZCgpLmVxdWFscyhbMCwgMF0pKSB7XHJcblx0XHRcdHJldHVybiBjZW50ZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3Qgb2Zmc2V0IGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcblx0XHR2YXIgdmlld0JvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcblx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRNYXhCb3VuZHMgPSB0b0JvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcblx0XHQgICAgKSxcclxuXHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcblx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuXHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LngsIC1tYXhPZmZzZXQueCksXHJcblx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC55LCAtbWF4T2Zmc2V0LnkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZHgsIGR5KTtcclxuXHR9LFxyXG5cclxuXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcblx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcblx0XHRcdE1hdGgucm91bmQobGVmdCAtIHJpZ2h0KSAvIDIgOlxyXG5cdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG5cdH0sXHJcblxyXG5cdF9saW1pdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgc25hcCA9IGFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG5cdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcclxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fdHJ1bmMoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblx0XHR0aGlzLl9wYW5lcy5tYXBQYW5lLmFwcGVuZENoaWxkKHByb3h5KTtcclxuXHJcblx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHZhciBwcm9wID0gVFJBTlNGT1JNLFxyXG5cdFx0XHQgICAgdHJhbnNmb3JtID0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF07XHJcblxyXG5cdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XHJcblxyXG5cdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG5cdFx0XHRpZiAodHJhbnNmb3JtID09PSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXSAmJiB0aGlzLl9hbmltYXRpbmdab29tKSB7XHJcblx0XHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLm9uKCdsb2FkIG1vdmVlbmQnLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcclxuXHRcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX29uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95QW5pbVByb3h5LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmVtb3ZlKHRoaXMuX3Byb3h5KTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9wcm94eTtcclxuXHR9LFxyXG5cclxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xyXG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XHJcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRyZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpXHJcblx0XHRcdCAgICAuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgdHJ1ZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwUGFuZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoc3RhcnRBbmltKSB7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb0NlbnRlciA9IGNlbnRlcjtcclxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG5cdFx0XHRhZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgem9vbWFuaW06IFpvb21BbmltRXZlbnRcclxuXHRcdC8vIEZpcmVkIG9uIGV2ZXJ5IGZyYW1lIG9mIGEgem9vbSBhbmltYXRpb25cclxuXHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tLFxyXG5cdFx0XHRub1VwZGF0ZTogbm9VcGRhdGVcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFdvcmsgYXJvdW5kIHdlYmtpdCBub3QgZmlyaW5nICd0cmFuc2l0aW9uZW5kJywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzM2ODksIDI2OTNcclxuXHRcdHNldFRpbWVvdXQoYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuXHR9LFxyXG5cclxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XHJcblx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSk7XHJcblxyXG5cdFx0Ly8gVGhpcyBhbmltIGZyYW1lIHNob3VsZCBwcmV2ZW50IGFuIG9ic2N1cmUgaU9TIHdlYmtpdCB0aWxlIGxvYWRpbmcgcmFjZSBjb25kaXRpb24uXHJcblx0XHRyZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbmZ1bmN0aW9uIGNyZWF0ZU1hcChpZCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTWFwKGlkLCBvcHRpb25zKTtcclxufVxuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbFxyXG4gKiBAYWthIEwuQ29udHJvbFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxudmFyIENvbnRyb2wgPSBDbGFzcy5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIHBvc2l0aW9uOiBTdHJpbmcgPSAndG9wcmlnaHQnXHJcblx0XHQvLyBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgKG9uZSBvZiB0aGUgbWFwIGNvcm5lcnMpLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAndG9wbGVmdCdgLFxyXG5cdFx0Ly8gYCd0b3ByaWdodCdgLCBgJ2JvdHRvbWxlZnQnYCBvciBgJ2JvdHRvbXJpZ2h0J2BcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdCAqL1xyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG5cdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB7XHJcblx0XHRcdHRoaXMub25SZW1vdmUodGhpcy5fbWFwKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yZWZvY3VzT25NYXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBpZiBtYXAgZXhpc3RzIGFuZCBldmVudCBpcyBub3QgYSBrZXlib2FyZCBldmVudFxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiBlICYmIGUuc2NyZWVuWCA+IDAgJiYgZS5zY3JlZW5ZID4gMCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxudmFyIGNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQ29udHJvbChvcHRpb25zKTtcclxufTtcclxuXHJcbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAqIEB1bmluaGVyaXRhYmxlXHJcbiAqXHJcbiAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudFxyXG4gKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICpcclxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcClcclxuICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gKi9cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICovXHJcbk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIGFkZENvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcblx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIGNyZWF0ZSQxKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG5cdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAncmlnaHQnKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2NvbnRyb2xDb3JuZXJzKSB7XHJcblx0XHRcdHJlbW92ZSh0aGlzLl9jb250cm9sQ29ybmVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcclxuXHR9XHJcbn0pO1xuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHA6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2xheWVycy1jb250cm9sLykpLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAqIFx0XCJNYXBib3hcIjogbWFwYm94LFxyXG4gKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICogfTtcclxuICpcclxuICogdmFyIG92ZXJsYXlzID0ge1xyXG4gKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICogXHRcIlJvYWRzXCI6IHJvYWRzTGF5ZXJcclxuICogfTtcclxuICpcclxuICogTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBgYmFzZUxheWVyc2AgYW5kIGBvdmVybGF5c2AgcGFyYW1ldGVycyBhcmUgb2JqZWN0IGxpdGVyYWxzIHdpdGggbGF5ZXIgbmFtZXMgYXMga2V5cyBhbmQgYExheWVyYCBvYmplY3RzIGFzIHZhbHVlczpcclxuICpcclxuICogYGBganNcclxuICoge1xyXG4gKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXIgbmFtZXMgY2FuIGNvbnRhaW4gSFRNTCwgd2hpY2ggYWxsb3dzIHlvdSB0byBhZGQgYWRkaXRpb25hbCBzdHlsaW5nIHRvIHRoZSBpdGVtczpcclxuICpcclxuICogYGBganNcclxuICoge1wiPGltZyBzcmM9J215LWxheWVyLWljb24nIC8+IDxzcGFuIGNsYXNzPSdteS1sYXllci1pdGVtJz5NeSBMYXllcjwvc3Bhbj5cIjogbXlMYXllcn1cclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIExheWVycyA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyIG9yIHRvdWNoLlxyXG5cdFx0Y29sbGFwc2VkOiB0cnVlLFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGFzc2lnbiB6SW5kZXhlcyBpbiBpbmNyZWFzaW5nIG9yZGVyIHRvIGFsbCBvZiBpdHMgbGF5ZXJzIHNvIHRoYXQgdGhlIG9yZGVyIGlzIHByZXNlcnZlZCB3aGVuIHN3aXRjaGluZyB0aGVtIG9uL29mZi5cclxuXHRcdGF1dG9aSW5kZXg6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGxheWVycyBpbiB0aGUgY29udHJvbCB3aWxsIGJlIGhpZGRlbiB3aGVuIHRoZXJlIGlzIG9ubHkgb25lLlxyXG5cdFx0aGlkZVNpbmdsZUJhc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydExheWVyczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRvIHNvcnQgdGhlIGxheWVycy4gV2hlbiBgZmFsc2VgLCBsYXllcnMgd2lsbCBrZWVwIHRoZSBvcmRlclxyXG5cdFx0Ly8gaW4gd2hpY2ggdGhleSB3ZXJlIGFkZGVkIHRvIHRoZSBjb250cm9sLlxyXG5cdFx0c29ydExheWVyczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzb3J0RnVuY3Rpb246IEZ1bmN0aW9uID0gKlxyXG5cdFx0Ly8gQSBbY29tcGFyZSBmdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydClcclxuXHRcdC8vIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBzb3J0aW5nIHRoZSBsYXllcnMsIHdoZW4gYHNvcnRMYXllcnNgIGlzIGB0cnVlYC5cclxuXHRcdC8vIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBib3RoIHRoZSBgTC5MYXllcmAgaW5zdGFuY2VzIGFuZCB0aGVpciBuYW1lcywgYXMgaW5cclxuXHRcdC8vIGBzb3J0RnVuY3Rpb24obGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQilgLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgaXQgc29ydHMgbGF5ZXJzIGFscGhhYmV0aWNhbGx5IGJ5IHRoZWlyIG5hbWUuXHJcblx0XHRzb3J0RnVuY3Rpb246IGZ1bmN0aW9uIChsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKSB7XHJcblx0XHRcdHJldHVybiBuYW1lQSA8IG5hbWVCID8gLTEgOiAobmFtZUIgPCBuYW1lQSA/IDEgOiAwKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRDb250cm9sLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMsIG1hcCk7XHJcblx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuXHRcdHJldHVybiB0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBiYXNlIGxheWVyIChyYWRpbyBidXR0b24gZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBvdmVybGF5IChjaGVja2JveCBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRPdmVybGF5OiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmUgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGNvbnRyb2wuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKHN0YW1wKGxheWVyKSk7XHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xyXG5cdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG5cdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0dGhpcy5fZm9ybS5zdHlsZS5oZWlnaHQgPSBudWxsO1xyXG5cdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuXHRcdGlmIChhY2NlcHRhYmxlSGVpZ2h0IDwgdGhpcy5fZm9ybS5jbGllbnRIZWlnaHQpIHtcclxuXHRcdFx0YWRkQ2xhc3ModGhpcy5fZm9ybSwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHRcdHRoaXMuX2Zvcm0uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9mb3JtLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29sbGFwc2UoKTogdGhpc1xyXG5cdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycycsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXHJcblx0XHQgICAgY29sbGFwc2VkID0gdGhpcy5vcHRpb25zLmNvbGxhcHNlZDtcclxuXHJcblx0XHQvLyBtYWtlcyB0aGlzIHdvcmsgb24gSUUgdG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXHJcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG5cdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cclxuXHRcdHZhciBmb3JtID0gdGhpcy5fZm9ybSA9IGNyZWF0ZSQxKCdmb3JtJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG5cdFx0aWYgKGNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5jb2xsYXBzZSwgdGhpcyk7XHJcblxyXG5cdFx0XHRpZiAoIWFuZHJvaWQpIHtcclxuXHRcdFx0XHRvbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuZXhwYW5kLFxyXG5cdFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gY3JlYXRlJDEoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcblxyXG5cdFx0aWYgKHRvdWNoKSB7XHJcblx0XHRcdG9uKGxpbmssICdjbGljaycsIHN0b3ApO1xyXG5cdFx0XHRvbihsaW5rLCAnY2xpY2snLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvbihsaW5rLCAnZm9jdXMnLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBmb3JtKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIGZvcm0pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBmb3JtKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZm9ybSk7XHJcblx0fSxcclxuXHJcblx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIHN0YW1wKHRoaXMuX2xheWVyc1tpXS5sYXllcikgPT09IGlkKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9hZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lLCBvdmVybGF5KSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdGxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzLnB1c2goe1xyXG5cdFx0XHRsYXllcjogbGF5ZXIsXHJcblx0XHRcdG5hbWU6IG5hbWUsXHJcblx0XHRcdG92ZXJsYXk6IG92ZXJsYXlcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc29ydExheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnMuc29ydChiaW5kKGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0ZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG5cdFx0ZW1wdHkodGhpcy5fb3ZlcmxheXNMaXN0KTtcclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuXHRcdHZhciBiYXNlTGF5ZXJzUHJlc2VudCwgb3ZlcmxheXNQcmVzZW50LCBpLCBvYmosIGJhc2VMYXllcnNDb3VudCA9IDA7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRvYmogPSB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdHRoaXMuX2FkZEl0ZW0ob2JqKTtcclxuXHRcdFx0b3ZlcmxheXNQcmVzZW50ID0gb3ZlcmxheXNQcmVzZW50IHx8IG9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50IHx8ICFvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc0NvdW50ICs9ICFvYmoub3ZlcmxheSA/IDEgOiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEhpZGUgYmFzZSBsYXllcnMgc2VjdGlvbiBpZiB0aGVyZSdzIG9ubHkgb25lIGxheWVyLlxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5oaWRlU2luZ2xlQmFzZSkge1xyXG5cdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50ICYmIGJhc2VMYXllcnNDb3VudCA+IDE7XHJcblx0XHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0LnN0eWxlLmRpc3BsYXkgPSBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3NlcGFyYXRvci5zdHlsZS5kaXNwbGF5ID0gb3ZlcmxheXNQcmVzZW50ICYmIGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29uTGF5ZXJDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2hhbmRsaW5nQ2xpY2spIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKHN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheWFkZDogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnMnLCBjaGVja2VkKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMucHVzaChpbnB1dCk7XHJcblx0XHRpbnB1dC5sYXllcklkID0gc3RhbXAob2JqLmxheWVyKTtcclxuXHJcblx0XHRvbihpbnB1dCwgJ2NsaWNrJywgdGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHRcdG5hbWUuaW5uZXJIVE1MID0gJyAnICsgb2JqLm5hbWU7XHJcblxyXG5cdFx0Ly8gSGVscHMgZnJvbSBwcmV2ZW50aW5nIGxheWVyIGNvbnRyb2wgZmxpY2tlciB3aGVuIGNoZWNrYm94ZXMgYXJlIGRpc2FibGVkXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yNzcxXHJcblx0XHR2YXIgaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG5cdFx0bGFiZWwuYXBwZW5kQ2hpbGQoaG9sZGVyKTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChpbnB1dCk7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IG9iai5vdmVybGF5ID8gdGhpcy5fb3ZlcmxheXNMaXN0IDogdGhpcy5fYmFzZUxheWVyc0xpc3Q7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG5cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiBsYWJlbDtcclxuXHR9LFxyXG5cclxuXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG5cdFx0ICAgIGlucHV0LCBsYXllcjtcclxuXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG5cdFx0ICAgIHJlbW92ZWRMYXllcnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cclxuXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRhZGRlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdHJlbW92ZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBCdWdmaXggaXNzdWUgMjMxODogU2hvdWxkIHJlbW92ZSBhbGwgb2xkIGxheWVycyBiZWZvcmUgcmVhZGRpbmcgbmV3IG9uZXNcclxuXHRcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIocmVtb3ZlZExheWVyc1tpXSkpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBhZGRlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuX21hcC5oYXNMYXllcihhZGRlZExheWVyc1tpXSkpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIoYWRkZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jaGVja0Rpc2FibGVkTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG5cdFx0ICAgIGlucHV0LFxyXG5cdFx0ICAgIGxheWVyLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblx0XHRcdGlucHV0LmRpc2FibGVkID0gKGxheWVyLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPCBsYXllci5vcHRpb25zLm1pblpvb20pIHx8XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgKGxheWVyLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPiBsYXllci5vcHRpb25zLm1heFpvb20pO1xyXG5cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kSWZOb3RDb2xsYXBzZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9leHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHJlbW92ZSBtZSBpbiAxLjEuXHJcblx0XHRyZXR1cm4gdGhpcy5leHBhbmQoKTtcclxuXHR9LFxyXG5cclxuXHRfY29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHJlbW92ZSBtZSBpbiAxLjEuXHJcblx0XHRyZXR1cm4gdGhpcy5jb2xsYXBzZSgpO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5sYXllcnMoYmFzZWxheWVycz86IE9iamVjdCwgb3ZlcmxheXM/OiBPYmplY3QsIG9wdGlvbnM/OiBDb250cm9sLkxheWVycyBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxyXG52YXIgbGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAqIEBha2EgTC5Db250cm9sLlpvb21cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogQSBiYXNpYyB6b29tIGNvbnRyb2wgd2l0aCB0d28gYnV0dG9ucyAoem9vbSBpbiBhbmQgem9vbSBvdXQpLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHRvIGBmYWxzZWAuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKi9cclxuXHJcbnZhciBab29tID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLlpvb20gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnKydcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRleHQ6ICcrJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRpdGxlOiBTdHJpbmcgPSAnWm9vbSBpbidcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRleHQ6IFN0cmluZyA9ICcmI3gyMjEyOydcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGV4dDogJyYjeDIyMTI7JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUaXRsZTogU3RyaW5nID0gJ1pvb20gb3V0J1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGl0bGU6ICdab29tIG91dCdcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuXHRcdCAgICBjb250YWluZXIgPSBjcmVhdGUkMSgnZGl2Jywgem9vbU5hbWUgKyAnIGxlYWZsZXQtYmFyJyksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbUluVGV4dCwgb3B0aW9ucy56b29tSW5UaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLWluJywgIGNvbnRhaW5lciwgdGhpcy5fem9vbUluKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tT3V0VGV4dCwgb3B0aW9ucy56b29tT3V0VGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1vdXQnLCBjb250YWluZXIsIHRoaXMuX3pvb21PdXQpO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRtYXAub24oJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub2ZmKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPCB0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdHRoaXMuX21hcC56b29tSW4odGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF96b29tT3V0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPiB0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdHRoaXMuX21hcC56b29tT3V0KHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbiAoaHRtbCwgdGl0bGUsIGNsYXNzTmFtZSwgY29udGFpbmVyLCBmbikge1xyXG5cdFx0dmFyIGxpbmsgPSBjcmVhdGUkMSgnYScsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSB0aXRsZTtcclxuXHJcblx0XHQvKlxyXG5cdFx0ICogV2lsbCBmb3JjZSBzY3JlZW4gcmVhZGVycyBsaWtlIFZvaWNlT3ZlciB0byByZWFkIHRoaXMgYXMgXCJab29tIGluIC0gYnV0dG9uXCJcclxuXHRcdCAqL1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcclxuXHJcblx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihsaW5rKTtcclxuXHRcdG9uKGxpbmssICdjbGljaycsIHN0b3ApO1xyXG5cdFx0b24obGluaywgJ2NsaWNrJywgZm4sIHRoaXMpO1xyXG5cdFx0b24obGluaywgJ2NsaWNrJywgdGhpcy5fcmVmb2N1c09uTWFwLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gbGluaztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY2xhc3NOYW1lID0gJ2xlYWZsZXQtZGlzYWJsZWQnO1xyXG5cclxuXHRcdHJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdHJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHRhZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHRhZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIHpvb21Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW3pvb20gY29udHJvbF0oI2NvbnRyb2wtem9vbSkgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHR6b29tQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy56b29tQ29udHJvbCkge1xyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbnZhciB6b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFpvb20ob3B0aW9ucyk7XHJcbn07XG5cbi8qXG4gKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAqIEBpbmhlcml0cyBDb250cm9sXG4gKlxuICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbnZhciBTY2FsZSA9IENvbnRyb2wuZXh0ZW5kKHtcblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcblx0XHQvLyBNYXhpbXVtIHdpZHRoIG9mIHRoZSBjb250cm9sIGluIHBpeGVscy4gVGhlIHdpZHRoIGlzIHNldCBkeW5hbWljYWxseSB0byBzaG93IHJvdW5kIHZhbHVlcyAoZS5nLiAxMDAsIDIwMCwgNTAwKS5cblx0XHRtYXhXaWR0aDogMTAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBtZXRyaWMgc2NhbGUgbGluZSAobS9rbSkuXG5cdFx0bWV0cmljOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIGltcGVyaWFsIHNjYWxlIGxpbmUgKG1pL2Z0KS5cblx0XHRpbXBlcmlhbDogdHJ1ZVxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCBpcyB1cGRhdGVkIG9uIFtgbW92ZWVuZGBdKCNtYXAtbW92ZWVuZCksIG90aGVyd2lzZSBpdCdzIGFsd2F5cyB1cC10by1kYXRlICh1cGRhdGVkIG9uIFtgbW92ZWBdKCNtYXAtbW92ZSkpLlxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuXHRcdCAgICBjb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuX2FkZFNjYWxlcyhvcHRpb25zLCBjbGFzc05hbWUgKyAnLWxpbmUnLCBjb250YWluZXIpO1xuXG5cdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHR9LFxuXG5cdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuXHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuXHRcdFx0dGhpcy5fbVNjYWxlID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcblx0XHRcdHRoaXMuX2lTY2FsZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB5ID0gbWFwLmdldFNpemUoKS55IC8gMjtcblxuXHRcdHZhciBtYXhNZXRlcnMgPSBtYXAuZGlzdGFuY2UoXG5cdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3RoaXMub3B0aW9ucy5tYXhXaWR0aCwgeV0pKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zLm1ldHJpYyAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU1ldHJpYyhtYXhNZXRlcnMpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmltcGVyaWFsICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlSW1wZXJpYWwobWF4TWV0ZXJzKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtZXRlcnMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNZXRlcnMpLFxuXHRcdCAgICBsYWJlbCA9IG1ldGVycyA8IDEwMDAgPyBtZXRlcnMgKyAnIG0nIDogKG1ldGVycyAvIDEwMDApICsgJyBrbSc7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsIGxhYmVsLCBtZXRlcnMgLyBtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuXHRcdCAgICBtYXhNaWxlcywgbWlsZXMsIGZlZXQ7XG5cblx0XHRpZiAobWF4RmVldCA+IDUyODApIHtcblx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG5cdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgbWlsZXMgKyAnIG1pJywgbWlsZXMgLyBtYXhNaWxlcyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBmZWV0ICsgJyBmdCcsIGZlZXQgLyBtYXhGZWV0KTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlOiBmdW5jdGlvbiAoc2NhbGUsIHRleHQsIHJhdGlvKSB7XG5cdFx0c2NhbGUuc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSArICdweCc7XG5cdFx0c2NhbGUuaW5uZXJIVE1MID0gdGV4dDtcblx0fSxcblxuXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcblx0XHR2YXIgcG93MTAgPSBNYXRoLnBvdygxMCwgKE1hdGguZmxvb3IobnVtKSArICcnKS5sZW5ndGggLSAxKSxcblx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG5cdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG5cdFx0ICAgIGQgPj0gNSA/IDUgOlxuXHRcdCAgICBkID49IDMgPyAzIDpcblx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cblx0XHRyZXR1cm4gcG93MTAgKiBkO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuc2NhbGUob3B0aW9ucz86IENvbnRyb2wuU2NhbGUgb3B0aW9ucylcbi8vIENyZWF0ZXMgYW4gc2NhbGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxudmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTY2FsZShvcHRpb25zKTtcbn07XG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBha2EgTC5Db250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250cm9sIGFsbG93cyB5b3UgdG8gZGlzcGxheSBhdHRyaWJ1dGlvbiBkYXRhIGluIGEgc21hbGwgdGV4dCBib3ggb24gYSBtYXAuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgYXR0cmlidXRpb25Db250cm9sYCBvcHRpb25dKCNtYXAtYXR0cmlidXRpb25jb250cm9sKSB0byBgZmFsc2VgLCBhbmQgaXQgZmV0Y2hlcyBhdHRyaWJ1dGlvbiB0ZXh0cyBmcm9tIGxheWVycyB3aXRoIHRoZSBbYGdldEF0dHJpYnV0aW9uYCBtZXRob2RdKCNsYXllci1nZXRhdHRyaWJ1dGlvbikgYXV0b21hdGljYWxseS4gRXh0ZW5kcyBDb250cm9sLlxyXG4gKi9cclxuXHJcbnZhciBBdHRyaWJ1dGlvbiA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICdib3R0b21yaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZyA9ICdMZWFmbGV0J1xyXG5cdFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcblx0XHRwcmVmaXg6ICc8YSBocmVmPVwiaHR0cDovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPkxlYWZsZXQ8L2E+J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uJyk7XHJcblx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdGV4dCBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy5cclxuXHRzZXRQcmVmaXg6IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5wcmVmaXggPSBwcmVmaXg7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gYXR0cmlidXRpb24gdGV4dCAoZS5nLiBgJ1ZlY3RvciBkYXRhICZjb3B5OyBNYXBib3gnYCkuXHJcblx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0gPSAwO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdKys7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG5cdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0tLTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG5cdFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW2ldKSB7XHJcblx0XHRcdFx0YXR0cmlicy5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZWZpeEFuZEF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIHwgJyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIGF0dHJpYnV0aW9uQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFthdHRyaWJ1dGlvbiBjb250cm9sXSgjY29udHJvbC1hdHRyaWJ1dGlvbikgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sKSB7XHJcblx0XHRuZXcgQXR0cmlidXRpb24oKS5hZGRUbyh0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLkF0dHJpYnV0aW9uXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5hdHRyaWJ1dGlvbihvcHRpb25zOiBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbC5cclxudmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xuXG5Db250cm9sLkxheWVycyA9IExheWVycztcbkNvbnRyb2wuWm9vbSA9IFpvb207XG5Db250cm9sLlNjYWxlID0gU2NhbGU7XG5Db250cm9sLkF0dHJpYnV0aW9uID0gQXR0cmlidXRpb247XG5cbmNvbnRyb2wubGF5ZXJzID0gbGF5ZXJzO1xuY29udHJvbC56b29tID0gem9vbTtcbmNvbnRyb2wuc2NhbGUgPSBzY2FsZTtcbmNvbnRyb2wuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvbjtcblxuLypcblx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3Rcblx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4qL1xuXG4vLyBAY2xhc3MgSGFuZGxlclxuLy8gQGFrYSBMLkhhbmRsZXJcbi8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxudmFyIEhhbmRsZXIgPSBDbGFzcy5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcblx0Ly8gRW5hYmxlcyB0aGUgaGFuZGxlclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5hZGRIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB0aGlzXG5cdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLnJlbW92ZUhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZFxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcblx0fVxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIENsYXNzZXMgaW5oZXJpdGluZyBmcm9tIGBIYW5kbGVyYCBtdXN0IGltcGxlbWVudCB0aGUgdHdvIGZvbGxvd2luZyBtZXRob2RzOlxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGRpc2FibGVkLCBzaG91bGQgcmVtb3ZlIHRoZSBldmVudCBob29rcyBhZGRlZCBwcmV2aW91c2x5LlxufSk7XG5cbi8vIEBzZWN0aW9uIFRoZXJlIGlzIHN0YXRpYyBmdW5jdGlvbiB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkhhbmRsZXI6XG4vLyBAZnVuY3Rpb24gYWRkVG8obWFwOiBNYXAsIG5hbWU6IFN0cmluZyk6IHRoaXNcbi8vIEFkZHMgYSBuZXcgSGFuZGxlciB0byB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5IYW5kbGVyLmFkZFRvID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuXHRtYXAuYWRkSGFuZGxlcihuYW1lLCB0aGlzKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG52YXIgTWl4aW4gPSB7RXZlbnRzOiBFdmVudHN9O1xuXG4vKlxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBha2EgTC5EcmFnZ2FibGVcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgU1RBUlQgPSB0b3VjaCA/ICd0b3VjaHN0YXJ0IG1vdXNlZG93bicgOiAnbW91c2Vkb3duJztcclxudmFyIEVORCA9IHtcclxuXHRtb3VzZWRvd246ICdtb3VzZXVwJyxcclxuXHR0b3VjaHN0YXJ0OiAndG91Y2hlbmQnLFxyXG5cdHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxyXG5cdE1TUG9pbnRlckRvd246ICd0b3VjaGVuZCdcclxufTtcclxudmFyIE1PVkUgPSB7XHJcblx0bW91c2Vkb3duOiAnbW91c2Vtb3ZlJyxcclxuXHR0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcclxuXHRwb2ludGVyZG93bjogJ3RvdWNobW92ZScsXHJcblx0TVNQb2ludGVyRG93bjogJ3RvdWNobW92ZSdcclxufTtcclxuXHJcblxyXG52YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG5cdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcblx0fSxcclxuXHJcblx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuXHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSQkMSwgb3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuXHRcdHRoaXMuX2RyYWdTdGFydFRhcmdldCA9IGRyYWdTdGFydFRhcmdldCB8fCBlbGVtZW50O1xyXG5cdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZSQkMTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpXHJcblx0Ly8gRW5hYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0b24odGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKVxyXG5cdC8vIERpc2FibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIElmIHdlJ3JlIGN1cnJlbnRseSBkcmFnZ2luZyB0aGlzIGRyYWdnYWJsZSxcclxuXHRcdC8vIGRpc2FibGluZyBpdCBjb3VudHMgYXMgZmlyc3QgZW5kaW5nIHRoZSBkcmFnLlxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuXHRcdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0b2ZmKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChoYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSB0aGlzOyAgLy8gUHJldmVudCBkcmFnZ2luZyBtdWx0aXBsZSBvYmplY3RzIGF0IG9uY2UuXHJcblxyXG5cdFx0aWYgKHRoaXMuX3ByZXZlbnRPdXRsaW5lKSB7XHJcblx0XHRcdHByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRpc2FibGVJbWFnZURyYWcoKTtcclxuXHRcdGRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmluZykgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBAZXZlbnQgZG93bjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG5cdFx0dGhpcy5maXJlKCdkb3duJyk7XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHJcblx0XHR0aGlzLl9zdGFydFBvaW50ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG5cclxuXHRcdG9uKGRvY3VtZW50LCBNT1ZFW2UudHlwZV0sIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHRvbihkb2N1bWVudCwgRU5EW2UudHlwZV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgbmV3UG9pbnQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSksXHJcblx0XHQgICAgb2Zmc2V0ID0gbmV3UG9pbnQuc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgdGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHRoaXMuX3N0YXJ0UG9zID0gZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdGFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuXHRcdFx0Ly8gaWYgbmVjZXNzYXJ5XHJcblx0XHRcdGlmICgod2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSkgJiYgKHRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50SW5zdGFuY2UpKSB7XHJcblx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlUG9zaXRpb24sIHRoaXMsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcblx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcblx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG5cdFx0c2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcblx0XHR0aGlzLmZpcmUoJ2RyYWcnLCBlKTtcclxuXHR9LFxyXG5cclxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHR9LFxyXG5cclxuXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gTU9WRSkge1xyXG5cdFx0XHRvZmYoZG9jdW1lbnQsIE1PVkVbaV0sIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHRcdG9mZihkb2N1bWVudCwgRU5EW2ldLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRlbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdGVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XHJcblxyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcblx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gZmFsc2U7XHJcblx0fVxyXG5cclxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGluZVV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWxpbmUgcG9pbnRzIHByb2Nlc3NpbmcsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIG1ha2UgcG9seWxpbmVzIGxpZ2h0bmluZy1mYXN0LlxyXG4gKi9cclxuXHJcbi8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG4vLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuLy8gQGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50czogUG9pbnRbXSwgdG9sZXJhbmNlOiBOdW1iZXIpOiBQb2ludFtdXHJcbi8vIERyYW1hdGljYWxseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIGEgcG9seWxpbmUgd2hpbGUgcmV0YWluaW5nXHJcbi8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcbi8vIFtEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG4vLyBVc2VkIGZvciBhIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBwcm9jZXNzaW5nL2Rpc3BsYXlpbmcgTGVhZmxldCBwb2x5bGluZXMgZm9yXHJcbi8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuLy8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuLy8gQWxzbyByZWxlYXNlZCBhcyBhIHNlcGFyYXRlZCBtaWNyby1saWJyYXJ5IFtTaW1wbGlmeS5qc10oaHR0cDovL21vdXJuZXIuZ2l0aHViLmNvbS9zaW1wbGlmeS1qcy8pLlxyXG5mdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG5cdGlmICghdG9sZXJhbmNlIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0fVxyXG5cclxuXHR2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHQgICAgcG9pbnRzID0gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIE1hdGguc3FydChfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGNsb3Nlc3QgcG9pbnQgZnJvbSBhIHBvaW50IGBwYCBvbiBhIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5mdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG59XHJcblxyXG4vLyBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuXHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuXHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdCAgICBtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcclxuXHJcblx0dmFyIGksXHJcblx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcblx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3UG9pbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcblx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0aW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuXHRcdHNxRGlzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xyXG5cdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0bWFya2Vyc1tpbmRleF0gPSAxO1xyXG5cclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIHJlZHVjZSBwb2ludHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvIGVhY2ggb3RoZXIgdG8gYSBzaW5nbGUgcG9pbnRcclxuZnVuY3Rpb24gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChfc3FEaXN0KHBvaW50c1tpXSwgcG9pbnRzW3ByZXZdKSA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHRwcmV2ID0gaTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDFdKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcbn1cclxuXHJcbnZhciBfbGFzdENvZGU7XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xpcFNlZ21lbnQoYTogUG9pbnQsIGI6IFBvaW50LCBib3VuZHM6IEJvdW5kcywgdXNlTGFzdENvZGU/OiBCb29sZWFuLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdfEJvb2xlYW5cclxuLy8gQ2xpcHMgdGhlIHNlZ21lbnQgYSB0byBiIGJ5IHJlY3Rhbmd1bGFyIGJvdW5kcyB3aXRoIHRoZVxyXG4vLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcbi8vIChtb2RpZnlpbmcgdGhlIHNlZ21lbnQgcG9pbnRzIGRpcmVjdGx5ISkuIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWxpbmVcclxuLy8gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cclxuZnVuY3Rpb24gY2xpcFNlZ21lbnQoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuXHR2YXIgY29kZUEgPSB1c2VMYXN0Q29kZSA/IF9sYXN0Q29kZSA6IF9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcblx0ICAgIGNvZGVCID0gX2dldEJpdENvZGUoYiwgYm91bmRzKSxcclxuXHJcblx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG5cdCAgICAvLyBzYXZlIDJuZCBjb2RlIHRvIGF2b2lkIGNhbGN1bGF0aW5nIGl0IG9uIHRoZSBuZXh0IHNlZ21lbnRcclxuXHQgICAgX2xhc3RDb2RlID0gY29kZUI7XHJcblxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHQvLyBpZiBhLGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCBhY2NlcHQpXHJcblx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xyXG5cdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIGEsYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCByZWplY3QpXHJcblx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3RoZXIgY2FzZXNcclxuXHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcclxuXHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdG5ld0NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuXHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG5cdFx0XHRhID0gcDtcclxuXHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YiA9IHA7XHJcblx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdCAgICB4LCB5O1xyXG5cclxuXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWluLnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdHggPSBtYXgueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHR4ID0gbWluLng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX2dldEJpdENvZGUocCwgYm91bmRzKSB7XHJcblx0dmFyIGNvZGUgPSAwO1xyXG5cclxuXHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdGNvZGUgfD0gMTtcclxuXHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG5cdFx0Y29kZSB8PSAyO1xyXG5cdH1cclxuXHJcblx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdGNvZGUgfD0gNDtcclxuXHR9IGVsc2UgaWYgKHAueSA+IGJvdW5kcy5tYXgueSkgeyAvLyB0b3BcclxuXHRcdGNvZGUgfD0gODtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb2RlO1xyXG59XHJcblxyXG4vLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuZnVuY3Rpb24gX3NxRGlzdChwMSwgcDIpIHtcclxuXHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5mdW5jdGlvbiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCBzcURpc3QpIHtcclxuXHR2YXIgeCA9IHAxLngsXHJcblx0ICAgIHkgPSBwMS55LFxyXG5cdCAgICBkeCA9IHAyLnggLSB4LFxyXG5cdCAgICBkeSA9IHAyLnkgLSB5LFxyXG5cdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuXHQgICAgdDtcclxuXHJcblx0aWYgKGRvdCA+IDApIHtcclxuXHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG5cdFx0aWYgKHQgPiAxKSB7XHJcblx0XHRcdHggPSBwMi54O1xyXG5cdFx0XHR5ID0gcDIueTtcclxuXHRcdH0gZWxzZSBpZiAodCA+IDApIHtcclxuXHRcdFx0eCArPSBkeCAqIHQ7XHJcblx0XHRcdHkgKz0gZHkgKiB0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZHggPSBwLnggLSB4O1xyXG5cdGR5ID0gcC55IC0geTtcclxuXHJcblx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IFBvaW50KHgsIHkpO1xyXG59XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzOiBMYXRMbmdbXSk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyB0cnVlIGlmIGBsYXRsbmdzYCBpcyBhIGZsYXQgYXJyYXksIGZhbHNlIGlzIG5lc3RlZC5cclxuZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuXHRyZXR1cm4gIWlzQXJyYXkobGF0bG5nc1swXSkgfHwgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcblx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG5cdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbn1cclxuXG5cbnZhciBMaW5lVXRpbCA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRzaW1wbGlmeTogc2ltcGxpZnksXG5cdHBvaW50VG9TZWdtZW50RGlzdGFuY2U6IHBvaW50VG9TZWdtZW50RGlzdGFuY2UsXG5cdGNsb3Nlc3RQb2ludE9uU2VnbWVudDogY2xvc2VzdFBvaW50T25TZWdtZW50LFxuXHRjbGlwU2VnbWVudDogY2xpcFNlZ21lbnQsXG5cdF9nZXRFZGdlSW50ZXJzZWN0aW9uOiBfZ2V0RWRnZUludGVyc2VjdGlvbixcblx0X2dldEJpdENvZGU6IF9nZXRCaXRDb2RlLFxuXHRfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0aXNGbGF0OiBpc0ZsYXQsXG5cdF9mbGF0OiBfZmxhdFxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHMsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgY2xpcHBlZFBvaW50cyxcclxuXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcblx0ICAgIGksIGosIGssXHJcblx0ICAgIGEsIGIsXHJcblx0ICAgIGxlbiwgZWRnZSwgcDtcclxuXHJcblx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRwb2ludHNbaV0uX2NvZGUgPSBfZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgZWFjaCBlZGdlIChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXHJcblx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG5cdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG5cdFx0Y2xpcHBlZFBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRcdGEgPSBwb2ludHNbaV07XHJcblx0XHRcdGIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0Ly8gaWYgYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBnb2VzIG91dCBvZiBzY3JlZW4pXHJcblx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcblx0XHRcdFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0XHRwLl9jb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKGEpO1xyXG5cclxuXHRcdFx0Ly8gZWxzZSBpZiBiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZW50ZXJzIHRoZSBzY3JlZW4pXHJcblx0XHRcdH0gZWxzZSBpZiAoIShiLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0cC5fY29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRwb2ludHMgPSBjbGlwcGVkUG9pbnRzO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufVxyXG5cblxudmFyIFBvbHlVdGlsID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdGNsaXBQb2x5Z29uOiBjbGlwUG9seWdvblxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAc2VjdGlvblxyXG4gKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gKlxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAqXHJcbiAqIEVxdWlyZWN0YW5ndWxhciwgb3IgUGxhdGUgQ2FycmVlIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IHNpbXBsZSBwcm9qZWN0aW9uLFxyXG4gKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gKiBgRVBTRzo0MzI2YCBhbmQgYFNpbXBsZWAgQ1JTLlxyXG4gKi9cclxuXHJcbnZhciBMb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICpcclxuICogRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCBtb3JlIGNvbXBsZXggdGhhbiBTcGhlcmljYWwgTWVyY2F0b3IuIFRha2VzIGludG8gYWNjb3VudCB0aGF0IEVhcnRoIGlzIGEgZ2VvaWQsIG5vdCBhIHBlcmZlY3Qgc3BoZXJlLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gKi9cclxuXHJcbnZhciBNZXJjYXRvciA9IHtcclxuXHRSOiA2Mzc4MTM3LFxyXG5cdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cclxuXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0yMDAzNzUwOC4zNDI3OSwgLTE1NDk2NTcwLjczOTcyXSwgWzIwMDM3NTA4LjM0Mjc5LCAxODc2NDY1Ni4yMzEzOF0pLFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcclxuXHJcblx0XHR2YXIgdHMgPSBNYXRoLnRhbihNYXRoLlBJIC8gNCAtIHkgLyAyKSAvIE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0eSA9IC1yICogTWF0aC5sb2coTWF0aC5tYXgodHMsIDFFLTEwKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nICogZCAqIHIsIHkpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgdHMgPSBNYXRoLmV4cCgtcG9pbnQueSAvIHIpLFxyXG5cdFx0ICAgIHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGRwaGkgPSAwLjEsIGNvbjsgaSA8IDE1ICYmIE1hdGguYWJzKGRwaGkpID4gMWUtNzsgaSsrKSB7XHJcblx0XHRcdGNvbiA9IGUgKiBNYXRoLnNpbihwaGkpO1xyXG5cdFx0XHRjb24gPSBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdFx0ZHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyAqIGNvbikgLSBwaGk7XHJcblx0XHRcdHBoaSArPSBkcGhpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcblx0fVxyXG59O1xuXG4vKlxuICogQGNsYXNzIFByb2plY3Rpb25cblxuICogQW4gb2JqZWN0IHdpdGggbWV0aG9kcyBmb3IgcHJvamVjdGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHdvcmxkIG9udG9cbiAqIGEgZmxhdCBzdXJmYWNlIChhbmQgYmFjaykuIFNlZSBbTWFwIHByb2plY3Rpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwX3Byb2plY3Rpb24pLlxuXG4gKiBAcHJvcGVydHkgYm91bmRzOiBCb3VuZHNcbiAqIFRoZSBib3VuZHMgKHNwZWNpZmllZCBpbiBDUlMgdW5pdHMpIHdoZXJlIHRoZSBwcm9qZWN0aW9uIGlzIHZhbGlkXG5cbiAqIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XG4gKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXG4gKiBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuIFByb2plY3RzIGEgMkQgcG9pbnQgaW50byBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogTm90ZSB0aGF0IHRoZSBwcm9qZWN0aW9uIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxuICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXG4gKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cblxuICovXG5cblxuXG5cbnZhciBpbmRleCA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRMb25MYXQ6IExvbkxhdCxcblx0TWVyY2F0b3I6IE1lcmNhdG9yLFxuXHRTcGhlcmljYWxNZXJjYXRvcjogU3BoZXJpY2FsTWVyY2F0b3Jcbn0pO1xuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czMzk1XHJcbiAqXHJcbiAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAqL1xyXG52YXIgRVBTRzMzOTUgPSBleHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6MzM5NScsXHJcblx0cHJvamVjdGlvbjogTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0c0MzI2XHJcbiAqXHJcbiAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gKlxyXG4gKiBMZWFmbGV0IDEuMC54IGNvbXBsaWVzIHdpdGggdGhlIFtUTVMgY29vcmRpbmF0ZSBzY2hlbWUgZm9yIEVQU0c6NDMyNl0oaHR0cHM6Ly93aWtpLm9zZ2VvLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2VfU3BlY2lmaWNhdGlvbiNnbG9iYWwtZ2VvZGV0aWMpLFxyXG4gKiB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZSBmcm9tIDAuNy54IGJlaGF2aW91ci4gIElmIHlvdSBhcmUgdXNpbmcgYSBgVGlsZUxheWVyYFxyXG4gKiB3aXRoIHRoaXMgQ1JTLCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgdHdvIDI1NngyNTYgcGl4ZWwgdGlsZXMgY292ZXJpbmcgdGhlXHJcbiAqIHdob2xlIGVhcnRoIGF0IHpvb20gbGV2ZWwgemVybywgYW5kIHRoYXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBvcmlnaW4gaXMgKC0xODAsKzkwKSxcclxuICogb3IgKC0xODAsLTkwKSBmb3IgYFRpbGVMYXllcmBzIHdpdGggW3RoZSBgdG1zYCBvcHRpb25dKCN0aWxlbGF5ZXItdG1zKSBzZXQuXHJcbiAqL1xyXG5cclxudmFyIEVQU0c0MzI2ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG5cdHByb2plY3Rpb246IExvbkxhdCxcclxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxIC8gMTgwLCAxLCAtMSAvIDE4MCwgMC41KVxyXG59KTtcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbnZhciBTaW1wbGUgPSBleHRlbmQoe30sIENSUywge1xuXHRwcm9qZWN0aW9uOiBMb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcblxuQ1JTLkVhcnRoID0gRWFydGg7XG5DUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbkNSUy5FUFNHMzg1NyA9IEVQU0czODU3O1xuQ1JTLkVQU0c5MDA5MTMgPSBFUFNHOTAwOTEzO1xuQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG5DUlMuU2ltcGxlID0gU2ltcGxlO1xuXG4vKlxuICogQGNsYXNzIExheWVyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogQGFrYSBMLkxheWVyXG4gKiBAYWthIElMYXllclxuICpcbiAqIEEgc2V0IG9mIG1ldGhvZHMgZnJvbSB0aGUgTGF5ZXIgYmFzZSBjbGFzcyB0aGF0IGFsbCBMZWFmbGV0IGxheWVycyB1c2UuXG4gKiBJbmhlcml0cyBhbGwgbWV0aG9kcywgb3B0aW9ucyBhbmQgZXZlbnRzIGZyb20gYEwuRXZlbnRlZGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5NYXJrZXIobGF0bG5nKS5hZGRUbyhtYXApO1xuICogbGF5ZXIuYWRkVG8obWFwKTtcbiAqIGxheWVyLnJlbW92ZSgpO1xuICogYGBgXG4gKlxuICogQGV2ZW50IGFkZDogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyBhZGRlZCB0byBhIG1hcFxuICpcbiAqIEBldmVudCByZW1vdmU6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgbWFwXG4gKi9cblxuXG52YXIgTGF5ZXIgPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcblx0XHQvLyBCeSBkZWZhdWx0IHRoZSBsYXllciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAncyBbb3ZlcmxheSBwYW5lXSgjbWFwLW92ZXJsYXlwYW5lKS4gT3ZlcnJpZGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBsYXllciB0byBiZSBwbGFjZWQgb24gYW5vdGhlciBwYW5lIGJ5IGRlZmF1bHQuXG5cdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcblx0XHQvLyBTdHJpbmcgdG8gYmUgc2hvd24gaW4gdGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wsIGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSwgZS5nLiBcIsKpIE1hcGJveFwiLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcblx0XHRpZiAob2JqKSB7XG5cdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcblx0fSxcblxuXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0dGhpcy5fbWFwLl90YXJnZXRzW3N0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW3N0YW1wKHRhcmdldEVsKV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbjogU3RyaW5nXG5cdC8vIFVzZWQgYnkgdGhlIGBhdHRyaWJ1dGlvbiBjb250cm9sYCwgcmV0dXJucyB0aGUgW2F0dHJpYnV0aW9uIG9wdGlvbl0oI2dyaWRsYXllci1hdHRyaWJ1dGlvbikuXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcblx0fSxcblxuXHRfbGF5ZXJBZGQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IGUudGFyZ2V0O1xuXG5cdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuXHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG5cdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcblx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRtYXAub2ZmKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uQWRkKG1hcCk7XG5cblx0XHRpZiAodGhpcy5nZXRBdHRyaWJ1dGlvbiAmJiBtYXAuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sLmFkZEF0dHJpYnV0aW9uKHRoaXMuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcblx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IHRoaXN9KTtcblx0fVxufSk7XG5cbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gKiBAdW5pbmhlcml0YWJsZVxuICpcbiAqIEV2ZXJ5IGxheWVyIHNob3VsZCBleHRlbmQgZnJvbSBgTC5MYXllcmAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cbiAqXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gY29kZSB0aGF0IGNyZWF0ZXMgRE9NIGVsZW1lbnRzIGZvciB0aGUgbGF5ZXIsIGFkZHMgdGhlbSB0byBgbWFwIHBhbmVzYCB3aGVyZSB0aGV5IHNob3VsZCBiZWxvbmcgYW5kIHB1dHMgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsYXllcidzIGVsZW1lbnRzIGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlcyBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2xheWVyLW9uYWRkKS4gQ2FsbGVkIG9uIFtgbWFwLnJlbW92ZUxheWVyKGxheWVyKWBdKCNtYXAtcmVtb3ZlbGF5ZXIpLlxuICpcbiAqIEBtZXRob2QgZ2V0RXZlbnRzKCk6IE9iamVjdFxuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSBgeyB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0IH1gIGZvciBbYGFkZEV2ZW50TGlzdGVuZXJgXSgjZXZlbnRlZC1hZGRldmVudGxpc3RlbmVyKS4gVGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoaXMgb2JqZWN0IHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgd2l0aCB5b3VyIGxheWVyLlxuICpcbiAqIEBtZXRob2QgZ2V0QXR0cmlidXRpb24oKTogU3RyaW5nXG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgIHdoZW5ldmVyIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICpcbiAqIEBtZXRob2QgYmVmb3JlQWRkKG1hcDogTWFwKTogdGhpc1xuICogT3B0aW9uYWwgbWV0aG9kLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllciksIGJlZm9yZSB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCwgYmVmb3JlIGV2ZW50cyBhcmUgaW5pdGlhbGl6ZWQsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGUgbWFwIGlzIGluIGEgdXNhYmxlIHN0YXRlLiBVc2UgZm9yIGVhcmx5IGluaXRpYWxpemF0aW9uIG9ubHkuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcFxuICogQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXG4gKlxuICogQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIGEgbmV3IGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAuXG4gKlxuICogQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIHNvbWUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXBcbiAqXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gKi9cbk1hcC5pbmNsdWRlKHtcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBtYXBcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghbGF5ZXIuX2xheWVyQWRkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBvYmplY3QgaXMgbm90IGEgTGF5ZXIuJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG5cblx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5nZXRBdHRyaWJ1dGlvbiAmJiB0aGlzLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wucmVtb3ZlQXR0cmlidXRpb24obGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRyZXR1cm4gISFsYXllciAmJiAoc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XG5cdH0sXG5cblx0LyogQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuXHQgKiBgYGBcblx0ICogbWFwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG5cdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG5cdCAqIH0pO1xuXHQgKiBgYGBcblx0ICovXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG5cdFx0bGF5ZXJzID0gbGF5ZXJzID8gKGlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF0pIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtaW5ab29tID0gSW5maW5pdHksXG5cdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG5cdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG5cdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcblx0XHRcdG1heFpvb20gPSBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBNYXRoLm1heChtYXhab29tLCBvcHRpb25zLm1heFpvb20pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuXHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1pblpvb207XG5cblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuXHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG51bWJlciBvZiB6b29tbGV2ZWxzIG9uIHRoZSBtYXAgaXMgY2hhbmdlZCBkdWVcblx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cblx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01heFpvb20gJiYgdGhpcy5nZXRab29tKCkgPiB0aGlzLl9sYXllcnNNYXhab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWF4Wm9vbSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01pblpvb20gJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLl9sYXllcnNNaW5ab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWluWm9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLypcclxuICogQGNsYXNzIExheWVyR3JvdXBcclxuICogQGFrYSBMLkxheWVyR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gZ3JvdXAgc2V2ZXJhbCBsYXllcnMgYW5kIGhhbmRsZSB0aGVtIGFzIG9uZS4gSWYgeW91IGFkZCBpdCB0byB0aGUgbWFwLFxyXG4gKiBhbnkgbGF5ZXJzIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBtYXAgYXNcclxuICogd2VsbC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmxheWVyR3JvdXAoW21hcmtlcjEsIG1hcmtlcjJdKVxyXG4gKiBcdC5hZGRMYXllcihwb2x5bGluZSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdHZhciBpLCBsZW47XHJcblxyXG5cdFx0aWYgKGxheWVycykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgZ3JvdXAuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIoaWQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBmcm9tIHRoZSBncm91cC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSBsYXllciBpbiB0aGlzLl9sYXllcnMgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiB0aGlzLl9sYXllcnNbaWRdKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaWRdKTtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGlkOiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGludGVybmFsIElEIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuICEhbGF5ZXIgJiYgKGxheWVyIGluIHRoaXMuX2xheWVycyB8fCB0aGlzLmdldExheWVySWQobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbGVhckxheWVycygpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVtb3ZlTGF5ZXIsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG5cdC8vIENhbGxzIGBtZXRob2ROYW1lYCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyBhbnlcclxuXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcblx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuXHRpbnZva2U6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcblx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcblx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG5cdFx0XHRcdGxheWVyW21ldGhvZE5hbWVdLmFwcGx5KGxheWVyLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAuYWRkTGF5ZXIsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5yZW1vdmVMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBncm91cCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxyXG5cdC8vIGBgYGpzXHJcblx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdC8vIFx0bGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xyXG5cdC8vIH0pO1xyXG5cdC8vIGBgYFxyXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXIoaWQ6IE51bWJlcik6IExheWVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGxheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobGF5ZXJzLnB1c2gsIGxheWVycyk7XHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRaSW5kZXgnLCB6SW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBJRCBmb3IgYSBsYXllclxyXG5cdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuIHN0YW1wKGxheWVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4vLyBDcmVhdGUgYSBsYXllciBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbnZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAqIEBha2EgTC5GZWF0dXJlR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICpcclxuICogRXh0ZW5kZWQgYExheWVyR3JvdXBgIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIGRvIHRoZSBzYW1lIHRoaW5nIHRvIGFsbCBpdHMgbWVtYmVyIGxheWVyczpcclxuICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAqICAqIEV2ZW50cyBhcmUgcHJvcGFnYXRlZCB0byB0aGUgYEZlYXR1cmVHcm91cGAsIHNvIGlmIHRoZSBncm91cCBoYXMgYW4gZXZlbnRcclxuICogaGFuZGxlciwgaXQgd2lsbCBoYW5kbGUgZXZlbnRzIGZyb20gYW55IG9mIHRoZSBsYXllcnMuIFRoaXMgaW5jbHVkZXMgbW91c2UgZXZlbnRzXHJcbiAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gKiAgKiBIYXMgYGxheWVyYWRkYCBhbmQgYGxheWVycmVtb3ZlYCBldmVudHNcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICogXHQuYmluZFBvcHVwKCdIZWxsbyB3b3JsZCEnKVxyXG4gKiBcdC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgYWxlcnQoJ0NsaWNrZWQgb24gYSBtZW1iZXIgb2YgdGhlIGdyb3VwIScpOyB9KVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgYWRkZWQgdG8gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgYmFjayBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5mZWF0dXJlR3JvdXAobGF5ZXJzOiBMYXllcltdKVxyXG4vLyBDcmVhdGUgYSBmZWF0dXJlIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycy5cclxudmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG59O1xuXG4vKlxyXG4gKiBAY2xhc3MgSWNvblxyXG4gKiBAYWthIEwuSWNvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAqICAgICBpY29uUmV0aW5hVXJsOiAnbXktaWNvbkAyeC5wbmcnLFxyXG4gKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAqICAgICBwb3B1cEFuY2hvcjogWy0zLCAtNzZdLFxyXG4gKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAqICAgICBzaGFkb3dTaXplOiBbNjgsIDk1XSxcclxuICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICogfSk7XHJcbiAqXHJcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqL1xyXG5cclxudmFyIEljb24gPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgSWNvbiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiAqKihyZXF1aXJlZCkqKiBUaGUgVVJMIHRvIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyIHNjcmlwdCBwYXRoKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91clxyXG5cdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uU2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25BbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcblx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG5cdCAqIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gdG9vbHRpcEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdG9vbHRpcHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG5cdCAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHQgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0ICovXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvcHVwQW5jaG9yOiBbMCwgMF0sXHJcblx0XHR0b29sdGlwQW5jaG9yOiBbMCwgMF0sXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG5cdC8vIHN0eWxlZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMuXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuXHRcdGlmICghc3JjKSB7XHJcblx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcblx0XHRyZXR1cm4gaW1nO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcblx0XHRpZiAodHlwZW9mIHNpemVPcHRpb24gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdHNpemVPcHRpb24gPSBbc2l6ZU9wdGlvbiwgc2l6ZU9wdGlvbl07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNpemUgPSB0b1BvaW50KHNpemVPcHRpb24pLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRvUG9pbnQobmFtZSA9PT0gJ3NoYWRvdycgJiYgb3B0aW9ucy5zaGFkb3dBbmNob3IgfHwgb3B0aW9ucy5pY29uQW5jaG9yIHx8XHJcblx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuXHRcdGltZy5jbGFzc05hbWUgPSAnbGVhZmxldC1tYXJrZXItJyArIG5hbWUgKyAnICcgKyAob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpO1xyXG5cclxuXHRcdGlmIChhbmNob3IpIHtcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKC1hbmNob3IueSkgKyAncHgnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaXplKSB7XHJcblx0XHRcdGltZy5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSW1nOiBmdW5jdGlvbiAoc3JjLCBlbCkge1xyXG5cdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHRcdGVsLnNyYyA9IHNyYztcclxuXHRcdHJldHVybiBlbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdHJldHVybiByZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10gfHwgdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmljb24ob3B0aW9uczogSWNvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGljb24gaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cclxuZnVuY3Rpb24gaWNvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJY29uKG9wdGlvbnMpO1xyXG59XG5cbi8qXG4gKiBAbWluaWNsYXNzIEljb24uRGVmYXVsdCAoSWNvbilcbiAqIEBha2EgTC5JY29uLkRlZmF1bHRcbiAqIEBzZWN0aW9uXG4gKlxuICogQSB0cml2aWFsIHN1YmNsYXNzIG9mIGBJY29uYCwgcmVwcmVzZW50cyB0aGUgaWNvbiB0byB1c2UgaW4gYE1hcmtlcmBzIHdoZW5cbiAqIG5vIGljb24gaXMgc3BlY2lmaWVkLiBQb2ludHMgdG8gdGhlIGJsdWUgbWFya2VyIGltYWdlIGRpc3RyaWJ1dGVkIHdpdGggTGVhZmxldFxuICogcmVsZWFzZXMuXG4gKlxuICogSW4gb3JkZXIgdG8gY3VzdG9taXplIHRoZSBkZWZhdWx0IGljb24sIGp1c3QgY2hhbmdlIHRoZSBwcm9wZXJ0aWVzIG9mIGBMLkljb24uRGVmYXVsdC5wcm90b3R5cGUub3B0aW9uc2BcbiAqICh3aGljaCBpcyBhIHNldCBvZiBgSWNvbiBvcHRpb25zYCkuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gX2NvbXBsZXRlbHlfIHJlcGxhY2UgdGhlIGRlZmF1bHQgaWNvbiwgb3ZlcnJpZGUgdGhlXG4gKiBgTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMuaWNvbmAgd2l0aCB5b3VyIG93biBpY29uIGluc3RlYWQuXG4gKi9cblxudmFyIEljb25EZWZhdWx0ID0gSWNvbi5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRpY29uVXJsOiAgICAgICAnbWFya2VyLWljb24ucG5nJyxcblx0XHRpY29uUmV0aW5hVXJsOiAnbWFya2VyLWljb24tMngucG5nJyxcblx0XHRzaGFkb3dVcmw6ICAgICAnbWFya2VyLXNoYWRvdy5wbmcnLFxuXHRcdGljb25TaXplOiAgICBbMjUsIDQxXSxcblx0XHRpY29uQW5jaG9yOiAgWzEyLCA0MV0sXG5cdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuXHRcdHRvb2x0aXBBbmNob3I6IFsxNiwgLTI4XSxcblx0XHRzaGFkb3dTaXplOiAgWzQxLCA0MV1cblx0fSxcblxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAoIUljb25EZWZhdWx0LmltYWdlUGF0aCkge1x0Ly8gRGVwcmVjYXRlZCwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgb25seVxuXHRcdFx0SWNvbkRlZmF1bHQuaW1hZ2VQYXRoID0gdGhpcy5fZGV0ZWN0SWNvblBhdGgoKTtcblx0XHR9XG5cblx0XHQvLyBAb3B0aW9uIGltYWdlUGF0aDogU3RyaW5nXG5cdFx0Ly8gYEljb24uRGVmYXVsdGAgd2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGxvY2F0aW9uIG9mIHRoZVxuXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcblx0XHQvLyB3YXksIHNldCB0aGlzIG9wdGlvbiB0byBwb2ludCB0byB0aGUgcmlnaHQgcGF0aC5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSArIEljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG5cdH0sXG5cblx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gY3JlYXRlJDEoJ2RpdicsICAnbGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCcsIGRvY3VtZW50LmJvZHkpO1xuXHRcdHZhciBwYXRoID0gZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kLWltYWdlJykgfHxcblx0XHQgICAgICAgICAgIGdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXG5cdFx0aWYgKHBhdGggPT09IG51bGwgfHwgcGF0aC5pbmRleE9mKCd1cmwnKSAhPT0gMCkge1xuXHRcdFx0cGF0aCA9ICcnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC9edXJsXFwoW1wiJ10/LywgJycpLnJlcGxhY2UoL21hcmtlci1pY29uXFwucG5nW1wiJ10/XFwpJC8sICcnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aDtcblx0fVxufSk7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcmtlclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAqXG4gKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBhcmUgcHJvcGVydGllcyBvZiBhIG1hcmtlciBpbnN0YW5jZSB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2ggYXMgZHJhZ2dpbmcgKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIG1hcmtlci5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gKiBgYGBcbiAqXG4gKiBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuIE9ubHkgdmFsaWQgd2hlbiB0aGUgbWFya2VyIGlzIG9uIHRoZSBtYXAgKE90aGVyd2lzZSBzZXQgW2BtYXJrZXIub3B0aW9ucy5kcmFnZ2FibGVgXSgjbWFya2VyLWRyYWdnYWJsZSkpLlxuICovXG5cbnZhciBNYXJrZXJEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShpY29uLCBpY29uLCB0cnVlKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmVuYWJsZSgpO1xuXG5cdFx0YWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9mZih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG5cdFx0aWYgKHRoaXMuX21hcmtlci5faWNvbikge1xuXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgbWFwID0gbWFya2VyLl9tYXAsXG5cdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG5cdFx0ICAgIGljb25Qb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgYm91bmRzID0gbWFwLmdldFBpeGVsQm91bmRzKCksXG5cdFx0ICAgIG9yaWdpbiA9IG1hcC5nZXRQaXhlbE9yaWdpbigpO1xuXG5cdFx0dmFyIHBhbkJvdW5kcyA9IHRvQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi5fc3VidHJhY3Qob3JpZ2luKS5hZGQocGFkZGluZyksXG5cdFx0XHRib3VuZHMubWF4Ll9zdWJ0cmFjdChvcmlnaW4pLnN1YnRyYWN0KHBhZGRpbmcpXG5cdFx0KTtcblxuXHRcdGlmICghcGFuQm91bmRzLmNvbnRhaW5zKGljb25Qb3MpKSB7XG5cdFx0XHQvLyBDb21wdXRlIGluY3JlbWVudGFsIG1vdmVtZW50XG5cdFx0XHR2YXIgbW92ZW1lbnQgPSB0b1BvaW50KFxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5taW4ueCkgLyAoYm91bmRzLm1pbi54IC0gcGFuQm91bmRzLm1pbi54KSxcblxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1heC55KSAvIChib3VuZHMubWF4LnkgLSBwYW5Cb3VuZHMubWF4LnkpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5taW4ueSkgLyAoYm91bmRzLm1pbi55IC0gcGFuQm91bmRzLm1pbi55KVxuXHRcdFx0KS5tdWx0aXBseUJ5KHNwZWVkKTtcblxuXHRcdFx0bWFwLnBhbkJ5KG1vdmVtZW50LCB7YW5pbWF0ZTogZmFsc2V9KTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLl9hZGQobW92ZW1lbnQpO1xuXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24obWFya2VyLl9pY29uLCB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcyk7XG5cdFx0XHR0aGlzLl9vbkRyYWcoZSk7XG5cblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cblx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5jbG9zZVBvcHVwKClcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblx0fSxcblxuXHRfb25QcmVEcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuKSB7XG5cdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgc2hhZG93ID0gbWFya2VyLl9zaGFkb3csXG5cdFx0aWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cblx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHRzZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuXHRcdH1cblxuXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG5cbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBNYXJrZXIgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcblx0XHQvLyBJY29uIGluc3RhbmNlIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuXHJcblx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkLCBhIGNvbW1vbiBpbnN0YW5jZSBvZiBgTC5JY29uLkRlZmF1bHRgIGlzIHVzZWQuXHJcblx0XHRpY29uOiBuZXcgSWNvbkRlZmF1bHQoKSxcclxuXHJcblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGRyYWdnYWJsZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxyXG5cdFx0ZHJhZ2dhYmxlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uIHdoZW4gbWFya2VyIGhpdHMgdGhlIGVkZ2VzLlxyXG5cdFx0YXV0b1BhbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1MCwgNTApXHJcblx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNTAsIDUwXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5TcGVlZDogTnVtYmVyID0gMTBcclxuXHRcdC8vIE51bWJlciBvZiBwaXhlbHMgdGhlIG1hcCBzaG91bGQgbW92ZSBieS5cclxuXHRcdGF1dG9QYW5TcGVlZDogMTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdHRpdGxlOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG5cdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIG1hcmtlciB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxyXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICpcclxuXHQgKiBJbiBhZGRpdGlvbiB0byBbc2hhcmVkIGxheWVyIG1ldGhvZHNdKCNMYXllcikgbGlrZSBgYWRkVG8oKWAgYW5kIGByZW1vdmUoKWAgYW5kIFtwb3B1cCBtZXRob2RzXSgjUG9wdXApIGxpa2UgYmluZFBvcHVwKCkgeW91IGNhbiBhbHNvIHVzZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4IG9mZnNldF0oI21hcmtlci16aW5kZXhvZmZzZXQpIG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIGljb24uXHJcblx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCwgdGhpcy5fcG9wdXAub3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24gJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaWNvbi50YWdOYW1lID09PSAnSU1HJykge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQgfHwgJyc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRhZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5rZXlib2FyZCkge1xyXG5cdFx0XHRpY29uLnRhYkluZGV4ID0gJzAnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG5cdFx0ICAgIGFkZFNoYWRvdyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cgIT09IHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHRcdFx0YWRkU2hhZG93ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV3U2hhZG93KSB7XHJcblx0XHRcdGFkZENsYXNzKG5ld1NoYWRvdywgY2xhc3NUb0FkZCk7XHJcblx0XHRcdG5ld1NoYWRvdy5hbHQgPSAnJztcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoYWRkSWNvbikge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCdzaGFkb3dQYW5lJykuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJlbW92ZSh0aGlzLl9pY29uKTtcclxuXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHRyZW1vdmUodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG5cdFx0c2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRhZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0aWYgKE1hcmtlckRyYWcpIHtcclxuXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTWFya2VyRHJhZyh0aGlzKTtcclxuXHJcblx0XHRcdGlmIChkcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuXHRcdHNldE9wYWNpdHkodGhpcy5faWNvbiwgb3BhY2l0eSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHRzZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb29sdGlwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbi8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBNYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5mdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxufVxuXG4vKlxuICogQGNsYXNzIFBhdGhcbiAqIEBha2EgTC5QYXRoXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGNvbnRhaW5zIG9wdGlvbnMgYW5kIGNvbnN0YW50cyBzaGFyZWQgYmV0d2VlbiB2ZWN0b3JcbiAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICovXG5cbnZhciBQYXRoID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0c3Ryb2tlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG5cdFx0Ly8gU3Ryb2tlIGNvbG9yXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG5cdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuXHRcdHdlaWdodDogMyxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoQXJyYXk6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0ZmlsbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcblx0XHQvLyBGaWxsIG9wYWNpdHkuXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG5cdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBwYXRoIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cblx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlU3R5bGUodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlc1xuXHRcdHRoaXMuX3Byb2plY3QoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB1c2VkIHdoZW4gZG9pbmcgaGl0IGRldGVjdGlvbiBmb3IgQ2FudmFzIGxheWVyc1xuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMCkgKyB0aGlzLl9yZW5kZXJlci5vcHRpb25zLnRvbGVyYW5jZTtcblx0fVxufSk7XG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAqL1xuXG52YXIgQ2lyY2xlTWFya2VyID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ2lyY2xlTWFya2VyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyID0gMTBcblx0XHQvLyBSYWRpdXMgb2YgdGhlIGNpcmNsZSBtYXJrZXIsIGluIHBpeGVsc1xuXHRcdHJhZGl1czogMTBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7bGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xuXHR9LFxuXG5cdHNldFN0eWxlIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG5cdFx0UGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLnNldFJhZGl1cyhyYWRpdXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuXHRcdCAgICByMiA9IHRoaXMuX3JhZGl1c1kgfHwgcixcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LnN1YnRyYWN0KHApLCB0aGlzLl9wb2ludC5hZGQocCkpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcblx0fSxcblxuXHRfZW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0cmV0dXJuIHAuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCkgPD0gdGhpcy5fcmFkaXVzICsgdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jaXJjbGVNYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGVNYXJrZXIgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBtYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG5mdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59XG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAYWthIEwuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBjaXJjbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYENpcmNsZU1hcmtlcmAuXG4gKlxuICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG52YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuXHRcdFx0b3B0aW9ucyA9IGV4dGVuZCh7fSwgbGVnYWN5T3B0aW9ucywge3JhZGl1czogb3B0aW9uc30pO1xuXHRcdH1cblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cblx0XHRpZiAoaXNOYU4odGhpcy5vcHRpb25zLnJhZGl1cykpIHsgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU4nKTsgfVxuXG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlcjsgUmFkaXVzIG9mIHRoZSBjaXJjbGUsIGluIG1ldGVycy5cblx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21SYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LmFkZChoYWxmKSkpO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBQYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGxuZyA9IHRoaXMuX2xhdGxuZy5sbmcsXG5cdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gRWFydGguZGlzdGFuY2UpIHtcblx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdCAgICBsYXRSID0gKHRoaXMuX21SYWRpdXMgLyBFYXJ0aC5SKSAvIGQsXG5cdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIGJvdHRvbSA9IG1hcC5wcm9qZWN0KFtsYXQgLSBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBwID0gdG9wLmFkZChib3R0b20pLmRpdmlkZUJ5KDIpLFxuXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcblx0XHRcdCAgICBsbmdSID0gTWF0aC5hY29zKChNYXRoLmNvcyhsYXRSICogZCkgLSBNYXRoLnNpbihsYXQgKiBkKSAqIE1hdGguc2luKGxhdDIgKiBkKSkgL1xuXHRcdFx0ICAgICAgICAgICAgKE1hdGguY29zKGxhdCAqIGQpICogTWF0aC5jb3MobGF0MiAqIGQpKSkgLyBkO1xuXG5cdFx0XHRpZiAoaXNOYU4obG5nUikgfHwgbG5nUiA9PT0gMCkge1xuXHRcdFx0XHRsbmdSID0gbGF0UiAvIE1hdGguY29zKE1hdGguUEkgLyAxODAgKiBsYXQpOyAvLyBGYWxsYmFjayBmb3IgZWRnZSBjYXNlLCAjMjQyNVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gaXNOYU4obG5nUikgPyAwIDogcC54IC0gbWFwLnByb2plY3QoW2xhdDIsIGxuZyAtIGxuZ1JdKS54O1xuXHRcdFx0dGhpcy5fcmFkaXVzWSA9IHAueSAtIHRvcC55O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsYXRsbmcyID0gY3JzLnVucHJvamVjdChjcnMucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLCAwXSkpO1xuXG5cdFx0XHR0aGlzLl9wb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4vLyB3aGljaCBjb250YWlucyB0aGUgY2lyY2xlIHJhZGl1cy5cbi8vIEBhbHRlcm5hdGl2ZVxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBPYnNvbGV0ZSB3YXkgb2YgaW5zdGFudGlhdGluZyBhIGNpcmNsZSwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBjb2RlLlxuLy8gRG8gbm90IHVzZSBpbiBuZXcgYXBwbGljYXRpb25zIG9yIHBsdWdpbnMuXG5mdW5jdGlvbiBjaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucyk7XG59XG5cbi8qXG4gKiBAY2xhc3MgUG9seWxpbmVcbiAqIEBha2EgTC5Qb2x5bGluZVxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlsaW5lIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQYXRoYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0WzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0WzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0WzM0LjA0LCAtMTE4LjJdXG4gKiBdO1xuICpcbiAqIHZhciBwb2x5bGluZSA9IEwucG9seWxpbmUobGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5bGluZVxuICogbWFwLmZpdEJvdW5kcyhwb2x5bGluZS5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIGBNdWx0aVBvbHlsaW5lYCBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbWzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0IFszNy43NywgLTEyMi40M10sXG4gKiBcdCBbMzQuMDQsIC0xMTguMl1dLFxuICogXHRbWzQwLjc4LCAtNzMuOTFdLFxuICogXHQgWzQxLjgzLCAtODcuNjJdLFxuICogXHQgWzMyLjc2LCAtOTYuNzJdXVxuICogXTtcbiAqIGBgYFxuICovXG5cblxudmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcblx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG5cdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cblx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cblx0XHRub0NsaXA6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmdzKCk6IExhdExuZ1tdXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cblx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5ncyhsYXRsbmdzOiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gUmVwbGFjZXMgYWxsIHRoZSBwb2ludHMgaW4gdGhlIHBvbHlsaW5lIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMuXG5cdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzRW1wdHkoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgUG9seWxpbmUgaGFzIG5vIExhdExuZ3MuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VzdExheWVyUG9pbnQ6IFBvaW50XG5cdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHQgICAgcDEsIHAyO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG5cdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG5cdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Qb2ludDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcG9seWxpbmUuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxuXHRcdGlmIChoYWxmRGlzdCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tpICsgMV07XG5cdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XG5cblx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtcblx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz8gTGF0TG5nW10pOiB0aGlzXG5cdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2Zcblx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3Npbmdcblx0Ly8gYSBzcGVjaWZpYyByaW5nIGFzIGEgTGF0TG5nIGFycmF5ICh0aGF0IHlvdSBjYW4gZWFybGllciBhY2Nlc3Mgd2l0aCBbYGdldExhdExuZ3NgXSgjcG9seWxpbmUtZ2V0bGF0bG5ncykpLlxuXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcblx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcblx0XHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgY29udmVydCBsYXRsbmdzIGlucHV0IGludG8gYWN0dWFsIExhdExuZyBpbnN0YW5jZXM7IGNhbGN1bGF0ZSBib3VuZHMgYWxvbmcgdGhlIHdheVxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdCAgICBmbGF0ID0gaXNGbGF0KGxhdGxuZ3MpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChmbGF0KSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Qm91bmRzID0gbmV3IEJvdW5kcygpO1xuXHRcdHRoaXMuX3JpbmdzID0gW107XG5cdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuXHRcdGlmICh0aGlzLl9ib3VuZHMuaXNWYWxpZCgpICYmIHB4Qm91bmRzLmlzVmFsaWQoKSkge1xuXHRcdFx0cHhCb3VuZHMubWluLl9zdWJ0cmFjdChwKTtcblx0XHRcdHB4Qm91bmRzLm1heC5fYWRkKHApO1xuXHRcdFx0dGhpcy5fcHhCb3VuZHMgPSBweEJvdW5kcztcblx0XHR9XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG5cdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTGF0TG5nLFxuXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcblx0XHQgICAgaSwgcmluZztcblxuXHRcdGlmIChmbGF0KSB7XG5cdFx0XHRyaW5nID0gW107XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmluZ1tpXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucHVzaChyaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3NbaV0sIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cblx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBvaW50cyA9IHRoaXMuX3JpbmdzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcblx0XHRcdFx0c2VnbWVudCA9IGNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIXNlZ21lbnQpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG5cdFx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyBvdXQgb2Ygc2NyZWVuLCBvciBpdCdzIHRoZSBsYXN0IG9uZSwgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lIHBhcnRcblx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG5cdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcblx0XHRcdFx0XHRrKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydHNbaV0gPSBzaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuXHRcdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIHBhcnQsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBoaXQgZGV0ZWN0aW9uIGZvciBwb2x5bGluZXNcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0aWYgKHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4vLyBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LiBZb3UgY2FuIGNyZWF0ZSBhIGBQb2x5bGluZWAgb2JqZWN0IHdpdGhcbi8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4vLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbmZ1bmN0aW9uIHBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbn1cblxuLy8gUmV0cm9jb21wYXQuIEFsbG93IHBsdWdpbnMgdG8gc3VwcG9ydCBMZWFmbGV0IHZlcnNpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgMS4xLlxuUG9seWxpbmUuX2ZsYXQgPSBfZmxhdDtcblxuLypcbiAqIEBjbGFzcyBQb2x5Z29uXG4gKiBAYWthIEwuUG9seWdvblxuICogQGluaGVyaXRzIFBvbHlsaW5lXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gKlxuICogTm90ZSB0aGF0IHBvaW50cyB5b3UgcGFzcyB3aGVuIGNyZWF0aW5nIGEgcG9seWdvbiBzaG91bGRuJ3QgaGF2ZSBhbiBhZGRpdGlvbmFsIGxhc3QgcG9pbnQgZXF1YWwgdG8gdGhlIGZpcnN0IG9uZSDigJQgaXQncyBiZXR0ZXIgdG8gZmlsdGVyIG91dCBzdWNoIHBvaW50cy5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlnb24gZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXTtcbiAqXG4gKiB2YXIgcG9seWdvbiA9IEwucG9seWdvbihsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAqIG1hcC5maXRCb3VuZHMocG9seWdvbi5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgbGF0bG5ncywgd2l0aCB0aGUgZmlyc3QgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBvdXRlciBzaGFwZSBhbmQgdGhlIG90aGVyIGFycmF5cyByZXByZXNlbnRpbmcgaG9sZXMgaW4gdGhlIG91dGVyIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiBdO1xuICogYGBgXG4gKlxuICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBNdWx0aVBvbHlnb24gc2hhcGUuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAqICAgICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogICBdLFxuICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gKiAgICAgW1s0MSwgLTExMS4wM10sWzQ1LCAtMTExLjA0XSxbNDUsIC0xMDQuMDVdLFs0MSwgLTEwNC4wNV1dXG4gKiAgIF1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG52YXIgUG9seWdvbiA9IFBvbHlsaW5lLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWVcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcixcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuXHRcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XG5cdFx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xuXHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcblx0XHRcdGFyZWEgKz0gZiAqIDM7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZWEgPT09IDApIHtcblx0XHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxuXHRcdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoY2VudGVyKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChpc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IGNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0cDEgPSBwYXJ0W2pdO1xuXHRcdFx0XHRwMiA9IHBhcnRba107XG5cblx0XHRcdFx0aWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcblx0XHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYWxzbyBjaGVjayBpZiBpdCdzIG9uIHBvbHlnb24gc3Ryb2tlXG5cdFx0cmV0dXJuIGluc2lkZSB8fCBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQuY2FsbCh0aGlzLCBwLCB0cnVlKTtcblx0fVxuXG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnBvbHlnb24obGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZnVuY3Rpb24gcG9seWdvbihsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbn1cblxuLypcclxuICogQGNsYXNzIEdlb0pTT05cclxuICogQGFrYSBMLkdlb0pTT05cclxuICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICogXHR9XHJcbiAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gKiB9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgR2VvSlNPTiA9IEZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgR2VvSlNPTiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvaW50VG9MYXllcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIGhvdyBHZW9KU09OIHBvaW50cyBzcGF3biBMZWFmbGV0IGxheWVycy4gSXQgaXMgaW50ZXJuYWxseVxyXG5cdCAqIGNhbGxlZCB3aGVuIGRhdGEgaXMgYWRkZWQsIHBhc3NpbmcgdGhlIEdlb0pTT04gcG9pbnQgZmVhdHVyZSBhbmQgaXRzIGBMYXRMbmdgLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIHNwYXduIGEgZGVmYXVsdCBgTWFya2VyYDpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uKGdlb0pzb25Qb2ludCwgbGF0bG5nKSB7XHJcblx0ICogXHRyZXR1cm4gTC5tYXJrZXIobGF0bG5nKTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHN0eWxlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgdGhlIGBQYXRoIG9wdGlvbnNgIGZvciBzdHlsaW5nIEdlb0pTT04gbGluZXMgYW5kIHBvbHlnb25zLFxyXG5cdCAqIGNhbGxlZCBpbnRlcm5hbGx5IHdoZW4gZGF0YSBpcyBhZGRlZC5cclxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0byBub3Qgb3ZlcnJpZGUgYW55IGRlZmF1bHRzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4ge31cclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG9uRWFjaEZlYXR1cmU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggY3JlYXRlZCBgRmVhdHVyZWAsIGFmdGVyIGl0IGhhc1xyXG5cdCAqIGJlZW4gY3JlYXRlZCBhbmQgc3R5bGVkLiBVc2VmdWwgZm9yIGF0dGFjaGluZyBldmVudHMgYW5kIHBvcHVwcyB0byBmZWF0dXJlcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBkbyBub3RoaW5nIHdpdGggdGhlIG5ld2x5IGNyZWF0ZWQgbGF5ZXJzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7fVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBmaWx0ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZWNpZGUgd2hldGhlciB0byBpbmNsdWRlIGEgZmVhdHVyZSBvciBub3QuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gaW5jbHVkZSBhbGwgZmVhdHVyZXM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB0cnVlO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKiBOb3RlOiBkeW5hbWljYWxseSBjaGFuZ2luZyB0aGUgYGZpbHRlcmAgb3B0aW9uIHdpbGwgaGF2ZSBlZmZlY3Qgb25seSBvbiBuZXdseVxyXG5cdCAqIGFkZGVkIGRhdGEuIEl0IHdpbGwgX25vdF8gcmUtZXZhbHVhdGUgYWxyZWFkeSBpbmNsdWRlZCBmZWF0dXJlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY29vcmRzVG9MYXRMbmc6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyBHZW9KU09OIGNvb3JkaW5hdGVzIHRvIGBMYXRMbmdgcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0aGUgYGNvb3Jkc1RvTGF0TG5nYCBzdGF0aWMgbWV0aG9kLlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHRpZiAoZ2VvanNvbikge1xyXG5cdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiB0aGlzXHJcblx0Ly8gQWRkcyBhIEdlb0pTT04gb2JqZWN0IHRvIHRoZSBsYXllci5cclxuXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0dmFyIGZlYXR1cmVzID0gaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG5cdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcblx0XHRpZiAoZmVhdHVyZXMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHQvLyBvbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuXHRcdFx0XHRmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcblx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG5cdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKGdlb2pzb24pKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGxheWVyLmZlYXR1cmUgPSBhc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG5cdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG5cdFx0dGhpcy5yZXNldFN0eWxlKGxheWVyKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcblx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVzZXRTdHlsZSggPFBhdGg+IGxheWVyICk6IHRoaXNcclxuXHQvLyBSZXNldHMgdGhlIGdpdmVuIHZlY3RvciBsYXllcidzIHN0eWxlIHRvIHRoZSBvcmlnaW5hbCBHZW9KU09OIHN0eWxlLCB1c2VmdWwgZm9yIHJlc2V0dGluZyBzdHlsZSBhZnRlciBob3ZlciBldmVudHMuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHQvLyByZXNldCBhbnkgY3VzdG9tIHN0eWxlc1xyXG5cdFx0bGF5ZXIub3B0aW9ucyA9IGV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuXHJcbi8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcbi8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuLy8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbi8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG5mdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG5cdCAgICBjb29yZHMgPSBnZW9tZXRyeSA/IGdlb21ldHJ5LmNvb3JkaW5hdGVzIDogbnVsbCxcclxuXHQgICAgbGF5ZXJzID0gW10sXHJcblx0ICAgIHBvaW50VG9MYXllciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludFRvTGF5ZXIsXHJcblx0ICAgIF9jb29yZHNUb0xhdExuZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZyxcclxuXHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG5cdGlmICghY29vcmRzICYmICFnZW9tZXRyeSkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcclxuXHRjYXNlICdQb2ludCc6XHJcblx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzKTtcclxuXHRcdHJldHVybiBwb2ludFRvTGF5ZXIgPyBwb2ludFRvTGF5ZXIoZ2VvanNvbiwgbGF0bG5nKSA6IG5ldyBNYXJrZXIobGF0bG5nKTtcclxuXHJcblx0Y2FzZSAnTXVsdGlQb2ludCc6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcblx0XHRcdGxheWVycy5wdXNoKHBvaW50VG9MYXllciA/IHBvaW50VG9MYXllcihnZW9qc29uLCBsYXRsbmcpIDogbmV3IE1hcmtlcihsYXRsbmcpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGNhc2UgJ0xpbmVTdHJpbmcnOlxyXG5cdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnID8gMCA6IDEsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdQb2x5Z29uJzpcclxuXHRjYXNlICdNdWx0aVBvbHlnb24nOlxyXG5cdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBfY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoe1xyXG5cdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldLFxyXG5cdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuXHRcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0XHRpZiAobGF5ZXIpIHtcclxuXHRcdFx0XHRsYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG5cdGRlZmF1bHQ6XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4vLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cclxuZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzKSB7XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcbi8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuLy8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG4vLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcbmZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGxldmVsc0RlZXAsIF9jb29yZHNUb0xhdExuZykge1xyXG5cdHZhciBsYXRsbmdzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcblx0XHRcdGNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBfY29vcmRzVG9MYXRMbmcpIDpcclxuXHRcdFx0KF9jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcclxuXHJcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBsYXRsbmdzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nOiBMYXRMbmcsIHByZWNpc2lvbj86IE51bWJlcik6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG5mdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmcsIHByZWNpc2lvbikge1xyXG5cdHByZWNpc2lvbiA9IHR5cGVvZiBwcmVjaXNpb24gPT09ICdudW1iZXInID8gcHJlY2lzaW9uIDogNjtcclxuXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFtmb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcuYWx0LCBwcmVjaXNpb24pXSA6XHJcblx0XHRbZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pXTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbik6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbi8vIGBjbG9zZWRgIGRldGVybWluZXMgd2hldGhlciB0aGUgZmlyc3QgcG9pbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIGNsb3NlIHRoZSBmZWF0dXJlLCBvbmx5IHVzZWQgd2hlbiBgbGV2ZWxzRGVlcGAgaXMgMC4gRmFsc2UgYnkgZGVmYXVsdC5cclxuZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCwgcHJlY2lzaW9uKSB7XHJcblx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0Y29vcmRzLnB1c2gobGV2ZWxzRGVlcCA/XHJcblx0XHRcdGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY2xvc2VkLCBwcmVjaXNpb24pIDpcclxuXHRcdFx0bGF0TG5nVG9Db29yZHMobGF0bG5nc1tpXSwgcHJlY2lzaW9uKSk7XHJcblx0fVxyXG5cclxuXHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkKSB7XHJcblx0XHRjb29yZHMucHVzaChjb29yZHNbMF0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvb3JkcztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RmVhdHVyZShsYXllciwgbmV3R2VvbWV0cnkpIHtcclxuXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRleHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcblx0XHRhc0ZlYXR1cmUobmV3R2VvbWV0cnkpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb246IE9iamVjdCk6IE9iamVjdFxyXG4vLyBOb3JtYWxpemUgR2VvSlNPTiBnZW9tZXRyaWVzL2ZlYXR1cmVzIGludG8gR2VvSlNPTiBmZWF0dXJlcy5cclxuZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb24pIHtcclxuXHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgfHwgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRyZXR1cm4gZ2VvanNvbjtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcblx0fTtcclxufVxyXG5cclxudmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogbGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSwgcHJlY2lzaW9uKVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXJrZXJcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5NYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENpcmNsZU1hcmtlclxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkNpcmNsZU1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlsaW5lXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWxpbmUgKGFzIGEgR2VvSlNPTiBgTGluZVN0cmluZ2Agb3IgYE11bHRpTGluZVN0cmluZ2AgRmVhdHVyZSkuXHJcblBvbHlsaW5lLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIG11bHRpID0gIWlzRmxhdCh0aGlzLl9sYXRsbmdzKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMSA6IDAsIGZhbHNlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdMaW5lU3RyaW5nJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWdvblxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcblBvbHlnb24uaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgaG9sZXMgPSAhaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG5cdFx0ICAgIG11bHRpID0gaG9sZXMgJiYgIWlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMiA6IGhvbGVzID8gMSA6IDAsIHRydWUsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0aWYgKCFob2xlcykge1xyXG5cdFx0XHRjb29yZHMgPSBbY29vcmRzXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbkxheWVyR3JvdXAuaW5jbHVkZSh7XHJcblx0dG9NdWx0aVBvaW50OiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXIgZ3JvdXAgKGFzIGEgR2VvSlNPTiBgRmVhdHVyZUNvbGxlY3Rpb25gLCBgR2VvbWV0cnlDb2xsZWN0aW9uYCwgb3IgYE11bHRpUG9pbnRgKS5cclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHJcblx0XHR2YXIgdHlwZSA9IHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b011bHRpUG9pbnQocHJlY2lzaW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSB0eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcclxuXHRcdCAgICBqc29ucyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XHJcblx0XHRcdFx0dmFyIGpzb24gPSBsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKTtcclxuXHRcdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0XHRcdGpzb25zLnB1c2goanNvbi5nZW9tZXRyeSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBmZWF0dXJlID0gYXNGZWF0dXJlKGpzb24pO1xyXG5cdFx0XHRcdFx0Ly8gU3F1YXNoIG5lc3RlZCBmZWF0dXJlIGNvbGxlY3Rpb25zXHJcblx0XHRcdFx0XHRpZiAoZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2guYXBwbHkoanNvbnMsIGZlYXR1cmUuZmVhdHVyZXMpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaChmZWF0dXJlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbidcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIEdlb0pTT05cclxuLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbi8vIFtHZW9KU09OIGZvcm1hdF0oaHR0cDovL2dlb2pzb24ub3JnL2dlb2pzb24tc3BlYy5odG1sKSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZnVuY3Rpb24gZ2VvSlNPTihnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG52YXIgZ2VvSnNvbiA9IGdlb0pTT047XG5cbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHA6Ly93d3cubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAqIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBpbWFnZUJvdW5kcykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIEltYWdlT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIGltYWdlIHdpbGwgaGF2ZSBpdHMgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byAnJy4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvck92ZXJsYXlVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JPdmVybGF5VXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgdGlsZSBsYXllci5cclxuXHRcdHpJbmRleDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHRcdGNsYXNzTmFtZTogJycsXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIExhdExuZ0JvdW5kcywgT2JqZWN0KVxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0YWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ltYWdlKTtcclxuXHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlT3B0cykge1xyXG5cdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcblx0XHRcdHRoaXMuc2V0T3BhY2l0eShzdHlsZU9wdHMub3BhY2l0eSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRvQmFjayh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBVUkwgb2YgdGhlIGltYWdlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCkge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSB1cmw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBVcGRhdGUgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0LFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kOiBzZXRaSW5kZXgodmFsdWU6IE51bWJlcikgOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2ltYWdlb3ZlcmxheS16aW5kZXgpIG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTEltYWdlRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdJTUcnO1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogY3JlYXRlJDEoJ2ltZycpO1xyXG5cclxuXHRcdGFkZENsYXNzKGltZywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IGFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcblx0XHRpbWcub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcblx0XHRpbWcub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcblx0XHRpbWcub25sb2FkID0gYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblx0XHRpbWcub25lcnJvciA9IGJpbmQodGhpcy5fb3ZlcmxheU9uRXJyb3IsIHRoaXMsICdlcnJvcicpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gJyc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy56SW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHdhc0VsZW1lbnRTdXBwbGllZCkge1xyXG5cdFx0XHR0aGlzLl91cmwgPSBpbWcuc3JjO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aW1nLnNyYyA9IHRoaXMuX3VybDtcclxuXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9tYXAuX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHModGhpcy5fYm91bmRzLCBlLnpvb20sIGUuY2VudGVyKS5taW47XHJcblxyXG5cdFx0c2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHRzZXRQb3NpdGlvbihpbWFnZSwgYm91bmRzLm1pbik7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb3ZlcmxheU9uRXJyb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEBldmVudCBlcnJvcjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBoYXMgbG9hZGVkIGl0cyBpbWFnZVxyXG5cdFx0dGhpcy5maXJlKCdlcnJvcicpO1xyXG5cclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvck92ZXJsYXlVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGhpcy5fdXJsICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aGlzLl91cmwgPSBlcnJvclVybDtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsOiBTdHJpbmcsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogSW1hZ2VPdmVybGF5IG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSBpbWFnZSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxudmFyIGltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcblxuLypcclxuICogQGNsYXNzIFZpZGVvT3ZlcmxheVxyXG4gKiBAYWthIEwuVmlkZW9PdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgdmlkZW8gcGxheWVyIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXHJcbiAqXHJcbiAqIEEgdmlkZW8gb3ZlcmxheSB1c2VzIHRoZSBbYDx2aWRlbz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvdmlkZW8pXHJcbiAqIEhUTUw1IGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB2aWRlb1VybCA9ICdodHRwczovL3d3dy5tYXBib3guY29tL2JpdGVzLzAwMTg4L3BhdHJpY2lhX25hc2Eud2VibScsXHJcbiAqIFx0dmlkZW9Cb3VuZHMgPSBbWyAzMiwgLTEzMF0sIFsgMTMsIC0xMDBdXTtcclxuICogTC5WaWRlb092ZXJsYXkodmlkZW9VcmwsIHZpZGVvQm91bmRzICkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIFZpZGVvT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVmlkZW9PdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGF1dG9wbGF5OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIHBsYXlpbmcgYXV0b21hdGljYWxseSB3aGVuIGxvYWRlZC5cclxuXHRcdGF1dG9wbGF5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbG9vcDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgbG9vcCBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgd2hlbiBwbGF5ZWQuXHJcblx0XHRsb29wOiB0cnVlXHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG5cdFx0dmFyIHZpZCA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogY3JlYXRlJDEoJ3ZpZGVvJyk7XHJcblxyXG5cdFx0YWRkQ2xhc3ModmlkLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cclxuXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcclxuXHRcdHZpZC5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHZhciBzb3VyY2VFbGVtZW50cyA9IHZpZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcblx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlRWxlbWVudHNbal0uc3JjKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fdXJsID0gKHNvdXJjZUVsZW1lbnRzLmxlbmd0aCA+IDApID8gc291cmNlcyA6IFt2aWQuc3JjXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghaXNBcnJheSh0aGlzLl91cmwpKSB7IHRoaXMuX3VybCA9IFt0aGlzLl91cmxdOyB9XHJcblxyXG5cdFx0dmlkLmF1dG9wbGF5ID0gISF0aGlzLm9wdGlvbnMuYXV0b3BsYXk7XHJcblx0XHR2aWQubG9vcCA9ICEhdGhpcy5vcHRpb25zLmxvb3A7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3VybC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgc291cmNlID0gY3JlYXRlJDEoJ3NvdXJjZScpO1xyXG5cdFx0XHRzb3VyY2Uuc3JjID0gdGhpcy5fdXJsW2ldO1xyXG5cdFx0XHR2aWQuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MVmlkZW9FbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MVmlkZW9FbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxWaWRlb0VsZW1lbnQpXHJcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudmlkZW9PdmVybGF5KHZpZGVvOiBTdHJpbmd8QXJyYXl8SFRNTFZpZGVvRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBWaWRlb092ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIHZpZGVvIChvciBhcnJheSBvZiBVUkxzLCBvciBldmVuIGEgdmlkZW8gZWxlbWVudCkgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcblxyXG5mdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59XG5cbi8qXHJcbiAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIHBvcHVwIGxpa2UgcGx1Z2lucy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxudmFyIERpdk92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgRGl2T3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHBvcHVwIHBvc2l0aW9uLiBVc2VmdWwgdG8gY29udHJvbCB0aGUgYW5jaG9yXHJcblx0XHQvLyBvZiB0aGUgcG9wdXAgd2hlbiBvcGVuaW5nIGl0IG9uIHNvbWUgb3ZlcmxheXMuXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQocmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiBwb3B1cC5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4uXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAuXHJcblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBwb3B1cC4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBwb3B1cC5cclxuXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBBbGlhcyBmb3IgW2dldENvbnRlbnQoKV0oI3BvcHVwLWdldGNvbnRlbnQpXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG5cdC8vIFVwZGF0ZXMgdGhlIHBvcHVwIGNvbnRlbnQsIGxheW91dCBhbmQgcG9zaXRpb24uIFVzZWZ1bCBmb3IgdXBkYXRpbmcgdGhlIHBvcHVwIGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc09wZW46IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBwb3B1cCBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcblx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgaW4gZnJvbnQgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCB0byB0aGUgYmFjayBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG5vZGUgPSB0aGlzLl9jb250ZW50Tm9kZTtcclxuXHRcdHZhciBjb250ZW50ID0gKHR5cGVvZiB0aGlzLl9jb250ZW50ID09PSAnZnVuY3Rpb24nKSA/IHRoaXMuX2NvbnRlbnQodGhpcy5fc291cmNlIHx8IHRoaXMpIDogdGhpcy5fY29udGVudDtcclxuXHJcblx0XHRpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xyXG5cdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIHBvcHVwIGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbMCwgMF07XHJcblx0fVxyXG5cclxufSk7XG5cbi8qXHJcbiAqIEBjbGFzcyBQb3B1cFxyXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gKiBAYWthIEwuUG9wdXBcclxuICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICpcclxuICogYGBganNcclxuICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gKiBgYGBcclxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxudmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDMwMFxyXG5cdFx0Ly8gTWF4IHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxyXG5cdFx0Ly8gTWluIHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4SGVpZ2h0OiBOdW1iZXIgPSBudWxsXHJcblx0XHQvLyBJZiBzZXQsIGNyZWF0ZXMgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0XHJcblx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuXHRcdC8vIHRvIGZpdCB0aGUgb3BlbmVkIHBvcHVwLlxyXG5cdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUsIDUpXHJcblx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwSW5WaWV3OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcblx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxyXG5cdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIENvbnRyb2xzIHRoZSBwcmVzZW5jZSBvZiBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG5cdFx0YXV0b0Nsb3NlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkVzY2FwZUtleTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgRVNDIGtleSBmb3IgY2xvc2luZyBvZiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZU9uRXNjYXBlS2V5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkNsaWNrOiBCb29sZWFuID0gKlxyXG5cdFx0Ly8gU2V0IGl0IGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3NcclxuXHRcdC8vIG9uIHRoZSBtYXAuIERlZmF1bHRzIHRvIHRoZSBtYXAncyBbYGNsb3NlUG9wdXBPbkNsaWNrYF0oI21hcC1jbG9zZXBvcHVwb25jbGljaykgb3B0aW9uLlxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuIFRoZSBzYW1lIGFzIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub3BlblBvcHVwKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcblx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICE9PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLFxyXG5cdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG5cdFx0XHQnIGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cclxuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQtd3JhcHBlcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcblx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih3cmFwcGVyKTtcclxuXHRcdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcblx0XHRvbih3cmFwcGVyLCAnY29udGV4dG1lbnUnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fdGlwID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcblx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gY3JlYXRlJDEoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XHJcblxyXG5cdFx0XHRvbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcblx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAnJztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcblx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcblx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcblx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG5cdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG5cdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbiB8fCAodGhpcy5fbWFwLl9wYW5BbmltICYmIHRoaXMuX21hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChnZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCArIG1hcmdpbkJvdHRvbSxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGxheWVyUG9zLl9hZGQoZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9jbG9zZSgpO1xyXG5cdFx0c3RvcChlKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbnZhciBwb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRyZXR1cm4gbmV3IFBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbn07XHJcblxyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gKiBAb3B0aW9uIGNsb3NlUG9wdXBPbkNsaWNrOiBCb29sZWFuID0gdHJ1ZVxyXG4gKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gKi9cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBQb3B1cCkpIHtcclxuXHRcdFx0cG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucykuc2V0Q29udGVudChwb3B1cCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRwb3B1cC5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihwb3B1cCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRwb3B1cCA9IHRoaXMuX3BvcHVwO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMYXllclxyXG4gKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICpcclxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgcG9wdXBzIHRvIGl0LlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFBvcHVwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xyXG4gKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xyXG4gKiBgYGBcclxuICpcclxuICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcbiAqL1xyXG5cclxuLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG5MYXllci5pbmNsdWRlKHtcclxuXHJcblx0Ly8gQG1ldGhvZCBiaW5kUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFBvcHVwLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXHJcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgUG9wdXApIHtcclxuXHRcdFx0c2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xyXG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucywgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXHJcblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XHJcblx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIExheWVyKSkge1xyXG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxhdGxuZykge1xyXG5cdFx0XHRsYXRsbmcgPSBsYXllci5nZXRDZW50ZXIgPyBsYXllci5nZXRDZW50ZXIoKSA6IGxheWVyLmdldExhdExuZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0Ly8gc2V0IHBvcHVwIHNvdXJjZSB0byB0aGlzIGxheWVyXHJcblx0XHRcdHRoaXMuX3BvcHVwLl9zb3VyY2UgPSBsYXllcjtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSB0aGUgcG9wdXAgKGNvbnRlbnQsIGxheW91dCwgZWN0Li4uKVxyXG5cdFx0XHR0aGlzLl9wb3B1cC51cGRhdGUoKTtcclxuXHJcblx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Qb3B1cCh0aGlzLl9wb3B1cCwgbGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRpZiAodGhpcy5fcG9wdXAuX21hcCkge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKHRhcmdldCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxyXG5cdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBvcHVwKCk6IFBvcHVwXHJcblx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xyXG5cdH0sXHJcblxyXG5cdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG5cdFx0c3RvcChlKTtcclxuXHJcblx0XHQvLyBpZiB0aGlzIGluaGVyaXRzIGZyb20gUGF0aCBpdHMgYSB2ZWN0b3IgYW5kIHdlIGNhbiBqdXN0XHJcblx0XHQvLyBvcGVuIHRoZSBwb3B1cCBhdCB0aGUgbmV3IGxvY2F0aW9uXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBQYXRoKSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF5ZXIgfHwgZS50YXJnZXQsIGUubGF0bG5nKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyd2lzZSB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XHJcblx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcblx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSAmJiB0aGlzLl9wb3B1cC5fc291cmNlID09PSBsYXllcikge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGxheWVyLCBlLmxhdGxuZyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuX29wZW5Qb3B1cChlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXR0aW5nOlxuICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICovXG5cblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG52YXIgVG9vbHRpcCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndG9vbHRpcFBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0b29sdGlwUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxuXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cblx0XHRvZmZzZXQ6IFswLCAwXSxcblxuXHRcdC8vIEBvcHRpb24gZGlyZWN0aW9uOiBTdHJpbmcgPSAnYXV0bydcblx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuXHRcdC8vIGB0b3BgLCBgYm90dG9tYCwgYGNlbnRlcmAsIGBhdXRvYC5cblx0XHQvLyBgYXV0b2Agd2lsbCBkeW5hbWljYWxseSBzd2l0Y2ggYmV0d2VlbiBgcmlnaHRgIGFuZCBgbGVmdGAgYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwXG5cdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cblx0XHRkaXJlY3Rpb246ICdhdXRvJyxcblxuXHRcdC8vIEBvcHRpb24gcGVybWFuZW50OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG5cdFx0cGVybWFuZW50OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gc3RpY2t5OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG5cdFx0c3RpY2t5OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgbGlzdGVuIHRvIHRoZSBmZWF0dXJlIGV2ZW50cy5cblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuXHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG9wYWNpdHkuXG5cdFx0b3BhY2l0eTogMC45XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGlzIG9wZW5lZCBpbiB0aGUgbWFwLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaW4gdGhlIG1hcCBpcyBjbG9zZWQuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAodG91Y2ggJiYgIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fbWFwLmNsb3NlVG9vbHRpcCh0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG5cdFx0ICAgIGNsYXNzTmFtZSA9IHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XG5cblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUpO1xuXHR9LFxuXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcblx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcblx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuXHRcdFx0cG9zID0gcG9zLmFkZCh0b1BvaW50KC10b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIC10b29sdGlwSGVpZ2h0ICsgb2Zmc2V0LnkgKyBhbmNob3IueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQodG9vbHRpcFdpZHRoIC8gMiAtIG9mZnNldC54LCAtb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCAvIDIgKyBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSArIG9mZnNldC55LCB0cnVlKSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcgfHwgZGlyZWN0aW9uID09PSAnYXV0bycgJiYgdG9vbHRpcFBvaW50LnggPCBjZW50ZXJQb2ludC54KSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuXHRcdFx0cG9zID0gcG9zLmFkZCh0b1BvaW50KG9mZnNldC54ICsgYW5jaG9yLngsIGFuY2hvci55IC0gdG9vbHRpcEhlaWdodCAvIDIgKyBvZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludCh0b29sdGlwV2lkdGggKyBhbmNob3IueCAtIG9mZnNldC54LCB0b29sdGlwSGVpZ2h0IC8gMiAtIGFuY2hvci55IC0gb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9XG5cblx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcblx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtbGVmdCcpO1xuXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG5cdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLScgKyBkaXJlY3Rpb24pO1xuXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcblx0fVxuXG59KTtcblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4vLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4vLyBJbnN0YW50aWF0ZXMgYSBUb29sdGlwIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxudmFyIHRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xufTtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0aWYgKCEodG9vbHRpcCBpbnN0YW5jZW9mIFRvb2x0aXApKSB7XG5cdFx0XHR0b29sdGlwID0gbmV3IFRvb2x0aXAob3B0aW9ucykuc2V0Q29udGVudCh0b29sdGlwKTtcblx0XHR9XG5cblx0XHRpZiAobGF0bG5nKSB7XG5cdFx0XHR0b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmhhc0xheWVyKHRvb2x0aXApKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcih0b29sdGlwKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwPzogVG9vbHRpcCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHRvb2x0aXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59KTtcblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Ub29sdGlwKCk7XG4gKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAqIGBgYFxuICovXG5cbi8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuTGF5ZXIuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBiaW5kVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258VG9vbHRpcCwgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFRvb2x0aXApIHtcblx0XHRcdHNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gY29udGVudDtcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRpb25zLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCk7XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG5cdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRUb29sdGlwKCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cblx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcblx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlJCQxKSB7XG5cdFx0aWYgKCFyZW1vdmUkJDEgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlJCQxID8gJ29mZicgOiAnb24nLFxuXHRcdCAgICBldmVudHMgPSB7XG5cdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuXHRcdFx0bW92ZTogdGhpcy5fbW92ZVRvb2x0aXBcblx0XHQgICAgfTtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcblx0XHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRvdWNoKSB7XG5cdFx0XHRcdGV2ZW50cy5jbGljayA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudHMuYWRkID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0fVxuXHRcdHRoaXNbb25PZmZdKGV2ZW50cyk7XG5cdFx0dGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQgPSAhcmVtb3ZlJCQxO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgYm91bmQgdG9vbHRpcCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XG5cdFx0aWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyO1xuXHRcdFx0bGF5ZXIgPSB0aGlzO1xuXHRcdH1cblxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFsYXRsbmcpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlciA/IGxheWVyLmdldENlbnRlcigpIDogbGF5ZXIuZ2V0TGF0TG5nKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAgJiYgdGhpcy5fbWFwKSB7XG5cblx0XHRcdC8vIHNldCB0b29sdGlwIHNvdXJjZSB0byB0aGlzIGxheWVyXG5cdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBsYXllcjtcblxuXHRcdFx0Ly8gdXBkYXRlIHRoZSB0b29sdGlwIChjb250ZW50LCBsYXlvdXQsIGVjdC4uLilcblx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlKCk7XG5cblx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAsIGxhdGxuZyk7XG5cblx0XHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG1heSBub3QgYmUgZGVmaW5lZCBpZiBub3QgcGVybWFuZW50IGFuZCBuZXZlclxuXHRcdFx0Ly8gb3BlbmVkLlxuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiB0aGlzLl90b29sdGlwLl9jb250YWluZXIpIHtcblx0XHRcdFx0YWRkQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuX2Nsb3NlKCk7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdG9nZ2xlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cblx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNUb29sdGlwT3BlbigpOiBib29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG5cdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5pc09wZW4oKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFRvb2x0aXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxUb29sdGlwKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdHNldFRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0VG9vbHRpcCgpOiBUb29sdGlwXG5cdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0Z2V0VG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuXHR9LFxuXG5cdF9vcGVuVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8ICF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5vcGVuVG9vbHRpcChsYXllciwgdGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSA/IGUubGF0bG5nIDogdW5kZWZpbmVkKTtcblx0fSxcblxuXHRfbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nLCBjb250YWluZXJQb2ludCwgbGF5ZXJQb2ludDtcblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSAmJiBlLm9yaWdpbmFsRXZlbnQpIHtcblx0XHRcdGNvbnRhaW5lclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG5cdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KTtcblx0XHRcdGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XG5cdFx0fVxuXHRcdHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdH1cbn0pO1xuXG4vKlxuICogQGNsYXNzIERpdkljb25cbiAqIEBha2EgTC5EaXZJY29uXG4gKiBAaW5oZXJpdHMgSWNvblxuICpcbiAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICpcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gKi9cblxudmFyIERpdkljb24gPSBJY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG5cdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG5cdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cblx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC5cblx0XHRodG1sOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuXHRcdGJnUG9zOiBudWxsLFxuXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG5cblx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuXHRcdFx0dmFyIGJnUG9zID0gdG9Qb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmZ1bmN0aW9uIGRpdkljb24ob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IERpdkljb24ob3B0aW9ucyk7XG59XG5cbkljb24uRGVmYXVsdCA9IEljb25EZWZhdWx0O1xuXG4vKlxuICogQGNsYXNzIEdyaWRMYXllclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuR3JpZExheWVyXG4gKlxuICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICpcbiAqXG4gKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMpe1xuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBnZXQgYSBjYW52YXMgY29udGV4dCBhbmQgZHJhdyBzb21ldGhpbmcgb24gaXQgdXNpbmcgY29vcmRzLngsIGNvb3Jkcy55IGFuZCBjb29yZHMuelxuICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICpcbiAqICAgICAgICAgLy8gcmV0dXJuIHRoZSB0aWxlIHNvIGl0IGNhbiBiZSByZW5kZXJlZCBvbiBzY3JlZW5cbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvbiBBc3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVGlsZSBjcmVhdGlvbiBjYW4gYWxzbyBiZSBhc3luY2hyb25vdXMsIHRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYSB0aGlyZC1wYXJ0eSBkcmF3aW5nIGxpYnJhcnkuIE9uY2UgdGhlIHRpbGUgaXMgZmluaXNoZWQgZHJhd2luZyBpdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgZG9uZSgpYCBjYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICogICAgICAgICB2YXIgZXJyb3I7XG4gKlxuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBkcmF3IHNvbWV0aGluZyBhc3luY2hyb25vdXNseSBhbmQgcGFzcyB0aGUgdGlsZSB0byB0aGUgZG9uZSgpIGNhbGxiYWNrXG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAqICAgICAgICAgfSwgMTAwMCk7XG4gKlxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uXG4gKi9cblxuXG52YXIgR3JpZExheWVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcblx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG5cdFx0dGlsZVNpemU6IDI1NixcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuXHRcdC8vIExvYWQgbmV3IHRpbGVzIG9ubHkgd2hlbiBwYW5uaW5nIGVuZHMuXG5cdFx0Ly8gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBpbiBvcmRlciB0byBhdm9pZCB0b28gbWFueSByZXF1ZXN0cyBhbmQga2VlcCBzbW9vdGggbmF2aWdhdGlvbi5cblx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuXHRcdC8vIFtga2VlcEJ1ZmZlcmBdKCNncmlkbGF5ZXIta2VlcGJ1ZmZlcikgb3B0aW9uIGluIGRlc2t0b3AgYnJvd3NlcnMuXG5cdFx0dXBkYXRlV2hlbklkbGU6IG1vYmlsZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYSBzbW9vdGggem9vbSBhbmltYXRpb24gKGR1cmluZyBhIFt0b3VjaCB6b29tXSgjbWFwLXRvdWNoem9vbSkgb3IgYSBbYGZseVRvKClgXSgjbWFwLWZseXRvKSkgd2lsbCB1cGRhdGUgZ3JpZCBsYXllcnMgZXZlcnkgaW50ZWdlciB6b29tIGxldmVsLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgd2lsbCB1cGRhdGUgdGhlIGdyaWQgbGF5ZXIgb25seSB3aGVuIHRoZSBzbW9vdGggYW5pbWF0aW9uIGVuZHMuXG5cdFx0dXBkYXRlV2hlblpvb21pbmc6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcblx0XHQvLyBUaWxlcyB3aWxsIG5vdCB1cGRhdGUgbW9yZSB0aGFuIG9uY2UgZXZlcnkgYHVwZGF0ZUludGVydmFsYCBtaWxsaXNlY29uZHMgd2hlbiBwYW5uaW5nLlxuXHRcdHVwZGF0ZUludGVydmFsOiAyMDAsXG5cblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuXHRcdC8vIFRoZSBleHBsaWNpdCB6SW5kZXggb2YgdGhlIHRpbGUgbGF5ZXIuXG5cdFx0ekluZGV4OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuXHRcdC8vIElmIHNldCwgdGlsZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpbnNpZGUgdGhlIHNldCBgTGF0TG5nQm91bmRzYC5cblx0XHRib3VuZHM6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtaW5ab29tOiAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBoaWdoZXIgdGhhbiBgbWF4TmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWF4TmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5OYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBsb3dlciB0aGFuIGBtaW5OYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1pbk5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG5vV3JhcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0aGUgbGF5ZXIgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGFudGltZXJpZGlhbi4gSWYgYHRydWVgLCB0aGVcblx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG5cdFx0Ly8gZWZmZWN0IHdoZW4gdGhlIFttYXAgQ1JTXSgjbWFwLWNycykgZG9lc24ndCB3cmFwIGFyb3VuZC4gQ2FuIGJlIHVzZWRcblx0XHQvLyBpbiBjb21iaW5hdGlvbiB3aXRoIFtgYm91bmRzYF0oI2dyaWRsYXllci1ib3VuZHMpIHRvIHByZXZlbnQgcmVxdWVzdGluZ1xuXHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG5cdFx0bm9XcmFwOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3RpbGVQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndGlsZVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0Y2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMlxuXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cblx0XHRrZWVwQnVmZmVyOiAyXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdHRoaXMuX3Jlc2V0VmlldygpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gdGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRldmVudHMubW92ZSA9IHRoaXMuX29uTW92ZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIExheWVycyBleHRlbmRpbmcgYEdyaWRMYXllcmAgc2hhbGwgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG5cdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0fSxcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIFBvaW50ID8gcyA6IG5ldyBQb2ludChzLCBzKTtcblx0fSxcblxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuXHRcdC8vIGdvIHRocm91Z2ggYWxsIG90aGVyIGxheWVycyBvZiB0aGUgc2FtZSBwYW5lLCBzZXQgekluZGV4IHRvIG1heCArIDEgKGZyb250KSBvciBtaW4gLSAxIChiYWNrKVxuXG5cdFx0dmFyIGxheWVycyA9IHRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLFxuXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aCwgekluZGV4OyBpIDwgbGVuOyBpKyspIHtcblxuXHRcdFx0ekluZGV4ID0gbGF5ZXJzW2ldLnN0eWxlLnpJbmRleDtcblxuXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuXHRcdFx0XHRlZGdlWkluZGV4ID0gY29tcGFyZShlZGdlWkluZGV4LCArekluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNGaW5pdGUoZWRnZVpJbmRleCkpIHtcblx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuXHRcdGlmIChpZWx0OSkgeyByZXR1cm47IH1cblxuXHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdHNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG5cdFx0XHRpZiAoZmFkZSA8IDEpIHtcblx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHdpbGxQcnVuZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fb25PcGFxdWVUaWxlKHRpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG5cdFx0aWYgKG5leHRGcmFtZSkge1xuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25PcGFxdWVUaWxlOiBmYWxzZUZuLFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oeik7XG5cdFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoeik7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoIWxldmVsKSB7XG5cdFx0XHRsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSA9IHt9O1xuXG5cdFx0XHRsZXZlbC5lbCA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuXHRcdFx0bGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG5cdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdFx0Ly8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cblx0XHRcdGZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXG5cdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG5cdFx0cmV0dXJuIGxldmVsO1xuXHR9LFxuXG5cdF9vblVwZGF0ZUxldmVsOiBmYWxzZUZuLFxuXG5cdF9vblJlbW92ZUxldmVsOiBmYWxzZUZuLFxuXG5cdF9vbkNyZWF0ZUxldmVsOiBmYWxzZUZuLFxuXG5cdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIga2V5LCB0aWxlO1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRfcmV0YWluUGFyZW50OiBmdW5jdGlvbiAoeCwgeSwgeiwgbWluWm9vbSkge1xuXHRcdHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpLFxuXHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuXHRcdCAgICB6MiA9IHogLSAxLFxuXHRcdCAgICBjb29yZHMyID0gbmV3IFBvaW50KCt4MiwgK3kyKTtcblx0XHRjb29yZHMyLnogPSArejI7XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh6MiA+IG1pblpvb20pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cblx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpLFxuXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xuXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG5cdH0sXG5cblx0X2NsYW1wWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWluTmF0aXZlWm9vbSAmJiB6b29tIDwgb3B0aW9ucy5taW5OYXRpdmVab29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5taW5OYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWF4TmF0aXZlWm9vbSAmJiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPCB6b29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5tYXhOYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiB6b29tO1xuXHR9LFxuXG5cdF9zZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuXHRcdHZhciB0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbShNYXRoLnJvdW5kKHpvb20pKTtcblx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcblx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG5cblx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG5cdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG5cdFx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG5cdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFub1BydW5lKSB7XG5cdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcblx0XHRcdC8vIGEgem9vbSBhbmltIG9yIGEgcGluY2ggZ2VzdHVyZVxuXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcblx0XHR9XG5cblx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtcyhjZW50ZXIsIHpvb20pO1xuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcblx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpXG5cdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG5cdFx0aWYgKGFueTNkKSB7XG5cdFx0XHRzZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycyxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcyh0aGlzLl90aWxlWm9vbSk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHR9LFxuXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSBtYXAucHJvamVjdChjZW50ZXIsIHRoaXMuX3RpbGVab29tKS5mbG9vcigpLFxuXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuXHRcdHJldHVybiBuZXcgQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG5cdH0sXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG5cdF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxuXHRcdHZhciB6b29tID0gdGhpcy5fY2xhbXBab29tKG1hcC5nZXRab29tKCkpO1xuXG5cdFx0aWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTsgfVxuXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG5cdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuXHRcdCAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcblx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcblx0XHQgICAgcXVldWUgPSBbXSxcblx0XHQgICAgbWFyZ2luID0gdGhpcy5vcHRpb25zLmtlZXBCdWZmZXIsXG5cdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBCb3VuZHModGlsZVJhbmdlLmdldEJvdHRvbUxlZnQoKS5zdWJ0cmFjdChbbWFyZ2luLCAtbWFyZ2luXSksXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cblx0XHQvLyBTYW5pdHkgY2hlY2s6IHBhbmljIGlmIHRoZSB0aWxlIHJhbmdlIGNvbnRhaW5zIEluZmluaXR5IHNvbWV3aGVyZS5cblx0XHRpZiAoIShpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLngpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1pbi55KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LnkpKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlcycpOyB9XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG5cdFx0XHRpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKG5ldyBQb2ludChjLngsIGMueSkpKSB7XG5cdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcblx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG5cdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG5cdFx0Zm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0XHRcdGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuXHRcdFx0XHRpZiAodGlsZSkge1xuXHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaChjb29yZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG5cdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcblx0XHR9KTtcblxuXHRcdGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcblx0XHRcdC8vIGlmIGl0J3MgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcblx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0Ly8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG5cdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcblx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcblx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcblx0XHRcdCAgICAoIWNycy53cmFwTGF0ICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG5cdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG5cdFx0cmV0dXJuIFtudywgc2VdO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcblx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcblx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXG5cdFx0Ly8gdW5sZXNzIHdlJ3JlIG9uIEFuZHJvaWQncyBzdG9jayBicm93c2VyLFxuXHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xMzdcblx0XHRpZiAoIWFuZHJvaWRTdG9jaykge1xuXHRcdFx0dGlsZS5lbC5zZXRBdHRyaWJ1dGUoJ3NyYycsIGVtcHR5SW1hZ2VVcmwpO1xuXHRcdH1cblx0XHRyZW1vdmUodGlsZS5lbCk7XG5cblx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcblx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuXHRcdGFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUnKTtcblxuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHR0aWxlLnN0eWxlLndpZHRoID0gdGlsZVNpemUueCArICdweCc7XG5cdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSB0aWxlU2l6ZS55ICsgJ3B4JztcblxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XG5cblx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuXHRcdGlmIChpZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblxuXHRcdC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDc4XG5cdFx0aWYgKGFuZHJvaWQgJiYgIWFuZHJvaWQyMykge1xuXHRcdFx0dGlsZS5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHR9XG5cdH0sXG5cblx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpLFxuXHRcdCAgICBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG5cdFx0dGhpcy5faW5pdFRpbGUodGlsZSk7XG5cblx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2Vcblx0XHRpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcblx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG5cdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcblx0XHR9XG5cblx0XHRzZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG5cdFx0XHRlbDogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzLFxuXHRcdFx0Y3VycmVudDogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG5cdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuXHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAoZXJyKSB7XG5cdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBsb2FkaW5nIGEgdGlsZS5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuXHRcdFx0XHRlcnJvcjogZXJyLFxuXHRcdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0dGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcblx0XHRpZiAodGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdHNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG5cdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHR9XG5cblx0XHRpZiAoIWVycikge1xuXHRcdFx0YWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcblx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuXHRcdFx0aWYgKGllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBtb3JlIHRoYW4gMC4yIHNlY3MgKHRoZSBkdXJhdGlvbiBvZiB0aGUgdGlsZSBmYWRlLWluKVxuXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cblx0XHRcdFx0c2V0VGltZW91dChiaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG5cdH0sXG5cblx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuXHRcdFx0dGhpcy5fd3JhcFggPyB3cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcblx0XHRcdHRoaXMuX3dyYXBZID8gd3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcFkpIDogY29vcmRzLnkpO1xuXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG5cdFx0cmV0dXJuIG5ld0Nvb3Jkcztcblx0fSxcblxuXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuXHRcdFx0Ym91bmRzLm1heC51bnNjYWxlQnkodGlsZVNpemUpLmNlaWwoKS5zdWJ0cmFjdChbMSwgMV0pKTtcblx0fSxcblxuXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLmxvYWRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmdyaWRMYXllcihvcHRpb25zPzogR3JpZExheWVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEdyaWRMYXllciB3aXRoIHRoZSBzdXBwbGllZCBvcHRpb25zLlxuZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBHcmlkTGF5ZXIob3B0aW9ucyk7XG59XG5cbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXJcclxuICogQGluaGVyaXRzIEdyaWRMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLnRpbGVMYXllcignaHR0cDovL3tzfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZz97Zm9vfScsIHtmb286ICdiYXInfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAnaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS9ibGFibGEve3p9L3t4fS97eX17cn0ucG5nJ1xyXG4gKiBgYGBcclxuICpcclxuICogYHtzfWAgbWVhbnMgb25lIG9mIHRoZSBhdmFpbGFibGUgc3ViZG9tYWlucyAodXNlZCBzZXF1ZW50aWFsbHkgdG8gaGVscCB3aXRoIGJyb3dzZXIgcGFyYWxsZWwgcmVxdWVzdHMgcGVyIGRvbWFpbiBsaW1pdGF0aW9uOyBzdWJkb21haW4gdmFsdWVzIGFyZSBzcGVjaWZpZWQgaW4gb3B0aW9uczsgYGFgLCBgYmAgb3IgYGNgIGJ5IGRlZmF1bHQsIGNhbiBiZSBvbWl0dGVkKSwgYHt6fWAg4oCUIHpvb20gbGV2ZWwsIGB7eH1gIGFuZCBge3l9YCDigJQgdGlsZSBjb29yZGluYXRlcy4gYHtyfWAgY2FuIGJlIHVzZWQgdG8gYWRkIFwiJmNvbW1hdDsyeFwiIHRvIHRoZSBVUkwgdG8gbG9hZCByZXRpbmEgdGlsZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbnZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1pblpvb206IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG5cdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcblx0XHR0bXM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHRydWUsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byAnJy4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gZGV0ZWN0aW5nIHJldGluYSBkaXNwbGF5cywgYWRqdXN0aW5nIHRpbGVTaXplIGFuZCB6b29tIGxldmVsc1xyXG5cdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIHJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG5cdFx0XHRvcHRpb25zLnRpbGVTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnRpbGVTaXplIC8gMik7XHJcblxyXG5cdFx0XHRpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuXHRcdFx0XHRvcHRpb25zLm1heFpvb20tLTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuXHRcdFx0XHRvcHRpb25zLm1pblpvb20rKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5taW5ab29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0b3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTM3XHJcblx0XHRpZiAoIWFuZHJvaWQpIHtcclxuXHRcdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcblx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG5cdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XHJcblx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuXHRcdG9uKHRpbGUsICdsb2FkJywgYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblx0XHRvbih0aWxlLCAnZXJyb3InLCBiaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbikge1xyXG5cdFx0XHR0aWxlLmNyb3NzT3JpZ2luID0gJyc7XHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdCBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXHJcblx0XHQgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG5cdFx0Ki9cclxuXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG5cdFx0LypcclxuXHRcdCBTZXQgcm9sZT1cInByZXNlbnRhdGlvblwiIHRvIGZvcmNlIHNjcmVlbiByZWFkZXJzIHRvIGlnbm9yZSB0aGlzXHJcblx0XHQgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhL3JvbGVzI3RleHRhbHRlcm5hdGl2ZWNvbXB1dGF0aW9uXHJcblx0XHQqL1xyXG5cdFx0dGlsZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XHJcblxyXG5cdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG5cdC8vIEB1bmluaGVyaXRhYmxlXHJcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdHI6IHJldGluYSA/ICdAMngnIDogJycsXHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpLFxyXG5cdFx0XHR4OiBjb29yZHMueCxcclxuXHRcdFx0eTogY29vcmRzLnksXHJcblx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG5cdFx0fTtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG5cdFx0XHR2YXIgaW52ZXJ0ZWRZID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55IC0gY29vcmRzLnk7XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRlbXBsYXRlKHRoaXMuX3VybCwgZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG5cdFx0Ly8gRm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzMzMzJcclxuXHRcdGlmIChpZWx0OSkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KGJpbmQoZG9uZSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHRcdGRvbmUoZSwgdGlsZSk7XHJcblx0fSxcclxuXHJcblx0X29uVGlsZVJlbW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUudGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxyXG5cdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG5cdFx0em9vbVJldmVyc2UgPSB0aGlzLm9wdGlvbnMuem9vbVJldmVyc2UsXHJcblx0XHR6b29tT2Zmc2V0ID0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcblx0XHRcdHpvb20gPSBtYXhab29tIC0gem9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2dldFN1YmRvbWFpbjogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnNbaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcblx0X2Fib3J0TG9hZGluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksIHRpbGU7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2ldLmNvb3Jkcy56ICE9PSB0aGlzLl90aWxlWm9vbSkge1xyXG5cdFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXS5lbDtcclxuXHJcblx0XHRcdFx0dGlsZS5vbmxvYWQgPSBmYWxzZUZuO1xyXG5cdFx0XHRcdHRpbGUub25lcnJvciA9IGZhbHNlRm47XHJcblxyXG5cdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0dGlsZS5zcmMgPSBlbXB0eUltYWdlVXJsO1xyXG5cdFx0XHRcdFx0cmVtb3ZlKHRpbGUpO1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlbGF5ZXIodXJsVGVtcGxhdGU6IFN0cmluZywgb3B0aW9ucz86IFRpbGVMYXllciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGBVUkwgdGVtcGxhdGVgIGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5cclxuZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn1cblxuLypcclxuICogQGNsYXNzIFRpbGVMYXllci5XTVNcclxuICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gKiBVc2VkIHRvIGRpc3BsYXkgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcyBhcyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBUaWxlTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gKiBcdGxheWVyczogJ25leHJhZC1uMHItOTAwOTEzJyxcclxuICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gKiBcdGF0dHJpYnV0aW9uOiBcIldlYXRoZXIgZGF0YSDCqSAyMDEyIElFTSBOZXhyYWRcIlxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIFRpbGVMYXllcldNUyA9IFRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyLldNUyBvcHRpb25zXHJcblx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG5cdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcblx0Ly8gW25vbi1zdGFuZGFyZCB2ZW5kb3IgV01TIHBhcmFtZXRlcnNdKGh0dHA6Ly9kb2NzLmdlb3NlcnZlci5vcmcvc3RhYmxlL2VuL3VzZXIvc2VydmljZXMvd21zL3ZlbmRvci5odG1sKS5cclxuXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcblx0XHRzZXJ2aWNlOiAnV01TJyxcclxuXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gKioocmVxdWlyZWQpKiogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIGxheWVycyB0byBzaG93LlxyXG5cdFx0bGF5ZXJzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN0eWxlczogU3RyaW5nID0gJydcclxuXHRcdC8vIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBzdHlsZXMuXHJcblx0XHRzdHlsZXM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZm9ybWF0OiBTdHJpbmcgPSAnaW1hZ2UvanBlZydcclxuXHRcdC8vIFdNUyBpbWFnZSBmb3JtYXQgKHVzZSBgJ2ltYWdlL3BuZydgIGZvciBsYXllcnMgd2l0aCB0cmFuc3BhcmVuY3kpLlxyXG5cdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc3BhcmVudDogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBXTVMgc2VydmljZSB3aWxsIHJldHVybiBpbWFnZXMgd2l0aCB0cmFuc3BhcmVuY3kuXHJcblx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB2ZXJzaW9uOiBTdHJpbmcgPSAnMS4xLjEnXHJcblx0XHQvLyBWZXJzaW9uIG9mIHRoZSBXTVMgc2VydmljZSB0byB1c2VcclxuXHRcdHZlcnNpb246ICcxLjEuMSdcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gbnVsbFxyXG5cdFx0Ly8gQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIHRvIHVzZSBmb3IgdGhlIFdNUyByZXF1ZXN0cywgZGVmYXVsdHMgdG9cclxuXHRcdC8vIG1hcCBDUlMuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3Qgc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdXBwZXJjYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgV01TIHJlcXVlc3QgcGFyYW1ldGVyIGtleXMgd2lsbCBiZSB1cHBlcmNhc2UuXHJcblx0XHR1cHBlcmNhc2U6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHR2YXIgd21zUGFyYW1zID0gZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMpO1xyXG5cclxuXHRcdC8vIGFsbCBrZXlzIHRoYXQgYXJlIG5vdCBUaWxlTGF5ZXIgb3B0aW9ucyBnbyB0byBXTVMgcGFyYW1zXHJcblx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdFx0aWYgKCEoaSBpbiB0aGlzLm9wdGlvbnMpKSB7XHJcblx0XHRcdFx0d21zUGFyYW1zW2ldID0gb3B0aW9uc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciByZWFsUmV0aW5hID0gb3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgcmV0aW5hID8gMiA6IDE7XHJcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XHJcblx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuXHRcdHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZS55ICogcmVhbFJldGluYTtcclxuXHJcblx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuXHRcdCAgICBjcnMgPSB0aGlzLl9jcnMsXHJcblx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID9cclxuXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuXHRcdCAgICBbbWluLngsIG1pbi55LCBtYXgueCwgbWF4LnldKS5qb2luKCcsJyksXHJcblx0XHR1cmwgPSBMLlRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gdXJsICtcclxuXHRcdFx0Z2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuXHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwYXJhbXMsIG5vUmVkcmF3KSB7XHJcblxyXG5cdFx0ZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgV01TIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYmFzZSBVUkwgb2YgdGhlIFdNUyBzZXJ2aWNlIGFuZCBhIFdNUyBwYXJhbWV0ZXJzL29wdGlvbnMgb2JqZWN0LlxyXG5mdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxufVxuXG5UaWxlTGF5ZXIuV01TID0gVGlsZUxheWVyV01TO1xudGlsZUxheWVyLndtcyA9IHRpbGVMYXllcldNUztcblxuLypcbiAqIEBjbGFzcyBSZW5kZXJlclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuUmVuZGVyZXJcbiAqXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gKlxuICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAqXG4gKiBAZXZlbnQgdXBkYXRlOiBFdmVudFxuICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gKi9cblxudmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG5cdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0cGFkZGluZzogMC4xLFxuXG5cdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgY2xpY2sgdG9sZXJhbmNlIHJvdW5kIGEgcGF0aC9vYmplY3Qgb24gdGhlIG1hcFxuXHRcdHRvbGVyYW5jZSA6IDBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0c3RhbXAodGhpcyk7XG5cdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdFx0dGhpcy5fZGVzdHJveUNvbnRhaW5lcigpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuXHRcdFx0em9vbWVuZDogdGhpcy5fb25ab29tRW5kXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuXHRcdH1cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcblx0fSxcblxuXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdH0sXG5cblx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG5cdFx0ICAgIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSxcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41ICsgdGhpcy5vcHRpb25zLnBhZGRpbmcpLFxuXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuXHRcdCAgICBkZXN0Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChjZW50ZXIsIHpvb20pLFxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBkZXN0Q2VudGVyUG9pbnQuc3VidHJhY3QoY3VycmVudENlbnRlclBvaW50KSxcblxuXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChwb3NpdGlvbikuYWRkKHZpZXdIYWxmKS5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xuXG5cdFx0aWYgKGFueTNkKSB7XG5cdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG5cbi8qXG4gKiBAY2xhc3MgQ2FudmFzXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5DYW52YXNcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9Y2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgSUU4LCBhbmQgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcyBtaWdodFxuICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLmNhbnZhcygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxudmFyIENhbnZhcyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnZpZXdwcmVyZXNldCA9IHRoaXMuX29uVmlld1ByZVJlc2V0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X29uVmlld1ByZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gU2V0IGEgZmxhZyBzbyB0aGF0IGEgdmlld3ByZXJlc2V0K21vdmVlbmQrdmlld3Jlc2V0IG9ubHkgdXBkYXRlcyZyZWRyYXdzIG9uY2Vcblx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gdHJ1ZTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMpO1xuXG5cdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuXHRcdC8vIGluIGNhc2Ugb2YgcmVtb3ZpbmcgdGhlIHJlbmRlcmVyIGl0c2VsZiBmcm9tIHRoZSBtYXAuXG5cdFx0dGhpcy5fZHJhdygpO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG5cdFx0b24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgdGhyb3R0bGUodGhpcy5fb25Nb3VzZU1vdmUsIDMyLCB0aGlzKSwgdGhpcyk7XG5cdFx0b24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcblx0XHRvbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcblxuXHRcdHRoaXMuX2N0eCA9IGNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuXHR9LFxuXG5cdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX2N0eDtcblx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGxheWVyO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0fVxuXHRcdHRoaXMuX3JlZHJhdygpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2RyYXduTGF5ZXJzID0ge307XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gcmV0aW5hID8gMiA6IDE7XG5cblx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblxuXHRcdC8vIHNldCBjYW52YXMgc2l6ZSAoYWxzbyBjbGVhcmluZyBpdCk7IHVzZSBkb3VibGUgc2l6ZSBvbiByZXRpbmFcblx0XHRjb250YWluZXIud2lkdGggPSBtICogc2l6ZS54O1xuXHRcdGNvbnRhaW5lci5oZWlnaHQgPSBtICogc2l6ZS55O1xuXHRcdGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHNpemUueCArICdweCc7XG5cdFx0Y29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cblx0XHRpZiAocmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG5cdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcblx0XHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyID0ge1xuXHRcdFx0bGF5ZXI6IGxheWVyLFxuXHRcdFx0cHJldjogdGhpcy5fZHJhd0xhc3QsXG5cdFx0XHRuZXh0OiBudWxsXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fZHJhd0xhc3QpIHsgdGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyOyB9XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBsYXllci5fb3JkZXI7XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW0wuc3RhbXAobGF5ZXIpXTtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBSZWRyYXcgdGhlIHVuaW9uIG9mIHRoZSBsYXllcidzIG9sZCBwaXhlbFxuXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHQvLyBUaGUgcmVkcmF3IHdpbGwgZXh0ZW5kIHRoZSByZWRyYXcgYm91bmRzXG5cdFx0Ly8gd2l0aCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHR2YXIgcGFydHMgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheS5zcGxpdCgnLCcpLFxuXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuXHRcdFx0ICAgIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGFzaEFycmF5LnB1c2goTnVtYmVyKHBhcnRzW2ldKSk7XG5cdFx0XHR9XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IHRoaXMuX3JlZHJhd1JlcXVlc3QgfHwgcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuXHR9LFxuXG5cdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcblx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NsZWFyKCk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG5cdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jb250YWluZXIud2lkdGgsIHRoaXMuX2NvbnRhaW5lci5oZWlnaHQpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IHRydWU7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZHJhd25MYXllcnNbbGF5ZXIuX2xlYWZsZXRfaWRdID0gbGF5ZXI7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0c1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0cCA9IHBhcnRzW2ldW2pdO1xuXHRcdFx0XHRjdHhbaiA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHAueCwgcC55KTtcblx0XHRcdH1cblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuXHRcdGlmICghdGhpcy5fZHJhd2luZyB8fCBsYXllci5fZW1wdHkoKSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHgsXG5cdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcblx0XHQgICAgcyA9IChNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcikgLyByO1xuXG5cdFx0dGhpcy5fZHJhd25MYXllcnNbbGF5ZXIuX2xlYWZsZXRfaWRdID0gbGF5ZXI7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXHR9LFxuXG5cdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcblx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxheWVyLm9wdGlvbnMgJiYgbGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5IHx8IFtdKTtcblx0XHRcdH1cblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMub3BhY2l0eTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcblx0XHRcdGN0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuXHQvLyBzbyB3ZSBlbXVsYXRlIHRoYXQgYnkgY2FsY3VsYXRpbmcgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBvbiBtb3VzZW1vdmUvY2xpY2sgbWFudWFsbHlcblxuXHRfb25DbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpICYmICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuXHRcdFx0XHRjbGlja2VkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNsaWNrZWRMYXllcikgIHtcblx0XHRcdGZha2VTdG9wKGUpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjbGlja2VkTGF5ZXJdLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcblx0fSxcblxuXG5cdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG5cdFx0aWYgKGxheWVyKSB7XG5cdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW91dCcpO1xuXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdHZhciBsYXllciwgY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlKTtcblxuXHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllcikge1xuXHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3Jcblx0XHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjYW5kaWRhdGVIb3ZlcmVkTGF5ZXJdLCBlLCAnbW91c2VvdmVyJyk7XG5cdFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW3RoaXMuX2hvdmVyZWRMYXllcl0sIGUpO1xuXHRcdH1cblx0fSxcblxuXHRfZmlyZUV2ZW50OiBmdW5jdGlvbiAobGF5ZXJzLCBlLCB0eXBlKSB7XG5cdFx0dGhpcy5fbWFwLl9maXJlRE9NRXZlbnQoZSwgdHlwZSB8fCBlLnR5cGUsIGxheWVycyk7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBsYXN0XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSBpZiAobmV4dCkge1xuXHRcdFx0Ly8gVXBkYXRlIGZpcnN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuXHRcdH1cblxuXHRcdG9yZGVyLnByZXYgPSB0aGlzLl9kcmF3TGFzdDtcblx0XHR0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7XG5cblx0XHRvcmRlci5uZXh0ID0gbnVsbDtcblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbHJlYWR5IGZpcnN0XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSBpZiAocHJldikge1xuXHRcdFx0Ly8gVXBkYXRlIGxhc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG5cdFx0XHQvLyBzaW5nbGUgZW50cnlcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gbnVsbDtcblxuXHRcdG9yZGVyLm5leHQgPSB0aGlzLl9kcmF3Rmlyc3Q7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0LnByZXYgPSBvcmRlcjtcblx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jYW52YXMob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5mdW5jdGlvbiBjYW52YXMkMShvcHRpb25zKSB7XG5cdHJldHVybiBjYW52YXMgPyBuZXcgQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbn1cblxuLypcbiAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gKi9cblxuXG52YXIgdm1sQ3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcblx0dHJ5IHtcblx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxsdm1sOicgKyBuYW1lICsgJyBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHR9O1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0fTtcblx0fVxufSkoKTtcblxuXG4vKlxuICogQGNsYXNzIFNWR1xuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0IFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW4gdGhpcyBjYXNlLlxuICpcbiAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5cbi8vIG1peGluIHRvIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG52YXIgdm1sTWl4aW4gPSB7XG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtdm1sLWNvbnRhaW5lcicpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG5cdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cblx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cblx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdHJlbW92ZShjb250YWluZXIpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRpZiAoIXN0cm9rZSkge1xuXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4Jztcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBpc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0c3Ryb2tlLmVuZGNhcCA9IG9wdGlvbnMubGluZUNhcC5yZXBsYWNlKCdidXR0JywgJ2ZsYXQnKTtcblx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG5cdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0aWYgKCFmaWxsKSB7XG5cdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xuXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXG5cdFx0fSBlbHNlIGlmIChmaWxsKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG5cdFx0XHRsYXllci5fZmlsbCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG5cdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuXHRcdCAgICByMiA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kgfHwgcik7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH1cbn07XG5cbnZhciBjcmVhdGUkMiA9IHZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLlNWR1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zdmcpLCBTVkcgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICogdGhpcyBjYXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxudmFyIFNWRyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMuem9vbXN0YXJ0ID0gdGhpcy5fb25ab29tU3RhcnQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQyKCdzdmcnKTtcblxuXHRcdC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNsaWNrIHRocm91Z2ggc3ZnIHJvb3Q7IHdlJ2xsIHJlc2V0IGl0IGJhY2sgaW4gaW5kaXZpZHVhbCBwYXRoc1xuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuXHRcdHRoaXMuX3Jvb3RHcm91cCA9IGNyZWF0ZSQyKCdnJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuXHRcdGRlbGV0ZSB0aGlzLl9yb290R3JvdXA7XG5cdFx0ZGVsZXRlIHRoaXMuX3N2Z1NpemU7XG5cdH0sXG5cblx0X29uWm9vbVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gRHJhZy10aGVuLXBpbmNoIGludGVyYWN0aW9ucyBtaWdodCBtZXNzIHVwIHRoZSBjZW50ZXIgYW5kIHpvb20uXG5cdFx0Ly8gSW4gdGhpcyBjYXNlLCB0aGUgZWFzaWVzdCB3YXkgdG8gcHJldmVudCB0aGlzIGlzIHJlLWRvIHRoZSByZW5kZXJlclxuXHRcdC8vICAgYm91bmRzIGFuZCBwYWRkaW5nIHdoZW4gdGhlIHpvb21pbmcgc3RhcnRzLlxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cblx0XHQvLyBzZXQgc2l6ZSBvZiBzdmctY29udGFpbmVyIGlmIGNoYW5nZWRcblx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR0aGlzLl9zdmdTaXplID0gc2l6ZTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZW1lbnQ6IHVwZGF0ZSBjb250YWluZXIgdmlld0JveCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGluZGl2aWR1YWwgbGF5ZXJzXG5cdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFtiLm1pbi54LCBiLm1pbi55LCBzaXplLngsIHNpemUueV0uam9pbignICcpKTtcblxuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0Ly8gbWV0aG9kcyBiZWxvdyBhcmUgY2FsbGVkIGJ5IHZlY3RvciBsYXllcnMgaW1wbGVtZW50YXRpb25zXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlJDIoJ3BhdGgnKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcblx0XHRcdGFkZENsYXNzKHBhdGgsIGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0YWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9yb290R3JvdXApIHsgdGhpcy5faW5pdENvbnRhaW5lcigpOyB9XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJlbW92ZShsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBvcHRpb25zLmxpbmVDYXApO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvcHRpb25zLmRhc2hBcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCBvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgcG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcblx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcblx0XHQgICAgYXJjID0gJ2EnICsgciArICcsJyArIHIyICsgJyAwIDEsMCAnO1xuXG5cdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3Ncblx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdNJyArIChwLnggLSByKSArICcsJyArIHAueSArXG5cdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuXHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoKTtcblx0fSxcblxuXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dG9Gcm9udChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuaWYgKHZtbCkge1xuXHRTVkcuaW5jbHVkZSh2bWxNaXhpbik7XG59XG5cbi8vIEBuYW1lc3BhY2UgU1ZHXG4vLyBAZmFjdG9yeSBMLnN2ZyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmZ1bmN0aW9uIHN2ZyQxKG9wdGlvbnMpIHtcblx0cmV0dXJuIHN2ZyB8fCB2bWwgPyBuZXcgU1ZHKG9wdGlvbnMpIDogbnVsbDtcbn1cblxuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG5cdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cblx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG5cdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIE1hcDsgQG9wdGlvbiBwcmVmZXJDYW52YXM6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuXHRcdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gKHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgY2FudmFzJDEoKSkgfHwgc3ZnJDEoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcblx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVuZGVyZXIgPSAoU1ZHICYmIHN2ZyQxKHtwYW5lOiBuYW1lfSkpIHx8IChDYW52YXMgJiYgY2FudmFzJDEoe3BhbmU6IG5hbWV9KSk7XG5cdFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdID0gcmVuZGVyZXI7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fVxufSk7XG5cbi8qXG4gKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICovXG5cbi8qXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKiBAYWthIEwuUmVjdGFuZ2xlXG4gKiBAaW5oZXJpdHMgUG9seWdvblxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gKiBgYGBcbiAqXG4gKi9cblxuXG52YXIgUmVjdGFuZ2xlID0gUG9seWdvbi5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuXHR9LFxuXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRsYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuXHRcdHJldHVybiBbXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcblx0XHRdO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5mdW5jdGlvbiByZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG59XG5cblNWRy5jcmVhdGUgPSBjcmVhdGUkMjtcblNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5cbkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZyA9IGNvb3Jkc1RvTGF0TG5nO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG5HZW9KU09OLmxhdExuZ1RvQ29vcmRzID0gbGF0TG5nVG9Db29yZHM7XG5HZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcztcbkdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG5HZW9KU09OLmFzRmVhdHVyZSA9IGFzRmVhdHVyZTtcblxuLypcbiAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgdG8gYSByZWN0YW5ndWxhciBhcmVhIHNwZWNpZmllZCBieVxuXHQvLyBkcmFnZ2luZyB0aGUgbW91c2Ugd2hpbGUgcHJlc3NpbmcgdGhlIHNoaWZ0IGtleS5cblx0Ym94Wm9vbTogdHJ1ZVxufSk7XG5cbnZhciBCb3hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHRtYXAub24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHJlbW92ZSh0aGlzLl9wYW5lKTtcblx0XHRkZWxldGUgdGhpcy5fcGFuZTtcblx0fSxcblxuXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNldFN0YXRlVGltZW91dCAhPT0gMCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0KTtcblx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gQ2xlYXIgdGhlIGRlZmVycmVkIHJlc2V0U3RhdGUgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldCwgb3RoZXJ3aXNlIGl0XG5cdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG5cdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHRkaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0b24oZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBzdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG5cdFx0c2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHR9LFxuXG5cdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdHJlbW92ZSh0aGlzLl9ib3gpO1xuXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblx0XHR9XG5cblx0XHRlbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0ZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHRvZmYoZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBzdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG5cdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGJveFpvb206IEhhbmRsZXJcbi8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEJveFpvb20pO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxudmFyIERvdWJsZUNsaWNrWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcblx0XHQgICAgem9vbSA9IGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IG9sZFpvb20gLSBkZWx0YSA6IG9sZFpvb20gKyBkZWx0YTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vXG4vLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbi8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbi8vIGFzIGRyYWdnaW5nIG9yIHRvdWNoIHpvb20gKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEZvciBleGFtcGxlOlxuLy9cbi8vIGBgYGpzXG4vLyBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbi8vIGBgYFxuLy9cbi8vIEBwcm9wZXJ0eSBkb3VibGVDbGlja1pvb206IEhhbmRsZXJcbi8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgRG91YmxlQ2xpY2tab29tKTtcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgYmUgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQgdW5sZXNzIHJ1bm5pbmcgb24gb2xkIEFuZHJvaWQgZGV2aWNlcy5cblx0aW5lcnRpYTogIWFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFEZWNlbGVyYXRpb246IE51bWJlciA9IDMwMDBcblx0Ly8gVGhlIHJhdGUgd2l0aCB3aGljaCB0aGUgaW5lcnRpYWwgbW92ZW1lbnQgc2xvd3MgZG93biwgaW4gcGl4ZWxzL3NlY29uZMKyLlxuXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFNYXhTcGVlZDogTnVtYmVyID0gSW5maW5pdHlcblx0Ly8gTWF4IHNwZWVkIG9mIHRoZSBpbmVydGlhbCBtb3ZlbWVudCwgaW4gcGl4ZWxzL3NlY29uZC5cblx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG5cdC8vIEBvcHRpb24gZWFzZUxpbmVhcml0eTogTnVtYmVyID0gMC4yXG5cdGVhc2VMaW5lYXJpdHk6IDAuMixcblxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHQvLyBAb3B0aW9uIHdvcmxkQ29weUp1bXA6IEJvb2xlYW4gPSBmYWxzZVxuXHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIHRoZSBtYXAgdHJhY2tzIHdoZW4geW91IHBhbiB0byBhbm90aGVyIFwiY29weVwiXG5cdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG5cdC8vIGxpa2UgbWFya2VycyBhbmQgdmVjdG9yIGxheWVycyBhcmUgc3RpbGwgdmlzaWJsZS5cblx0d29ybGRDb3B5SnVtcDogZmFsc2UsXG5cblx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuXHQvLyBJZiBgbWF4Qm91bmRzYCBpcyBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgY29udHJvbCBob3cgc29saWQgdGhlIGJvdW5kc1xuXHQvLyBhcmUgd2hlbiBkcmFnZ2luZyB0aGUgbWFwIGFyb3VuZC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDAuMGAgYWxsb3dzIHRoZVxuXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG5cdC8vIHNsb3cgZG93biBtYXAgZHJhZ2dpbmcgb3V0c2lkZSBib3VuZHMsIGFuZCBgMS4wYCBtYWtlcyB0aGUgYm91bmRzIGZ1bGx5XG5cdC8vIHNvbGlkLCBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gZHJhZ2dpbmcgb3V0c2lkZSB0aGUgYm91bmRzLlxuXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxufSk7XG5cbnZhciBEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0YWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdHRoaXMuX3RpbWVzID0gW107XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYicpO1xuXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRtYXAuX3N0b3AoKTtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gdG9Cb3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcblx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bWFwXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnModGltZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWFwXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfcHJ1bmVQb3NpdGlvbnM6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0d2hpbGUgKHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggPiAxICYmIHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG5cdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcblx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcblx0fSxcblxuXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG5cdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG5cdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cblx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG5cdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuXHR9LFxuXG5cdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG5cdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG5cdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnMoK25ldyBEYXRlKCkpO1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcblx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG5cdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcblx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cblx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHRcdHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIERyYWcpO1xuXG4vKlxuICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG5cdC8vIGFycm93cyBhbmQgYCtgL2AtYCBrZXlzLlxuXHRrZXlib2FyZDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG5cdC8vIEFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIHdoZW4gcHJlc3NpbmcgYW4gYXJyb3cga2V5LlxuXHRrZXlib2FyZFBhbkRlbHRhOiA4MFxufSk7XG5cbnZhciBLZXlib2FyZCA9IEhhbmRsZXIuZXh0ZW5kKHtcblxuXHRrZXlDb2Rlczoge1xuXHRcdGxlZnQ6ICAgIFszN10sXG5cdFx0cmlnaHQ6ICAgWzM5XSxcblx0XHRkb3duOiAgICBbNDBdLFxuXHRcdHVwOiAgICAgIFszOF0sXG5cdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcblx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuXHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG5cdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG5cdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0b24oY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vbih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVtb3ZlSG9va3MoKTtcblxuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub2ZmKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9mZnNldDtcblxuXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuXG5cdFx0XHRpZiAobWFwLl9wYW5BbmltICYmIG1hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuXHRcdFx0aWYgKGUuc2hpZnRLZXkpIHtcblx0XHRcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLm11bHRpcGx5QnkoMyk7XG5cdFx0XHR9XG5cblx0XHRcdG1hcC5wYW5CeShvZmZzZXQpO1xuXG5cdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KSB7XG5cdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzdG9wKGUpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbi8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEtleWJvYXJkKTtcblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNld2hlZWwgb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG5cdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG5cdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG5cdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG5cdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcblx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG5cdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG59KTtcblxudmFyIFNjcm9sbFdoZWVsWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblx0fSxcblxuXHRfb25XaGVlbFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZGVsdGEgPSBnZXRXaGVlbERlbHRhKGUpO1xuXG5cdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cblx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcblx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0c3RvcChlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cblx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcblx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuXG4vKlxuICogTC5NYXAuVGFwIGlzIHVzZWQgdG8gZW5hYmxlIG1vYmlsZSBoYWNrcyBsaWtlIHF1aWNrIHRhcHMgYW5kIGxvbmcgaG9sZC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0YXA6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIEVuYWJsZXMgbW9iaWxlIGhhY2tzIGZvciBzdXBwb3J0aW5nIGluc3RhbnQgdGFwcyAoZml4aW5nIDIwMG1zIGNsaWNrXG5cdC8vIGRlbGF5IG9uIGlPUy9BbmRyb2lkKSBhbmQgdG91Y2ggaG9sZHMgKGZpcmVkIGFzIGBjb250ZXh0bWVudWAgZXZlbnRzKS5cblx0dGFwOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gdGFwVG9sZXJhbmNlOiBOdW1iZXIgPSAxNVxuXHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCBoaXMgZmluZ2VyIGR1cmluZyB0b3VjaFxuXHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cblx0dGFwVG9sZXJhbmNlOiAxNVxufSk7XG5cbnZhciBUYXAgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMpIHsgcmV0dXJuOyB9XG5cblx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdHRoaXMuX2ZpcmVDbGljayA9IHRydWU7XG5cblx0XHQvLyBkb24ndCBzaW11bGF0ZSBjbGljayBvciB0cmFjayBsb25ncHJlc3MgaWYgbW9yZSB0aGFuIDEgdG91Y2hcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF0sXG5cdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHQvLyBpZiB0b3VjaGluZyBhIGxpbmssIGhpZ2hsaWdodCBpdFxuXHRcdGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRhZGRDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0Ly8gc2ltdWxhdGUgbG9uZyBob2xkIGJ1dCBzZXR0aW5nIGEgdGltZW91dFxuXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChiaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX29uVXAoKTtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyksIDEwMDApO1xuXG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vkb3duJywgZmlyc3QpO1xuXG5cdFx0b24oZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdFx0b2ZmKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cblx0XHRpZiAodGhpcy5fZmlyZUNsaWNrICYmIGUgJiYgZS5jaGFuZ2VkVG91Y2hlcykge1xuXG5cdFx0XHR2YXIgZmlyc3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLFxuXHRcdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0XHRyZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNldXAnLCBmaXJzdCk7XG5cblx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vtb3ZlJywgZmlyc3QpO1xuXHR9LFxuXG5cdF9zaW11bGF0ZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cdFx0ZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrID0gdHJ1ZTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KFxuXHRcdCAgICAgICAgdHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLFxuXHRcdCAgICAgICAgZS5zY3JlZW5YLCBlLnNjcmVlblksXG5cdFx0ICAgICAgICBlLmNsaWVudFgsIGUuY2xpZW50WSxcblx0XHQgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblxuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0YXA6IEhhbmRsZXJcbi8vIE1vYmlsZSB0b3VjaCBoYWNrcyAocXVpY2sgdGFwIGFuZCB0b3VjaCBob2xkKSBoYW5kbGVyLlxuaWYgKHRvdWNoICYmICFwb2ludGVyKSB7XG5cdE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXAnLCBUYXApO1xufVxuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdG91Y2gtZHJhZ2dpbmcgd2l0aCB0d28gZmluZ2Vycy4gSWZcblx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Zcblx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcblx0Ly8gYnJvd3NlcnMgZXhjZXB0IGZvciBvbGQgQW5kcm9pZHMuXG5cdHRvdWNoWm9vbTogdG91Y2ggJiYgIWFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcblx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG5cdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxudmFyIFRvdWNoWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRhZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cblx0XHRvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG5cdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0dmFyIG1vdmVGbiA9IGJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwge3BpbmNoOiB0cnVlLCByb3VuZDogZmFsc2V9KTtcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0b2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG5cblx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG5cdFx0XHR0aGlzLl9tYXAuX2FuaW1hdGVab29tKHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSksIHRydWUsIHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fbWFwLl9yZXNldFZpZXcodGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbi8vIFRvdWNoIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0b3VjaFpvb20nLCBUb3VjaFpvb20pO1xuXG5NYXAuQm94Wm9vbSA9IEJveFpvb207XG5NYXAuRG91YmxlQ2xpY2tab29tID0gRG91YmxlQ2xpY2tab29tO1xuTWFwLkRyYWcgPSBEcmFnO1xuTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG5NYXAuU2Nyb2xsV2hlZWxab29tID0gU2Nyb2xsV2hlZWxab29tO1xuTWFwLlRhcCA9IFRhcDtcbk1hcC5Ub3VjaFpvb20gPSBUb3VjaFpvb207XG5cbi8vIG1pc2NcclxuXHJcbnZhciBvbGRMID0gd2luZG93Lkw7XHJcbmZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XHJcblx0d2luZG93LkwgPSBvbGRMO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBBbHdheXMgZXhwb3J0IHVzIHRvIHdpbmRvdyBnbG9iYWwgKHNlZSAjMjM2NClcclxud2luZG93LkwgPSBleHBvcnRzO1xyXG5cclxuT2JqZWN0LmZyZWV6ZSA9IGZyZWV6ZTtcblxuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG5leHBvcnRzLkNvbnRyb2wgPSBDb250cm9sO1xuZXhwb3J0cy5jb250cm9sID0gY29udHJvbDtcbmV4cG9ydHMuQnJvd3NlciA9IEJyb3dzZXI7XG5leHBvcnRzLkV2ZW50ZWQgPSBFdmVudGVkO1xuZXhwb3J0cy5NaXhpbiA9IE1peGluO1xuZXhwb3J0cy5VdGlsID0gVXRpbDtcbmV4cG9ydHMuQ2xhc3MgPSBDbGFzcztcbmV4cG9ydHMuSGFuZGxlciA9IEhhbmRsZXI7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuYmluZCA9IGJpbmQ7XG5leHBvcnRzLnN0YW1wID0gc3RhbXA7XG5leHBvcnRzLnNldE9wdGlvbnMgPSBzZXRPcHRpb25zO1xuZXhwb3J0cy5Eb21FdmVudCA9IERvbUV2ZW50O1xuZXhwb3J0cy5Eb21VdGlsID0gRG9tVXRpbDtcbmV4cG9ydHMuUG9zQW5pbWF0aW9uID0gUG9zQW5pbWF0aW9uO1xuZXhwb3J0cy5EcmFnZ2FibGUgPSBEcmFnZ2FibGU7XG5leHBvcnRzLkxpbmVVdGlsID0gTGluZVV0aWw7XG5leHBvcnRzLlBvbHlVdGlsID0gUG9seVV0aWw7XG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XG5leHBvcnRzLnBvaW50ID0gdG9Qb2ludDtcbmV4cG9ydHMuQm91bmRzID0gQm91bmRzO1xuZXhwb3J0cy5ib3VuZHMgPSB0b0JvdW5kcztcbmV4cG9ydHMuVHJhbnNmb3JtYXRpb24gPSBUcmFuc2Zvcm1hdGlvbjtcbmV4cG9ydHMudHJhbnNmb3JtYXRpb24gPSB0b1RyYW5zZm9ybWF0aW9uO1xuZXhwb3J0cy5Qcm9qZWN0aW9uID0gaW5kZXg7XG5leHBvcnRzLkxhdExuZyA9IExhdExuZztcbmV4cG9ydHMubGF0TG5nID0gdG9MYXRMbmc7XG5leHBvcnRzLkxhdExuZ0JvdW5kcyA9IExhdExuZ0JvdW5kcztcbmV4cG9ydHMubGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHM7XG5leHBvcnRzLkNSUyA9IENSUztcbmV4cG9ydHMuR2VvSlNPTiA9IEdlb0pTT047XG5leHBvcnRzLmdlb0pTT04gPSBnZW9KU09OO1xuZXhwb3J0cy5nZW9Kc29uID0gZ2VvSnNvbjtcbmV4cG9ydHMuTGF5ZXIgPSBMYXllcjtcbmV4cG9ydHMuTGF5ZXJHcm91cCA9IExheWVyR3JvdXA7XG5leHBvcnRzLmxheWVyR3JvdXAgPSBsYXllckdyb3VwO1xuZXhwb3J0cy5GZWF0dXJlR3JvdXAgPSBGZWF0dXJlR3JvdXA7XG5leHBvcnRzLmZlYXR1cmVHcm91cCA9IGZlYXR1cmVHcm91cDtcbmV4cG9ydHMuSW1hZ2VPdmVybGF5ID0gSW1hZ2VPdmVybGF5O1xuZXhwb3J0cy5pbWFnZU92ZXJsYXkgPSBpbWFnZU92ZXJsYXk7XG5leHBvcnRzLlZpZGVvT3ZlcmxheSA9IFZpZGVvT3ZlcmxheTtcbmV4cG9ydHMudmlkZW9PdmVybGF5ID0gdmlkZW9PdmVybGF5O1xuZXhwb3J0cy5EaXZPdmVybGF5ID0gRGl2T3ZlcmxheTtcbmV4cG9ydHMuUG9wdXAgPSBQb3B1cDtcbmV4cG9ydHMucG9wdXAgPSBwb3B1cDtcbmV4cG9ydHMuVG9vbHRpcCA9IFRvb2x0aXA7XG5leHBvcnRzLnRvb2x0aXAgPSB0b29sdGlwO1xuZXhwb3J0cy5JY29uID0gSWNvbjtcbmV4cG9ydHMuaWNvbiA9IGljb247XG5leHBvcnRzLkRpdkljb24gPSBEaXZJY29uO1xuZXhwb3J0cy5kaXZJY29uID0gZGl2SWNvbjtcbmV4cG9ydHMuTWFya2VyID0gTWFya2VyO1xuZXhwb3J0cy5tYXJrZXIgPSBtYXJrZXI7XG5leHBvcnRzLlRpbGVMYXllciA9IFRpbGVMYXllcjtcbmV4cG9ydHMudGlsZUxheWVyID0gdGlsZUxheWVyO1xuZXhwb3J0cy5HcmlkTGF5ZXIgPSBHcmlkTGF5ZXI7XG5leHBvcnRzLmdyaWRMYXllciA9IGdyaWRMYXllcjtcbmV4cG9ydHMuU1ZHID0gU1ZHO1xuZXhwb3J0cy5zdmcgPSBzdmckMTtcbmV4cG9ydHMuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbmV4cG9ydHMuQ2FudmFzID0gQ2FudmFzO1xuZXhwb3J0cy5jYW52YXMgPSBjYW52YXMkMTtcbmV4cG9ydHMuUGF0aCA9IFBhdGg7XG5leHBvcnRzLkNpcmNsZU1hcmtlciA9IENpcmNsZU1hcmtlcjtcbmV4cG9ydHMuY2lyY2xlTWFya2VyID0gY2lyY2xlTWFya2VyO1xuZXhwb3J0cy5DaXJjbGUgPSBDaXJjbGU7XG5leHBvcnRzLmNpcmNsZSA9IGNpcmNsZTtcbmV4cG9ydHMuUG9seWxpbmUgPSBQb2x5bGluZTtcbmV4cG9ydHMucG9seWxpbmUgPSBwb2x5bGluZTtcbmV4cG9ydHMuUG9seWdvbiA9IFBvbHlnb247XG5leHBvcnRzLnBvbHlnb24gPSBwb2x5Z29uO1xuZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG5leHBvcnRzLnJlY3RhbmdsZSA9IHJlY3RhbmdsZTtcbmV4cG9ydHMuTWFwID0gTWFwO1xuZXhwb3J0cy5tYXAgPSBjcmVhdGVNYXA7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWFmbGV0LXNyYy5qcy5tYXBcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAgKiB2ZWUtdmFsaWRhdGUgdjIuMS43XG4gICogKGMpIDIwMTkgQWJkZWxyYWhtYW4gQXdhZFxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5WZWVWYWxpZGF0ZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBNSUxMSVNFQ09ORFNfSU5fSE9VUiA9IDM2MDAwMDA7XG4gIHZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFID0gNjAwMDA7XG4gIHZhciBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTID0gMjtcblxuICB2YXIgcGF0dGVybnMgPSB7XG4gICAgZGF0ZVRpbWVEZWxpbWV0ZXI6IC9bVCBdLyxcbiAgICBwbGFpblRpbWU6IC86LyxcblxuICAgIC8vIHllYXIgdG9rZW5zXG4gICAgWVk6IC9eKFxcZHsyfSkkLyxcbiAgICBZWVk6IFtcbiAgICAgIC9eKFsrLV1cXGR7Mn0pJC8sIC8vIDAgYWRkaXRpb25hbCBkaWdpdHNcbiAgICAgIC9eKFsrLV1cXGR7M30pJC8sIC8vIDEgYWRkaXRpb25hbCBkaWdpdFxuICAgICAgL14oWystXVxcZHs0fSkkLyAvLyAyIGFkZGl0aW9uYWwgZGlnaXRzXG4gICAgXSxcbiAgICBZWVlZOiAvXihcXGR7NH0pLyxcbiAgICBZWVlZWTogW1xuICAgICAgL14oWystXVxcZHs0fSkvLCAvLyAwIGFkZGl0aW9uYWwgZGlnaXRzXG4gICAgICAvXihbKy1dXFxkezV9KS8sIC8vIDEgYWRkaXRpb25hbCBkaWdpdFxuICAgICAgL14oWystXVxcZHs2fSkvIC8vIDIgYWRkaXRpb25hbCBkaWdpdHNcbiAgICBdLFxuXG4gICAgLy8gZGF0ZSB0b2tlbnNcbiAgICBNTTogL14tKFxcZHsyfSkkLyxcbiAgICBEREQ6IC9eLT8oXFxkezN9KSQvLFxuICAgIE1NREQ6IC9eLT8oXFxkezJ9KS0/KFxcZHsyfSkkLyxcbiAgICBXd3c6IC9eLT9XKFxcZHsyfSkkLyxcbiAgICBXd3dEOiAvXi0/VyhcXGR7Mn0pLT8oXFxkezF9KSQvLFxuXG4gICAgSEg6IC9eKFxcZHsyfShbLixdXFxkKik/KSQvLFxuICAgIEhITU06IC9eKFxcZHsyfSk6PyhcXGR7Mn0oWy4sXVxcZCopPykkLyxcbiAgICBISE1NU1M6IC9eKFxcZHsyfSk6PyhcXGR7Mn0pOj8oXFxkezJ9KFsuLF1cXGQqKT8pJC8sXG5cbiAgICAvLyB0aW1lem9uZSB0b2tlbnNcbiAgICB0aW1lem9uZTogLyhbWistXS4qKSQvLFxuICAgIHRpbWV6b25lWjogL14oWikkLyxcbiAgICB0aW1lem9uZUhIOiAvXihbKy1dKShcXGR7Mn0pJC8sXG4gICAgdGltZXpvbmVISE1NOiAvXihbKy1dKShcXGR7Mn0pOj8oXFxkezJ9KSQvXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIHRvRGF0ZVxuICAgKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAgICogQHN1bW1hcnkgQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gICAqXG4gICAqIElmIHRoZSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBpdHMgY2xvbmUuXG4gICAqXG4gICAqIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cbiAgICpcbiAgICogSWYgYW4gYXJndW1lbnQgaXMgYSBzdHJpbmcsIHRoZSBmdW5jdGlvbiB0cmllcyB0byBwYXJzZSBpdC5cbiAgICogRnVuY3Rpb24gYWNjZXB0cyBjb21wbGV0ZSBJU08gODYwMSBmb3JtYXRzIGFzIHdlbGwgYXMgcGFydGlhbCBpbXBsZW1lbnRhdGlvbnMuXG4gICAqIElTTyA4NjAxOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxXG4gICAqXG4gICAqIElmIHRoZSBhcmd1bWVudCBpcyBudWxsLCBpdCBpcyB0cmVhdGVkIGFzIGFuIGludmFsaWQgZGF0ZS5cbiAgICpcbiAgICogSWYgYWxsIGFib3ZlIGZhaWxzLCB0aGUgZnVuY3Rpb24gcGFzc2VzIHRoZSBnaXZlbiBhcmd1bWVudCB0byBEYXRlIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiAqKk5vdGUqKjogKmFsbCogRGF0ZSBhcmd1bWVudHMgcGFzc2VkIHRvIGFueSAqZGF0ZS1mbnMqIGZ1bmN0aW9uIGlzIHByb2Nlc3NlZCBieSBgdG9EYXRlYC5cbiAgICogQWxsICpkYXRlLWZucyogZnVuY3Rpb25zIHdpbGwgdGhyb3cgYFJhbmdlRXJyb3JgIGlmIGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIGlzIG5vdCAwLCAxLCAyIG9yIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBhcmd1bWVudCAtIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxuICAgKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXRcbiAgICogQHJldHVybnMge0RhdGV9IHRoZSBwYXJzZWQgZGF0ZSBpbiB0aGUgbG9jYWwgdGltZSB6b25lXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBDb252ZXJ0IHN0cmluZyAnMjAxNC0wMi0xMVQxMTozMDozMCcgdG8gZGF0ZTpcbiAgICogdmFyIHJlc3VsdCA9IHRvRGF0ZSgnMjAxNC0wMi0xMVQxMTozMDozMCcpXG4gICAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENvbnZlcnQgc3RyaW5nICcrMDIwMTQxMDEnIHRvIGRhdGUsXG4gICAqIC8vIGlmIHRoZSBhZGRpdGlvbmFsIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGV4dGVuZGVkIHllYXIgZm9ybWF0IGlzIDE6XG4gICAqIHZhciByZXN1bHQgPSB0b0RhdGUoJyswMjAxNDEwMScsIHthZGRpdGlvbmFsRGlnaXRzOiAxfSlcbiAgICogLy89PiBGcmkgQXByIDExIDIwMTQgMDA6MDA6MDBcbiAgICovXG4gIGZ1bmN0aW9uIHRvRGF0ZSAoYXJndW1lbnQsIGRpcnR5T3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICAgIH1cblxuICAgIGlmIChhcmd1bWVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBhZGRpdGlvbmFsRGlnaXRzID0gb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzID09PSB1bmRlZmluZWQgPyBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTIDogTnVtYmVyKG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0cyk7XG4gICAgaWYgKGFkZGl0aW9uYWxEaWdpdHMgIT09IDIgJiYgYWRkaXRpb25hbERpZ2l0cyAhPT0gMSAmJiBhZGRpdGlvbmFsRGlnaXRzICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYWRkaXRpb25hbERpZ2l0cyBtdXN0IGJlIDAsIDEgb3IgMicpXG4gICAgfVxuXG4gICAgLy8gQ2xvbmUgdGhlIGRhdGVcbiAgICBpZiAoYXJndW1lbnQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAvLyBQcmV2ZW50IHRoZSBkYXRlIHRvIGxvc2UgdGhlIG1pbGxpc2Vjb25kcyB3aGVuIHBhc3NlZCB0byBuZXcgRGF0ZSgpIGluIElFMTBcbiAgICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudC5nZXRUaW1lKCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQpXG4gICAgfVxuXG4gICAgdmFyIGRhdGVTdHJpbmdzID0gc3BsaXREYXRlU3RyaW5nKGFyZ3VtZW50KTtcblxuICAgIHZhciBwYXJzZVllYXJSZXN1bHQgPSBwYXJzZVllYXIoZGF0ZVN0cmluZ3MuZGF0ZSwgYWRkaXRpb25hbERpZ2l0cyk7XG4gICAgdmFyIHllYXIgPSBwYXJzZVllYXJSZXN1bHQueWVhcjtcbiAgICB2YXIgcmVzdERhdGVTdHJpbmcgPSBwYXJzZVllYXJSZXN1bHQucmVzdERhdGVTdHJpbmc7XG5cbiAgICB2YXIgZGF0ZSA9IHBhcnNlRGF0ZShyZXN0RGF0ZVN0cmluZywgeWVhcik7XG5cbiAgICBpZiAoZGF0ZSkge1xuICAgICAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgdmFyIHRpbWUgPSAwO1xuICAgICAgdmFyIG9mZnNldDtcblxuICAgICAgaWYgKGRhdGVTdHJpbmdzLnRpbWUpIHtcbiAgICAgICAgdGltZSA9IHBhcnNlVGltZShkYXRlU3RyaW5ncy50aW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGVTdHJpbmdzLnRpbWV6b25lKSB7XG4gICAgICAgIG9mZnNldCA9IHBhcnNlVGltZXpvbmUoZGF0ZVN0cmluZ3MudGltZXpvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2V0IG9mZnNldCBhY2N1cmF0ZSB0byBob3VyIGluIHRpbWV6b25lcyB0aGF0IGNoYW5nZSBvZmZzZXRcbiAgICAgICAgb2Zmc2V0ID0gbmV3IERhdGUodGltZXN0YW1wICsgdGltZSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgb2Zmc2V0ID0gbmV3IERhdGUodGltZXN0YW1wICsgdGltZSArIG9mZnNldCAqIE1JTExJU0VDT05EU19JTl9NSU5VVEUpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lICsgb2Zmc2V0ICogTUlMTElTRUNPTkRTX0lOX01JTlVURSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0RGF0ZVN0cmluZyAoZGF0ZVN0cmluZykge1xuICAgIHZhciBkYXRlU3RyaW5ncyA9IHt9O1xuICAgIHZhciBhcnJheSA9IGRhdGVTdHJpbmcuc3BsaXQocGF0dGVybnMuZGF0ZVRpbWVEZWxpbWV0ZXIpO1xuICAgIHZhciB0aW1lU3RyaW5nO1xuXG4gICAgaWYgKHBhdHRlcm5zLnBsYWluVGltZS50ZXN0KGFycmF5WzBdKSkge1xuICAgICAgZGF0ZVN0cmluZ3MuZGF0ZSA9IG51bGw7XG4gICAgICB0aW1lU3RyaW5nID0gYXJyYXlbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBhcnJheVswXTtcbiAgICAgIHRpbWVTdHJpbmcgPSBhcnJheVsxXTtcbiAgICB9XG5cbiAgICBpZiAodGltZVN0cmluZykge1xuICAgICAgdmFyIHRva2VuID0gcGF0dGVybnMudGltZXpvbmUuZXhlYyh0aW1lU3RyaW5nKTtcbiAgICAgIGlmICh0b2tlbikge1xuICAgICAgICBkYXRlU3RyaW5ncy50aW1lID0gdGltZVN0cmluZy5yZXBsYWNlKHRva2VuWzFdLCAnJyk7XG4gICAgICAgIGRhdGVTdHJpbmdzLnRpbWV6b25lID0gdG9rZW5bMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlU3RyaW5ncy50aW1lID0gdGltZVN0cmluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZVN0cmluZ3NcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlWWVhciAoZGF0ZVN0cmluZywgYWRkaXRpb25hbERpZ2l0cykge1xuICAgIHZhciBwYXR0ZXJuWVlZID0gcGF0dGVybnMuWVlZW2FkZGl0aW9uYWxEaWdpdHNdO1xuICAgIHZhciBwYXR0ZXJuWVlZWVkgPSBwYXR0ZXJucy5ZWVlZWVthZGRpdGlvbmFsRGlnaXRzXTtcblxuICAgIHZhciB0b2tlbjtcblxuICAgIC8vIFlZWVkgb3IgwrFZWVlZWVxuICAgIHRva2VuID0gcGF0dGVybnMuWVlZWS5leGVjKGRhdGVTdHJpbmcpIHx8IHBhdHRlcm5ZWVlZWS5leGVjKGRhdGVTdHJpbmcpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgdmFyIHllYXJTdHJpbmcgPSB0b2tlblsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHllYXI6IHBhcnNlSW50KHllYXJTdHJpbmcsIDEwKSxcbiAgICAgICAgcmVzdERhdGVTdHJpbmc6IGRhdGVTdHJpbmcuc2xpY2UoeWVhclN0cmluZy5sZW5ndGgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gWVkgb3IgwrFZWVlcbiAgICB0b2tlbiA9IHBhdHRlcm5zLllZLmV4ZWMoZGF0ZVN0cmluZykgfHwgcGF0dGVybllZWS5leGVjKGRhdGVTdHJpbmcpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgdmFyIGNlbnR1cnlTdHJpbmcgPSB0b2tlblsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHllYXI6IHBhcnNlSW50KGNlbnR1cnlTdHJpbmcsIDEwKSAqIDEwMCxcbiAgICAgICAgcmVzdERhdGVTdHJpbmc6IGRhdGVTdHJpbmcuc2xpY2UoY2VudHVyeVN0cmluZy5sZW5ndGgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHllYXJcbiAgICByZXR1cm4ge1xuICAgICAgeWVhcjogbnVsbFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF0ZSAoZGF0ZVN0cmluZywgeWVhcikge1xuICAgIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXG4gICAgaWYgKHllYXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdmFyIHRva2VuO1xuICAgIHZhciBkYXRlO1xuICAgIHZhciBtb250aDtcbiAgICB2YXIgd2VlaztcblxuICAgIC8vIFlZWVlcbiAgICBpZiAoZGF0ZVN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhcik7XG4gICAgICByZXR1cm4gZGF0ZVxuICAgIH1cblxuICAgIC8vIFlZWVktTU1cbiAgICB0b2tlbiA9IHBhdHRlcm5zLk1NLmV4ZWMoZGF0ZVN0cmluZyk7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBkYXRlID0gbmV3IERhdGUoMCk7XG4gICAgICBtb250aCA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCkgLSAxO1xuICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCBtb250aCk7XG4gICAgICByZXR1cm4gZGF0ZVxuICAgIH1cblxuICAgIC8vIFlZWVktREREIG9yIFlZWVlERERcbiAgICB0b2tlbiA9IHBhdHRlcm5zLkRERC5leGVjKGRhdGVTdHJpbmcpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgZGF0ZSA9IG5ldyBEYXRlKDApO1xuICAgICAgdmFyIGRheU9mWWVhciA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCk7XG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIGRheU9mWWVhcik7XG4gICAgICByZXR1cm4gZGF0ZVxuICAgIH1cblxuICAgIC8vIFlZWVktTU0tREQgb3IgWVlZWU1NRERcbiAgICB0b2tlbiA9IHBhdHRlcm5zLk1NREQuZXhlYyhkYXRlU3RyaW5nKTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgICAgIG1vbnRoID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDE7XG4gICAgICB2YXIgZGF5ID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKTtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGgsIGRheSk7XG4gICAgICByZXR1cm4gZGF0ZVxuICAgIH1cblxuICAgIC8vIFlZWVktV3d3IG9yIFlZWVlXd3dcbiAgICB0b2tlbiA9IHBhdHRlcm5zLld3dy5leGVjKGRhdGVTdHJpbmcpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgd2VlayA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCkgLSAxO1xuICAgICAgcmV0dXJuIGRheU9mSVNPWWVhcih5ZWFyLCB3ZWVrKVxuICAgIH1cblxuICAgIC8vIFlZWVktV3d3LUQgb3IgWVlZWVd3d0RcbiAgICB0b2tlbiA9IHBhdHRlcm5zLld3d0QuZXhlYyhkYXRlU3RyaW5nKTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIHdlZWsgPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMTtcbiAgICAgIHZhciBkYXlPZldlZWsgPSBwYXJzZUludCh0b2tlblsyXSwgMTApIC0gMTtcbiAgICAgIHJldHVybiBkYXlPZklTT1llYXIoeWVhciwgd2VlaywgZGF5T2ZXZWVrKVxuICAgIH1cblxuICAgIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCBkYXRlXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVGltZSAodGltZVN0cmluZykge1xuICAgIHZhciB0b2tlbjtcbiAgICB2YXIgaG91cnM7XG4gICAgdmFyIG1pbnV0ZXM7XG5cbiAgICAvLyBoaFxuICAgIHRva2VuID0gcGF0dGVybnMuSEguZXhlYyh0aW1lU3RyaW5nKTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGhvdXJzID0gcGFyc2VGbG9hdCh0b2tlblsxXS5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICByZXR1cm4gKGhvdXJzICUgMjQpICogTUlMTElTRUNPTkRTX0lOX0hPVVJcbiAgICB9XG5cbiAgICAvLyBoaDptbSBvciBoaG1tXG4gICAgdG9rZW4gPSBwYXR0ZXJucy5ISE1NLmV4ZWModGltZVN0cmluZyk7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCk7XG4gICAgICBtaW51dGVzID0gcGFyc2VGbG9hdCh0b2tlblsyXS5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICByZXR1cm4gKGhvdXJzICUgMjQpICogTUlMTElTRUNPTkRTX0lOX0hPVVIgK1xuICAgICAgICBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURVxuICAgIH1cblxuICAgIC8vIGhoOm1tOnNzIG9yIGhobW1zc1xuICAgIHRva2VuID0gcGF0dGVybnMuSEhNTVNTLmV4ZWModGltZVN0cmluZyk7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCk7XG4gICAgICBtaW51dGVzID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKTtcbiAgICAgIHZhciBzZWNvbmRzID0gcGFyc2VGbG9hdCh0b2tlblszXS5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICByZXR1cm4gKGhvdXJzICUgMjQpICogTUlMTElTRUNPTkRTX0lOX0hPVVIgK1xuICAgICAgICBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSArXG4gICAgICAgIHNlY29uZHMgKiAxMDAwXG4gICAgfVxuXG4gICAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHRpbWVcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUaW1lem9uZSAodGltZXpvbmVTdHJpbmcpIHtcbiAgICB2YXIgdG9rZW47XG4gICAgdmFyIGFic29sdXRlT2Zmc2V0O1xuXG4gICAgLy8gWlxuICAgIHRva2VuID0gcGF0dGVybnMudGltZXpvbmVaLmV4ZWModGltZXpvbmVTdHJpbmcpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICAvLyDCsWhoXG4gICAgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZUhILmV4ZWModGltZXpvbmVTdHJpbmcpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgYWJzb2x1dGVPZmZzZXQgPSBwYXJzZUludCh0b2tlblsyXSwgMTApICogNjA7XG4gICAgICByZXR1cm4gKHRva2VuWzFdID09PSAnKycpID8gLWFic29sdXRlT2Zmc2V0IDogYWJzb2x1dGVPZmZzZXRcbiAgICB9XG5cbiAgICAvLyDCsWhoOm1tIG9yIMKxaGhtbVxuICAgIHRva2VuID0gcGF0dGVybnMudGltZXpvbmVISE1NLmV4ZWModGltZXpvbmVTdHJpbmcpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgYWJzb2x1dGVPZmZzZXQgPSBwYXJzZUludCh0b2tlblsyXSwgMTApICogNjAgKyBwYXJzZUludCh0b2tlblszXSwgMTApO1xuICAgICAgcmV0dXJuICh0b2tlblsxXSA9PT0gJysnKSA/IC1hYnNvbHV0ZU9mZnNldCA6IGFic29sdXRlT2Zmc2V0XG4gICAgfVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGRheU9mSVNPWWVhciAoaXNvWWVhciwgd2VlaywgZGF5KSB7XG4gICAgd2VlayA9IHdlZWsgfHwgMDtcbiAgICBkYXkgPSBkYXkgfHwgMDtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKDApO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoaXNvWWVhciwgMCwgNCk7XG4gICAgdmFyIGZvdXJ0aE9mSmFudWFyeURheSA9IGRhdGUuZ2V0VVRDRGF5KCkgfHwgNztcbiAgICB2YXIgZGlmZiA9IHdlZWsgKiA3ICsgZGF5ICsgMSAtIGZvdXJ0aE9mSmFudWFyeURheTtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaWZmKTtcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIGFkZE1pbGxpc2Vjb25kc1xuICAgKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xuICAgKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAgICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICAgKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIG1pbGxpc2Vjb25kcyBhZGRlZFxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEFkZCA3NTAgbWlsbGlzZWNvbmRzIHRvIDEwIEp1bHkgMjAxNCAxMjo0NTozMC4wMDA6XG4gICAqIHZhciByZXN1bHQgPSBhZGRNaWxsaXNlY29uZHMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCA0NSwgMzAsIDApLCA3NTApXG4gICAqIC8vPT4gVGh1IEp1bCAxMCAyMDE0IDEyOjQ1OjMwLjc1MFxuICAgKi9cbiAgZnVuY3Rpb24gYWRkTWlsbGlzZWNvbmRzIChkaXJ0eURhdGUsIGRpcnR5QW1vdW50LCBkaXJ0eU9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXG4gICAgfVxuXG4gICAgdmFyIHRpbWVzdGFtcCA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykuZ2V0VGltZSgpO1xuICAgIHZhciBhbW91bnQgPSBOdW1iZXIoZGlydHlBbW91bnQpO1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKyBhbW91bnQpXG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZU9iamVjdCAoZGlydHlPYmplY3QpIHtcbiAgICBkaXJ0eU9iamVjdCA9IGRpcnR5T2JqZWN0IHx8IHt9O1xuICAgIHZhciBvYmplY3QgPSB7fTtcblxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIGRpcnR5T2JqZWN0KSB7XG4gICAgICBpZiAoZGlydHlPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSBkaXJ0eU9iamVjdFtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdFxuICB9XG5cbiAgdmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUkMiA9IDYwMDAwO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBhZGRNaW51dGVzXG4gICAqIEBjYXRlZ29yeSBNaW51dGUgSGVscGVyc1xuICAgKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWludXRlcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaW51dGVzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWludXRlcyB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAgICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICAgKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIG1pbnV0ZXMgYWRkZWRcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBBZGQgMzAgbWludXRlcyB0byAxMCBKdWx5IDIwMTQgMTI6MDA6MDA6XG4gICAqIHZhciByZXN1bHQgPSBhZGRNaW51dGVzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgMCksIDMwKVxuICAgKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjozMDowMFxuICAgKi9cbiAgZnVuY3Rpb24gYWRkTWludXRlcyAoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCwgZGlydHlPcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICAgIH1cblxuICAgIHZhciBhbW91bnQgPSBOdW1iZXIoZGlydHlBbW91bnQpO1xuICAgIHJldHVybiBhZGRNaWxsaXNlY29uZHMoZGlydHlEYXRlLCBhbW91bnQgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDIsIGRpcnR5T3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBpc1ZhbGlkXG4gICAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICAgKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSB2YWxpZD9cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybnMgZmFsc2UgaWYgYXJndW1lbnQgaXMgSW52YWxpZCBEYXRlIGFuZCB0cnVlIG90aGVyd2lzZS5cbiAgICogQXJndW1lbnQgaXMgY29udmVydGVkIHRvIERhdGUgdXNpbmcgYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAgICogSW52YWxpZCBEYXRlIGlzIGEgRGF0ZSwgd2hvc2UgdGltZSB2YWx1ZSBpcyBOYU4uXG4gICAqXG4gICAqIFRpbWUgdmFsdWUgb2YgRGF0ZTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS45LjEuMVxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGUgLSB0aGUgZGF0ZSB0byBjaGVja1xuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAgICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGRhdGUgaXMgdmFsaWRcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEZvciB0aGUgdmFsaWQgZGF0ZTpcbiAgICogdmFyIHJlc3VsdCA9IGlzVmFsaWQobmV3IERhdGUoMjAxNCwgMSwgMzEpKVxuICAgKiAvLz0+IHRydWVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gRm9yIHRoZSB2YWx1ZSwgY29udmVydGFibGUgaW50byBhIGRhdGU6XG4gICAqIHZhciByZXN1bHQgPSBpc1ZhbGlkKCcyMDE0LTAyLTMxJylcbiAgICogLy89PiB0cnVlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEZvciB0aGUgaW52YWxpZCBkYXRlOlxuICAgKiB2YXIgcmVzdWx0ID0gaXNWYWxpZChuZXcgRGF0ZSgnJykpXG4gICAqIC8vPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzVmFsaWQgKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXG4gICAgfVxuXG4gICAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICAgIHJldHVybiAhaXNOYU4oZGF0ZSlcbiAgfVxuXG4gIHZhciBmb3JtYXREaXN0YW5jZUxvY2FsZSA9IHtcbiAgICBsZXNzVGhhblhTZWNvbmRzOiB7XG4gICAgICBvbmU6ICdsZXNzIHRoYW4gYSBzZWNvbmQnLFxuICAgICAgb3RoZXI6ICdsZXNzIHRoYW4ge3tjb3VudH19IHNlY29uZHMnXG4gICAgfSxcblxuICAgIHhTZWNvbmRzOiB7XG4gICAgICBvbmU6ICcxIHNlY29uZCcsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBzZWNvbmRzJ1xuICAgIH0sXG5cbiAgICBoYWxmQU1pbnV0ZTogJ2hhbGYgYSBtaW51dGUnLFxuXG4gICAgbGVzc1RoYW5YTWludXRlczoge1xuICAgICAgb25lOiAnbGVzcyB0aGFuIGEgbWludXRlJyxcbiAgICAgIG90aGVyOiAnbGVzcyB0aGFuIHt7Y291bnR9fSBtaW51dGVzJ1xuICAgIH0sXG5cbiAgICB4TWludXRlczoge1xuICAgICAgb25lOiAnMSBtaW51dGUnLFxuICAgICAgb3RoZXI6ICd7e2NvdW50fX0gbWludXRlcydcbiAgICB9LFxuXG4gICAgYWJvdXRYSG91cnM6IHtcbiAgICAgIG9uZTogJ2Fib3V0IDEgaG91cicsXG4gICAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBob3VycydcbiAgICB9LFxuXG4gICAgeEhvdXJzOiB7XG4gICAgICBvbmU6ICcxIGhvdXInLFxuICAgICAgb3RoZXI6ICd7e2NvdW50fX0gaG91cnMnXG4gICAgfSxcblxuICAgIHhEYXlzOiB7XG4gICAgICBvbmU6ICcxIGRheScsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBkYXlzJ1xuICAgIH0sXG5cbiAgICBhYm91dFhNb250aHM6IHtcbiAgICAgIG9uZTogJ2Fib3V0IDEgbW9udGgnLFxuICAgICAgb3RoZXI6ICdhYm91dCB7e2NvdW50fX0gbW9udGhzJ1xuICAgIH0sXG5cbiAgICB4TW9udGhzOiB7XG4gICAgICBvbmU6ICcxIG1vbnRoJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IG1vbnRocydcbiAgICB9LFxuXG4gICAgYWJvdXRYWWVhcnM6IHtcbiAgICAgIG9uZTogJ2Fib3V0IDEgeWVhcicsXG4gICAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSB5ZWFycydcbiAgICB9LFxuXG4gICAgeFllYXJzOiB7XG4gICAgICBvbmU6ICcxIHllYXInLFxuICAgICAgb3RoZXI6ICd7e2NvdW50fX0geWVhcnMnXG4gICAgfSxcblxuICAgIG92ZXJYWWVhcnM6IHtcbiAgICAgIG9uZTogJ292ZXIgMSB5ZWFyJyxcbiAgICAgIG90aGVyOiAnb3ZlciB7e2NvdW50fX0geWVhcnMnXG4gICAgfSxcblxuICAgIGFsbW9zdFhZZWFyczoge1xuICAgICAgb25lOiAnYWxtb3N0IDEgeWVhcicsXG4gICAgICBvdGhlcjogJ2FsbW9zdCB7e2NvdW50fX0geWVhcnMnXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdERpc3RhbmNlICh0b2tlbiwgY291bnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl0gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXN1bHQgPSBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl07XG4gICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dLm9uZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dLm90aGVyLnJlcGxhY2UoJ3t7Y291bnR9fScsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hZGRTdWZmaXgpIHtcbiAgICAgIGlmIChvcHRpb25zLmNvbXBhcmlzb24gPiAwKSB7XG4gICAgICAgIHJldHVybiAnaW4gJyArIHJlc3VsdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArICcgYWdvJ1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHZhciB0b2tlbnNUb0JlU2hvcnRlZFBhdHRlcm4gPSAvTU1NTXxNTXxERHxkZGRkL2c7XG5cbiAgZnVuY3Rpb24gYnVpbGRTaG9ydExvbmdGb3JtYXQgKGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSh0b2tlbnNUb0JlU2hvcnRlZFBhdHRlcm4sIGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgcmV0dXJuIHRva2VuLnNsaWNlKDEpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBidWlsZEZvcm1hdExvbmdGblxuICAgKiBAY2F0ZWdvcnkgTG9jYWxlIEhlbHBlcnNcbiAgICogQHN1bW1hcnkgQnVpbGQgYGZvcm1hdExvbmdgIHByb3BlcnR5IGZvciBsb2NhbGUgdXNlZCBieSBgZm9ybWF0YCwgYGZvcm1hdFJlbGF0aXZlYCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBCdWlsZCBgZm9ybWF0TG9uZ2AgcHJvcGVydHkgZm9yIGxvY2FsZSB1c2VkIGJ5IGBmb3JtYXRgLCBgZm9ybWF0UmVsYXRpdmVgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucy5cbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIG9uZSBvZiB0aGUgZm9sbG93aW5nIHRva2VucyBhcyB0aGUgYXJndW1lbnQ6XG4gICAqIGAnTFRTJ2AsIGAnTFQnYCwgYCdMJ2AsIGAnTEwnYCwgYCdMTEwnYCwgYCdsJ2AsIGAnbGwnYCwgYCdsbGwnYCwgYCdsbGxsJ2BcbiAgICogYW5kIHJldHVybnMgYSBsb25nIGZvcm1hdCBzdHJpbmcgd3JpdHRlbiBhcyBgZm9ybWF0YCB0b2tlbiBzdHJpbmdzLlxuICAgKiBTZWUgW2Zvcm1hdF17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9mb3JtYXR9XG4gICAqXG4gICAqIGAnbCdgLCBgJ2xsJ2AsIGAnbGxsJ2AgYW5kIGAnbGxsbCdgIGZvcm1hdHMgYXJlIGJ1aWx0IGF1dG9tYXRpY2FsbHlcbiAgICogYnkgc2hvcnRlbmluZyBzb21lIG9mIHRoZSB0b2tlbnMgZnJvbSBjb3JyZXNwb25kaW5nIHVuc2hvcnRlbmVkIGZvcm1hdHNcbiAgICogKGUuZy4sIGlmIGBMTGAgaXMgYCdNTU1NIEREIFlZWVknYCB0aGVuIGBsbGAgd2lsbCBiZSBgTU1NIEQgWVlZWWApXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHdpdGggbG9uZyBmb3JtYXRzIHdyaXR0ZW4gYXMgYGZvcm1hdGAgdG9rZW4gc3RyaW5nc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqLkxUIC0gdGltZSBmb3JtYXQ6IGhvdXJzIGFuZCBtaW51dGVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvYmouTFRTIC0gdGltZSBmb3JtYXQ6IGhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvYmouTCAtIHNob3J0IGRhdGUgZm9ybWF0OiBudW1lcmljIGRheSwgbW9udGggYW5kIHllYXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvYmoubF0gLSBzaG9ydCBkYXRlIGZvcm1hdDogbnVtZXJpYyBkYXksIG1vbnRoIGFuZCB5ZWFyIChzaG9ydGVuZWQpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvYmouTEwgLSBsb25nIGRhdGUgZm9ybWF0OiBkYXksIG1vbnRoIGluIHdvcmRzLCBhbmQgeWVhclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29iai5sbF0gLSBsb25nIGRhdGUgZm9ybWF0OiBkYXksIG1vbnRoIGluIHdvcmRzLCBhbmQgeWVhciAoc2hvcnRlbmVkKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqLkxMTCAtIGxvbmcgZGF0ZSBhbmQgdGltZSBmb3JtYXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvYmoubGxsXSAtIGxvbmcgZGF0ZSBhbmQgdGltZSBmb3JtYXQgKHNob3J0ZW5lZClcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9iai5MTExMIC0gbG9uZyBkYXRlLCB0aW1lIGFuZCB3ZWVrZGF5IGZvcm1hdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29iai5sbGxsXSAtIGxvbmcgZGF0ZSwgdGltZSBhbmQgd2Vla2RheSBmb3JtYXQgKHNob3J0ZW5lZClcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBgZm9ybWF0TG9uZ2AgcHJvcGVydHkgb2YgdGhlIGxvY2FsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBGb3IgYGVuLVVTYCBsb2NhbGU6XG4gICAqIGxvY2FsZS5mb3JtYXRMb25nID0gYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgKiAgIExUOiAnaDptbSBhYScsXG4gICAqICAgTFRTOiAnaDptbTpzcyBhYScsXG4gICAqICAgTDogJ01NL0REL1lZWVknLFxuICAgKiAgIExMOiAnTU1NTSBEIFlZWVknLFxuICAgKiAgIExMTDogJ01NTU0gRCBZWVlZIGg6bW0gYWEnLFxuICAgKiAgIExMTEw6ICdkZGRkLCBNTU1NIEQgWVlZWSBoOm1tIGFhJ1xuICAgKiB9KVxuICAgKi9cbiAgZnVuY3Rpb24gYnVpbGRGb3JtYXRMb25nRm4gKG9iaikge1xuICAgIHZhciBmb3JtYXRMb25nTG9jYWxlID0ge1xuICAgICAgTFRTOiBvYmouTFRTLFxuICAgICAgTFQ6IG9iai5MVCxcbiAgICAgIEw6IG9iai5MLFxuICAgICAgTEw6IG9iai5MTCxcbiAgICAgIExMTDogb2JqLkxMTCxcbiAgICAgIExMTEw6IG9iai5MTExMLFxuICAgICAgbDogb2JqLmwgfHwgYnVpbGRTaG9ydExvbmdGb3JtYXQob2JqLkwpLFxuICAgICAgbGw6IG9iai5sbCB8fCBidWlsZFNob3J0TG9uZ0Zvcm1hdChvYmouTEwpLFxuICAgICAgbGxsOiBvYmoubGxsIHx8IGJ1aWxkU2hvcnRMb25nRm9ybWF0KG9iai5MTEwpLFxuICAgICAgbGxsbDogb2JqLmxsbGwgfHwgYnVpbGRTaG9ydExvbmdGb3JtYXQob2JqLkxMTEwpXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgIHJldHVybiBmb3JtYXRMb25nTG9jYWxlW3Rva2VuXVxuICAgIH1cbiAgfVxuXG4gIHZhciBmb3JtYXRMb25nID0gYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIExUOiAnaDptbSBhYScsXG4gICAgTFRTOiAnaDptbTpzcyBhYScsXG4gICAgTDogJ01NL0REL1lZWVknLFxuICAgIExMOiAnTU1NTSBEIFlZWVknLFxuICAgIExMTDogJ01NTU0gRCBZWVlZIGg6bW0gYWEnLFxuICAgIExMTEw6ICdkZGRkLCBNTU1NIEQgWVlZWSBoOm1tIGFhJ1xuICB9KTtcblxuICB2YXIgZm9ybWF0UmVsYXRpdmVMb2NhbGUgPSB7XG4gICAgbGFzdFdlZWs6ICdbbGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICB5ZXN0ZXJkYXk6ICdbeWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgdG9kYXk6ICdbdG9kYXkgYXRdIExUJyxcbiAgICB0b21vcnJvdzogJ1t0b21vcnJvdyBhdF0gTFQnLFxuICAgIG5leHRXZWVrOiAnZGRkZCBbYXRdIExUJyxcbiAgICBvdGhlcjogJ0wnXG4gIH07XG5cbiAgZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmUgKHRva2VuLCBkYXRlLCBiYXNlRGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBmb3JtYXRSZWxhdGl2ZUxvY2FsZVt0b2tlbl1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBidWlsZExvY2FsaXplRm5cbiAgICogQGNhdGVnb3J5IExvY2FsZSBIZWxwZXJzXG4gICAqIEBzdW1tYXJ5IEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5YCwgYGxvY2FsaXplLm1vbnRoYCBhbmQgYGxvY2FsaXplLnRpbWVPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5YCwgYGxvY2FsaXplLm1vbnRoYCBhbmQgYGxvY2FsaXplLnRpbWVPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZVxuICAgKiB1c2VkIGJ5IGBmb3JtYXRgIGZ1bmN0aW9uLlxuICAgKiBJZiBubyBgdHlwZWAgaXMgc3VwcGxpZWQgdG8gdGhlIG9wdGlvbnMgb2YgdGhlIHJlc3VsdGluZyBmdW5jdGlvbiwgYGRlZmF1bHRUeXBlYCB3aWxsIGJlIHVzZWQgKHNlZSBleGFtcGxlKS5cbiAgICpcbiAgICogYGxvY2FsaXplLndlZWtkYXlgIGZ1bmN0aW9uIHRha2VzIHRoZSB3ZWVrZGF5IGluZGV4IGFzIGFyZ3VtZW50ICgwIC0gU3VuZGF5KS5cbiAgICogYGxvY2FsaXplLm1vbnRoYCB0YWtlcyB0aGUgbW9udGggaW5kZXggKDAgLSBKYW51YXJ5KS5cbiAgICogYGxvY2FsaXplLnRpbWVPZkRheWAgdGFrZXMgdGhlIGhvdXJzLiBVc2UgYGluZGV4Q2FsbGJhY2tgIHRvIGNvbnZlcnQgdGhlbSB0byBhbiBhcnJheSBpbmRleCAoc2VlIGV4YW1wbGUpLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gdGhlIG9iamVjdCB3aXRoIGFycmF5cyBvZiB2YWx1ZXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRUeXBlIC0gdGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhlIGxvY2FsaXplIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbmRleENhbGxiYWNrXSAtIHRoZSBjYWxsYmFjayB3aGljaCB0YWtlcyB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uIGFyZ3VtZW50XG4gICAqICAgYW5kIGNvbnZlcnRzIGl0IGludG8gdmFsdWUgYXJyYXkgaW5kZXhcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0aW1lT2ZEYXlWYWx1ZXMgPSB7XG4gICAqICAgdXBwZXJjYXNlOiBbJ0FNJywgJ1BNJ10sXG4gICAqICAgbG93ZXJjYXNlOiBbJ2FtJywgJ3BtJ10sXG4gICAqICAgbG9uZzogWydhLm0uJywgJ3AubS4nXVxuICAgKiB9XG4gICAqIGxvY2FsZS5sb2NhbGl6ZS50aW1lT2ZEYXkgPSBidWlsZExvY2FsaXplRm4odGltZU9mRGF5VmFsdWVzLCAnbG9uZycsIGZ1bmN0aW9uIChob3Vycykge1xuICAgKiAgIC8vIDAgaXMgYS5tLiBhcnJheSBpbmRleCwgMSBpcyBwLm0uIGFycmF5IGluZGV4XG4gICAqICAgcmV0dXJuIChob3VycyAvIDEyKSA+PSAxID8gMSA6IDBcbiAgICogfSlcbiAgICogbG9jYWxlLmxvY2FsaXplLnRpbWVPZkRheSgxNiwge3R5cGU6ICd1cHBlcmNhc2UnfSkgLy89PiAnUE0nXG4gICAqIGxvY2FsZS5sb2NhbGl6ZS50aW1lT2ZEYXkoNSkgLy89PiAnYS5tLidcbiAgICovXG4gIGZ1bmN0aW9uIGJ1aWxkTG9jYWxpemVGbiAodmFsdWVzLCBkZWZhdWx0VHlwZSwgaW5kZXhDYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGlydHlJbmRleCwgZGlydHlPcHRpb25zKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlID8gU3RyaW5nKG9wdGlvbnMudHlwZSkgOiBkZWZhdWx0VHlwZTtcbiAgICAgIHZhciB2YWx1ZXNBcnJheSA9IHZhbHVlc1t0eXBlXSB8fCB2YWx1ZXNbZGVmYXVsdFR5cGVdO1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhDYWxsYmFjayA/IGluZGV4Q2FsbGJhY2soTnVtYmVyKGRpcnR5SW5kZXgpKSA6IE51bWJlcihkaXJ0eUluZGV4KTtcbiAgICAgIHJldHVybiB2YWx1ZXNBcnJheVtpbmRleF1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgYnVpbGRMb2NhbGl6ZUFycmF5Rm5cbiAgICogQGNhdGVnb3J5IExvY2FsZSBIZWxwZXJzXG4gICAqIEBzdW1tYXJ5IEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5c2AsIGBsb2NhbGl6ZS5tb250aHNgIGFuZCBgbG9jYWxpemUudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEJ1aWxkIGBsb2NhbGl6ZS53ZWVrZGF5c2AsIGBsb2NhbGl6ZS5tb250aHNgIGFuZCBgbG9jYWxpemUudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAgICogSWYgbm8gYHR5cGVgIGlzIHN1cHBsaWVkIHRvIHRoZSBvcHRpb25zIG9mIHRoZSByZXN1bHRpbmcgZnVuY3Rpb24sIGBkZWZhdWx0VHlwZWAgd2lsbCBiZSB1c2VkIChzZWUgZXhhbXBsZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgb2JqZWN0IHdpdGggYXJyYXlzIG9mIHZhbHVlc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdFR5cGUgLSB0aGUgZGVmYXVsdCB0eXBlIGZvciB0aGUgbG9jYWxpemUgZnVuY3Rpb25cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB3ZWVrZGF5VmFsdWVzID0ge1xuICAgKiAgIG5hcnJvdzogWydTdScsICdNbycsICdUdScsICdXZScsICdUaCcsICdGcicsICdTYSddLFxuICAgKiAgIHNob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICAgKiAgIGxvbmc6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXVxuICAgKiB9XG4gICAqIGxvY2FsZS5sb2NhbGl6ZS53ZWVrZGF5cyA9IGJ1aWxkTG9jYWxpemVBcnJheUZuKHdlZWtkYXlWYWx1ZXMsICdsb25nJylcbiAgICogbG9jYWxlLmxvY2FsaXplLndlZWtkYXlzKHt0eXBlOiAnbmFycm93J30pIC8vPT4gWydTdScsICdNbycsIC4uLl1cbiAgICogbG9jYWxlLmxvY2FsaXplLndlZWtkYXlzKCkgLy89PiBbJ1N1bmRheScsICdNb25kYXknLCAuLi5dXG4gICAqL1xuICBmdW5jdGlvbiBidWlsZExvY2FsaXplQXJyYXlGbiAodmFsdWVzLCBkZWZhdWx0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGlydHlPcHRpb25zKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlID8gU3RyaW5nKG9wdGlvbnMudHlwZSkgOiBkZWZhdWx0VHlwZTtcbiAgICAgIHJldHVybiB2YWx1ZXNbdHlwZV0gfHwgdmFsdWVzW2RlZmF1bHRUeXBlXVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdGU6IGluIEVuZ2xpc2gsIHRoZSBuYW1lcyBvZiBkYXlzIG9mIHRoZSB3ZWVrIGFuZCBtb250aHMgYXJlIGNhcGl0YWxpemVkLlxuICAvLyBJZiB5b3UgYXJlIG1ha2luZyBhIG5ldyBsb2NhbGUgYmFzZWQgb24gdGhpcyBvbmUsIGNoZWNrIGlmIHRoZSBzYW1lIGlzIHRydWUgZm9yIHRoZSBsYW5ndWFnZSB5b3UncmUgd29ya2luZyBvbi5cbiAgLy8gR2VuZXJhbGx5LCBmb3JtYXR0ZWQgZGF0ZXMgc2hvdWxkIGxvb2sgbGlrZSB0aGV5IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgc2VudGVuY2UsXG4gIC8vIGUuZy4gaW4gU3BhbmlzaCBsYW5ndWFnZSB0aGUgd2Vla2RheXMgYW5kIG1vbnRocyBzaG91bGQgYmUgaW4gdGhlIGxvd2VyY2FzZS5cbiAgdmFyIHdlZWtkYXlWYWx1ZXMgPSB7XG4gICAgbmFycm93OiBbJ1N1JywgJ01vJywgJ1R1JywgJ1dlJywgJ1RoJywgJ0ZyJywgJ1NhJ10sXG4gICAgc2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gICAgbG9uZzogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddXG4gIH07XG5cbiAgdmFyIG1vbnRoVmFsdWVzID0ge1xuICAgIHNob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gICAgbG9uZzogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ11cbiAgfTtcblxuICAvLyBgdGltZU9mRGF5YCBpcyB1c2VkIHRvIGRlc2lnbmF0ZSB3aGljaCBwYXJ0IG9mIHRoZSBkYXkgaXQgaXMsIHdoZW4gdXNlZCB3aXRoIDEyLWhvdXIgY2xvY2suXG4gIC8vIFVzZSB0aGUgc3lzdGVtIHdoaWNoIGlzIHVzZWQgdGhlIG1vc3QgY29tbW9ubHkgaW4gdGhlIGxvY2FsZS5cbiAgLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSBjb3VudHJ5IGRvZXNuJ3QgdXNlIGEubS4vcC5tLiwgeW91IGNhbiB1c2UgYG5pZ2h0YC9gbW9ybmluZ2AvYGFmdGVybm9vbmAvYGV2ZW5pbmdgOlxuICAvL1xuICAvLyAgIHZhciB0aW1lT2ZEYXlWYWx1ZXMgPSB7XG4gIC8vICAgICBhbnk6IFsnaW4gdGhlIG5pZ2h0JywgJ2luIHRoZSBtb3JuaW5nJywgJ2luIHRoZSBhZnRlcm5vb24nLCAnaW4gdGhlIGV2ZW5pbmcnXVxuICAvLyAgIH1cbiAgLy9cbiAgLy8gQW5kIGxhdGVyOlxuICAvL1xuICAvLyAgIHZhciBsb2NhbGl6ZSA9IHtcbiAgLy8gICAgIC8vIFRoZSBjYWxsYmFjayB0YWtlcyB0aGUgaG91cnMgYXMgdGhlIGFyZ3VtZW50IGFuZCByZXR1cm5zIHRoZSBhcnJheSBpbmRleFxuICAvLyAgICAgdGltZU9mRGF5OiBidWlsZExvY2FsaXplRm4odGltZU9mRGF5VmFsdWVzLCAnYW55JywgZnVuY3Rpb24gKGhvdXJzKSB7XG4gIC8vICAgICAgIGlmIChob3VycyA+PSAxNykge1xuICAvLyAgICAgICAgIHJldHVybiAzXG4gIC8vICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPj0gMTIpIHtcbiAgLy8gICAgICAgICByZXR1cm4gMlxuICAvLyAgICAgICB9IGVsc2UgaWYgKGhvdXJzID49IDQpIHtcbiAgLy8gICAgICAgICByZXR1cm4gMVxuICAvLyAgICAgICB9IGVsc2Uge1xuICAvLyAgICAgICAgIHJldHVybiAwXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH0pLFxuICAvLyAgICAgdGltZXNPZkRheTogYnVpbGRMb2NhbGl6ZUFycmF5Rm4odGltZU9mRGF5VmFsdWVzLCAnYW55JylcbiAgLy8gICB9XG4gIHZhciB0aW1lT2ZEYXlWYWx1ZXMgPSB7XG4gICAgdXBwZXJjYXNlOiBbJ0FNJywgJ1BNJ10sXG4gICAgbG93ZXJjYXNlOiBbJ2FtJywgJ3BtJ10sXG4gICAgbG9uZzogWydhLm0uJywgJ3AubS4nXVxuICB9O1xuXG4gIGZ1bmN0aW9uIG9yZGluYWxOdW1iZXIgKGRpcnR5TnVtYmVyLCBkaXJ0eU9wdGlvbnMpIHtcbiAgICB2YXIgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTtcblxuICAgIC8vIElmIG9yZGluYWwgbnVtYmVycyBkZXBlbmQgb24gY29udGV4dCwgZm9yIGV4YW1wbGUsXG4gICAgLy8gaWYgdGhleSBhcmUgZGlmZmVyZW50IGZvciBkaWZmZXJlbnQgZ3JhbW1hdGljYWwgZ2VuZGVycyxcbiAgICAvLyB1c2UgYG9wdGlvbnMudW5pdGA6XG4gICAgLy9cbiAgICAvLyAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9XG4gICAgLy8gICB2YXIgdW5pdCA9IFN0cmluZyhvcHRpb25zLnVuaXQpXG4gICAgLy9cbiAgICAvLyB3aGVyZSBgdW5pdGAgY2FuIGJlICdtb250aCcsICdxdWFydGVyJywgJ3dlZWsnLCAnaXNvV2VlaycsICdkYXlPZlllYXInLFxuICAgIC8vICdkYXlPZk1vbnRoJyBvciAnZGF5T2ZXZWVrJ1xuXG4gICAgdmFyIHJlbTEwMCA9IG51bWJlciAlIDEwMDtcbiAgICBpZiAocmVtMTAwID4gMjAgfHwgcmVtMTAwIDwgMTApIHtcbiAgICAgIHN3aXRjaCAocmVtMTAwICUgMTApIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnc3QnXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ25kJ1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciArICdyZCdcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bWJlciArICd0aCdcbiAgfVxuXG4gIHZhciBsb2NhbGl6ZSA9IHtcbiAgICBvcmRpbmFsTnVtYmVyOiBvcmRpbmFsTnVtYmVyLFxuICAgIHdlZWtkYXk6IGJ1aWxkTG9jYWxpemVGbih3ZWVrZGF5VmFsdWVzLCAnbG9uZycpLFxuICAgIHdlZWtkYXlzOiBidWlsZExvY2FsaXplQXJyYXlGbih3ZWVrZGF5VmFsdWVzLCAnbG9uZycpLFxuICAgIG1vbnRoOiBidWlsZExvY2FsaXplRm4obW9udGhWYWx1ZXMsICdsb25nJyksXG4gICAgbW9udGhzOiBidWlsZExvY2FsaXplQXJyYXlGbihtb250aFZhbHVlcywgJ2xvbmcnKSxcbiAgICB0aW1lT2ZEYXk6IGJ1aWxkTG9jYWxpemVGbih0aW1lT2ZEYXlWYWx1ZXMsICdsb25nJywgZnVuY3Rpb24gKGhvdXJzKSB7XG4gICAgICByZXR1cm4gKGhvdXJzIC8gMTIpID49IDEgPyAxIDogMFxuICAgIH0pLFxuICAgIHRpbWVzT2ZEYXk6IGJ1aWxkTG9jYWxpemVBcnJheUZuKHRpbWVPZkRheVZhbHVlcywgJ2xvbmcnKVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBidWlsZE1hdGNoRm5cbiAgICogQGNhdGVnb3J5IExvY2FsZSBIZWxwZXJzXG4gICAqIEBzdW1tYXJ5IEJ1aWxkIGBtYXRjaC53ZWVrZGF5c2AsIGBtYXRjaC5tb250aHNgIGFuZCBgbWF0Y2gudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEJ1aWxkIGBtYXRjaC53ZWVrZGF5c2AsIGBtYXRjaC5tb250aHNgIGFuZCBgbWF0Y2gudGltZXNPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZSB1c2VkIGJ5IGBwYXJzZWAgZnVuY3Rpb24uXG4gICAqIElmIG5vIGB0eXBlYCBpcyBzdXBwbGllZCB0byB0aGUgb3B0aW9ucyBvZiB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uLCBgZGVmYXVsdFR5cGVgIHdpbGwgYmUgdXNlZCAoc2VlIGV4YW1wbGUpLlxuICAgKiBUaGUgcmVzdWx0IG9mIHRoZSBtYXRjaCBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBpbnRvIGNvcnJlc3BvbmRpbmcgcGFyc2VyIGZ1bmN0aW9uXG4gICAqIChgbWF0Y2gud2Vla2RheWAsIGBtYXRjaC5tb250aGAgb3IgYG1hdGNoLnRpbWVPZkRheWAgcmVzcGVjdGl2ZWx5LiBTZWUgYGJ1aWxkUGFyc2VGbmApLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gdGhlIG9iamVjdCB3aXRoIFJlZ0V4cHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRUeXBlIC0gdGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhlIG1hdGNoIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdGhlIHJlc3VsdGluZyBmdW5jdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgbWF0Y2hXZWVrZGF5c1BhdHRlcm5zID0ge1xuICAgKiAgIG5hcnJvdzogL14oc3V8bW98dHV8d2V8dGh8ZnJ8c2EpL2ksXG4gICAqICAgc2hvcnQ6IC9eKHN1bnxtb258dHVlfHdlZHx0aHV8ZnJpfHNhdCkvaSxcbiAgICogICBsb25nOiAvXihzdW5kYXl8bW9uZGF5fHR1ZXNkYXl8d2VkbmVzZGF5fHRodXJzZGF5fGZyaWRheXxzYXR1cmRheSkvaVxuICAgKiB9XG4gICAqIGxvY2FsZS5tYXRjaC53ZWVrZGF5cyA9IGJ1aWxkTWF0Y2hGbihtYXRjaFdlZWtkYXlzUGF0dGVybnMsICdsb25nJylcbiAgICogbG9jYWxlLm1hdGNoLndlZWtkYXlzKCdTdW5kYXknLCB7dHlwZTogJ25hcnJvdyd9KSAvLz0+IFsnU3UnLCAnU3UnLCAuLi5dXG4gICAqIGxvY2FsZS5tYXRjaC53ZWVrZGF5cygnU3VuZGF5JykgLy89PiBbJ1N1bmRheScsICdTdW5kYXknLCAuLi5dXG4gICAqL1xuICBmdW5jdGlvbiBidWlsZE1hdGNoRm4gKHBhdHRlcm5zLCBkZWZhdWx0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGlydHlTdHJpbmcsIGRpcnR5T3B0aW9ucykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSA/IFN0cmluZyhvcHRpb25zLnR5cGUpIDogZGVmYXVsdFR5cGU7XG4gICAgICB2YXIgcGF0dGVybiA9IHBhdHRlcm5zW3R5cGVdIHx8IHBhdHRlcm5zW2RlZmF1bHRUeXBlXTtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcoZGlydHlTdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBidWlsZFBhcnNlRm5cbiAgICogQGNhdGVnb3J5IExvY2FsZSBIZWxwZXJzXG4gICAqIEBzdW1tYXJ5IEJ1aWxkIGBtYXRjaC53ZWVrZGF5YCwgYG1hdGNoLm1vbnRoYCBhbmQgYG1hdGNoLnRpbWVPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEJ1aWxkIGBtYXRjaC53ZWVrZGF5YCwgYG1hdGNoLm1vbnRoYCBhbmQgYG1hdGNoLnRpbWVPZkRheWAgcHJvcGVydGllcyBmb3IgdGhlIGxvY2FsZSB1c2VkIGJ5IGBwYXJzZWAgZnVuY3Rpb24uXG4gICAqIFRoZSBhcmd1bWVudCBvZiB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uIGlzIHRoZSByZXN1bHQgb2YgdGhlIGNvcnJlc3BvbmRpbmcgbWF0Y2ggZnVuY3Rpb25cbiAgICogKGBtYXRjaC53ZWVrZGF5c2AsIGBtYXRjaC5tb250aHNgIG9yIGBtYXRjaC50aW1lc09mRGF5YCByZXNwZWN0aXZlbHkuIFNlZSBgYnVpbGRNYXRjaEZuYCkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgb2JqZWN0IHdpdGggYXJyYXlzIG9mIFJlZ0V4cHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRUeXBlIC0gdGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhlIHBhcnNlciBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSByZXN1bHRpbmcgZnVuY3Rpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHBhcnNlV2Vla2RheVBhdHRlcm5zID0ge1xuICAgKiAgIGFueTogWy9ec3UvaSwgL15tL2ksIC9edHUvaSwgL153L2ksIC9edGgvaSwgL15mL2ksIC9ec2EvaV1cbiAgICogfVxuICAgKiBsb2NhbGUubWF0Y2gud2Vla2RheSA9IGJ1aWxkUGFyc2VGbihtYXRjaFdlZWtkYXlzUGF0dGVybnMsICdsb25nJylcbiAgICogdmFyIG1hdGNoUmVzdWx0ID0gbG9jYWxlLm1hdGNoLndlZWtkYXlzKCdGcmlkYXknKVxuICAgKiBsb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCkgLy89PiA1XG4gICAqL1xuICBmdW5jdGlvbiBidWlsZFBhcnNlRm4gKHBhdHRlcm5zLCBkZWZhdWx0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIGRpcnR5T3B0aW9ucykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSA/IFN0cmluZyhvcHRpb25zLnR5cGUpIDogZGVmYXVsdFR5cGU7XG4gICAgICB2YXIgcGF0dGVybnNBcnJheSA9IHBhdHRlcm5zW3R5cGVdIHx8IHBhdHRlcm5zW2RlZmF1bHRUeXBlXTtcbiAgICAgIHZhciBzdHJpbmcgPSBtYXRjaFJlc3VsdFsxXTtcblxuICAgICAgcmV0dXJuIHBhdHRlcm5zQXJyYXkuZmluZEluZGV4KGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3Qoc3RyaW5nKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgYnVpbGRNYXRjaFBhdHRlcm5GblxuICAgKiBAY2F0ZWdvcnkgTG9jYWxlIEhlbHBlcnNcbiAgICogQHN1bW1hcnkgQnVpbGQgbWF0Y2ggZnVuY3Rpb24gZnJvbSBhIHNpbmdsZSBSZWdFeHAuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBCdWlsZCBtYXRjaCBmdW5jdGlvbiBmcm9tIGEgc2luZ2xlIFJlZ0V4cC5cbiAgICogVXN1YWxseSB1c2VkIGZvciBidWlsZGluZyBgbWF0Y2gub3JkaW5hbE51bWJlcnNgIHByb3BlcnR5IG9mIHRoZSBsb2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXR0ZXJuIC0gdGhlIFJlZ0V4cFxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSByZXN1bHRpbmcgZnVuY3Rpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXJzID0gYnVpbGRNYXRjaFBhdHRlcm5GbigvXihcXGQrKSh0aHxzdHxuZHxyZCk/L2kpXG4gICAqIGxvY2FsZS5tYXRjaC5vcmRpbmFsTnVtYmVycygnM3JkJykgLy89PiBbJzNyZCcsICczJywgJ3JkJywgLi4uXVxuICAgKi9cbiAgZnVuY3Rpb24gYnVpbGRNYXRjaFBhdHRlcm5GbiAocGF0dGVybikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGlydHlTdHJpbmcpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcoZGlydHlTdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBwYXJzZURlY2ltYWxcbiAgICogQGNhdGVnb3J5IExvY2FsZSBIZWxwZXJzXG4gICAqIEBzdW1tYXJ5IFBhcnNlcyB0aGUgbWF0Y2ggcmVzdWx0IGludG8gZGVjaW1hbCBudW1iZXIuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBQYXJzZXMgdGhlIG1hdGNoIHJlc3VsdCBpbnRvIGRlY2ltYWwgbnVtYmVyLlxuICAgKiBVc2VzIHRoZSBzdHJpbmcgbWF0Y2hlZCB3aXRoIHRoZSBmaXJzdCBzZXQgb2YgcGFyZW50aGVzZXMgb2YgbWF0Y2ggUmVnRXhwLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaFJlc3VsdCAtIHRoZSBvYmplY3QgcmV0dXJuZWQgYnkgbWF0Y2hpbmcgZnVuY3Rpb25cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHBhcnNlZCB2YWx1ZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBsb2NhbGUubWF0Y2ggPSB7XG4gICAqICAgb3JkaW5hbE51bWJlcnM6IChkaXJ0eVN0cmluZykge1xuICAgKiAgICAgcmV0dXJuIFN0cmluZyhkaXJ0eVN0cmluZykubWF0Y2goL14oXFxkKykodGh8c3R8bmR8cmQpPy9pKVxuICAgKiAgIH0sXG4gICAqICAgb3JkaW5hbE51bWJlcjogcGFyc2VEZWNpbWFsXG4gICAqIH1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlRGVjaW1hbCAobWF0Y2hSZXN1bHQpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hSZXN1bHRbMV0sIDEwKVxuICB9XG5cbiAgdmFyIG1hdGNoT3JkaW5hbE51bWJlcnNQYXR0ZXJuID0gL14oXFxkKykodGh8c3R8bmR8cmQpPy9pO1xuXG4gIHZhciBtYXRjaFdlZWtkYXlzUGF0dGVybnMgPSB7XG4gICAgbmFycm93OiAvXihzdXxtb3x0dXx3ZXx0aHxmcnxzYSkvaSxcbiAgICBzaG9ydDogL14oc3VufG1vbnx0dWV8d2VkfHRodXxmcml8c2F0KS9pLFxuICAgIGxvbmc6IC9eKHN1bmRheXxtb25kYXl8dHVlc2RheXx3ZWRuZXNkYXl8dGh1cnNkYXl8ZnJpZGF5fHNhdHVyZGF5KS9pXG4gIH07XG5cbiAgdmFyIHBhcnNlV2Vla2RheVBhdHRlcm5zID0ge1xuICAgIGFueTogWy9ec3UvaSwgL15tL2ksIC9edHUvaSwgL153L2ksIC9edGgvaSwgL15mL2ksIC9ec2EvaV1cbiAgfTtcblxuICB2YXIgbWF0Y2hNb250aHNQYXR0ZXJucyA9IHtcbiAgICBzaG9ydDogL14oamFufGZlYnxtYXJ8YXByfG1heXxqdW58anVsfGF1Z3xzZXB8b2N0fG5vdnxkZWMpL2ksXG4gICAgbG9uZzogL14oamFudWFyeXxmZWJydWFyeXxtYXJjaHxhcHJpbHxtYXl8anVuZXxqdWx5fGF1Z3VzdHxzZXB0ZW1iZXJ8b2N0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcikvaVxuICB9O1xuXG4gIHZhciBwYXJzZU1vbnRoUGF0dGVybnMgPSB7XG4gICAgYW55OiBbL15qYS9pLCAvXmYvaSwgL15tYXIvaSwgL15hcC9pLCAvXm1heS9pLCAvXmp1bi9pLCAvXmp1bC9pLCAvXmF1L2ksIC9ecy9pLCAvXm8vaSwgL15uL2ksIC9eZC9pXVxuICB9O1xuXG4gIC8vIGB0aW1lT2ZEYXlgIGlzIHVzZWQgdG8gZGVzaWduYXRlIHdoaWNoIHBhcnQgb2YgdGhlIGRheSBpdCBpcywgd2hlbiB1c2VkIHdpdGggMTItaG91ciBjbG9jay5cbiAgLy8gVXNlIHRoZSBzeXN0ZW0gd2hpY2ggaXMgdXNlZCB0aGUgbW9zdCBjb21tb25seSBpbiB0aGUgbG9jYWxlLlxuICAvLyBGb3IgZXhhbXBsZSwgaWYgdGhlIGNvdW50cnkgZG9lc24ndCB1c2UgYS5tLi9wLm0uLCB5b3UgY2FuIHVzZSBgbmlnaHRgL2Btb3JuaW5nYC9gYWZ0ZXJub29uYC9gZXZlbmluZ2A6XG4gIC8vXG4gIC8vICAgdmFyIG1hdGNoVGltZXNPZkRheVBhdHRlcm5zID0ge1xuICAvLyAgICAgbG9uZzogL14oKGluIHRoZSk/IChuaWdodHxtb3JuaW5nfGFmdGVybm9vbnxldmVuaW5nPykpL2lcbiAgLy8gICB9XG4gIC8vXG4gIC8vICAgdmFyIHBhcnNlVGltZU9mRGF5UGF0dGVybnMgPSB7XG4gIC8vICAgICBhbnk6IFsvKG5pZ2h0fG1vcm5pbmcpL2ksIC8oYWZ0ZXJub29ufGV2ZW5pbmcpL2ldXG4gIC8vICAgfVxuICB2YXIgbWF0Y2hUaW1lc09mRGF5UGF0dGVybnMgPSB7XG4gICAgc2hvcnQ6IC9eKGFtfHBtKS9pLFxuICAgIGxvbmc6IC9eKFthcF1cXC4/XFxzP21cXC4/KS9pXG4gIH07XG5cbiAgdmFyIHBhcnNlVGltZU9mRGF5UGF0dGVybnMgPSB7XG4gICAgYW55OiBbL15hL2ksIC9ecC9pXVxuICB9O1xuXG4gIHZhciBtYXRjaCA9IHtcbiAgICBvcmRpbmFsTnVtYmVyczogYnVpbGRNYXRjaFBhdHRlcm5GbihtYXRjaE9yZGluYWxOdW1iZXJzUGF0dGVybiksXG4gICAgb3JkaW5hbE51bWJlcjogcGFyc2VEZWNpbWFsLFxuICAgIHdlZWtkYXlzOiBidWlsZE1hdGNoRm4obWF0Y2hXZWVrZGF5c1BhdHRlcm5zLCAnbG9uZycpLFxuICAgIHdlZWtkYXk6IGJ1aWxkUGFyc2VGbihwYXJzZVdlZWtkYXlQYXR0ZXJucywgJ2FueScpLFxuICAgIG1vbnRoczogYnVpbGRNYXRjaEZuKG1hdGNoTW9udGhzUGF0dGVybnMsICdsb25nJyksXG4gICAgbW9udGg6IGJ1aWxkUGFyc2VGbihwYXJzZU1vbnRoUGF0dGVybnMsICdhbnknKSxcbiAgICB0aW1lc09mRGF5OiBidWlsZE1hdGNoRm4obWF0Y2hUaW1lc09mRGF5UGF0dGVybnMsICdsb25nJyksXG4gICAgdGltZU9mRGF5OiBidWlsZFBhcnNlRm4ocGFyc2VUaW1lT2ZEYXlQYXR0ZXJucywgJ2FueScpXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtMb2NhbGV9XG4gICAqIEBjYXRlZ29yeSBMb2NhbGVzXG4gICAqIEBzdW1tYXJ5IEVuZ2xpc2ggbG9jYWxlIChVbml0ZWQgU3RhdGVzKS5cbiAgICogQGxhbmd1YWdlIEVuZ2xpc2hcbiAgICogQGlzby02MzktMiBlbmdcbiAgICovXG4gIHZhciBsb2NhbGUgPSB7XG4gICAgZm9ybWF0RGlzdGFuY2U6IGZvcm1hdERpc3RhbmNlLFxuICAgIGZvcm1hdExvbmc6IGZvcm1hdExvbmcsXG4gICAgZm9ybWF0UmVsYXRpdmU6IGZvcm1hdFJlbGF0aXZlLFxuICAgIGxvY2FsaXplOiBsb2NhbGl6ZSxcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgb3B0aW9uczoge1xuICAgICAgd2Vla1N0YXJ0c09uOiAwIC8qIFN1bmRheSAqLyxcbiAgICAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogMVxuICAgIH1cbiAgfTtcblxuICB2YXIgTUlMTElTRUNPTkRTX0lOX0RBWSQxID0gODY0MDAwMDA7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4gIC8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcbiAgZnVuY3Rpb24gZ2V0VVRDRGF5T2ZZZWFyIChkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgIHZhciBzdGFydE9mWWVhclRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICAgIHZhciBkaWZmZXJlbmNlID0gdGltZXN0YW1wIC0gc3RhcnRPZlllYXJUaW1lc3RhbXA7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZGlmZmVyZW5jZSAvIE1JTExJU0VDT05EU19JTl9EQVkkMSkgKyAxXG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbiAgLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuICBmdW5jdGlvbiBzdGFydE9mVVRDSVNPV2VlayAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgICB2YXIgd2Vla1N0YXJ0c09uID0gMTtcblxuICAgIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgICB2YXIgZGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcbiAgICB2YXIgZGlmZiA9IChkYXkgPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSB3ZWVrU3RhcnRzT247XG5cbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgIHJldHVybiBkYXRlXG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbiAgLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuICBmdW5jdGlvbiBnZXRVVENJU09XZWVrWWVhciAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gICAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG5cbiAgICB2YXIgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhciA9IG5ldyBEYXRlKDApO1xuICAgIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0VVRDRnVsbFllYXIoeWVhciArIDEsIDAsIDQpO1xuICAgIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgdmFyIHN0YXJ0T2ZOZXh0WWVhciA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIsIGRpcnR5T3B0aW9ucyk7XG5cbiAgICB2YXIgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhciA9IG5ldyBEYXRlKDApO1xuICAgIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgNCk7XG4gICAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICB2YXIgc3RhcnRPZlRoaXNZZWFyID0gc3RhcnRPZlVUQ0lTT1dlZWsoZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhciwgZGlydHlPcHRpb25zKTtcblxuICAgIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mTmV4dFllYXIuZ2V0VGltZSgpKSB7XG4gICAgICByZXR1cm4geWVhciArIDFcbiAgICB9IGVsc2UgaWYgKGRhdGUuZ2V0VGltZSgpID49IHN0YXJ0T2ZUaGlzWWVhci5nZXRUaW1lKCkpIHtcbiAgICAgIHJldHVybiB5ZWFyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB5ZWFyIC0gMVxuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuICAvLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG4gIGZ1bmN0aW9uIHN0YXJ0T2ZVVENJU09XZWVrWWVhciAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgICB2YXIgeWVhciA9IGdldFVUQ0lTT1dlZWtZZWFyKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgICB2YXIgZm91cnRoT2ZKYW51YXJ5ID0gbmV3IERhdGUoMCk7XG4gICAgZm91cnRoT2ZKYW51YXJ5LnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIDQpO1xuICAgIGZvdXJ0aE9mSmFudWFyeS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICB2YXIgZGF0ZSA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeSwgZGlydHlPcHRpb25zKTtcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgdmFyIE1JTExJU0VDT05EU19JTl9XRUVLJDIgPSA2MDQ4MDAwMDA7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXG4gIC8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcbiAgZnVuY3Rpb24gZ2V0VVRDSVNPV2VlayAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gICAgdmFyIGRpZmYgPSBzdGFydE9mVVRDSVNPV2VlayhkYXRlLCBkaXJ0eU9wdGlvbnMpLmdldFRpbWUoKSAtIHN0YXJ0T2ZVVENJU09XZWVrWWVhcihkYXRlLCBkaXJ0eU9wdGlvbnMpLmdldFRpbWUoKTtcblxuICAgIC8vIFJvdW5kIHRoZSBudW1iZXIgb2YgZGF5cyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyXG4gICAgLy8gYmVjYXVzZSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpbiBhIHdlZWsgaXMgbm90IGNvbnN0YW50XG4gICAgLy8gKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2YgdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KVxuICAgIHJldHVybiBNYXRoLnJvdW5kKGRpZmYgLyBNSUxMSVNFQ09ORFNfSU5fV0VFSyQyKSArIDFcbiAgfVxuXG4gIHZhciBmb3JtYXR0ZXJzID0ge1xuICAgIC8vIE1vbnRoOiAxLCAyLCAuLi4sIDEyXG4gICAgJ00nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUuZ2V0VVRDTW9udGgoKSArIDFcbiAgICB9LFxuXG4gICAgLy8gTW9udGg6IDFzdCwgMm5kLCAuLi4sIDEydGhcbiAgICAnTW8nOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpICsgMTtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKG1vbnRoLCB7dW5pdDogJ21vbnRoJ30pXG4gICAgfSxcblxuICAgIC8vIE1vbnRoOiAwMSwgMDIsIC4uLiwgMTJcbiAgICAnTU0nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ01vbnRoKCkgKyAxLCAyKVxuICAgIH0sXG5cbiAgICAvLyBNb250aDogSmFuLCBGZWIsIC4uLiwgRGVjXG4gICAgJ01NTSc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUubW9udGgoZGF0ZS5nZXRVVENNb250aCgpLCB7dHlwZTogJ3Nob3J0J30pXG4gICAgfSxcblxuICAgIC8vIE1vbnRoOiBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxuICAgICdNTU1NJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5tb250aChkYXRlLmdldFVUQ01vbnRoKCksIHt0eXBlOiAnbG9uZyd9KVxuICAgIH0sXG5cbiAgICAvLyBRdWFydGVyOiAxLCAyLCAzLCA0XG4gICAgJ1EnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCgoZGF0ZS5nZXRVVENNb250aCgpICsgMSkgLyAzKVxuICAgIH0sXG5cbiAgICAvLyBRdWFydGVyOiAxc3QsIDJuZCwgM3JkLCA0dGhcbiAgICAnUW8nOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHF1YXJ0ZXIgPSBNYXRoLmNlaWwoKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpIC8gMyk7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUub3JkaW5hbE51bWJlcihxdWFydGVyLCB7dW5pdDogJ3F1YXJ0ZXInfSlcbiAgICB9LFxuXG4gICAgLy8gRGF5IG9mIG1vbnRoOiAxLCAyLCAuLi4sIDMxXG4gICAgJ0QnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUuZ2V0VVRDRGF0ZSgpXG4gICAgfSxcblxuICAgIC8vIERheSBvZiBtb250aDogMXN0LCAybmQsIC4uLiwgMzFzdFxuICAgICdEbyc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldFVUQ0RhdGUoKSwge3VuaXQ6ICdkYXlPZk1vbnRoJ30pXG4gICAgfSxcblxuICAgIC8vIERheSBvZiBtb250aDogMDEsIDAyLCAuLi4sIDMxXG4gICAgJ0REJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENEYXRlKCksIDIpXG4gICAgfSxcblxuICAgIC8vIERheSBvZiB5ZWFyOiAxLCAyLCAuLi4sIDM2NlxuICAgICdEREQnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGdldFVUQ0RheU9mWWVhcihkYXRlKVxuICAgIH0sXG5cbiAgICAvLyBEYXkgb2YgeWVhcjogMXN0LCAybmQsIC4uLiwgMzY2dGhcbiAgICAnREREbyc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUub3JkaW5hbE51bWJlcihnZXRVVENEYXlPZlllYXIoZGF0ZSksIHt1bml0OiAnZGF5T2ZZZWFyJ30pXG4gICAgfSxcblxuICAgIC8vIERheSBvZiB5ZWFyOiAwMDEsIDAwMiwgLi4uLCAzNjZcbiAgICAnRERERCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGdldFVUQ0RheU9mWWVhcihkYXRlKSwgMylcbiAgICB9LFxuXG4gICAgLy8gRGF5IG9mIHdlZWs6IFN1LCBNbywgLi4uLCBTYVxuICAgICdkZCc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUud2Vla2RheShkYXRlLmdldFVUQ0RheSgpLCB7dHlwZTogJ25hcnJvdyd9KVxuICAgIH0sXG5cbiAgICAvLyBEYXkgb2Ygd2VlazogU3VuLCBNb24sIC4uLiwgU2F0XG4gICAgJ2RkZCc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUud2Vla2RheShkYXRlLmdldFVUQ0RheSgpLCB7dHlwZTogJ3Nob3J0J30pXG4gICAgfSxcblxuICAgIC8vIERheSBvZiB3ZWVrOiBTdW5kYXksIE1vbmRheSwgLi4uLCBTYXR1cmRheVxuICAgICdkZGRkJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS53ZWVrZGF5KGRhdGUuZ2V0VVRDRGF5KCksIHt0eXBlOiAnbG9uZyd9KVxuICAgIH0sXG5cbiAgICAvLyBEYXkgb2Ygd2VlazogMCwgMSwgLi4uLCA2XG4gICAgJ2QnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUuZ2V0VVRDRGF5KClcbiAgICB9LFxuXG4gICAgLy8gRGF5IG9mIHdlZWs6IDB0aCwgMXN0LCAybmQsIC4uLiwgNnRoXG4gICAgJ2RvJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0VVRDRGF5KCksIHt1bml0OiAnZGF5T2ZXZWVrJ30pXG4gICAgfSxcblxuICAgIC8vIERheSBvZiBJU08gd2VlazogMSwgMiwgLi4uLCA3XG4gICAgJ0UnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUuZ2V0VVRDRGF5KCkgfHwgN1xuICAgIH0sXG5cbiAgICAvLyBJU08gd2VlazogMSwgMiwgLi4uLCA1M1xuICAgICdXJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiBnZXRVVENJU09XZWVrKGRhdGUpXG4gICAgfSxcblxuICAgIC8vIElTTyB3ZWVrOiAxc3QsIDJuZCwgLi4uLCA1M3RoXG4gICAgJ1dvJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGdldFVUQ0lTT1dlZWsoZGF0ZSksIHt1bml0OiAnaXNvV2Vlayd9KVxuICAgIH0sXG5cbiAgICAvLyBJU08gd2VlazogMDEsIDAyLCAuLi4sIDUzXG4gICAgJ1dXJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZ2V0VVRDSVNPV2VlayhkYXRlKSwgMilcbiAgICB9LFxuXG4gICAgLy8gWWVhcjogMDAsIDAxLCAuLi4sIDk5XG4gICAgJ1lZJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCA0KS5zdWJzdHIoMilcbiAgICB9LFxuXG4gICAgLy8gWWVhcjogMTkwMCwgMTkwMSwgLi4uLCAyMDk5XG4gICAgJ1lZWVknOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIDQpXG4gICAgfSxcblxuICAgIC8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiAwMCwgMDEsIC4uLiwgOTlcbiAgICAnR0cnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhnZXRVVENJU09XZWVrWWVhcihkYXRlKSkuc3Vic3RyKDIpXG4gICAgfSxcblxuICAgIC8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiAxOTAwLCAxOTAxLCAuLi4sIDIwOTlcbiAgICAnR0dHRyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICByZXR1cm4gZ2V0VVRDSVNPV2Vla1llYXIoZGF0ZSlcbiAgICB9LFxuXG4gICAgLy8gSG91cjogMCwgMSwgLi4uIDIzXG4gICAgJ0gnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKVxuICAgIH0sXG5cbiAgICAvLyBIb3VyOiAwMCwgMDEsIC4uLiwgMjNcbiAgICAnSEgnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ0hvdXJzKCksIDIpXG4gICAgfSxcblxuICAgIC8vIEhvdXI6IDEsIDIsIC4uLiwgMTJcbiAgICAnaCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgICBpZiAoaG91cnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDEyXG4gICAgICB9IGVsc2UgaWYgKGhvdXJzID4gMTIpIHtcbiAgICAgICAgcmV0dXJuIGhvdXJzICUgMTJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBob3Vyc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBIb3VyOiAwMSwgMDIsIC4uLiwgMTJcbiAgICAnaGgnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhmb3JtYXR0ZXJzWydoJ10oZGF0ZSksIDIpXG4gICAgfSxcblxuICAgIC8vIE1pbnV0ZTogMCwgMSwgLi4uLCA1OVxuICAgICdtJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiBkYXRlLmdldFVUQ01pbnV0ZXMoKVxuICAgIH0sXG5cbiAgICAvLyBNaW51dGU6IDAwLCAwMSwgLi4uLCA1OVxuICAgICdtbSc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDTWludXRlcygpLCAyKVxuICAgIH0sXG5cbiAgICAvLyBTZWNvbmQ6IDAsIDEsIC4uLiwgNTlcbiAgICAncyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZS5nZXRVVENTZWNvbmRzKClcbiAgICB9LFxuXG4gICAgLy8gU2Vjb25kOiAwMCwgMDEsIC4uLiwgNTlcbiAgICAnc3MnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldFVUQ1NlY29uZHMoKSwgMilcbiAgICB9LFxuXG4gICAgLy8gMS8xMCBvZiBzZWNvbmQ6IDAsIDEsIC4uLiwgOVxuICAgICdTJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgLyAxMDApXG4gICAgfSxcblxuICAgIC8vIDEvMTAwIG9mIHNlY29uZDogMDAsIDAxLCAuLi4sIDk5XG4gICAgJ1NTJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoTWF0aC5mbG9vcihkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpIC8gMTApLCAyKVxuICAgIH0sXG5cbiAgICAvLyBNaWxsaXNlY29uZDogMDAwLCAwMDEsIC4uLiwgOTk5XG4gICAgJ1NTUyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCksIDMpXG4gICAgfSxcblxuICAgIC8vIFRpbWV6b25lOiAtMDE6MDAsICswMDowMCwgLi4uICsxMjowMFxuICAgICdaJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZShvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSwgJzonKVxuICAgIH0sXG5cbiAgICAvLyBUaW1lem9uZTogLTAxMDAsICswMDAwLCAuLi4gKzEyMDBcbiAgICAnWlonOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKVxuICAgIH0sXG5cbiAgICAvLyBTZWNvbmRzIHRpbWVzdGFtcDogNTEyOTY5NTIwXG4gICAgJ1gnOiBmdW5jdGlvbiAoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIG9yaWdpbmFsRGF0ZSA9IG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB8fCBkYXRlO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3Iob3JpZ2luYWxEYXRlLmdldFRpbWUoKSAvIDEwMDApXG4gICAgfSxcblxuICAgIC8vIE1pbGxpc2Vjb25kcyB0aW1lc3RhbXA6IDUxMjk2OTUyMDkwMFxuICAgICd4JzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcbiAgICAgIHJldHVybiBvcmlnaW5hbERhdGUuZ2V0VGltZSgpXG4gICAgfSxcblxuICAgIC8vIEFNLCBQTVxuICAgICdBJzogZnVuY3Rpb24gKGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5sb2NhbGl6ZS50aW1lT2ZEYXkoZGF0ZS5nZXRVVENIb3VycygpLCB7dHlwZTogJ3VwcGVyY2FzZSd9KVxuICAgIH0sXG5cbiAgICAvLyBhbSwgcG1cbiAgICAnYSc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUudGltZU9mRGF5KGRhdGUuZ2V0VVRDSG91cnMoKSwge3R5cGU6ICdsb3dlcmNhc2UnfSlcbiAgICB9LFxuXG4gICAgLy8gYS5tLiwgcC5tLlxuICAgICdhYSc6IGZ1bmN0aW9uIChkYXRlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubG9jYWxpemUudGltZU9mRGF5KGRhdGUuZ2V0VVRDSG91cnMoKSwge3R5cGU6ICdsb25nJ30pXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lIChvZmZzZXQsIGRlbGltZXRlcikge1xuICAgIGRlbGltZXRlciA9IGRlbGltZXRlciB8fCAnJztcbiAgICB2YXIgc2lnbiA9IG9mZnNldCA+IDAgPyAnLScgOiAnKyc7XG4gICAgdmFyIGFic09mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG4gICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihhYnNPZmZzZXQgLyA2MCk7XG4gICAgdmFyIG1pbnV0ZXMgPSBhYnNPZmZzZXQgJSA2MDtcbiAgICByZXR1cm4gc2lnbiArIGFkZExlYWRpbmdaZXJvcyhob3VycywgMikgKyBkZWxpbWV0ZXIgKyBhZGRMZWFkaW5nWmVyb3MobWludXRlcywgMilcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvcyAobnVtYmVyLCB0YXJnZXRMZW5ndGgpIHtcbiAgICB2YXIgb3V0cHV0ID0gTWF0aC5hYnMobnVtYmVyKS50b1N0cmluZygpO1xuICAgIHdoaWxlIChvdXRwdXQubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICBvdXRwdXQgPSAnMCcgKyBvdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuICAvLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG4gIGZ1bmN0aW9uIGFkZFVUQ01pbnV0ZXMgKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQsIGRpcnR5T3B0aW9ucykge1xuICAgIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgICB2YXIgYW1vdW50ID0gTnVtYmVyKGRpcnR5QW1vdW50KTtcbiAgICBkYXRlLnNldFVUQ01pbnV0ZXMoZGF0ZS5nZXRVVENNaW51dGVzKCkgKyBhbW91bnQpO1xuICAgIHJldHVybiBkYXRlXG4gIH1cblxuICB2YXIgbG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvKFxcW1teW10qXSl8KFxcXFwpPyhMVFN8TFR8TExMTHxMTEx8TEx8THxsbGxsfGxsbHxsbHxsKS9nO1xuICB2YXIgZGVmYXVsdEZvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvKFxcW1teW10qXSl8KFxcXFwpPyh4fHNzfHN8bW18bXxoaHxofGRvfGRkZGR8ZGRkfGRkfGR8YWF8YXxaWnxafFlZWVl8WVl8WHxXb3xXV3xXfFNTU3xTU3xTfFFvfFF8TW98TU1NTXxNTU18TU18TXxISHxIfEdHR0d8R0d8RXxEb3xERERvfERERER8REREfEREfER8QXwuKS9nO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBmb3JtYXRcbiAgICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gICAqIEBzdW1tYXJ5IEZvcm1hdCB0aGUgZGF0ZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybiB0aGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nIGluIHRoZSBnaXZlbiBmb3JtYXQuXG4gICAqXG4gICAqIEFjY2VwdGVkIHRva2VuczpcbiAgICogfCBVbml0ICAgICAgICAgICAgICAgICAgICB8IFRva2VuIHwgUmVzdWx0IGV4YW1wbGVzICAgICAgICAgICAgICAgICAgfFxuICAgKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAqIHwgTW9udGggICAgICAgICAgICAgICAgICAgfCBNICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8IE1vICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU0gICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU0gICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NTU0gIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgfFxuICAgKiB8IFF1YXJ0ZXIgICAgICAgICAgICAgICAgIHwgUSAgICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBRbyAgICB8IDFzdCwgMm5kLCAzcmQsIDR0aCAgICAgICAgICAgICAgIHxcbiAgICogfCBEYXkgb2YgbW9udGggICAgICAgICAgICB8IEQgICAgIHwgMSwgMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgRG8gICAgfCAxc3QsIDJuZCwgLi4uLCAzMXN0ICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBERCAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgIHxcbiAgICogfCBEYXkgb2YgeWVhciAgICAgICAgICAgICB8IERERCAgIHwgMSwgMiwgLi4uLCAzNjYgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgREREbyAgfCAxc3QsIDJuZCwgLi4uLCAzNjZ0aCAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBEREREICB8IDAwMSwgMDAyLCAuLi4sIDM2NiAgICAgICAgICAgICAgIHxcbiAgICogfCBEYXkgb2Ygd2VlayAgICAgICAgICAgICB8IGQgICAgIHwgMCwgMSwgLi4uLCA2ICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgZG8gICAgfCAwdGgsIDFzdCwgLi4uLCA2dGggICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZCAgICB8IFN1LCBNbywgLi4uLCBTYSAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8IGRkZCAgIHwgU3VuLCBNb24sIC4uLiwgU2F0ICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgZGRkZCAgfCBTdW5kYXksIE1vbmRheSwgLi4uLCBTYXR1cmRheSAgICB8XG4gICAqIHwgRGF5IG9mIElTTyB3ZWVrICAgICAgICAgfCBFICAgICB8IDEsIDIsIC4uLiwgNyAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCBJU08gd2VlayAgICAgICAgICAgICAgICB8IFcgICAgIHwgMSwgMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgV28gICAgfCAxc3QsIDJuZCwgLi4uLCA1M3JkICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBXVyAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgIHxcbiAgICogfCBZZWFyICAgICAgICAgICAgICAgICAgICB8IFlZICAgIHwgMDAsIDAxLCAuLi4sIDk5ICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVlZWSAgfCAxOTAwLCAxOTAxLCAuLi4sIDIwOTkgICAgICAgICAgICB8XG4gICAqIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgfCBHRyAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8IEdHR0cgIHwgMTkwMCwgMTkwMSwgLi4uLCAyMDk5ICAgICAgICAgICAgfFxuICAgKiB8IEFNL1BNICAgICAgICAgICAgICAgICAgIHwgQSAgICAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBhICAgICB8IGFtLCBwbSAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8IGFhICAgIHwgYS5tLiwgcC5tLiAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8IEhvdXIgICAgICAgICAgICAgICAgICAgIHwgSCAgICAgfCAwLCAxLCAuLi4gMjMgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBISCAgICB8IDAwLCAwMSwgLi4uIDIzICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8IGggICAgIHwgMSwgMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgaGggICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgTWludXRlICAgICAgICAgICAgICAgICAgfCBtICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8IG1tICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgfFxuICAgKiB8IFNlY29uZCAgICAgICAgICAgICAgICAgIHwgcyAgICAgfCAwLCAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBzcyAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAxLzEwIG9mIHNlY29uZCAgICAgICAgICB8IFMgICAgIHwgMCwgMSwgLi4uLCA5ICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8IDEvMTAwIG9mIHNlY29uZCAgICAgICAgIHwgU1MgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgTWlsbGlzZWNvbmQgICAgICAgICAgICAgfCBTU1MgICB8IDAwMCwgMDAxLCAuLi4sIDk5OSAgICAgICAgICAgICAgIHxcbiAgICogfCBUaW1lem9uZSAgICAgICAgICAgICAgICB8IFogICAgIHwgLTAxOjAwLCArMDA6MDAsIC4uLiArMTI6MDAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgWlogICAgfCAtMDEwMCwgKzAwMDAsIC4uLiwgKzEyMDAgICAgICAgICB8XG4gICAqIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgfCBYICAgICB8IDUxMjk2OTUyMCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCBNaWxsaXNlY29uZHMgdGltZXN0YW1wICB8IHggICAgIHwgNTEyOTY5NTIwOTAwICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8IExvbmcgZm9ybWF0ICAgICAgICAgICAgIHwgTFQgICAgfCAwNTozMCBhLm0uICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMVFMgICB8IDA1OjMwOjE1IGEubS4gICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8IEwgICAgIHwgMDcvMDIvMTk5NSAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgbCAgICAgfCA3LzIvMTk5NSAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTCAgICB8IEp1bHkgMiAxOTk1ICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8IGxsICAgIHwgSnVsIDIgMTk5NSAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgTExMICAgfCBKdWx5IDIgMTk5NSAwNTozMCBhLm0uICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBsbGwgICB8IEp1bCAyIDE5OTUgMDU6MzAgYS5tLiAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8IExMTEwgIHwgU3VuZGF5LCBKdWx5IDIgMTk5NSAwNTozMCBhLm0uICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgbGxsbCAgfCBTdW4sIEp1bCAyIDE5OTUgMDU6MzAgYS5tLiAgICAgICB8XG4gICAqXG4gICAqIFRoZSBjaGFyYWN0ZXJzIHdyYXBwZWQgaW4gc3F1YXJlIGJyYWNrZXRzIGFyZSBlc2NhcGVkLlxuICAgKlxuICAgKiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgb3JpZ2luYWwgZGF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IC0gdGhlIHN0cmluZyBvZiB0b2tlbnNcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XG4gICAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAgICogQHBhcmFtIHtMb2NhbGV9IFtvcHRpb25zLmxvY2FsZT1kZWZhdWx0TG9jYWxlXSAtIHRoZSBsb2NhbGUgb2JqZWN0LiBTZWUgW0xvY2FsZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9Mb2NhbGV9XG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgbG9jYWxpemVgIHByb3BlcnR5XG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBmb3JtYXRMb25nYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBSZXByZXNlbnQgMTEgRmVicnVhcnkgMjAxNCBpbiBtaWRkbGUtZW5kaWFuIGZvcm1hdDpcbiAgICogdmFyIHJlc3VsdCA9IGZvcm1hdChcbiAgICogICBuZXcgRGF0ZSgyMDE0LCAxLCAxMSksXG4gICAqICAgJ01NL0REL1lZWVknXG4gICAqIClcbiAgICogLy89PiAnMDIvMTEvMjAxNCdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gUmVwcmVzZW50IDIgSnVseSAyMDE0IGluIEVzcGVyYW50bzpcbiAgICogaW1wb3J0IHsgZW9Mb2NhbGUgfSBmcm9tICdkYXRlLWZucy9sb2NhbGUvZW8nXG4gICAqIHZhciByZXN1bHQgPSBmb3JtYXQoXG4gICAqICAgbmV3IERhdGUoMjAxNCwgNiwgMiksXG4gICAqICAgJ0RvIFtkZV0gTU1NTSBZWVlZJyxcbiAgICogICB7bG9jYWxlOiBlb0xvY2FsZX1cbiAgICogKVxuICAgKiAvLz0+ICcyLWEgZGUganVsaW8gMjAxNCdcbiAgICovXG4gIGZ1bmN0aW9uIGZvcm1hdCAoZGlydHlEYXRlLCBkaXJ0eUZvcm1hdFN0ciwgZGlydHlPcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICAgIH1cblxuICAgIHZhciBmb3JtYXRTdHIgPSBTdHJpbmcoZGlydHlGb3JtYXRTdHIpO1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGxvY2FsZSQkMSA9IG9wdGlvbnMubG9jYWxlIHx8IGxvY2FsZTtcblxuICAgIGlmICghbG9jYWxlJCQxLmxvY2FsaXplKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBsb2NhbGl6ZSBwcm9wZXJ0eScpXG4gICAgfVxuXG4gICAgaWYgKCFsb2NhbGUkJDEuZm9ybWF0TG9uZykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2xvY2FsZSBtdXN0IGNvbnRhaW4gZm9ybWF0TG9uZyBwcm9wZXJ0eScpXG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZUZvcm1hdHRlcnMgPSBsb2NhbGUkJDEuZm9ybWF0dGVycyB8fCB7fTtcbiAgICB2YXIgZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9IGxvY2FsZSQkMS5mb3JtYXR0aW5nVG9rZW5zUmVnRXhwIHx8IGRlZmF1bHRGb3JtYXR0aW5nVG9rZW5zUmVnRXhwO1xuICAgIHZhciBmb3JtYXRMb25nID0gbG9jYWxlJCQxLmZvcm1hdExvbmc7XG5cbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWlzVmFsaWQob3JpZ2luYWxEYXRlLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuICdJbnZhbGlkIERhdGUnXG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0aGUgZGF0ZSBpbiBzeXN0ZW0gdGltZXpvbmUgdG8gdGhlIHNhbWUgZGF0ZSBpbiBVVEMrMDA6MDAgdGltZXpvbmUuXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2hlbiBVVEMgZnVuY3Rpb25zIHdpbGwgYmUgaW1wbGVtZW50ZWQsIGxvY2FsZXMgd2lsbCBiZSBjb21wYXRpYmxlIHdpdGggdGhlbS5cbiAgICAvLyBTZWUgYW4gaXNzdWUgYWJvdXQgVVRDIGZ1bmN0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSBvcmlnaW5hbERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICB2YXIgdXRjRGF0ZSA9IGFkZFVUQ01pbnV0ZXMob3JpZ2luYWxEYXRlLCAtdGltZXpvbmVPZmZzZXQsIG9wdGlvbnMpO1xuXG4gICAgdmFyIGZvcm1hdHRlck9wdGlvbnMgPSBjbG9uZU9iamVjdChvcHRpb25zKTtcbiAgICBmb3JtYXR0ZXJPcHRpb25zLmxvY2FsZSA9IGxvY2FsZSQkMTtcbiAgICBmb3JtYXR0ZXJPcHRpb25zLmZvcm1hdHRlcnMgPSBmb3JtYXR0ZXJzO1xuXG4gICAgLy8gV2hlbiBVVEMgZnVuY3Rpb25zIHdpbGwgYmUgaW1wbGVtZW50ZWQsIG9wdGlvbnMuX29yaWdpbmFsRGF0ZSB3aWxsIGxpa2VseSBiZSBhIHBhcnQgb2YgcHVibGljIEFQSS5cbiAgICAvLyBSaWdodCBub3csIHBsZWFzZSBkb24ndCB1c2UgaXQgaW4gbG9jYWxlcy4gSWYgeW91IGhhdmUgdG8gdXNlIGFuIG9yaWdpbmFsIGRhdGUsXG4gICAgLy8gcGxlYXNlIHJlc3RvcmUgaXQgZnJvbSBgZGF0ZWAsIGFkZGluZyBhIHRpbWV6b25lIG9mZnNldCB0byBpdC5cbiAgICBmb3JtYXR0ZXJPcHRpb25zLl9vcmlnaW5hbERhdGUgPSBvcmlnaW5hbERhdGU7XG5cbiAgICB2YXIgcmVzdWx0ID0gZm9ybWF0U3RyXG4gICAgICAucmVwbGFjZShsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCwgZnVuY3Rpb24gKHN1YnN0cmluZykge1xuICAgICAgICBpZiAoc3Vic3RyaW5nWzBdID09PSAnWycpIHtcbiAgICAgICAgICByZXR1cm4gc3Vic3RyaW5nXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3Vic3RyaW5nWzBdID09PSAnXFxcXCcpIHtcbiAgICAgICAgICByZXR1cm4gY2xlYW5Fc2NhcGVkU3RyaW5nKHN1YnN0cmluZylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXRMb25nKHN1YnN0cmluZylcbiAgICAgIH0pXG4gICAgICAucmVwbGFjZShmb3JtYXR0aW5nVG9rZW5zUmVnRXhwLCBmdW5jdGlvbiAoc3Vic3RyaW5nKSB7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBsb2NhbGVGb3JtYXR0ZXJzW3N1YnN0cmluZ10gfHwgZm9ybWF0dGVyc1tzdWJzdHJpbmddO1xuXG4gICAgICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyKHV0Y0RhdGUsIGZvcm1hdHRlck9wdGlvbnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNsZWFuRXNjYXBlZFN0cmluZyhzdWJzdHJpbmcpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW5Fc2NhcGVkU3RyaW5nIChpbnB1dCkge1xuICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XSQvZywgJycpXG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIHN1Yk1pbnV0ZXNcbiAgICogQGNhdGVnb3J5IE1pbnV0ZSBIZWxwZXJzXG4gICAqIEBzdW1tYXJ5IFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbnV0ZXMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbnV0ZXMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIG1pbnV0ZXMgdG8gYmUgc3VidHJhY3RlZFxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAgICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICAgKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIG1pbnR1ZXMgc3VidHJhY3RlZFxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFN1YnRyYWN0IDMwIG1pbnV0ZXMgZnJvbSAxMCBKdWx5IDIwMTQgMTI6MDA6MDA6XG4gICAqIHZhciByZXN1bHQgPSBzdWJNaW51dGVzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgMCksIDMwKVxuICAgKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMTozMDowMFxuICAgKi9cbiAgZnVuY3Rpb24gc3ViTWludXRlcyAoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCwgZGlydHlPcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxuICAgIH1cblxuICAgIHZhciBhbW91bnQgPSBOdW1iZXIoZGlydHlBbW91bnQpO1xuICAgIHJldHVybiBhZGRNaW51dGVzKGRpcnR5RGF0ZSwgLWFtb3VudCwgZGlydHlPcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIGlzQWZ0ZXJcbiAgICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gICAqIEBzdW1tYXJ5IElzIHRoZSBmaXJzdCBkYXRlIGFmdGVyIHRoZSBzZWNvbmQgb25lP1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSXMgdGhlIGZpcnN0IGRhdGUgYWZ0ZXIgdGhlIHNlY29uZCBvbmU/XG4gICAqXG4gICAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdGhhdCBzaG91bGQgYmUgYWZ0ZXIgdGhlIG90aGVyIG9uZSB0byByZXR1cm4gdHJ1ZVxuICAgKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZVRvQ29tcGFyZSAtIHRoZSBkYXRlIHRvIGNvbXBhcmUgd2l0aFxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAgICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGZpcnN0IGRhdGUgaXMgYWZ0ZXIgdGhlIHNlY29uZCBkYXRlXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gSXMgMTAgSnVseSAxOTg5IGFmdGVyIDExIEZlYnJ1YXJ5IDE5ODc/XG4gICAqIHZhciByZXN1bHQgPSBpc0FmdGVyKG5ldyBEYXRlKDE5ODksIDYsIDEwKSwgbmV3IERhdGUoMTk4NywgMSwgMTEpKVxuICAgKiAvLz0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlzQWZ0ZXIgKGRpcnR5RGF0ZSwgZGlydHlEYXRlVG9Db21wYXJlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXG4gICAgfVxuXG4gICAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICAgIHZhciBkYXRlVG9Db21wYXJlID0gdG9EYXRlKGRpcnR5RGF0ZVRvQ29tcGFyZSwgZGlydHlPcHRpb25zKTtcbiAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgPiBkYXRlVG9Db21wYXJlLmdldFRpbWUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIGlzQmVmb3JlXG4gICAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICAgKiBAc3VtbWFyeSBJcyB0aGUgZmlyc3QgZGF0ZSBiZWZvcmUgdGhlIHNlY29uZCBvbmU/XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBJcyB0aGUgZmlyc3QgZGF0ZSBiZWZvcmUgdGhlIHNlY29uZCBvbmU/XG4gICAqXG4gICAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdGhhdCBzaG91bGQgYmUgYmVmb3JlIHRoZSBvdGhlciBvbmUgdG8gcmV0dXJuIHRydWVcbiAgICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGVUb0NvbXBhcmUgLSB0aGUgZGF0ZSB0byBjb21wYXJlIHdpdGhcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XG4gICAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBmaXJzdCBkYXRlIGlzIGJlZm9yZSB0aGUgc2Vjb25kIGRhdGVcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBJcyAxMCBKdWx5IDE5ODkgYmVmb3JlIDExIEZlYnJ1YXJ5IDE5ODc/XG4gICAqIHZhciByZXN1bHQgPSBpc0JlZm9yZShuZXcgRGF0ZSgxOTg5LCA2LCAxMCksIG5ldyBEYXRlKDE5ODcsIDEsIDExKSlcbiAgICogLy89PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNCZWZvcmUgKGRpcnR5RGF0ZSwgZGlydHlEYXRlVG9Db21wYXJlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXG4gICAgfVxuXG4gICAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICAgIHZhciBkYXRlVG9Db21wYXJlID0gdG9EYXRlKGRpcnR5RGF0ZVRvQ29tcGFyZSwgZGlydHlPcHRpb25zKTtcbiAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgPCBkYXRlVG9Db21wYXJlLmdldFRpbWUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIGlzRXF1YWxcbiAgICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gICAqIEBzdW1tYXJ5IEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgZXF1YWw/XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGVxdWFsP1xuICAgKlxuICAgKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZUxlZnQgLSB0aGUgZmlyc3QgZGF0ZSB0byBjb21wYXJlXG4gICAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlUmlnaHQgLSB0aGUgc2Vjb25kIGRhdGUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAgICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGRhdGVzIGFyZSBlcXVhbFxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEFyZSAyIEp1bHkgMjAxNCAwNjozMDo0NS4wMDAgYW5kIDIgSnVseSAyMDE0IDA2OjMwOjQ1LjUwMCBlcXVhbD9cbiAgICogdmFyIHJlc3VsdCA9IGlzRXF1YWwoXG4gICAqICAgbmV3IERhdGUoMjAxNCwgNiwgMiwgNiwgMzAsIDQ1LCAwKVxuICAgKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDYsIDMwLCA0NSwgNTAwKVxuICAgKiApXG4gICAqIC8vPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzRXF1YWwgKGRpcnR5TGVmdERhdGUsIGRpcnR5UmlnaHREYXRlLCBkaXJ0eU9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXG4gICAgfVxuXG4gICAgdmFyIGRhdGVMZWZ0ID0gdG9EYXRlKGRpcnR5TGVmdERhdGUsIGRpcnR5T3B0aW9ucyk7XG4gICAgdmFyIGRhdGVSaWdodCA9IHRvRGF0ZShkaXJ0eVJpZ2h0RGF0ZSwgZGlydHlPcHRpb25zKTtcbiAgICByZXR1cm4gZGF0ZUxlZnQuZ2V0VGltZSgpID09PSBkYXRlUmlnaHQuZ2V0VGltZSgpXG4gIH1cblxuICB2YXIgcGF0dGVybnMkMSA9IHtcbiAgICAnTSc6IC9eKDFbMC0yXXwwP1xcZCkvLCAvLyAwIHRvIDEyXG4gICAgJ0QnOiAvXigzWzAtMV18WzAtMl0/XFxkKS8sIC8vIDAgdG8gMzFcbiAgICAnREREJzogL14oMzZbMC02XXwzWzAtNV1cXGR8WzAtMl0/XFxkP1xcZCkvLCAvLyAwIHRvIDM2NlxuICAgICdXJzogL14oNVswLTNdfFswLTRdP1xcZCkvLCAvLyAwIHRvIDUzXG4gICAgJ1lZWVknOiAvXihcXGR7MSw0fSkvLCAvLyAwIHRvIDk5OTlcbiAgICAnSCc6IC9eKDJbMC0zXXxbMC0xXT9cXGQpLywgLy8gMCB0byAyM1xuICAgICdtJzogL14oWzAtNV0/XFxkKS8sIC8vIDAgdG8gNTlcbiAgICAnWic6IC9eKFsrLV0pKFxcZHsyfSk6KFxcZHsyfSkvLFxuICAgICdaWic6IC9eKFsrLV0pKFxcZHsyfSkoXFxkezJ9KS8sXG4gICAgc2luZ2xlRGlnaXQ6IC9eKFxcZCkvLFxuICAgIHR3b0RpZ2l0czogL14oXFxkezJ9KS8sXG4gICAgdGhyZWVEaWdpdHM6IC9eKFxcZHszfSkvLFxuICAgIGZvdXJEaWdpdHM6IC9eKFxcZHs0fSkvLFxuICAgIGFueURpZ2l0czogL14oXFxkKykvXG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VEZWNpbWFsJDEgKG1hdGNoUmVzdWx0KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KG1hdGNoUmVzdWx0WzFdLCAxMClcbiAgfVxuXG4gIHZhciBwYXJzZXJzID0ge1xuICAgIC8vIFllYXI6IDAwLCAwMSwgLi4uLCA5OVxuICAgICdZWSc6IHtcbiAgICAgIHVuaXQ6ICd0d29EaWdpdFllYXInLFxuICAgICAgbWF0Y2g6IHBhdHRlcm5zJDEudHdvRGlnaXRzLFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcGFyc2VEZWNpbWFsJDEobWF0Y2hSZXN1bHQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFllYXI6IDE5MDAsIDE5MDEsIC4uLiwgMjA5OVxuICAgICdZWVlZJzoge1xuICAgICAgdW5pdDogJ3llYXInLFxuICAgICAgbWF0Y2g6IHBhdHRlcm5zJDEuWVlZWSxcbiAgICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICAgIH0sXG5cbiAgICAvLyBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogMDAsIDAxLCAuLi4sIDk5XG4gICAgJ0dHJzoge1xuICAgICAgdW5pdDogJ2lzb1llYXInLFxuICAgICAgbWF0Y2g6IHBhdHRlcm5zJDEudHdvRGlnaXRzLFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcGFyc2VEZWNpbWFsJDEobWF0Y2hSZXN1bHQpICsgMTkwMFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogMTkwMCwgMTkwMSwgLi4uLCAyMDk5XG4gICAgJ0dHR0cnOiB7XG4gICAgICB1bml0OiAnaXNvWWVhcicsXG4gICAgICBtYXRjaDogcGF0dGVybnMkMS5ZWVlZLFxuICAgICAgcGFyc2U6IHBhcnNlRGVjaW1hbCQxXG4gICAgfSxcblxuICAgIC8vIFF1YXJ0ZXI6IDEsIDIsIDMsIDRcbiAgICAnUSc6IHtcbiAgICAgIHVuaXQ6ICdxdWFydGVyJyxcbiAgICAgIG1hdGNoOiBwYXR0ZXJucyQxLnNpbmdsZURpZ2l0LFxuICAgICAgcGFyc2U6IHBhcnNlRGVjaW1hbCQxXG4gICAgfSxcblxuICAgIC8vIE9yZGluYWwgcXVhcnRlclxuICAgICdRbyc6IHtcbiAgICAgIHVuaXQ6ICdxdWFydGVyJyxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5vcmRpbmFsTnVtYmVycyhzdHJpbmcsIHt1bml0OiAncXVhcnRlcid9KVxuICAgICAgfSxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXIobWF0Y2hSZXN1bHQsIHt1bml0OiAncXVhcnRlcid9KVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBNb250aDogMSwgMiwgLi4uLCAxMlxuICAgICdNJzoge1xuICAgICAgdW5pdDogJ21vbnRoJyxcbiAgICAgIG1hdGNoOiBwYXR0ZXJucyQxLk0sXG4gICAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBwYXJzZURlY2ltYWwkMShtYXRjaFJlc3VsdCkgLSAxXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIE9yZGluYWwgbW9udGhcbiAgICAnTW8nOiB7XG4gICAgICB1bml0OiAnbW9udGgnLFxuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXJzKHN0cmluZywge3VuaXQ6ICdtb250aCd9KVxuICAgICAgfSxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXIobWF0Y2hSZXN1bHQsIHt1bml0OiAnbW9udGgnfSkgLSAxXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIE1vbnRoOiAwMSwgMDIsIC4uLiwgMTJcbiAgICAnTU0nOiB7XG4gICAgICB1bml0OiAnbW9udGgnLFxuICAgICAgbWF0Y2g6IHBhdHRlcm5zJDEudHdvRGlnaXRzLFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcGFyc2VEZWNpbWFsJDEobWF0Y2hSZXN1bHQpIC0gMVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBNb250aDogSmFuLCBGZWIsIC4uLiwgRGVjXG4gICAgJ01NTSc6IHtcbiAgICAgIHVuaXQ6ICdtb250aCcsXG4gICAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gubW9udGhzKHN0cmluZywge3R5cGU6ICdzaG9ydCd9KVxuICAgICAgfSxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm1vbnRoKG1hdGNoUmVzdWx0LCB7dHlwZTogJ3Nob3J0J30pXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIE1vbnRoOiBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxuICAgICdNTU1NJzoge1xuICAgICAgdW5pdDogJ21vbnRoJyxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5tb250aHMoc3RyaW5nLCB7dHlwZTogJ2xvbmcnfSkgfHxcbiAgICAgICAgICBvcHRpb25zLmxvY2FsZS5tYXRjaC5tb250aHMoc3RyaW5nLCB7dHlwZTogJ3Nob3J0J30pXG4gICAgICB9LFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC5tb250aChtYXRjaFJlc3VsdCwge3R5cGU6ICdsb25nJ30pO1xuXG4gICAgICAgIGlmIChwYXJzZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC5tb250aChtYXRjaFJlc3VsdCwge3R5cGU6ICdzaG9ydCd9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZVJlc3VsdFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBJU08gd2VlazogMSwgMiwgLi4uLCA1M1xuICAgICdXJzoge1xuICAgICAgdW5pdDogJ2lzb1dlZWsnLFxuICAgICAgbWF0Y2g6IHBhdHRlcm5zJDEuVyxcbiAgICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICAgIH0sXG5cbiAgICAvLyBPcmRpbmFsIElTTyB3ZWVrXG4gICAgJ1dvJzoge1xuICAgICAgdW5pdDogJ2lzb1dlZWsnLFxuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXJzKHN0cmluZywge3VuaXQ6ICdpc29XZWVrJ30pXG4gICAgICB9LFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcihtYXRjaFJlc3VsdCwge3VuaXQ6ICdpc29XZWVrJ30pXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIElTTyB3ZWVrOiAwMSwgMDIsIC4uLiwgNTNcbiAgICAnV1cnOiB7XG4gICAgICB1bml0OiAnaXNvV2VlaycsXG4gICAgICBtYXRjaDogcGF0dGVybnMkMS50d29EaWdpdHMsXG4gICAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgICB9LFxuXG4gICAgLy8gRGF5IG9mIHdlZWs6IDAsIDEsIC4uLiwgNlxuICAgICdkJzoge1xuICAgICAgdW5pdDogJ2RheU9mV2VlaycsXG4gICAgICBtYXRjaDogcGF0dGVybnMkMS5zaW5nbGVEaWdpdCxcbiAgICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICAgIH0sXG5cbiAgICAvLyBPcmRpbmFsIGRheSBvZiB3ZWVrXG4gICAgJ2RvJzoge1xuICAgICAgdW5pdDogJ2RheU9mV2VlaycsXG4gICAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcnMoc3RyaW5nLCB7dW5pdDogJ2RheU9mV2Vlayd9KVxuICAgICAgfSxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXIobWF0Y2hSZXN1bHQsIHt1bml0OiAnZGF5T2ZXZWVrJ30pXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIERheSBvZiB3ZWVrOiBTdSwgTW8sIC4uLiwgU2FcbiAgICAnZGQnOiB7XG4gICAgICB1bml0OiAnZGF5T2ZXZWVrJyxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5cyhzdHJpbmcsIHt0eXBlOiAnbmFycm93J30pXG4gICAgICB9LFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCwge3R5cGU6ICduYXJyb3cnfSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gRGF5IG9mIHdlZWs6IFN1biwgTW9uLCAuLi4sIFNhdFxuICAgICdkZGQnOiB7XG4gICAgICB1bml0OiAnZGF5T2ZXZWVrJyxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5cyhzdHJpbmcsIHt0eXBlOiAnc2hvcnQnfSkgfHxcbiAgICAgICAgICBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5cyhzdHJpbmcsIHt0eXBlOiAnbmFycm93J30pXG4gICAgICB9LFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ3Nob3J0J30pO1xuXG4gICAgICAgIGlmIChwYXJzZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ25hcnJvdyd9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZVJlc3VsdFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBEYXkgb2Ygd2VlazogU3VuZGF5LCBNb25kYXksIC4uLiwgU2F0dXJkYXlcbiAgICAnZGRkZCc6IHtcbiAgICAgIHVuaXQ6ICdkYXlPZldlZWsnLFxuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLndlZWtkYXlzKHN0cmluZywge3R5cGU6ICdsb25nJ30pIHx8XG4gICAgICAgICAgb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheXMoc3RyaW5nLCB7dHlwZTogJ3Nob3J0J30pIHx8XG4gICAgICAgICAgb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheXMoc3RyaW5nLCB7dHlwZTogJ25hcnJvdyd9KVxuICAgICAgfSxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCwge3R5cGU6ICdsb25nJ30pO1xuXG4gICAgICAgIGlmIChwYXJzZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC53ZWVrZGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ3Nob3J0J30pO1xuXG4gICAgICAgICAgaWYgKHBhcnNlUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gud2Vla2RheShtYXRjaFJlc3VsdCwge3R5cGU6ICduYXJyb3cnfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIERheSBvZiBJU08gd2VlazogMSwgMiwgLi4uLCA3XG4gICAgJ0UnOiB7XG4gICAgICB1bml0OiAnZGF5T2ZJU09XZWVrJyxcbiAgICAgIG1hdGNoOiBwYXR0ZXJucyQxLnNpbmdsZURpZ2l0LFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcGFyc2VEZWNpbWFsJDEobWF0Y2hSZXN1bHQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIERheSBvZiBtb250aDogMSwgMiwgLi4uLCAzMVxuICAgICdEJzoge1xuICAgICAgdW5pdDogJ2RheU9mTW9udGgnLFxuICAgICAgbWF0Y2g6IHBhdHRlcm5zJDEuRCxcbiAgICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICAgIH0sXG5cbiAgICAvLyBPcmRpbmFsIGRheSBvZiBtb250aFxuICAgICdEbyc6IHtcbiAgICAgIHVuaXQ6ICdkYXlPZk1vbnRoJyxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC5vcmRpbmFsTnVtYmVycyhzdHJpbmcsIHt1bml0OiAnZGF5T2ZNb250aCd9KVxuICAgICAgfSxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXIobWF0Y2hSZXN1bHQsIHt1bml0OiAnZGF5T2ZNb250aCd9KVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBEYXkgb2YgbW9udGg6IDAxLCAwMiwgLi4uLCAzMVxuICAgICdERCc6IHtcbiAgICAgIHVuaXQ6ICdkYXlPZk1vbnRoJyxcbiAgICAgIG1hdGNoOiBwYXR0ZXJucyQxLnR3b0RpZ2l0cyxcbiAgICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICAgIH0sXG5cbiAgICAvLyBEYXkgb2YgeWVhcjogMSwgMiwgLi4uLCAzNjZcbiAgICAnREREJzoge1xuICAgICAgdW5pdDogJ2RheU9mWWVhcicsXG4gICAgICBtYXRjaDogcGF0dGVybnMkMS5EREQsXG4gICAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgICB9LFxuXG4gICAgLy8gT3JkaW5hbCBkYXkgb2YgeWVhclxuICAgICdERERvJzoge1xuICAgICAgdW5pdDogJ2RheU9mWWVhcicsXG4gICAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gub3JkaW5hbE51bWJlcnMoc3RyaW5nLCB7dW5pdDogJ2RheU9mWWVhcid9KVxuICAgICAgfSxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLm9yZGluYWxOdW1iZXIobWF0Y2hSZXN1bHQsIHt1bml0OiAnZGF5T2ZZZWFyJ30pXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIERheSBvZiB5ZWFyOiAwMDEsIDAwMiwgLi4uLCAzNjZcbiAgICAnRERERCc6IHtcbiAgICAgIHVuaXQ6ICdkYXlPZlllYXInLFxuICAgICAgbWF0Y2g6IHBhdHRlcm5zJDEudGhyZWVEaWdpdHMsXG4gICAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgICB9LFxuXG4gICAgLy8gQU0sIFBNXG4gICAgJ0EnOiB7XG4gICAgICB1bml0OiAndGltZU9mRGF5JyxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiAoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZS5tYXRjaC50aW1lc09mRGF5KHN0cmluZywge3R5cGU6ICdzaG9ydCd9KVxuICAgICAgfSxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9jYWxlLm1hdGNoLnRpbWVPZkRheShtYXRjaFJlc3VsdCwge3R5cGU6ICdzaG9ydCd9KVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBhLm0uLCBwLm0uXG4gICAgJ2FhJzoge1xuICAgICAgdW5pdDogJ3RpbWVPZkRheScsXG4gICAgICBtYXRjaDogZnVuY3Rpb24gKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5sb2NhbGUubWF0Y2gudGltZXNPZkRheShzdHJpbmcsIHt0eXBlOiAnbG9uZyd9KSB8fFxuICAgICAgICAgIG9wdGlvbnMubG9jYWxlLm1hdGNoLnRpbWVzT2ZEYXkoc3RyaW5nLCB7dHlwZTogJ3Nob3J0J30pXG4gICAgICB9LFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcGFyc2VSZXN1bHQgPSBvcHRpb25zLmxvY2FsZS5tYXRjaC50aW1lT2ZEYXkobWF0Y2hSZXN1bHQsIHt0eXBlOiAnbG9uZyd9KTtcblxuICAgICAgICBpZiAocGFyc2VSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHBhcnNlUmVzdWx0ID0gb3B0aW9ucy5sb2NhbGUubWF0Y2gudGltZU9mRGF5KG1hdGNoUmVzdWx0LCB7dHlwZTogJ3Nob3J0J30pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIEhvdXI6IDAsIDEsIC4uLiAyM1xuICAgICdIJzoge1xuICAgICAgdW5pdDogJ2hvdXJzJyxcbiAgICAgIG1hdGNoOiBwYXR0ZXJucyQxLkgsXG4gICAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgICB9LFxuXG4gICAgLy8gSG91cjogMDAsIDAxLCAuLi4sIDIzXG4gICAgJ0hIJzoge1xuICAgICAgdW5pdDogJ2hvdXJzJyxcbiAgICAgIG1hdGNoOiBwYXR0ZXJucyQxLnR3b0RpZ2l0cyxcbiAgICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICAgIH0sXG5cbiAgICAvLyBIb3VyOiAxLCAyLCAuLi4sIDEyXG4gICAgJ2gnOiB7XG4gICAgICB1bml0OiAndGltZU9mRGF5SG91cnMnLFxuICAgICAgbWF0Y2g6IHBhdHRlcm5zJDEuTSxcbiAgICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICAgIH0sXG5cbiAgICAvLyBIb3VyOiAwMSwgMDIsIC4uLiwgMTJcbiAgICAnaGgnOiB7XG4gICAgICB1bml0OiAndGltZU9mRGF5SG91cnMnLFxuICAgICAgbWF0Y2g6IHBhdHRlcm5zJDEudHdvRGlnaXRzLFxuICAgICAgcGFyc2U6IHBhcnNlRGVjaW1hbCQxXG4gICAgfSxcblxuICAgIC8vIE1pbnV0ZTogMCwgMSwgLi4uLCA1OVxuICAgICdtJzoge1xuICAgICAgdW5pdDogJ21pbnV0ZXMnLFxuICAgICAgbWF0Y2g6IHBhdHRlcm5zJDEubSxcbiAgICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICAgIH0sXG5cbiAgICAvLyBNaW51dGU6IDAwLCAwMSwgLi4uLCA1OVxuICAgICdtbSc6IHtcbiAgICAgIHVuaXQ6ICdtaW51dGVzJyxcbiAgICAgIG1hdGNoOiBwYXR0ZXJucyQxLnR3b0RpZ2l0cyxcbiAgICAgIHBhcnNlOiBwYXJzZURlY2ltYWwkMVxuICAgIH0sXG5cbiAgICAvLyBTZWNvbmQ6IDAsIDEsIC4uLiwgNTlcbiAgICAncyc6IHtcbiAgICAgIHVuaXQ6ICdzZWNvbmRzJyxcbiAgICAgIG1hdGNoOiBwYXR0ZXJucyQxLm0sXG4gICAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgICB9LFxuXG4gICAgLy8gU2Vjb25kOiAwMCwgMDEsIC4uLiwgNTlcbiAgICAnc3MnOiB7XG4gICAgICB1bml0OiAnc2Vjb25kcycsXG4gICAgICBtYXRjaDogcGF0dGVybnMkMS50d29EaWdpdHMsXG4gICAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgICB9LFxuXG4gICAgLy8gMS8xMCBvZiBzZWNvbmQ6IDAsIDEsIC4uLiwgOVxuICAgICdTJzoge1xuICAgICAgdW5pdDogJ21pbGxpc2Vjb25kcycsXG4gICAgICBtYXRjaDogcGF0dGVybnMkMS5zaW5nbGVEaWdpdCxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCQxKG1hdGNoUmVzdWx0KSAqIDEwMFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAxLzEwMCBvZiBzZWNvbmQ6IDAwLCAwMSwgLi4uLCA5OVxuICAgICdTUyc6IHtcbiAgICAgIHVuaXQ6ICdtaWxsaXNlY29uZHMnLFxuICAgICAgbWF0Y2g6IHBhdHRlcm5zJDEudHdvRGlnaXRzLFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIChtYXRjaFJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcGFyc2VEZWNpbWFsJDEobWF0Y2hSZXN1bHQpICogMTBcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gTWlsbGlzZWNvbmQ6IDAwMCwgMDAxLCAuLi4sIDk5OVxuICAgICdTU1MnOiB7XG4gICAgICB1bml0OiAnbWlsbGlzZWNvbmRzJyxcbiAgICAgIG1hdGNoOiBwYXR0ZXJucyQxLnRocmVlRGlnaXRzLFxuICAgICAgcGFyc2U6IHBhcnNlRGVjaW1hbCQxXG4gICAgfSxcblxuICAgIC8vIFRpbWV6b25lOiAtMDE6MDAsICswMDowMCwgLi4uICsxMjowMFxuICAgICdaJzoge1xuICAgICAgdW5pdDogJ3RpbWV6b25lJyxcbiAgICAgIG1hdGNoOiBwYXR0ZXJucyQxLlosXG4gICAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0KSB7XG4gICAgICAgIHZhciBzaWduID0gbWF0Y2hSZXN1bHRbMV07XG4gICAgICAgIHZhciBob3VycyA9IHBhcnNlSW50KG1hdGNoUmVzdWx0WzJdLCAxMCk7XG4gICAgICAgIHZhciBtaW51dGVzID0gcGFyc2VJbnQobWF0Y2hSZXN1bHRbM10sIDEwKTtcbiAgICAgICAgdmFyIGFic29sdXRlT2Zmc2V0ID0gaG91cnMgKiA2MCArIG1pbnV0ZXM7XG4gICAgICAgIHJldHVybiAoc2lnbiA9PT0gJysnKSA/IGFic29sdXRlT2Zmc2V0IDogLWFic29sdXRlT2Zmc2V0XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFRpbWV6b25lOiAtMDEwMCwgKzAwMDAsIC4uLiArMTIwMFxuICAgICdaWic6IHtcbiAgICAgIHVuaXQ6ICd0aW1lem9uZScsXG4gICAgICBtYXRjaDogcGF0dGVybnMkMS5aWixcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiAobWF0Y2hSZXN1bHQpIHtcbiAgICAgICAgdmFyIHNpZ24gPSBtYXRjaFJlc3VsdFsxXTtcbiAgICAgICAgdmFyIGhvdXJzID0gcGFyc2VJbnQobWF0Y2hSZXN1bHRbMl0sIDEwKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSBwYXJzZUludChtYXRjaFJlc3VsdFszXSwgMTApO1xuICAgICAgICB2YXIgYWJzb2x1dGVPZmZzZXQgPSBob3VycyAqIDYwICsgbWludXRlcztcbiAgICAgICAgcmV0dXJuIChzaWduID09PSAnKycpID8gYWJzb2x1dGVPZmZzZXQgOiAtYWJzb2x1dGVPZmZzZXRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2Vjb25kcyB0aW1lc3RhbXA6IDUxMjk2OTUyMFxuICAgICdYJzoge1xuICAgICAgdW5pdDogJ3RpbWVzdGFtcCcsXG4gICAgICBtYXRjaDogcGF0dGVybnMkMS5hbnlEaWdpdHMsXG4gICAgICBwYXJzZTogZnVuY3Rpb24gKG1hdGNoUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBwYXJzZURlY2ltYWwkMShtYXRjaFJlc3VsdCkgKiAxMDAwXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIE1pbGxpc2Vjb25kcyB0aW1lc3RhbXA6IDUxMjk2OTUyMDkwMFxuICAgICd4Jzoge1xuICAgICAgdW5pdDogJ3RpbWVzdGFtcCcsXG4gICAgICBtYXRjaDogcGF0dGVybnMkMS5hbnlEaWdpdHMsXG4gICAgICBwYXJzZTogcGFyc2VEZWNpbWFsJDFcbiAgICB9XG4gIH07XG5cbiAgcGFyc2Vyc1snYSddID0gcGFyc2Vyc1snQSddO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuICAvLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG4gIGZ1bmN0aW9uIHNldFVUQ0RheSAoZGlydHlEYXRlLCBkaXJ0eURheSwgZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XG4gICAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICAgIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xuICAgIHZhciBkZWZhdWx0V2Vla1N0YXJ0c09uID0gbG9jYWxlV2Vla1N0YXJ0c09uID09PSB1bmRlZmluZWQgPyAwIDogTnVtYmVyKGxvY2FsZVdlZWtTdGFydHNPbik7XG4gICAgdmFyIHdlZWtTdGFydHNPbiA9IG9wdGlvbnMud2Vla1N0YXJ0c09uID09PSB1bmRlZmluZWQgPyBkZWZhdWx0V2Vla1N0YXJ0c09uIDogTnVtYmVyKG9wdGlvbnMud2Vla1N0YXJ0c09uKTtcblxuICAgIC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXG4gICAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd2Vla1N0YXJ0c09uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2IGluY2x1c2l2ZWx5JylcbiAgICB9XG5cbiAgICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gICAgdmFyIGRheSA9IE51bWJlcihkaXJ0eURheSk7XG5cbiAgICB2YXIgY3VycmVudERheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG5cbiAgICB2YXIgcmVtYWluZGVyID0gZGF5ICUgNztcbiAgICB2YXIgZGF5SW5kZXggPSAocmVtYWluZGVyICsgNykgJSA3O1xuXG4gICAgdmFyIGRpZmYgPSAoZGF5SW5kZXggPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSBjdXJyZW50RGF5O1xuXG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlmZik7XG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuICAvLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG4gIGZ1bmN0aW9uIHNldFVUQ0lTT0RheSAoZGlydHlEYXRlLCBkaXJ0eURheSwgZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIGRheSA9IE51bWJlcihkaXJ0eURheSk7XG5cbiAgICBpZiAoZGF5ICUgNyA9PT0gMCkge1xuICAgICAgZGF5ID0gZGF5IC0gNztcbiAgICB9XG5cbiAgICB2YXIgd2Vla1N0YXJ0c09uID0gMTtcbiAgICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XG4gICAgdmFyIGN1cnJlbnREYXkgPSBkYXRlLmdldFVUQ0RheSgpO1xuXG4gICAgdmFyIHJlbWFpbmRlciA9IGRheSAlIDc7XG4gICAgdmFyIGRheUluZGV4ID0gKHJlbWFpbmRlciArIDcpICUgNztcblxuICAgIHZhciBkaWZmID0gKGRheUluZGV4IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gY3VycmVudERheTtcblxuICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICAgIHJldHVybiBkYXRlXG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cbiAgLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxuICBmdW5jdGlvbiBzZXRVVENJU09XZWVrIChkaXJ0eURhdGUsIGRpcnR5SVNPV2VlaywgZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICAgIHZhciBpc29XZWVrID0gTnVtYmVyKGRpcnR5SVNPV2Vlayk7XG4gICAgdmFyIGRpZmYgPSBnZXRVVENJU09XZWVrKGRhdGUsIGRpcnR5T3B0aW9ucykgLSBpc29XZWVrO1xuICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIGRpZmYgKiA3KTtcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgdmFyIE1JTExJU0VDT05EU19JTl9EQVkkMyA9IDg2NDAwMDAwO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxuICAvLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XG4gIGZ1bmN0aW9uIHNldFVUQ0lTT1dlZWtZZWFyIChkaXJ0eURhdGUsIGRpcnR5SVNPWWVhciwgZGlydHlPcHRpb25zKSB7XG4gICAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICAgIHZhciBpc29ZZWFyID0gTnVtYmVyKGRpcnR5SVNPWWVhcik7XG4gICAgdmFyIGRhdGVTdGFydE9mWWVhciA9IHN0YXJ0T2ZVVENJU09XZWVrWWVhcihkYXRlLCBkaXJ0eU9wdGlvbnMpO1xuICAgIHZhciBkaWZmID0gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSBkYXRlU3RhcnRPZlllYXIuZ2V0VGltZSgpKSAvIE1JTExJU0VDT05EU19JTl9EQVkkMyk7XG4gICAgdmFyIGZvdXJ0aE9mSmFudWFyeSA9IG5ldyBEYXRlKDApO1xuICAgIGZvdXJ0aE9mSmFudWFyeS5zZXRVVENGdWxsWWVhcihpc29ZZWFyLCAwLCA0KTtcbiAgICBmb3VydGhPZkphbnVhcnkuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZSA9IHN0YXJ0T2ZVVENJU09XZWVrWWVhcihmb3VydGhPZkphbnVhcnksIGRpcnR5T3B0aW9ucyk7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlmZik7XG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG4gIHZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDYgPSA2MDAwMDtcblxuICBmdW5jdGlvbiBzZXRUaW1lT2ZEYXkgKGhvdXJzLCB0aW1lT2ZEYXkpIHtcbiAgICB2YXIgaXNBTSA9IHRpbWVPZkRheSA9PT0gMDtcblxuICAgIGlmIChpc0FNKSB7XG4gICAgICBpZiAoaG91cnMgPT09IDEyKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChob3VycyAhPT0gMTIpIHtcbiAgICAgICAgcmV0dXJuIDEyICsgaG91cnNcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaG91cnNcbiAgfVxuXG4gIHZhciB1bml0cyA9IHtcbiAgICB0d29EaWdpdFllYXI6IHtcbiAgICAgIHByaW9yaXR5OiAxMCxcbiAgICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlKSB7XG4gICAgICAgIHZhciBjZW50dXJ5ID0gTWF0aC5mbG9vcihkYXRlVmFsdWVzLmRhdGUuZ2V0VVRDRnVsbFllYXIoKSAvIDEwMCk7XG4gICAgICAgIHZhciB5ZWFyID0gY2VudHVyeSAqIDEwMCArIHZhbHVlO1xuICAgICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgMSk7XG4gICAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgeWVhcjoge1xuICAgICAgcHJpb3JpdHk6IDEwLFxuICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0Z1bGxZZWFyKHZhbHVlLCAwLCAxKTtcbiAgICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc29ZZWFyOiB7XG4gICAgICBwcmlvcml0eTogMTAsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBkYXRlVmFsdWVzLmRhdGUgPSBzdGFydE9mVVRDSVNPV2Vla1llYXIoc2V0VVRDSVNPV2Vla1llYXIoZGF0ZVZhbHVlcy5kYXRlLCB2YWx1ZSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBxdWFydGVyOiB7XG4gICAgICBwcmlvcml0eTogMjAsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSkge1xuICAgICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDTW9udGgoKHZhbHVlIC0gMSkgKiAzLCAxKTtcbiAgICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBtb250aDoge1xuICAgICAgcHJpb3JpdHk6IDMwLFxuICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ01vbnRoKHZhbHVlLCAxKTtcbiAgICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc29XZWVrOiB7XG4gICAgICBwcmlvcml0eTogNDAsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBkYXRlVmFsdWVzLmRhdGUgPSBzdGFydE9mVVRDSVNPV2VlayhzZXRVVENJU09XZWVrKGRhdGVWYWx1ZXMuZGF0ZSwgdmFsdWUsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF5T2ZXZWVrOiB7XG4gICAgICBwcmlvcml0eTogNTAsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBkYXRlVmFsdWVzLmRhdGUgPSBzZXRVVENEYXkoZGF0ZVZhbHVlcy5kYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF5T2ZJU09XZWVrOiB7XG4gICAgICBwcmlvcml0eTogNTAsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBkYXRlVmFsdWVzLmRhdGUgPSBzZXRVVENJU09EYXkoZGF0ZVZhbHVlcy5kYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF5T2ZNb250aDoge1xuICAgICAgcHJpb3JpdHk6IDUwLFxuICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0RhdGUodmFsdWUpO1xuICAgICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgICB9XG4gICAgfSxcblxuICAgIGRheU9mWWVhcjoge1xuICAgICAgcHJpb3JpdHk6IDUwLFxuICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ01vbnRoKDAsIHZhbHVlKTtcbiAgICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0aW1lT2ZEYXk6IHtcbiAgICAgIHByaW9yaXR5OiA2MCxcbiAgICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGRhdGVWYWx1ZXMudGltZU9mRGF5ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgICB9XG4gICAgfSxcblxuICAgIGhvdXJzOiB7XG4gICAgICBwcmlvcml0eTogNzAsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDSG91cnModmFsdWUsIDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0aW1lT2ZEYXlIb3Vyczoge1xuICAgICAgcHJpb3JpdHk6IDcwLFxuICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRpbWVPZkRheSA9IGRhdGVWYWx1ZXMudGltZU9mRGF5O1xuICAgICAgICBpZiAodGltZU9mRGF5ICE9IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNldFRpbWVPZkRheSh2YWx1ZSwgdGltZU9mRGF5KTtcbiAgICAgICAgfVxuICAgICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDSG91cnModmFsdWUsIDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBtaW51dGVzOiB7XG4gICAgICBwcmlvcml0eTogODAsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlVmFsdWVzLCB2YWx1ZSkge1xuICAgICAgICBkYXRlVmFsdWVzLmRhdGUuc2V0VVRDTWludXRlcyh2YWx1ZSwgMCwgMCk7XG4gICAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNlY29uZHM6IHtcbiAgICAgIHByaW9yaXR5OiA5MCxcbiAgICAgIHNldDogZnVuY3Rpb24gKGRhdGVWYWx1ZXMsIHZhbHVlKSB7XG4gICAgICAgIGRhdGVWYWx1ZXMuZGF0ZS5zZXRVVENTZWNvbmRzKHZhbHVlLCAwKTtcbiAgICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbWlsbGlzZWNvbmRzOiB7XG4gICAgICBwcmlvcml0eTogMTAwLFxuICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgICAgZGF0ZVZhbHVlcy5kYXRlLnNldFVUQ01pbGxpc2Vjb25kcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBkYXRlVmFsdWVzXG4gICAgICB9XG4gICAgfSxcblxuICAgIHRpbWV6b25lOiB7XG4gICAgICBwcmlvcml0eTogMTEwLFxuICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgICAgZGF0ZVZhbHVlcy5kYXRlID0gbmV3IERhdGUoZGF0ZVZhbHVlcy5kYXRlLmdldFRpbWUoKSAtIHZhbHVlICogTUlMTElTRUNPTkRTX0lOX01JTlVURSQ2KTtcbiAgICAgICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGltZXN0YW1wOiB7XG4gICAgICBwcmlvcml0eTogMTIwLFxuICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZVZhbHVlcywgdmFsdWUpIHtcbiAgICAgICAgZGF0ZVZhbHVlcy5kYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICByZXR1cm4gZGF0ZVZhbHVlc1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgVElNRVpPTkVfVU5JVF9QUklPUklUWSA9IDExMDtcbiAgdmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUkNyA9IDYwMDAwO1xuXG4gIHZhciBsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCQxID0gLyhcXFtbXltdKl0pfChcXFxcKT8oTFRTfExUfExMTEx8TExMfExMfEx8bGxsbHxsbGx8bGx8bCkvZztcbiAgdmFyIGRlZmF1bHRQYXJzaW5nVG9rZW5zUmVnRXhwID0gLyhcXFtbXltdKl0pfChcXFxcKT8oeHxzc3xzfG1tfG18aGh8aHxkb3xkZGRkfGRkZHxkZHxkfGFhfGF8Wlp8WnxZWVlZfFlZfFh8V298V1d8V3xTU1N8U1N8U3xRb3xRfE1vfE1NTU18TU1NfE1NfE18SEh8SHxHR0dHfEdHfEV8RG98REREb3xEREREfERERHxERHxEfEF8LikvZztcblxuICAvKipcbiAgICogQG5hbWUgcGFyc2VcbiAgICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gICAqIEBzdW1tYXJ5IFBhcnNlIHRoZSBkYXRlLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0dXJuIHRoZSBkYXRlIHBhcnNlZCBmcm9tIHN0cmluZyB1c2luZyB0aGUgZ2l2ZW4gZm9ybWF0LlxuICAgKlxuICAgKiBBY2NlcHRlZCBmb3JtYXQgdG9rZW5zOlxuICAgKiB8IFVuaXQgICAgICAgICAgICAgICAgICAgIHwgUHJpb3JpdHkgfCBUb2tlbiB8IElucHV0IGV4YW1wbGVzICAgICAgICAgICAgICAgICAgIHxcbiAgICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLXwtLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAqIHwgWWVhciAgICAgICAgICAgICAgICAgICAgfCAxMCAgICAgICB8IFlZICAgIHwgMDAsIDAxLCAuLi4sIDk5ICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBZWVlZICB8IDE5MDAsIDE5MDEsIC4uLiwgMjA5OSAgICAgICAgICAgIHxcbiAgICogfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciB8IDEwICAgICAgIHwgR0cgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IEdHR0cgIHwgMTkwMCwgMTkwMSwgLi4uLCAyMDk5ICAgICAgICAgICAgfFxuICAgKiB8IFF1YXJ0ZXIgICAgICAgICAgICAgICAgIHwgMjAgICAgICAgfCBRICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgUW8gICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICB8XG4gICAqIHwgTW9udGggICAgICAgICAgICAgICAgICAgfCAzMCAgICAgICB8IE0gICAgIHwgMSwgMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBNbyAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgTU0gICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IE1NTSAgIHwgSmFuLCBGZWIsIC4uLiwgRGVjICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBNTU1NICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyIHxcbiAgICogfCBJU08gd2VlayAgICAgICAgICAgICAgICB8IDQwICAgICAgIHwgVyAgICAgfCAxLCAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IFdvICAgIHwgMXN0LCAybmQsIC4uLiwgNTNyZCAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBXVyAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgIHxcbiAgICogfCBEYXkgb2Ygd2VlayAgICAgICAgICAgICB8IDUwICAgICAgIHwgZCAgICAgfCAwLCAxLCAuLi4sIDYgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IGRvICAgIHwgMHRoLCAxc3QsIC4uLiwgNnRoICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBkZCAgICB8IFN1LCBNbywgLi4uLCBTYSAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgZGRkICAgfCBTdW4sIE1vbiwgLi4uLCBTYXQgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IGRkZGQgIHwgU3VuZGF5LCBNb25kYXksIC4uLiwgU2F0dXJkYXkgICAgfFxuICAgKiB8IERheSBvZiBJU08gd2VlayAgICAgICAgIHwgNTAgICAgICAgfCBFICAgICB8IDEsIDIsIC4uLiwgNyAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCBEYXkgb2YgbW9udGggICAgICAgICAgICB8IDUwICAgICAgIHwgRCAgICAgfCAxLCAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IERvICAgIHwgMXN0LCAybmQsIC4uLiwgMzFzdCAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBERCAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgIHxcbiAgICogfCBEYXkgb2YgeWVhciAgICAgICAgICAgICB8IDUwICAgICAgIHwgREREICAgfCAxLCAyLCAuLi4sIDM2NiAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IERERG8gIHwgMXN0LCAybmQsIC4uLiwgMzY2dGggICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBEREREICB8IDAwMSwgMDAyLCAuLi4sIDM2NiAgICAgICAgICAgICAgIHxcbiAgICogfCBUaW1lIG9mIGRheSAgICAgICAgICAgICB8IDYwICAgICAgIHwgQSAgICAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IGEgICAgIHwgYW0sIHBtICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBhYSAgICB8IGEubS4sIHAubS4gICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCBIb3VyICAgICAgICAgICAgICAgICAgICB8IDcwICAgICAgIHwgSCAgICAgfCAwLCAxLCAuLi4gMjMgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IEhIICAgIHwgMDAsIDAxLCAuLi4gMjMgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8IFRpbWUgb2YgZGF5IGhvdXIgICAgICAgIHwgNzAgICAgICAgfCBoICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgaGggICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgTWludXRlICAgICAgICAgICAgICAgICAgfCA4MCAgICAgICB8IG0gICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBtbSAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgIHxcbiAgICogfCBTZWNvbmQgICAgICAgICAgICAgICAgICB8IDkwICAgICAgIHwgcyAgICAgfCAwLCAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8IHNzICAgIHwgMDAsIDAxLCAuLi4sIDU5ICAgICAgICAgICAgICAgICAgfFxuICAgKiB8IDEvMTAgb2Ygc2Vjb25kICAgICAgICAgIHwgMTAwICAgICAgfCBTICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAxLzEwMCBvZiBzZWNvbmQgICAgICAgICB8IDEwMCAgICAgIHwgU1MgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgTWlsbGlzZWNvbmQgICAgICAgICAgICAgfCAxMDAgICAgICB8IFNTUyAgIHwgMDAwLCAwMDEsIC4uLiwgOTk5ICAgICAgICAgICAgICAgfFxuICAgKiB8IFRpbWV6b25lICAgICAgICAgICAgICAgIHwgMTEwICAgICAgfCBaICAgICB8IC0wMTowMCwgKzAwOjAwLCAuLi4gKzEyOjAwICAgICAgIHxcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgWlogICAgfCAtMDEwMCwgKzAwMDAsIC4uLiwgKzEyMDAgICAgICAgICB8XG4gICAqIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgfCAxMjAgICAgICB8IFggICAgIHwgNTEyOTY5NTIwICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgIHwgMTIwICAgICAgfCB4ICAgICB8IDUxMjk2OTUyMDkwMCAgICAgICAgICAgICAgICAgICAgIHxcbiAgICpcbiAgICogVmFsdWVzIHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIGRhdGUgaW4gdGhlIGFzY2VuZGluZyBvcmRlciBvZiBpdHMgdW5pdCdzIHByaW9yaXR5LlxuICAgKiBVbml0cyBvZiBhbiBlcXVhbCBwcmlvcml0eSBvdmVyd3JpdGUgZWFjaCBvdGhlciBpbiB0aGUgb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAgICpcbiAgICogSWYgbm8gdmFsdWVzIG9mIGhpZ2hlciBwcmlvcml0eSBhcmUgcGFyc2VkIChlLmcuIHdoZW4gcGFyc2luZyBzdHJpbmcgJ0phbnVhcnkgMXN0JyB3aXRob3V0IGEgeWVhciksXG4gICAqIHRoZSB2YWx1ZXMgd2lsbCBiZSB0YWtlbiBmcm9tIDNyZCBhcmd1bWVudCBgYmFzZURhdGVgIHdoaWNoIHdvcmtzIGFzIGEgY29udGV4dCBvZiBwYXJzaW5nLlxuICAgKlxuICAgKiBgYmFzZURhdGVgIG11c3QgYmUgcGFzc2VkIGZvciBjb3JyZWN0IHdvcmsgb2YgdGhlIGZ1bmN0aW9uLlxuICAgKiBJZiB5b3UncmUgbm90IHN1cmUgd2hpY2ggYGJhc2VEYXRlYCB0byBzdXBwbHksIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBEYXRlOlxuICAgKiBgcGFyc2UoJzAyLzExLzIwMTQnLCAnTU0vREQvWVlZWScsIG5ldyBEYXRlKCkpYFxuICAgKiBJbiB0aGlzIGNhc2UgcGFyc2luZyB3aWxsIGJlIGRvbmUgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGN1cnJlbnQgZGF0ZS5cbiAgICogSWYgYGJhc2VEYXRlYCBpcyBgSW52YWxpZCBEYXRlYCBvciBhIHZhbHVlIG5vdCBjb252ZXJ0aWJsZSB0byB2YWxpZCBgRGF0ZWAsXG4gICAqIHRoZW4gYEludmFsaWQgRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQWxzbywgYHBhcnNlYCB1bmZvbGRzIGxvbmcgZm9ybWF0cyBsaWtlIHRob3NlIGluIFtmb3JtYXRde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZm9ybWF0fTpcbiAgICogfCBUb2tlbiB8IElucHV0IGV4YW1wbGVzICAgICAgICAgICAgICAgICB8XG4gICAqIHwtLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgKiB8IExUICAgIHwgMDU6MzAgYS5tLiAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCBMVFMgICB8IDA1OjMwOjE1IGEubS4gICAgICAgICAgICAgICAgICB8XG4gICAqIHwgTCAgICAgfCAwNy8wMi8xOTk1ICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8IGwgICAgIHwgNy8yLzE5OTUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCBMTCAgICB8IEp1bHkgMiAxOTk1ICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgbGwgICAgfCBKdWwgMiAxOTk1ICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8IExMTCAgIHwgSnVseSAyIDE5OTUgMDU6MzAgYS5tLiAgICAgICAgIHxcbiAgICogfCBsbGwgICB8IEp1bCAyIDE5OTUgMDU6MzAgYS5tLiAgICAgICAgICB8XG4gICAqIHwgTExMTCAgfCBTdW5kYXksIEp1bHkgMiAxOTk1IDA1OjMwIGEubS4gfFxuICAgKiB8IGxsbGwgIHwgU3VuLCBKdWwgMiAxOTk1IDA1OjMwIGEubS4gICAgIHxcbiAgICpcbiAgICogVGhlIGNoYXJhY3RlcnMgd3JhcHBlZCBpbiBzcXVhcmUgYnJhY2tldHMgaW4gdGhlIGZvcm1hdCBzdHJpbmcgYXJlIGVzY2FwZWQuXG4gICAqXG4gICAqIFRoZSByZXN1bHQgbWF5IHZhcnkgYnkgbG9jYWxlLlxuICAgKlxuICAgKiBJZiBgZm9ybWF0U3RyaW5nYCBtYXRjaGVzIHdpdGggYGRhdGVTdHJpbmdgIGJ1dCBkb2VzIG5vdCBwcm92aWRlcyB0b2tlbnMsIGBiYXNlRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogSWYgcGFyc2luZyBmYWlsZWQsIGBJbnZhbGlkIERhdGVgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEludmFsaWQgRGF0ZSBpcyBhIERhdGUsIHdob3NlIHRpbWUgdmFsdWUgaXMgTmFOLlxuICAgKiBUaW1lIHZhbHVlIG9mIERhdGU6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuOS4xLjFcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGVTdHJpbmcgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRTdHJpbmcgLSB0aGUgc3RyaW5nIG9mIHRva2Vuc1xuICAgKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gYmFzZURhdGUgLSB0aGUgZGF0ZSB0byB0b29rIHRoZSBtaXNzaW5nIGhpZ2hlciBwcmlvcml0eSB2YWx1ZXMgZnJvbVxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAgICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICAgKiBAcGFyYW0ge0xvY2FsZX0gW29wdGlvbnMubG9jYWxlPWRlZmF1bHRMb2NhbGVdIC0gdGhlIGxvY2FsZSBvYmplY3QuIFNlZSBbTG9jYWxlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL0xvY2FsZX1cbiAgICogQHBhcmFtIHswfDF8MnwzfDR8NXw2fSBbb3B0aW9ucy53ZWVrU3RhcnRzT249MF0gLSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCAtIFN1bmRheSlcbiAgICogQHJldHVybnMge0RhdGV9IHRoZSBwYXJzZWQgZGF0ZVxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDMgYXJndW1lbnRzIHJlcXVpcmVkXG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLndlZWtTdGFydHNPbmAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDZcbiAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYG1hdGNoYCBwcm9wZXJ0eVxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgZm9ybWF0TG9uZ2AgcHJvcGVydHlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gUGFyc2UgMTEgRmVicnVhcnkgMjAxNCBmcm9tIG1pZGRsZS1lbmRpYW4gZm9ybWF0OlxuICAgKiB2YXIgcmVzdWx0ID0gcGFyc2UoXG4gICAqICAgJzAyLzExLzIwMTQnLFxuICAgKiAgICdNTS9ERC9ZWVlZJyxcbiAgICogICBuZXcgRGF0ZSgpXG4gICAqIClcbiAgICogLy89PiBUdWUgRmViIDExIDIwMTQgMDA6MDA6MDBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gUGFyc2UgMjh0aCBvZiBGZWJydWFyeSBpbiBFbmdsaXNoIGxvY2FsZSBpbiB0aGUgY29udGV4dCBvZiAyMDEwIHllYXI6XG4gICAqIGltcG9ydCBlb0xvY2FsZSBmcm9tICdkYXRlLWZucy9sb2NhbGUvZW8nXG4gICAqIHZhciByZXN1bHQgPSBwYXJzZShcbiAgICogICAnMjgtYSBkZSBmZWJydWFybycsXG4gICAqICAgJ0RvIFtkZV0gTU1NTScsXG4gICAqICAgbmV3IERhdGUoMjAxMCwgMCwgMSlcbiAgICogICB7bG9jYWxlOiBlb0xvY2FsZX1cbiAgICogKVxuICAgKiAvLz0+IFN1biBGZWIgMjggMjAxMCAwMDowMDowMFxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2UgKGRpcnR5RGF0ZVN0cmluZywgZGlydHlGb3JtYXRTdHJpbmcsIGRpcnR5QmFzZURhdGUsIGRpcnR5T3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMyBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50JylcbiAgICB9XG5cbiAgICB2YXIgZGF0ZVN0cmluZyA9IFN0cmluZyhkaXJ0eURhdGVTdHJpbmcpO1xuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHdlZWtTdGFydHNPbiA9IG9wdGlvbnMud2Vla1N0YXJ0c09uID09PSB1bmRlZmluZWQgPyAwIDogTnVtYmVyKG9wdGlvbnMud2Vla1N0YXJ0c09uKTtcblxuICAgIC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXG4gICAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd2Vla1N0YXJ0c09uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2IGluY2x1c2l2ZWx5JylcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlJCQxID0gb3B0aW9ucy5sb2NhbGUgfHwgbG9jYWxlO1xuICAgIHZhciBsb2NhbGVQYXJzZXJzID0gbG9jYWxlJCQxLnBhcnNlcnMgfHwge307XG4gICAgdmFyIGxvY2FsZVVuaXRzID0gbG9jYWxlJCQxLnVuaXRzIHx8IHt9O1xuXG4gICAgaWYgKCFsb2NhbGUkJDEubWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsb2NhbGUgbXVzdCBjb250YWluIG1hdGNoIHByb3BlcnR5JylcbiAgICB9XG5cbiAgICBpZiAoIWxvY2FsZSQkMS5mb3JtYXRMb25nKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBmb3JtYXRMb25nIHByb3BlcnR5JylcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0U3RyaW5nID0gU3RyaW5nKGRpcnR5Rm9ybWF0U3RyaW5nKVxuICAgICAgLnJlcGxhY2UobG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSwgZnVuY3Rpb24gKHN1YnN0cmluZykge1xuICAgICAgICBpZiAoc3Vic3RyaW5nWzBdID09PSAnWycpIHtcbiAgICAgICAgICByZXR1cm4gc3Vic3RyaW5nXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3Vic3RyaW5nWzBdID09PSAnXFxcXCcpIHtcbiAgICAgICAgICByZXR1cm4gY2xlYW5Fc2NhcGVkU3RyaW5nJDEoc3Vic3RyaW5nKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZSQkMS5mb3JtYXRMb25nKHN1YnN0cmluZylcbiAgICAgIH0pO1xuXG4gICAgaWYgKGZvcm1hdFN0cmluZyA9PT0gJycpIHtcbiAgICAgIGlmIChkYXRlU3RyaW5nID09PSAnJykge1xuICAgICAgICByZXR1cm4gdG9EYXRlKGRpcnR5QmFzZURhdGUsIG9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdWJGbk9wdGlvbnMgPSBjbG9uZU9iamVjdChvcHRpb25zKTtcbiAgICBzdWJGbk9wdGlvbnMubG9jYWxlID0gbG9jYWxlJCQxO1xuXG4gICAgdmFyIHRva2VucyA9IGZvcm1hdFN0cmluZy5tYXRjaChsb2NhbGUkJDEucGFyc2luZ1Rva2Vuc1JlZ0V4cCB8fCBkZWZhdWx0UGFyc2luZ1Rva2Vuc1JlZ0V4cCk7XG4gICAgdmFyIHRva2Vuc0xlbmd0aCA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICAvLyBJZiB0aW1lem9uZSBpc24ndCBzcGVjaWZpZWQsIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBzeXN0ZW0gdGltZXpvbmVcbiAgICB2YXIgc2V0dGVycyA9IFt7XG4gICAgICBwcmlvcml0eTogVElNRVpPTkVfVU5JVF9QUklPUklUWSxcbiAgICAgIHNldDogZGF0ZVRvU3lzdGVtVGltZXpvbmUsXG4gICAgICBpbmRleDogMFxuICAgIH1dO1xuXG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vuc0xlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICB2YXIgcGFyc2VyID0gbG9jYWxlUGFyc2Vyc1t0b2tlbl0gfHwgcGFyc2Vyc1t0b2tlbl07XG4gICAgICBpZiAocGFyc2VyKSB7XG4gICAgICAgIHZhciBtYXRjaFJlc3VsdDtcblxuICAgICAgICBpZiAocGFyc2VyLm1hdGNoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgbWF0Y2hSZXN1bHQgPSBwYXJzZXIubWF0Y2guZXhlYyhkYXRlU3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaFJlc3VsdCA9IHBhcnNlci5tYXRjaChkYXRlU3RyaW5nLCBzdWJGbk9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaFJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pdE5hbWUgPSBwYXJzZXIudW5pdDtcbiAgICAgICAgdmFyIHVuaXQgPSBsb2NhbGVVbml0c1t1bml0TmFtZV0gfHwgdW5pdHNbdW5pdE5hbWVdO1xuXG4gICAgICAgIHNldHRlcnMucHVzaCh7XG4gICAgICAgICAgcHJpb3JpdHk6IHVuaXQucHJpb3JpdHksXG4gICAgICAgICAgc2V0OiB1bml0LnNldCxcbiAgICAgICAgICB2YWx1ZTogcGFyc2VyLnBhcnNlKG1hdGNoUmVzdWx0LCBzdWJGbk9wdGlvbnMpLFxuICAgICAgICAgIGluZGV4OiBzZXR0ZXJzLmxlbmd0aFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc3Vic3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG4gICAgICAgIGRhdGVTdHJpbmcgPSBkYXRlU3RyaW5nLnNsaWNlKHN1YnN0cmluZy5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhlYWQgPSB0b2tlbnNbaV0ubWF0Y2goL15cXFsuKl0kLykgPyB0b2tlbnNbaV0ucmVwbGFjZSgvXlxcW3xdJC9nLCAnJykgOiB0b2tlbnNbaV07XG4gICAgICAgIGlmIChkYXRlU3RyaW5nLmluZGV4T2YoaGVhZCkgPT09IDApIHtcbiAgICAgICAgICBkYXRlU3RyaW5nID0gZGF0ZVN0cmluZy5zbGljZShoZWFkLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmlxdWVQcmlvcml0eVNldHRlcnMgPSBzZXR0ZXJzXG4gICAgICAubWFwKGZ1bmN0aW9uIChzZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHNldHRlci5wcmlvcml0eVxuICAgICAgfSlcbiAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYlxuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHByaW9yaXR5LCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YocHJpb3JpdHkpID09PSBpbmRleFxuICAgICAgfSlcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiBzZXR0ZXJzXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc2V0dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGVyLnByaW9yaXR5ID09PSBwcmlvcml0eVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgfSlcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHNldHRlckFycmF5KSB7XG4gICAgICAgIHJldHVybiBzZXR0ZXJBcnJheVswXVxuICAgICAgfSk7XG5cbiAgICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eUJhc2VEYXRlLCBvcHRpb25zKTtcblxuICAgIGlmIChpc05hTihkYXRlKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBkYXRlIGluIHN5c3RlbSB0aW1lem9uZSB0byB0aGUgc2FtZSBkYXRlIGluIFVUQyswMDowMCB0aW1lem9uZS5cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIFVUQyBmdW5jdGlvbnMgd2lsbCBiZSBpbXBsZW1lbnRlZCwgbG9jYWxlcyB3aWxsIGJlIGNvbXBhdGlibGUgd2l0aCB0aGVtLlxuICAgIC8vIFNlZSBhbiBpc3N1ZSBhYm91dCBVVEMgZnVuY3Rpb25zOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3XG4gICAgdmFyIHV0Y0RhdGUgPSBzdWJNaW51dGVzKGRhdGUsIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG5cbiAgICB2YXIgZGF0ZVZhbHVlcyA9IHtkYXRlOiB1dGNEYXRlfTtcblxuICAgIHZhciBzZXR0ZXJzTGVuZ3RoID0gdW5pcXVlUHJpb3JpdHlTZXR0ZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2V0dGVyc0xlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2V0dGVyID0gdW5pcXVlUHJpb3JpdHlTZXR0ZXJzW2ldO1xuICAgICAgZGF0ZVZhbHVlcyA9IHNldHRlci5zZXQoZGF0ZVZhbHVlcywgc2V0dGVyLnZhbHVlLCBzdWJGbk9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlVmFsdWVzLmRhdGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGRhdGVUb1N5c3RlbVRpbWV6b25lIChkYXRlVmFsdWVzKSB7XG4gICAgdmFyIGRhdGUgPSBkYXRlVmFsdWVzLmRhdGU7XG4gICAgdmFyIHRpbWUgPSBkYXRlLmdldFRpbWUoKTtcblxuICAgIC8vIEdldCB0aGUgc3lzdGVtIHRpbWV6b25lIG9mZnNldCBhdCAobW9tZW50IG9mIHRpbWUgLSBvZmZzZXQpXG4gICAgdmFyIG9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICAgIC8vIEdldCB0aGUgc3lzdGVtIHRpbWV6b25lIG9mZnNldCBhdCB0aGUgZXhhY3QgbW9tZW50IG9mIHRpbWVcbiAgICBvZmZzZXQgPSBuZXcgRGF0ZSh0aW1lICsgb2Zmc2V0ICogTUlMTElTRUNPTkRTX0lOX01JTlVURSQ3KS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG4gICAgLy8gQ29udmVydCBkYXRlIGluIHRpbWV6b25lIFwiVVRDKzAwOjAwXCIgdG8gdGhlIHN5c3RlbSB0aW1lem9uZVxuICAgIGRhdGVWYWx1ZXMuZGF0ZSA9IG5ldyBEYXRlKHRpbWUgKyBvZmZzZXQgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFJDcpO1xuXG4gICAgcmV0dXJuIGRhdGVWYWx1ZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFuRXNjYXBlZFN0cmluZyQxIChpbnB1dCkge1xuICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XSQvZywgJycpXG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKVxuICB9XG5cbiAgLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGJ5IGBzY3JpcHRzL2J1aWxkL2luZGljZXMuanNgLiBQbGVhc2UsIGRvbid0IGNoYW5nZSBpdC5cblxuICAvLyBcclxuXHJcbiAgLyoqXHJcbiAgICogQ3VzdG9tIHBhcnNlIGJlaGF2aW9yIG9uIHRvcCBvZiBkYXRlLWZucyBwYXJzZSBmdW5jdGlvbi5cclxuICAgKi9cclxuICBmdW5jdGlvbiBwYXJzZURhdGUkMSAoZGF0ZSwgZm9ybWF0JCQxKSB7XHJcbiAgICBpZiAodHlwZW9mIGRhdGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBpc1ZhbGlkKGRhdGUpID8gZGF0ZSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlKGRhdGUsIGZvcm1hdCQkMSwgbmV3IERhdGUoKSk7XHJcblxyXG4gICAgLy8gaWYgZGF0ZSBpcyBub3QgdmFsaWQgb3IgdGhlIGZvcm1hdHRlZCBvdXRwdXQgYWZ0ZXIgcGFyc2luZyBkb2VzIG5vdCBtYXRjaFxyXG4gICAgLy8gdGhlIHN0cmluZyB2YWx1ZSBwYXNzZWQgaW4gKGF2b2lkcyBvdmVyZmxvd3MpXHJcbiAgICBpZiAoIWlzVmFsaWQocGFyc2VkKSB8fCBmb3JtYXQocGFyc2VkLCBmb3JtYXQkJDEpICE9PSBkYXRlKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgfVxuXG4gIHZhciBhZnRlclZhbGlkYXRvciA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICAgIHZhciB0YXJnZXRWYWx1ZSA9IHJlZi50YXJnZXRWYWx1ZTtcbiAgICB2YXIgaW5jbHVzaW9uID0gcmVmLmluY2x1c2lvbjsgaWYgKCBpbmNsdXNpb24gPT09IHZvaWQgMCApIGluY2x1c2lvbiA9IGZhbHNlO1xuICAgIHZhciBmb3JtYXQkJDEgPSByZWYuZm9ybWF0O1xuXHJcbiAgICBpZiAodHlwZW9mIGZvcm1hdCQkMSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgZm9ybWF0JCQxID0gaW5jbHVzaW9uO1xyXG4gICAgICBpbmNsdXNpb24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZSA9IHBhcnNlRGF0ZSQxKHZhbHVlLCBmb3JtYXQkJDEpO1xyXG4gICAgdGFyZ2V0VmFsdWUgPSBwYXJzZURhdGUkMSh0YXJnZXRWYWx1ZSwgZm9ybWF0JCQxKTtcclxuXHJcbiAgICAvLyBpZiBlaXRoZXIgaXMgbm90IHZhbGlkLlxyXG4gICAgaWYgKCF2YWx1ZSB8fCAhdGFyZ2V0VmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpc0FmdGVyKHZhbHVlLCB0YXJnZXRWYWx1ZSkgfHwgKGluY2x1c2lvbiAmJiBpc0VxdWFsKHZhbHVlLCB0YXJnZXRWYWx1ZSkpO1xyXG4gIH07XHJcblxyXG4gIHZhciBvcHRpb25zID0ge1xyXG4gICAgaGFzVGFyZ2V0OiB0cnVlLFxyXG4gICAgaXNEYXRlOiB0cnVlXHJcbiAgfTtcclxuXHJcbiAgLy8gcmVxdWlyZWQgdG8gY29udmVydCBmcm9tIGEgbGlzdCBvZiBhcnJheSB2YWx1ZXMgdG8gYW4gb2JqZWN0LlxyXG4gIHZhciBwYXJhbU5hbWVzID0gWyd0YXJnZXRWYWx1ZScsICdpbmNsdXNpb24nLCAnZm9ybWF0J107XHJcblxyXG4gIHZhciBhZnRlciA9IHtcclxuICAgIHZhbGlkYXRlOiBhZnRlclZhbGlkYXRvcixcclxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXHJcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzXHJcbiAgfTtcblxuICAvKipcclxuICAgKiBTb21lIEFscGhhIFJlZ2V4IGhlbHBlcnMuXHJcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2Nocmlzby92YWxpZGF0b3IuanMvYmxvYi9tYXN0ZXIvc3JjL2xpYi9hbHBoYS5qc1xyXG4gICAqL1xyXG5cclxuICB2YXIgYWxwaGEgPSB7XHJcbiAgICBlbjogL15bQS1aXSokL2ksXHJcbiAgICBjczogL15bQS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XSokL2ksXHJcbiAgICBkYTogL15bQS1aw4bDmMOFXSokL2ksXHJcbiAgICBkZTogL15bQS1aw4TDlsOcw59dKiQvaSxcclxuICAgIGVzOiAvXltBLVrDgcOJw43DkcOTw5rDnF0qJC9pLFxyXG4gICAgZnI6IC9eW0EtWsOAw4LDhsOHw4nDiMOKw4vDj8OOw5TFksOZw5vDnMW4XSokL2ksXHJcbiAgICBsdDogL15bQS1axITEjMSYxJbErsWgxbLFqsW9XSokL2ksXHJcbiAgICBubDogL15bQS1aw4nDi8OPw5PDlsOcXSokL2ksXHJcbiAgICBodTogL15bQS1aw4HDicONw5PDlsWQw5rDnMWwXSokL2ksXHJcbiAgICBwbDogL15bQS1axITEhsSYxZrFgcWDw5PFu8W5XSokL2ksXHJcbiAgICBwdDogL15bQS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xdKiQvaSxcclxuICAgIHJ1OiAvXlvQkC3Qr9CBXSokL2ksXHJcbiAgICBzazogL15bQS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1dKiQvaSxcclxuICAgIHNyOiAvXltBLVrEjMSGxb3FoMSQXSokL2ksXHJcbiAgICBzdjogL15bQS1aw4XDhMOWXSokL2ksXHJcbiAgICB0cjogL15bQS1aw4fEnsSwxLHDlsWew5xdKiQvaSxcclxuICAgIHVrOiAvXlvQkC3QqdCs0K7Qr9CE0IbQh9KQXSokL2ksXHJcbiAgICBhcjogL15b2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXSokLyxcclxuICAgIGF6OiAvXltBLVrDh8aPxJ7EsMSxw5bFnsOcXSokL2lcclxuICB9O1xyXG5cclxuICB2YXIgYWxwaGFTcGFjZXMgPSB7XHJcbiAgICBlbjogL15bQS1aXFxzXSokL2ksXHJcbiAgICBjczogL15bQS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XFxzXSokL2ksXHJcbiAgICBkYTogL15bQS1aw4bDmMOFXFxzXSokL2ksXHJcbiAgICBkZTogL15bQS1aw4TDlsOcw59cXHNdKiQvaSxcclxuICAgIGVzOiAvXltBLVrDgcOJw43DkcOTw5rDnFxcc10qJC9pLFxyXG4gICAgZnI6IC9eW0EtWsOAw4LDhsOHw4nDiMOKw4vDj8OOw5TFksOZw5vDnMW4XFxzXSokL2ksXHJcbiAgICBsdDogL15bQS1axITEjMSYxJbErsWgxbLFqsW9XFxzXSokL2ksXHJcbiAgICBubDogL15bQS1aw4nDi8OPw5PDlsOcXFxzXSokL2ksXHJcbiAgICBodTogL15bQS1aw4HDicONw5PDlsWQw5rDnMWwXFxzXSokL2ksXHJcbiAgICBwbDogL15bQS1axITEhsSYxZrFgcWDw5PFu8W5XFxzXSokL2ksXHJcbiAgICBwdDogL15bQS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xcXHNdKiQvaSxcclxuICAgIHJ1OiAvXlvQkC3Qr9CBXFxzXSokL2ksXHJcbiAgICBzazogL15bQS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1cXHNdKiQvaSxcclxuICAgIHNyOiAvXltBLVrEjMSGxb3FoMSQXFxzXSokL2ksXHJcbiAgICBzdjogL15bQS1aw4XDhMOWXFxzXSokL2ksXHJcbiAgICB0cjogL15bQS1aw4fEnsSwxLHDlsWew5xcXHNdKiQvaSxcclxuICAgIHVrOiAvXlvQkC3QqdCs0K7Qr9CE0IbQh9KQXFxzXSokL2ksXHJcbiAgICBhcjogL15b2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXFxzXSokLyxcclxuICAgIGF6OiAvXltBLVrDh8aPxJ7EsMSxw5bFnsOcXFxzXSokL2lcclxuICB9O1xyXG5cclxuICB2YXIgYWxwaGFudW1lcmljID0ge1xyXG4gICAgZW46IC9eWzAtOUEtWl0qJC9pLFxyXG4gICAgY3M6IC9eWzAtOUEtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvV0qJC9pLFxyXG4gICAgZGE6IC9eWzAtOUEtWsOGw5jDhV0kL2ksXHJcbiAgICBkZTogL15bMC05QS1aw4TDlsOcw59dKiQvaSxcclxuICAgIGVzOiAvXlswLTlBLVrDgcOJw43DkcOTw5rDnF0qJC9pLFxyXG4gICAgZnI6IC9eWzAtOUEtWsOAw4LDhsOHw4nDiMOKw4vDj8OOw5TFksOZw5vDnMW4XSokL2ksXHJcbiAgICBsdDogL15bMC05QS1axITEjMSYxJbErsWgxbLFqsW9XSokL2ksXHJcbiAgICBodTogL15bMC05QS1aw4HDicONw5PDlsWQw5rDnMWwXSokL2ksXHJcbiAgICBubDogL15bMC05QS1aw4nDi8OPw5PDlsOcXSokL2ksXHJcbiAgICBwbDogL15bMC05QS1axITEhsSYxZrFgcWDw5PFu8W5XSokL2ksXHJcbiAgICBwdDogL15bMC05QS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xdKiQvaSxcclxuICAgIHJ1OiAvXlswLTnQkC3Qr9CBXSokL2ksXHJcbiAgICBzazogL15bMC05QS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1dKiQvaSxcclxuICAgIHNyOiAvXlswLTlBLVrEjMSGxb3FoMSQXSokL2ksXHJcbiAgICBzdjogL15bMC05QS1aw4XDhMOWXSokL2ksXHJcbiAgICB0cjogL15bMC05QS1aw4fEnsSwxLHDlsWew5xdKiQvaSxcclxuICAgIHVrOiAvXlswLTnQkC3QqdCs0K7Qr9CE0IbQh9KQXSokL2ksXHJcbiAgICBhcjogL15b2aDZodmi2aPZpNml2abZp9mo2akwLTnYodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi62YHZgtmD2YTZhdmG2YfZiNmJ2YrZi9mM2Y3ZjtmP2ZDZkdmS2bBdKiQvLFxyXG4gICAgYXo6IC9eWzAtOUEtWsOHxo/EnsSwxLHDlsWew5xdKiQvaVxyXG4gIH07XHJcblxyXG4gIHZhciBhbHBoYURhc2ggPSB7XHJcbiAgICBlbjogL15bMC05QS1aXy1dKiQvaSxcclxuICAgIGNzOiAvXlswLTlBLVrDgcSMxI7DicSaw43Fh8OTxZjFoMWkw5rFrsOdxb1fLV0qJC9pLFxyXG4gICAgZGE6IC9eWzAtOUEtWsOGw5jDhV8tXSokL2ksXHJcbiAgICBkZTogL15bMC05QS1aw4TDlsOcw59fLV0qJC9pLFxyXG4gICAgZXM6IC9eWzAtOUEtWsOBw4nDjcORw5PDmsOcXy1dKiQvaSxcclxuICAgIGZyOiAvXlswLTlBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF8tXSokL2ksXHJcbiAgICBsdDogL15bMC05QS1axITEjMSYxJbErsWgxbLFqsW9Xy1dKiQvaSxcclxuICAgIG5sOiAvXlswLTlBLVrDicOLw4/Dk8OWw5xfLV0qJC9pLFxyXG4gICAgaHU6IC9eWzAtOUEtWsOBw4nDjcOTw5bFkMOaw5zFsF8tXSokL2ksXHJcbiAgICBwbDogL15bMC05QS1axITEhsSYxZrFgcWDw5PFu8W5Xy1dKiQvaSxcclxuICAgIHB0OiAvXlswLTlBLVrDg8OBw4DDgsOHw4nDisONw5XDk8OUw5rDnF8tXSokL2ksXHJcbiAgICBydTogL15bMC050JAt0K/QgV8tXSokL2ksXHJcbiAgICBzazogL15bMC05QS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1fLV0qJC9pLFxyXG4gICAgc3I6IC9eWzAtOUEtWsSMxIbFvcWgxJBfLV0qJC9pLFxyXG4gICAgc3Y6IC9eWzAtOUEtWsOFw4TDll8tXSokL2ksXHJcbiAgICB0cjogL15bMC05QS1aw4fEnsSwxLHDlsWew5xfLV0qJC9pLFxyXG4gICAgdWs6IC9eWzAtOdCQLdCp0KzQrtCv0ITQhtCH0pBfLV0qJC9pLFxyXG4gICAgYXI6IC9eW9mg2aHZotmj2aTZpdmm2afZqNmpMC052KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXy1dKiQvLFxyXG4gICAgYXo6IC9eWzAtOUEtWsOHxo/EnsSwxLHDlsWew5xfLV0qJC9pXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgICB2YXIgbG9jYWxlID0gcmVmLmxvY2FsZTtcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSh2YWwsIFtsb2NhbGVdKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWF0Y2ggYXQgbGVhc3Qgb25lIGxvY2FsZS5cclxuICAgIGlmICghIGxvY2FsZSkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxwaGEpLnNvbWUoZnVuY3Rpb24gKGxvYykgeyByZXR1cm4gYWxwaGFbbG9jXS50ZXN0KHZhbHVlKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChhbHBoYVtsb2NhbGVdIHx8IGFscGhhLmVuKS50ZXN0KHZhbHVlKTtcclxuICB9O1xyXG5cclxuICB2YXIgcGFyYW1OYW1lcyQxID0gWydsb2NhbGUnXTtcclxuXHJcbiAgdmFyIGFscGhhJDEgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUsXHJcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzJDFcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSQxID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gICAgdmFyIGxvY2FsZSA9IHJlZi5sb2NhbGU7XG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkMSh2YWwsIFtsb2NhbGVdKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWF0Y2ggYXQgbGVhc3Qgb25lIGxvY2FsZS5cclxuICAgIGlmICghIGxvY2FsZSkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxwaGFEYXNoKS5zb21lKGZ1bmN0aW9uIChsb2MpIHsgcmV0dXJuIGFscGhhRGFzaFtsb2NdLnRlc3QodmFsdWUpOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKGFscGhhRGFzaFtsb2NhbGVdIHx8IGFscGhhRGFzaC5lbikudGVzdCh2YWx1ZSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHBhcmFtTmFtZXMkMiA9IFsnbG9jYWxlJ107XHJcblxyXG4gIHZhciBhbHBoYV9kYXNoID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJDEsXHJcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzJDJcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSQyID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gICAgdmFyIGxvY2FsZSA9IHJlZi5sb2NhbGU7XG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkMih2YWwsIFtsb2NhbGVdKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWF0Y2ggYXQgbGVhc3Qgb25lIGxvY2FsZS5cclxuICAgIGlmICghIGxvY2FsZSkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxwaGFudW1lcmljKS5zb21lKGZ1bmN0aW9uIChsb2MpIHsgcmV0dXJuIGFscGhhbnVtZXJpY1tsb2NdLnRlc3QodmFsdWUpOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKGFscGhhbnVtZXJpY1tsb2NhbGVdIHx8IGFscGhhbnVtZXJpYy5lbikudGVzdCh2YWx1ZSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHBhcmFtTmFtZXMkMyA9IFsnbG9jYWxlJ107XHJcblxyXG4gIHZhciBhbHBoYV9udW0gPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkMixcclxuICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMkM1xyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJDMgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgICB2YXIgbG9jYWxlID0gcmVmLmxvY2FsZTtcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSQzKHZhbCwgW2xvY2FsZV0pOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYXRjaCBhdCBsZWFzdCBvbmUgbG9jYWxlLlxyXG4gICAgaWYgKCEgbG9jYWxlKSB7XHJcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhbHBoYVNwYWNlcykuc29tZShmdW5jdGlvbiAobG9jKSB7IHJldHVybiBhbHBoYVNwYWNlc1tsb2NdLnRlc3QodmFsdWUpOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKGFscGhhU3BhY2VzW2xvY2FsZV0gfHwgYWxwaGFTcGFjZXMuZW4pLnRlc3QodmFsdWUpO1xyXG4gIH07XHJcblxyXG4gIHZhciBwYXJhbU5hbWVzJDQgPSBbJ2xvY2FsZSddO1xyXG5cclxuICB2YXIgYWxwaGFfc3BhY2VzID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJDMsXHJcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzJDRcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSQ0ID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gICAgdmFyIHRhcmdldFZhbHVlID0gcmVmLnRhcmdldFZhbHVlO1xuICAgIHZhciBpbmNsdXNpb24gPSByZWYuaW5jbHVzaW9uOyBpZiAoIGluY2x1c2lvbiA9PT0gdm9pZCAwICkgaW5jbHVzaW9uID0gZmFsc2U7XG4gICAgdmFyIGZvcm1hdCQkMSA9IHJlZi5mb3JtYXQ7XG5cclxuICAgIGlmICh0eXBlb2YgZm9ybWF0JCQxID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBmb3JtYXQkJDEgPSBpbmNsdXNpb247XHJcbiAgICAgIGluY2x1c2lvbiA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlID0gcGFyc2VEYXRlJDEodmFsdWUsIGZvcm1hdCQkMSk7XHJcbiAgICB0YXJnZXRWYWx1ZSA9IHBhcnNlRGF0ZSQxKHRhcmdldFZhbHVlLCBmb3JtYXQkJDEpO1xyXG5cclxuICAgIC8vIGlmIGVpdGhlciBpcyBub3QgdmFsaWQuXHJcbiAgICBpZiAoIXZhbHVlIHx8ICF0YXJnZXRWYWx1ZSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGlzQmVmb3JlKHZhbHVlLCB0YXJnZXRWYWx1ZSkgfHwgKGluY2x1c2lvbiAmJiBpc0VxdWFsKHZhbHVlLCB0YXJnZXRWYWx1ZSkpO1xyXG4gIH07XHJcblxyXG4gIHZhciBvcHRpb25zJDEgPSB7XHJcbiAgICBoYXNUYXJnZXQ6IHRydWUsXHJcbiAgICBpc0RhdGU6IHRydWVcclxuICB9O1xyXG5cclxuICB2YXIgcGFyYW1OYW1lcyQ1ID0gWyd0YXJnZXRWYWx1ZScsICdpbmNsdXNpb24nLCAnZm9ybWF0J107XHJcblxyXG4gIHZhciBiZWZvcmUgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkNCxcclxuICAgIG9wdGlvbnM6IG9wdGlvbnMkMSxcclxuICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMkNVxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJDUgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgICB2YXIgbWluID0gcmVmLm1pbjtcbiAgICB2YXIgbWF4ID0gcmVmLm1heDtcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSQ1KHZhbCwgeyBtaW46IG1pbiwgbWF4OiBtYXggfSk7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBOdW1iZXIobWluKSA8PSB2YWx1ZSAmJiBOdW1iZXIobWF4KSA+PSB2YWx1ZTtcclxuICB9O1xyXG5cclxuICB2YXIgcGFyYW1OYW1lcyQ2ID0gWydtaW4nLCAnbWF4J107XHJcblxyXG4gIHZhciBiZXR3ZWVuID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJDUsXHJcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzJDZcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSQ2ID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgICB2YXIgdGFyZ2V0VmFsdWUgPSByZWYudGFyZ2V0VmFsdWU7XG5cbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKSA9PT0gU3RyaW5nKHRhcmdldFZhbHVlKTtcbiAgfTtcclxuICB2YXIgb3B0aW9ucyQyID0ge1xyXG4gICAgaGFzVGFyZ2V0OiB0cnVlXHJcbiAgfTtcclxuXHJcbiAgdmFyIHBhcmFtTmFtZXMkNyA9IFsndGFyZ2V0VmFsdWUnXTtcclxuXHJcbiAgdmFyIGNvbmZpcm1lZCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQ2LFxyXG4gICAgb3B0aW9uczogb3B0aW9ucyQyLFxyXG4gICAgcGFyYW1OYW1lczogcGFyYW1OYW1lcyQ3XHJcbiAgfTtcblxuICBmdW5jdGlvbiB1bndyYXBFeHBvcnRzICh4KSB7XG4gIFx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geC5kZWZhdWx0IDogeDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcbiAgXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG4gIH1cblxuICB2YXIgYXNzZXJ0U3RyaW5nXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydFN0cmluZztcbiAgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKGlucHV0KSB7XG4gICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZztcblxuICAgIGlmICghaXNTdHJpbmcpIHtcbiAgICAgIHZhciBpbnZhbGlkVHlwZSA9IHZvaWQgMDtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICBpbnZhbGlkVHlwZSA9ICdudWxsJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFsaWRUeXBlID0gdHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpbnB1dCk7XG4gICAgICAgIGlmIChpbnZhbGlkVHlwZSA9PT0gJ29iamVjdCcgJiYgaW5wdXQuY29uc3RydWN0b3IgJiYgaW5wdXQuY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkoJ25hbWUnKSkge1xuICAgICAgICAgIGludmFsaWRUeXBlID0gaW5wdXQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZhbGlkVHlwZSA9ICdhICcgKyBpbnZhbGlkVHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgc3RyaW5nIGJ1dCByZWNlaXZlZCAnICsgaW52YWxpZFR5cGUgKyAnLicpO1xuICAgIH1cbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbiAgfSk7XG5cbiAgdW53cmFwRXhwb3J0cyhhc3NlcnRTdHJpbmdfMSk7XG5cbiAgdmFyIGlzQ3JlZGl0Q2FyZF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzLmRlZmF1bHQgPSBpc0NyZWRpdENhcmQ7XG5cblxuXG4gIHZhciBfYXNzZXJ0U3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICB2YXIgY3JlZGl0Q2FyZCA9IC9eKD86NFswLTldezEyfSg/OlswLTldezN9KT98NVsxLTVdWzAtOV17MTR9fCgyMjJbMS05XXwyMlszLTldWzAtOV18MlszLTZdWzAtOV17Mn18MjdbMDFdWzAtOV18MjcyMClbMC05XXsxMn18Nig/OjAxMXw1WzAtOV1bMC05XSlbMC05XXsxMn18M1s0N11bMC05XXsxM318Myg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9fCg/OjIxMzF8MTgwMHwzNVxcZHszfSlcXGR7MTF9fDZbMjddWzAtOV17MTR9KSQvO1xuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuICBmdW5jdGlvbiBpc0NyZWRpdENhcmQoc3RyKSB7XG4gICAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gICAgdmFyIHNhbml0aXplZCA9IHN0ci5yZXBsYWNlKC9bLSBdKy9nLCAnJyk7XG4gICAgaWYgKCFjcmVkaXRDYXJkLnRlc3Qoc2FuaXRpemVkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgZGlnaXQgPSB2b2lkIDA7XG4gICAgdmFyIHRtcE51bSA9IHZvaWQgMDtcbiAgICB2YXIgc2hvdWxkRG91YmxlID0gdm9pZCAwO1xuICAgIGZvciAodmFyIGkgPSBzYW5pdGl6ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGRpZ2l0ID0gc2FuaXRpemVkLnN1YnN0cmluZyhpLCBpICsgMSk7XG4gICAgICB0bXBOdW0gPSBwYXJzZUludChkaWdpdCwgMTApO1xuICAgICAgaWYgKHNob3VsZERvdWJsZSkge1xuICAgICAgICB0bXBOdW0gKj0gMjtcbiAgICAgICAgaWYgKHRtcE51bSA+PSAxMCkge1xuICAgICAgICAgIHN1bSArPSB0bXBOdW0gJSAxMCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VtICs9IHRtcE51bTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VtICs9IHRtcE51bTtcbiAgICAgIH1cbiAgICAgIHNob3VsZERvdWJsZSA9ICFzaG91bGREb3VibGU7XG4gICAgfVxuICAgIHJldHVybiAhIShzdW0gJSAxMCA9PT0gMCA/IHNhbml0aXplZCA6IGZhbHNlKTtcbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbiAgfSk7XG5cbiAgdmFyIGlzQ3JlZGl0Q2FyZCA9IHVud3JhcEV4cG9ydHMoaXNDcmVkaXRDYXJkXzEpO1xuXG4gIHZhciB2YWxpZGF0ZSQ3ID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpc0NyZWRpdENhcmQoU3RyaW5nKHZhbHVlKSk7IH07XHJcblxyXG4gIHZhciBjcmVkaXRfY2FyZCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQ3XHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkOCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICAgIHZhciBtaW4kJDEgPSByZWYubWluO1xuICAgIHZhciBtYXgkJDEgPSByZWYubWF4O1xuICAgIHZhciBpbmNsdXNpdml0eSA9IHJlZi5pbmNsdXNpdml0eTsgaWYgKCBpbmNsdXNpdml0eSA9PT0gdm9pZCAwICkgaW5jbHVzaXZpdHkgPSAnKCknO1xuICAgIHZhciBmb3JtYXQkJDEgPSByZWYuZm9ybWF0O1xuXHJcbiAgICBpZiAodHlwZW9mIGZvcm1hdCQkMSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgZm9ybWF0JCQxID0gaW5jbHVzaXZpdHk7XHJcbiAgICAgIGluY2x1c2l2aXR5ID0gJygpJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWluRGF0ZSA9IHBhcnNlRGF0ZSQxKFN0cmluZyhtaW4kJDEpLCBmb3JtYXQkJDEpO1xyXG4gICAgdmFyIG1heERhdGUgPSBwYXJzZURhdGUkMShTdHJpbmcobWF4JCQxKSwgZm9ybWF0JCQxKTtcclxuICAgIHZhciBkYXRlVmFsID0gcGFyc2VEYXRlJDEoU3RyaW5nKHZhbHVlKSwgZm9ybWF0JCQxKTtcclxuXHJcbiAgICBpZiAoIW1pbkRhdGUgfHwgIW1heERhdGUgfHwgIWRhdGVWYWwpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbmNsdXNpdml0eSA9PT0gJygpJykge1xyXG4gICAgICByZXR1cm4gaXNBZnRlcihkYXRlVmFsLCBtaW5EYXRlKSAmJiBpc0JlZm9yZShkYXRlVmFsLCBtYXhEYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5jbHVzaXZpdHkgPT09ICcoXScpIHtcclxuICAgICAgcmV0dXJuIGlzQWZ0ZXIoZGF0ZVZhbCwgbWluRGF0ZSkgJiYgKGlzRXF1YWwoZGF0ZVZhbCwgbWF4RGF0ZSkgfHwgaXNCZWZvcmUoZGF0ZVZhbCwgbWF4RGF0ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbmNsdXNpdml0eSA9PT0gJ1spJykge1xyXG4gICAgICByZXR1cm4gaXNCZWZvcmUoZGF0ZVZhbCwgbWF4RGF0ZSkgJiYgKGlzRXF1YWwoZGF0ZVZhbCwgbWluRGF0ZSkgfHwgaXNBZnRlcihkYXRlVmFsLCBtaW5EYXRlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGlzRXF1YWwoZGF0ZVZhbCwgbWF4RGF0ZSkgfHwgaXNFcXVhbChkYXRlVmFsLCBtaW5EYXRlKSB8fFxyXG4gICAgICAoaXNCZWZvcmUoZGF0ZVZhbCwgbWF4RGF0ZSkgJiYgaXNBZnRlcihkYXRlVmFsLCBtaW5EYXRlKSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIG9wdGlvbnMkMyA9IHtcclxuICAgIGlzRGF0ZTogdHJ1ZVxyXG4gIH07XHJcblxyXG4gIHZhciBwYXJhbU5hbWVzJDggPSBbJ21pbicsICdtYXgnLCAnaW5jbHVzaXZpdHknLCAnZm9ybWF0J107XHJcblxyXG4gIHZhciBkYXRlX2JldHdlZW4gPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkOCxcclxuICAgIG9wdGlvbnM6IG9wdGlvbnMkMyxcclxuICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMkOFxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJDkgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICAgIHZhciBmb3JtYXQgPSByZWYuZm9ybWF0O1xuXHJcbiAgICByZXR1cm4gISFwYXJzZURhdGUkMSh2YWx1ZSwgZm9ybWF0KTtcclxuICB9O1xyXG5cclxuICB2YXIgb3B0aW9ucyQ0ID0ge1xyXG4gICAgaXNEYXRlOiB0cnVlXHJcbiAgfTtcclxuXHJcbiAgdmFyIHBhcmFtTmFtZXMkOSA9IFsnZm9ybWF0J107XHJcblxyXG4gIHZhciBkYXRlX2Zvcm1hdCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQ5LFxyXG4gICAgb3B0aW9uczogb3B0aW9ucyQ0LFxyXG4gICAgcGFyYW1OYW1lczogcGFyYW1OYW1lcyQ5XHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkYSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICAgIHZhciBkZWNpbWFscyA9IHJlZi5kZWNpbWFsczsgaWYgKCBkZWNpbWFscyA9PT0gdm9pZCAwICkgZGVjaW1hbHMgPSAnKic7XG4gICAgdmFyIHNlcGFyYXRvciA9IHJlZi5zZXBhcmF0b3I7IGlmICggc2VwYXJhdG9yID09PSB2b2lkIDAgKSBzZXBhcmF0b3IgPSAnLic7XG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkYSh2YWwsIHsgZGVjaW1hbHM6IGRlY2ltYWxzLCBzZXBhcmF0b3I6IHNlcGFyYXRvciB9KTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBpcyAwLlxyXG4gICAgaWYgKE51bWJlcihkZWNpbWFscykgPT09IDApIHtcclxuICAgICAgcmV0dXJuIC9eLT9cXGQqJC8udGVzdCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlZ2V4UGFydCA9IGRlY2ltYWxzID09PSAnKicgPyAnKycgOiAoXCJ7MSxcIiArIGRlY2ltYWxzICsgXCJ9XCIpO1xyXG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgoXCJeWy0rXT9cXFxcZCooXFxcXFwiICsgc2VwYXJhdG9yICsgXCJcXFxcZFwiICsgcmVnZXhQYXJ0ICsgXCIpPyRcIikpO1xyXG5cclxuICAgIGlmICghIHJlZ2V4LnRlc3QodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgcmV0dXJuIHBhcnNlZFZhbHVlID09PSBwYXJzZWRWYWx1ZTtcclxuICB9O1xyXG5cclxuICB2YXIgcGFyYW1OYW1lcyRhID0gWydkZWNpbWFscycsICdzZXBhcmF0b3InXTtcclxuXHJcbiAgdmFyIGRlY2ltYWwgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkYSxcclxuICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMkYVxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJGIgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICAgIHZhciBsZW5ndGggPSByZWZbMF07XG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkYih2YWwsIFtsZW5ndGhdKTsgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgc3RyVmFsID0gU3RyaW5nKHZhbHVlKTtcclxuXHJcbiAgICByZXR1cm4gL15bMC05XSokLy50ZXN0KHN0clZhbCkgJiYgc3RyVmFsLmxlbmd0aCA9PT0gTnVtYmVyKGxlbmd0aCk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGRpZ2l0cyA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRiXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGVJbWFnZSA9IGZ1bmN0aW9uIChmaWxlLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh7IHZhbGlkOiBmYWxzZSB9KTsgfTtcclxuICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh7XHJcbiAgICAgICAgdmFsaWQ6IGltYWdlLndpZHRoID09PSBOdW1iZXIod2lkdGgpICYmIGltYWdlLmhlaWdodCA9PT0gTnVtYmVyKGhlaWdodClcclxuICAgICAgfSk7IH07XHJcblxyXG4gICAgICBpbWFnZS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHZhbGlkYXRlJGMgPSBmdW5jdGlvbiAoZmlsZXMsIHJlZikge1xuICAgIHZhciB3aWR0aCA9IHJlZlswXTtcbiAgICB2YXIgaGVpZ2h0ID0gcmVmWzFdO1xuXHJcbiAgICB2YXIgbGlzdCA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAvLyBpZiBmaWxlIGlzIG5vdCBhbiBpbWFnZSwgcmVqZWN0LlxyXG4gICAgICBpZiAoISAvXFwuKGpwZ3xzdmd8anBlZ3xwbmd8Ym1wfGdpZikkL2kudGVzdChmaWxlc1tpXS5uYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGlzdC5wdXNoKGZpbGVzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwobGlzdC5tYXAoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIHZhbGlkYXRlSW1hZ2UoZmlsZSwgd2lkdGgsIGhlaWdodCk7IH0pKTtcclxuICB9O1xyXG5cclxuICB2YXIgZGltZW5zaW9ucyA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRjXHJcbiAgfTtcblxuICB2YXIgbWVyZ2VfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5kZWZhdWx0ID0gbWVyZ2U7XG4gIGZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBkZWZhdWx0cyA9IGFyZ3VtZW50c1sxXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb2JqW2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuICB9KTtcblxuICB1bndyYXBFeHBvcnRzKG1lcmdlXzEpO1xuXG4gIHZhciBpc0J5dGVMZW5ndGhfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbiAgZXhwb3J0cy5kZWZhdWx0ID0gaXNCeXRlTGVuZ3RoO1xuXG5cblxuICB2YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICBmdW5jdGlvbiBpc0J5dGVMZW5ndGgoc3RyLCBvcHRpb25zKSB7XG4gICAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gICAgdmFyIG1pbiA9IHZvaWQgMDtcbiAgICB2YXIgbWF4ID0gdm9pZCAwO1xuICAgIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1pbiA9IG9wdGlvbnMubWluIHx8IDA7XG4gICAgICBtYXggPSBvcHRpb25zLm1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlzQnl0ZUxlbmd0aChzdHIsIG1pbiBbLCBtYXhdKVxuICAgICAgbWluID0gYXJndW1lbnRzWzFdO1xuICAgICAgbWF4ID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgICB2YXIgbGVuID0gZW5jb2RlVVJJKHN0cikuc3BsaXQoLyUuLnwuLykubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gbGVuID49IG1pbiAmJiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGVuIDw9IG1heCk7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4gIH0pO1xuXG4gIHVud3JhcEV4cG9ydHMoaXNCeXRlTGVuZ3RoXzEpO1xuXG4gIHZhciBpc0ZRRE5fMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5kZWZhdWx0ID0gaXNGUUROO1xuXG5cblxuICB2YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuXG5cbiAgdmFyIF9tZXJnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG1lcmdlXzEpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgdmFyIGRlZmF1bHRfZnFkbl9vcHRpb25zID0ge1xuICAgIHJlcXVpcmVfdGxkOiB0cnVlLFxuICAgIGFsbG93X3VuZGVyc2NvcmVzOiBmYWxzZSxcbiAgICBhbGxvd190cmFpbGluZ19kb3Q6IGZhbHNlXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNGUUROKHN0ciwgb3B0aW9ucykge1xuICAgICgwLCBfYXNzZXJ0U3RyaW5nMi5kZWZhdWx0KShzdHIpO1xuICAgIG9wdGlvbnMgPSAoMCwgX21lcmdlMi5kZWZhdWx0KShvcHRpb25zLCBkZWZhdWx0X2ZxZG5fb3B0aW9ucyk7XG5cbiAgICAvKiBSZW1vdmUgdGhlIG9wdGlvbmFsIHRyYWlsaW5nIGRvdCBiZWZvcmUgY2hlY2tpbmcgdmFsaWRpdHkgKi9cbiAgICBpZiAob3B0aW9ucy5hbGxvd190cmFpbGluZ19kb3QgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJy4nKSB7XG4gICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcuJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhcnRzW2ldLmxlbmd0aCA+IDYzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVxdWlyZV90bGQpIHtcbiAgICAgIHZhciB0bGQgPSBwYXJ0cy5wb3AoKTtcbiAgICAgIGlmICghcGFydHMubGVuZ3RoIHx8ICEvXihbYS16XFx1MDBhMS1cXHVmZmZmXXsyLH18eG5bYS16MC05LV17Mix9KSQvaS50ZXN0KHRsZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gZGlzYWxsb3cgc3BhY2VzXG4gICAgICBpZiAoL1tcXHNcXHUyMDAyLVxcdTIwMEJcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHVGRUZGXFx1REI0MFxcdURDMjBdLy50ZXN0KHRsZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBwYXJ0LCBfaSA9IDA7IF9pIDwgcGFydHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbX2ldO1xuICAgICAgaWYgKG9wdGlvbnMuYWxsb3dfdW5kZXJzY29yZXMpIHtcbiAgICAgICAgcGFydCA9IHBhcnQucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIS9eW2EtelxcdTAwYTEtXFx1ZmZmZjAtOS1dKyQvaS50ZXN0KHBhcnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGRpc2FsbG93IGZ1bGwtd2lkdGggY2hhcnNcbiAgICAgIGlmICgvW1xcdWZmMDEtXFx1ZmY1ZV0vLnRlc3QocGFydCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnRbMF0gPT09ICctJyB8fCBwYXJ0W3BhcnQubGVuZ3RoIC0gMV0gPT09ICctJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuICB9KTtcblxuICB1bndyYXBFeHBvcnRzKGlzRlFETl8xKTtcblxuICB2YXIgaXNJUF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzLmRlZmF1bHQgPSBpc0lQO1xuXG5cblxuICB2YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4gIHZhciBpcHY0TWF5YmUgPSAvXihcXGR7MSwzfSlcXC4oXFxkezEsM30pXFwuKFxcZHsxLDN9KVxcLihcXGR7MSwzfSkkLztcbiAgdmFyIGlwdjZCbG9jayA9IC9eWzAtOUEtRl17MSw0fSQvaTtcblxuICBmdW5jdGlvbiBpc0lQKHN0cikge1xuICAgIHZhciB2ZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcblxuICAgICgwLCBfYXNzZXJ0U3RyaW5nMi5kZWZhdWx0KShzdHIpO1xuICAgIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbik7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gaXNJUChzdHIsIDQpIHx8IGlzSVAoc3RyLCA2KTtcbiAgICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc0Jykge1xuICAgICAgaWYgKCFpcHY0TWF5YmUudGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFydHNbM10gPD0gMjU1O1xuICAgIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gJzYnKSB7XG4gICAgICB2YXIgYmxvY2tzID0gc3RyLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIgZm91bmRPbWlzc2lvbkJsb2NrID0gZmFsc2U7IC8vIG1hcmtlciB0byBpbmRpY2F0ZSA6OlxuXG4gICAgICAvLyBBdCBsZWFzdCBzb21lIE9TIGFjY2VwdCB0aGUgbGFzdCAzMiBiaXRzIG9mIGFuIElQdjYgYWRkcmVzc1xuICAgICAgLy8gKGkuZS4gMiBvZiB0aGUgYmxvY2tzKSBpbiBJUHY0IG5vdGF0aW9uLCBhbmQgUkZDIDM0OTMgc2F5c1xuICAgICAgLy8gdGhhdCAnOjpmZmZmOmEuYi5jLmQnIGlzIHZhbGlkIGZvciBJUHY0LW1hcHBlZCBJUHY2IGFkZHJlc3NlcyxcbiAgICAgIC8vIGFuZCAnOjphLmIuYy5kJyBpcyBkZXByZWNhdGVkLCBidXQgYWxzbyB2YWxpZC5cbiAgICAgIHZhciBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPSBpc0lQKGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV0sIDQpO1xuICAgICAgdmFyIGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MgPSBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPyA3IDogODtcblxuICAgICAgaWYgKGJsb2Nrcy5sZW5ndGggPiBleHBlY3RlZE51bWJlck9mQmxvY2tzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGluaXRpYWwgb3IgZmluYWwgOjpcbiAgICAgIGlmIChzdHIgPT09ICc6OicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHIoMCwgMikgPT09ICc6OicpIHtcbiAgICAgICAgYmxvY2tzLnNoaWZ0KCk7XG4gICAgICAgIGJsb2Nrcy5zaGlmdCgpO1xuICAgICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKHN0ci5sZW5ndGggLSAyKSA9PT0gJzo6Jykge1xuICAgICAgICBibG9ja3MucG9wKCk7XG4gICAgICAgIGJsb2Nrcy5wb3AoKTtcbiAgICAgICAgZm91bmRPbWlzc2lvbkJsb2NrID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgLy8gdGVzdCBmb3IgYSA6OiB3aGljaCBjYW4gbm90IGJlIGF0IHRoZSBzdHJpbmcgc3RhcnQvZW5kXG4gICAgICAgIC8vIHNpbmNlIHRob3NlIGNhc2VzIGhhdmUgYmVlbiBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGlmIChibG9ja3NbaV0gPT09ICcnICYmIGkgPiAwICYmIGkgPCBibG9ja3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGlmIChmb3VuZE9taXNzaW9uQmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbXVsdGlwbGUgOjogaW4gYWRkcmVzc1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3VuZE9taXNzaW9uQmxvY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGZvdW5kSVB2NFRyYW5zaXRpb25CbG9jayAmJiBpID09PSBibG9ja3MubGVuZ3RoIC0gMSkgOyBlbHNlIGlmICghaXB2NkJsb2NrLnRlc3QoYmxvY2tzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kT21pc3Npb25CbG9jaykge1xuICAgICAgICByZXR1cm4gYmxvY2tzLmxlbmd0aCA+PSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPT09IGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3M7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbiAgfSk7XG5cbiAgdmFyIGlzSVAgPSB1bndyYXBFeHBvcnRzKGlzSVBfMSk7XG5cbiAgdmFyIGlzRW1haWxfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5kZWZhdWx0ID0gaXNFbWFpbDtcblxuXG5cbiAgdmFyIF9hc3NlcnRTdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cblxuXG4gIHZhciBfbWVyZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChtZXJnZV8xKTtcblxuXG5cbiAgdmFyIF9pc0J5dGVMZW5ndGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0J5dGVMZW5ndGhfMSk7XG5cblxuXG4gIHZhciBfaXNGUUROMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXNGUUROXzEpO1xuXG5cblxuICB2YXIgX2lzSVAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0lQXzEpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbiAgdmFyIGRlZmF1bHRfZW1haWxfb3B0aW9ucyA9IHtcbiAgICBhbGxvd19kaXNwbGF5X25hbWU6IGZhbHNlLFxuICAgIHJlcXVpcmVfZGlzcGxheV9uYW1lOiBmYWxzZSxcbiAgICBhbGxvd191dGY4X2xvY2FsX3BhcnQ6IHRydWUsXG4gICAgcmVxdWlyZV90bGQ6IHRydWVcbiAgfTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cbiAgdmFyIGRpc3BsYXlOYW1lID0gL15bYS16XFxkISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5cXC5cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK1thLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcLFxcLlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRlxcc10qPCguKyk+JC9pO1xuICB2YXIgZW1haWxVc2VyUGFydCA9IC9eW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XSskL2k7XG4gIHZhciBnbWFpbFVzZXJQYXJ0ID0gL15bYS16XFxkXSskLztcbiAgdmFyIHF1b3RlZEVtYWlsVXNlciA9IC9eKFtcXHNcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdlXXwoXFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl0pKSokL2k7XG4gIHZhciBlbWFpbFVzZXJVdGY4UGFydCA9IC9eW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSskL2k7XG4gIHZhciBxdW90ZWRFbWFpbFVzZXJVdGY4ID0gL14oW1xcc1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2VcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdfChcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKiQvaTtcbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29udHJvbC1yZWdleCAqL1xuXG4gIGZ1bmN0aW9uIGlzRW1haWwoc3RyLCBvcHRpb25zKSB7XG4gICAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XG4gICAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZW1haWxfb3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlX2Rpc3BsYXlfbmFtZSB8fCBvcHRpb25zLmFsbG93X2Rpc3BsYXlfbmFtZSkge1xuICAgICAgdmFyIGRpc3BsYXlfZW1haWwgPSBzdHIubWF0Y2goZGlzcGxheU5hbWUpO1xuICAgICAgaWYgKGRpc3BsYXlfZW1haWwpIHtcbiAgICAgICAgc3RyID0gZGlzcGxheV9lbWFpbFsxXTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlX2Rpc3BsYXlfbmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCdAJyk7XG4gICAgdmFyIGRvbWFpbiA9IHBhcnRzLnBvcCgpO1xuICAgIHZhciB1c2VyID0gcGFydHMuam9pbignQCcpO1xuXG4gICAgdmFyIGxvd2VyX2RvbWFpbiA9IGRvbWFpbi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMuZG9tYWluX3NwZWNpZmljX3ZhbGlkYXRpb24gJiYgKGxvd2VyX2RvbWFpbiA9PT0gJ2dtYWlsLmNvbScgfHwgbG93ZXJfZG9tYWluID09PSAnZ29vZ2xlbWFpbC5jb20nKSkge1xuICAgICAgLypcbiAgICAgICAgUHJldmlvdXNseSB3ZSByZW1vdmVkIGRvdHMgZm9yIGdtYWlsIGFkZHJlc3NlcyBiZWZvcmUgdmFsaWRhdGluZy5cbiAgICAgICAgVGhpcyB3YXMgcmVtb3ZlZCBiZWNhdXNlIGl0IGFsbG93cyBgbXVsdGlwbGUuLmRvdHNAZ21haWwuY29tYFxuICAgICAgICB0byBiZSByZXBvcnRlZCBhcyB2YWxpZCwgYnV0IGl0IGlzIG5vdC5cbiAgICAgICAgR21haWwgb25seSBub3JtYWxpemVzIHNpbmdsZSBkb3RzLCByZW1vdmluZyB0aGVtIGZyb20gaGVyZSBpcyBwb2ludGxlc3MsXG4gICAgICAgIHNob3VsZCBiZSBkb25lIGluIG5vcm1hbGl6ZUVtYWlsXG4gICAgICAqL1xuICAgICAgdXNlciA9IHVzZXIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgLy8gUmVtb3Zpbmcgc3ViLWFkZHJlc3MgZnJvbSB1c2VybmFtZSBiZWZvcmUgZ21haWwgdmFsaWRhdGlvblxuICAgICAgdmFyIHVzZXJuYW1lID0gdXNlci5zcGxpdCgnKycpWzBdO1xuXG4gICAgICAvLyBEb3RzIGFyZSBub3QgaW5jbHVkZWQgaW4gZ21haWwgbGVuZ3RoIHJlc3RyaWN0aW9uXG4gICAgICBpZiAoISgwLCBfaXNCeXRlTGVuZ3RoMi5kZWZhdWx0KSh1c2VybmFtZS5yZXBsYWNlKCcuJywgJycpLCB7IG1pbjogNiwgbWF4OiAzMCB9KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfdXNlcl9wYXJ0cyA9IHVzZXJuYW1lLnNwbGl0KCcuJyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF91c2VyX3BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZ21haWxVc2VyUGFydC50ZXN0KF91c2VyX3BhcnRzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKDAsIF9pc0J5dGVMZW5ndGgyLmRlZmF1bHQpKHVzZXIsIHsgbWF4OiA2NCB9KSB8fCAhKDAsIF9pc0J5dGVMZW5ndGgyLmRlZmF1bHQpKGRvbWFpbiwgeyBtYXg6IDI1NCB9KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghKDAsIF9pc0ZRRE4yLmRlZmF1bHQpKGRvbWFpbiwgeyByZXF1aXJlX3RsZDogb3B0aW9ucy5yZXF1aXJlX3RsZCB9KSkge1xuICAgICAgaWYgKCFvcHRpb25zLmFsbG93X2lwX2RvbWFpbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghKDAsIF9pc0lQMi5kZWZhdWx0KShkb21haW4pKSB7XG4gICAgICAgIGlmICghZG9tYWluLnN0YXJ0c1dpdGgoJ1snKSB8fCAhZG9tYWluLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9CcmFja2V0ZG9tYWluID0gZG9tYWluLnN1YnN0cigxLCBkb21haW4ubGVuZ3RoIC0gMik7XG5cbiAgICAgICAgaWYgKG5vQnJhY2tldGRvbWFpbi5sZW5ndGggPT09IDAgfHwgISgwLCBfaXNJUDIuZGVmYXVsdCkobm9CcmFja2V0ZG9tYWluKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1c2VyWzBdID09PSAnXCInKSB7XG4gICAgICB1c2VyID0gdXNlci5zbGljZSgxLCB1c2VyLmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYWxsb3dfdXRmOF9sb2NhbF9wYXJ0ID8gcXVvdGVkRW1haWxVc2VyVXRmOC50ZXN0KHVzZXIpIDogcXVvdGVkRW1haWxVc2VyLnRlc3QodXNlcik7XG4gICAgfVxuXG4gICAgdmFyIHBhdHRlcm4gPSBvcHRpb25zLmFsbG93X3V0ZjhfbG9jYWxfcGFydCA/IGVtYWlsVXNlclV0ZjhQYXJ0IDogZW1haWxVc2VyUGFydDtcblxuICAgIHZhciB1c2VyX3BhcnRzID0gdXNlci5zcGxpdCgnLicpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB1c2VyX3BhcnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgaWYgKCFwYXR0ZXJuLnRlc3QodXNlcl9wYXJ0c1tfaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbiAgfSk7XG5cbiAgdmFyIGlzRW1haWwgPSB1bndyYXBFeHBvcnRzKGlzRW1haWxfMSk7XG5cbiAgdmFyIHZhbGlkYXRlJGQgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxyXG4gICAgaWYgKG9wdGlvbnMubXVsdGlwbGUpIHtcclxuICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoZW1haWxTdHIpIHsgcmV0dXJuIGVtYWlsU3RyLnRyaW0oKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiBpc0VtYWlsKFN0cmluZyh2YWwpLCBvcHRpb25zKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGlzRW1haWwoU3RyaW5nKHZhbHVlKSwgb3B0aW9ucyk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGVtYWlsID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJGRcclxuICB9O1xuXG4gIC8vIFxyXG5cclxuICB2YXIgaXNUZXh0SW5wdXQgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgIHJldHVybiBpbmNsdWRlcyhbJ3RleHQnLCAncGFzc3dvcmQnLCAnc2VhcmNoJywgJ2VtYWlsJywgJ3RlbCcsICd1cmwnLCAndGV4dGFyZWEnLCAnbnVtYmVyJ10sIGVsLnR5cGUpO1xyXG4gIH07XHJcblxyXG4gIHZhciBpc0NoZWNrYm94T3JSYWRpb0lucHV0ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICByZXR1cm4gaW5jbHVkZXMoWydyYWRpbycsICdjaGVja2JveCddLCBlbC50eXBlKTtcclxuICB9O1xyXG5cclxuICB2YXIgaXNEYXRlSW5wdXQgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgIHJldHVybiBpbmNsdWRlcyhbJ2RhdGUnLCAnd2VlaycsICdtb250aCcsICdkYXRldGltZS1sb2NhbCcsICd0aW1lJ10sIGVsLnR5cGUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGRhdGEgYXR0cmlidXRlLiB0aGUgbmFtZSBtdXN0IGJlIGtlYmFiLWNhc2UuXHJcbiAgICovXHJcbiAgdmFyIGdldERhdGFBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHsgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgoXCJkYXRhLXZ2LVwiICsgbmFtZSkpOyB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlcyBhcmUgZWl0aGVyIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gICAqL1xyXG4gIHZhciBpc051bGxPclVuZGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIHZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXHJcbiAgICByZXR1cm4gdmFsdWVzLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgdGhlIGRlZmF1bHQgZmxhZ3Mgb2JqZWN0LlxyXG4gICAqL1xyXG4gIHZhciBjcmVhdGVGbGFncyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XHJcbiAgICB1bnRvdWNoZWQ6IHRydWUsXHJcbiAgICB0b3VjaGVkOiBmYWxzZSxcclxuICAgIGRpcnR5OiBmYWxzZSxcclxuICAgIHByaXN0aW5lOiB0cnVlLFxyXG4gICAgdmFsaWQ6IG51bGwsXHJcbiAgICBpbnZhbGlkOiBudWxsLFxyXG4gICAgdmFsaWRhdGVkOiBmYWxzZSxcclxuICAgIHBlbmRpbmc6IGZhbHNlLFxyXG4gICAgcmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgY2hhbmdlZDogZmFsc2VcclxuICB9KTsgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2hhbGxvdyBvYmplY3QgY29tcGFyaXNvbi5cclxuICAgKi9cclxuICB2YXIgaXNFcXVhbCQxID0gZnVuY3Rpb24gKGxocywgcmhzKSB7XHJcbiAgICBpZiAobGhzIGluc3RhbmNlb2YgUmVnRXhwICYmIHJocyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgICByZXR1cm4gaXNFcXVhbCQxKGxocy5zb3VyY2UsIHJocy5zb3VyY2UpICYmIGlzRXF1YWwkMShsaHMuZmxhZ3MsIHJocy5mbGFncyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGhzKSAmJiBBcnJheS5pc0FycmF5KHJocykpIHtcclxuICAgICAgaWYgKGxocy5sZW5ndGggIT09IHJocy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghaXNFcXVhbCQxKGxoc1tpXSwgcmhzW2ldKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgYm90aCBhcmUgb2JqZWN0cywgY29tcGFyZSBlYWNoIGtleSByZWN1cnNpdmVseS5cclxuICAgIGlmIChpc09iamVjdChsaHMpICYmIGlzT2JqZWN0KHJocykpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGxocykuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiBpc0VxdWFsJDEobGhzW2tleV0sIHJoc1trZXldKTtcclxuICAgICAgfSkgJiYgT2JqZWN0LmtleXMocmhzKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGlzRXF1YWwkMShsaHNba2V5XSwgcmhzW2tleV0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGhzID09PSByaHM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB0aGUgaW5wdXQgZmllbGQgc2NvcGUuXHJcbiAgICovXHJcbiAgdmFyIGdldFNjb3BlID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICB2YXIgc2NvcGUgPSBnZXREYXRhQXR0cmlidXRlKGVsLCAnc2NvcGUnKTtcclxuICAgIGlmIChpc051bGxPclVuZGVmaW5lZChzY29wZSkpIHtcclxuICAgICAgdmFyIGZvcm0gPSBnZXRGb3JtKGVsKTtcclxuXHJcbiAgICAgIGlmIChmb3JtKSB7XHJcbiAgICAgICAgc2NvcGUgPSBnZXREYXRhQXR0cmlidXRlKGZvcm0sICdzY29wZScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICFpc051bGxPclVuZGVmaW5lZChzY29wZSkgPyBzY29wZSA6IG51bGw7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjbG9zZXN0IGZvcm0gZWxlbWVudC5cclxuICAgKi9cclxuICB2YXIgZ2V0Rm9ybSA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGVsKSkgeyByZXR1cm4gbnVsbDsgfVxyXG5cclxuICAgIGlmIChlbC50YWdOYW1lID09PSAnRk9STScpIHsgcmV0dXJuIGVsOyB9XHJcblxyXG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChlbC5mb3JtKSkgeyByZXR1cm4gZWwuZm9ybTsgfVxyXG5cclxuICAgIHJldHVybiAhaXNOdWxsT3JVbmRlZmluZWQoZWwucGFyZW50Tm9kZSkgPyBnZXRGb3JtKGVsLnBhcmVudE5vZGUpIDogbnVsbDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB2YWx1ZSBpbiBhbiBvYmplY3Qgc2FmZWx5LlxyXG4gICAqL1xyXG4gIHZhciBnZXRQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHRhcmdldCwgZGVmKSB7XG4gICAgaWYgKCBkZWYgPT09IHZvaWQgMCApIGRlZiA9IHVuZGVmaW5lZDtcblxyXG4gICAgaWYgKCFwYXRoIHx8ICF0YXJnZXQpIHsgcmV0dXJuIGRlZjsgfVxyXG5cclxuICAgIHZhciB2YWx1ZSA9IHRhcmdldDtcclxuICAgIHBhdGguc3BsaXQoJy4nKS5ldmVyeShmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICBpZiAocHJvcCBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWVbcHJvcF07XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YWx1ZSA9IGRlZjtcclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgcGF0aCBleGlzdHMgd2l0aGluIGFuIG9iamVjdC5cclxuICAgKi9cclxuICB2YXIgaGFzUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCB0YXJnZXQpIHtcclxuICAgIHZhciBvYmogPSB0YXJnZXQ7XHJcbiAgICByZXR1cm4gcGF0aC5zcGxpdCgnLicpLmV2ZXJ5KGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgIGlmIChwcm9wIGluIG9iaikge1xyXG4gICAgICAgIG9iaiA9IG9ialtwcm9wXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlcyBhIHJ1bGUgc3RyaW5nIGV4cHJlc3Npb24uXHJcbiAgICovXHJcbiAgdmFyIHBhcnNlUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICB2YXIgcGFyYW1zID0gW107XHJcbiAgICB2YXIgbmFtZSA9IHJ1bGUuc3BsaXQoJzonKVswXTtcclxuXHJcbiAgICBpZiAoaW5jbHVkZXMocnVsZSwgJzonKSkge1xyXG4gICAgICBwYXJhbXMgPSBydWxlLnNwbGl0KCc6Jykuc2xpY2UoMSkuam9pbignOicpLnNwbGl0KCcsJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgcGFyYW1zOiBwYXJhbXMgfTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBEZWJvdW5jZXMgYSBmdW5jdGlvbi5cclxuICAgKi9cclxuICB2YXIgZGVib3VuY2UgPSBmdW5jdGlvbiAoZm4sIHdhaXQsIHRva2VuKSB7XG4gICAgaWYgKCB3YWl0ID09PSB2b2lkIDAgKSB3YWl0ID0gMDtcbiAgICBpZiAoIHRva2VuID09PSB2b2lkIDAgKSB0b2tlbiA9IHsgY2FuY2VsbGVkOiBmYWxzZSB9O1xuXHJcbiAgICBpZiAod2FpdCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gZm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRpbWVvdXQ7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXHJcbiAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZuIGNhbGwgd2FzIGNhbmNlbGxlZC5cclxuICAgICAgICBpZiAoIXRva2VuLmNhbmNlbGxlZCkgeyBmbi5hcHBseSh2b2lkIDAsIGFyZ3MpOyB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcclxuICAgICAgaWYgKCF0aW1lb3V0KSB7IGZuLmFwcGx5KHZvaWQgMCwgYXJncyk7IH1cclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQXBwZW5kcyBhIHJ1bGUgZGVmaW5pdGlvbiB0byBhIGxpc3Qgb2YgcnVsZXMuXHJcbiAgICovXHJcbiAgdmFyIGFwcGVuZFJ1bGUgPSBmdW5jdGlvbiAocnVsZSwgcnVsZXMpIHtcclxuICAgIGlmICghcnVsZXMpIHtcclxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJ1bGVzKHJ1bGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghcnVsZSkge1xyXG4gICAgICByZXR1cm4gbm9ybWFsaXplUnVsZXMocnVsZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgcnVsZXMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJ1bGVzID0gbm9ybWFsaXplUnVsZXMocnVsZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhc3NpZ24oe30sIHJ1bGVzLCBub3JtYWxpemVSdWxlcyhydWxlKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gcnVsZXMgZXhwcmVzc2lvbi5cclxuICAgKi9cclxuICB2YXIgbm9ybWFsaXplUnVsZXMgPSBmdW5jdGlvbiAocnVsZXMpIHtcclxuICAgIC8vIGlmIGZhbHN5IHZhbHVlIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXHJcbiAgICBpZiAoIXJ1bGVzKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNPYmplY3QocnVsZXMpKSB7XHJcbiAgICAgIC8vICRGbG93Rml4TWVcclxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJ1bGVzKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxyXG4gICAgICAgIGlmIChydWxlc1tjdXJyXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgcGFyYW1zID0gW107XHJcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJ1bGVzW2N1cnJdKSkge1xyXG4gICAgICAgICAgcGFyYW1zID0gcnVsZXNbY3Vycl07XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChydWxlc1tjdXJyXSkpIHtcclxuICAgICAgICAgIHBhcmFtcyA9IHJ1bGVzW2N1cnJdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwYXJhbXMgPSBbcnVsZXNbY3Vycl1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxyXG4gICAgICAgIGlmIChydWxlc1tjdXJyXSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgIHByZXZbY3Vycl0gPSBwYXJhbXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgfSwge30pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgcnVsZXMgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHdhcm4oJ3J1bGVzIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdC4nKTtcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBydWxlcy5zcGxpdCgnfCcpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgcnVsZSkge1xyXG4gICAgICB2YXIgcGFyc2VkUnVsZSA9IHBhcnNlUnVsZShydWxlKTtcclxuICAgICAgaWYgKCFwYXJzZWRSdWxlLm5hbWUpIHtcclxuICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJldltwYXJzZWRSdWxlLm5hbWVdID0gcGFyc2VkUnVsZS5wYXJhbXM7XHJcbiAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgfSwge30pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEVtaXRzIGEgd2FybmluZyB0byB0aGUgY29uc29sZS5cclxuICAgKi9cclxuICB2YXIgd2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oKFwiW3ZlZS12YWxpZGF0ZV0gXCIgKyBtZXNzYWdlKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgYnJhbmRlZCBlcnJvciBvYmplY3QuXHJcbiAgICovXHJcbiAgdmFyIGNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIG5ldyBFcnJvcigoXCJbdmVlLXZhbGlkYXRlXSBcIiArIG1lc3NhZ2UpKTsgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QuXHJcbiAgICovXHJcbiAgdmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhIEFycmF5LmlzQXJyYXkob2JqKTsgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGEgZnVuY3Rpb24gaXMgY2FsbGFibGUuXHJcbiAgICovXHJcbiAgdmFyIGlzQ2FsbGFibGUgPSBmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7IH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGVsZW1lbnQgaGFzIHRoZSBjc3MgY2xhc3Mgb24gaXQuXHJcbiAgICovXHJcbiAgdmFyIGhhc0NsYXNzID0gZnVuY3Rpb24gKGVsLCBjbGFzc05hbWUpIHtcclxuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAhIWVsLmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKChcIihcXFxcc3xeKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHN8JClcIikpKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHRoZSBwcm92aWRlZCBjc3MgY2xhc3NOYW1lIHRvIHRoZSBlbGVtZW50LlxyXG4gICAqL1xyXG4gIHZhciBhZGRDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lKSB7XHJcbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaGFzQ2xhc3MoZWwsIGNsYXNzTmFtZSkpIHtcclxuICAgICAgZWwuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgcHJvdmlkZWQgY3NzIGNsYXNzTmFtZSBmcm9tIHRoZSBlbGVtZW50LlxyXG4gICAqL1xyXG4gIHZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lKSB7XHJcbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSkge1xyXG4gICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cCgoXCIoXFxcXHN8XilcIiArIGNsYXNzTmFtZSArIFwiKFxcXFxzfCQpXCIpKTtcclxuICAgICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UocmVnLCAnICcpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgb3IgcmVtb3ZlcyBhIGNsYXNzIG5hbWUgb24gdGhlIGlucHV0IGRlcGVuZGluZyBvbiB0aGUgc3RhdHVzIGZsYWcuXHJcbiAgICovXHJcbiAgdmFyIHRvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGVsLCBjbGFzc05hbWUsIHN0YXR1cykge1xyXG4gICAgaWYgKCFlbCB8fCAhY2xhc3NOYW1lKSB7IHJldHVybjsgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNsYXNzTmFtZSkpIHtcclxuICAgICAgY2xhc3NOYW1lLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIHRvZ2dsZUNsYXNzKGVsLCBpdGVtLCBzdGF0dXMpOyB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0dXMpIHtcclxuICAgICAgcmV0dXJuIGFkZENsYXNzKGVsLCBjbGFzc05hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIGFuIGFycmF5LWxpa2Ugb2JqZWN0IHRvIGFycmF5LCBwcm92aWRlcyBhIHNpbXBsZSBwb2x5ZmlsbCBmb3IgQXJyYXkuZnJvbVxyXG4gICAqL1xyXG4gIHZhciB0b0FycmF5ID0gZnVuY3Rpb24gKGFycmF5TGlrZSkge1xyXG4gICAgaWYgKGlzQ2FsbGFibGUoQXJyYXkuZnJvbSkpIHtcclxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXlMaWtlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXJyYXkgPSBbXTtcclxuICAgIHZhciBsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgYXJyYXkucHVzaChhcnJheUxpa2VbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQXNzaWduIHBvbHlmaWxsIGZyb20gdGhlIG1kbi5cclxuICAgKi9cclxuICB2YXIgYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBvdGhlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBvdGhlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICBpZiAoaXNDYWxsYWJsZShPYmplY3QuYXNzaWduKSkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIFsgdGFyZ2V0IF0uY29uY2F0KCBvdGhlcnMgKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgb3RoZXJzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xyXG4gICAgICAvLyBTa2lwIG92ZXIgaWYgdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgaWYgKGFyZyAhPSBudWxsKSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgIHRvW2tleV0gPSBhcmdba2V5XTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIHRvO1xyXG4gIH07XHJcblxyXG4gIHZhciBpZCA9IDA7XHJcbiAgdmFyIGlkVGVtcGxhdGUgPSAne2lkfSc7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBpZC5cclxuICAgKi9cclxuICB2YXIgdW5pcUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gaGFuZGxlIHRvbyBtYW55IHVzZXMgb2YgdW5pcUlkLCBhbHRob3VnaCB1bmxpa2VseS5cclxuICAgIGlmIChpZCA+PSA5OTk5KSB7XHJcbiAgICAgIGlkID0gMDtcclxuICAgICAgLy8gc2hpZnQgdGhlIHRlbXBsYXRlLlxyXG4gICAgICBpZFRlbXBsYXRlID0gaWRUZW1wbGF0ZS5yZXBsYWNlKCd7aWR9JywgJ197aWR9Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWQrKztcclxuICAgIHZhciBuZXdJZCA9IGlkVGVtcGxhdGUucmVwbGFjZSgne2lkfScsIFN0cmluZyhpZCkpO1xyXG5cclxuICAgIHJldHVybiBuZXdJZDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBmaW5kcyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlIGNhbGxiYWNrLCBwb2x5ZmlsbHMgYXJyYXkuZmluZFxyXG4gICAqL1xyXG4gIHZhciBmaW5kID0gZnVuY3Rpb24gKGFycmF5TGlrZSwgcHJlZGljYXRlKSB7XHJcbiAgICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KGFycmF5TGlrZSkgPyBhcnJheUxpa2UgOiB0b0FycmF5KGFycmF5TGlrZSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaV0pKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5W2ldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9O1xyXG5cclxuICB2YXIgaXNCdWlsdEluQ29tcG9uZW50ID0gZnVuY3Rpb24gKHZub2RlKSB7XHJcbiAgICBpZiAoIXZub2RlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGFnID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucy50YWc7XHJcblxyXG4gICAgcmV0dXJuIC9eKGtlZXAtYWxpdmV8dHJhbnNpdGlvbnx0cmFuc2l0aW9uLWdyb3VwKSQvLnRlc3QodGFnKTtcclxuICB9O1xyXG5cclxuICB2YXIgbWFrZURlbGF5T2JqZWN0ID0gZnVuY3Rpb24gKGV2ZW50cywgZGVsYXksIGRlbGF5Q29uZmlnKSB7XHJcbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJykge1xyXG4gICAgICByZXR1cm4gZXZlbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgZSkge1xyXG4gICAgICAgIHByZXZbZV0gPSBkZWxheTtcclxuICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgfSwge30pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBldmVudHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdvYmplY3QnICYmIGUgaW4gZGVsYXkpIHtcclxuICAgICAgICBwcmV2W2VdID0gZGVsYXlbZV07XHJcbiAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2YgZGVsYXlDb25maWcgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcHJldltlXSA9IGRlbGF5Q29uZmlnO1xyXG4gICAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcmV2W2VdID0gKGRlbGF5Q29uZmlnICYmIGRlbGF5Q29uZmlnW2VdKSB8fCAwO1xyXG5cclxuICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICB9LCB7fSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGRlZXBQYXJzZUludCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHsgcmV0dXJuIGlucHV0OyB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHBhcnNlSW50KGlucHV0KTsgfVxyXG5cclxuICAgIHZhciBtYXAgPSB7fTtcclxuICAgIGZvciAodmFyIGVsZW1lbnQgaW4gaW5wdXQpIHtcclxuICAgICAgbWFwW2VsZW1lbnRdID0gcGFyc2VJbnQoaW5wdXRbZWxlbWVudF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtYXA7XHJcbiAgfTtcclxuXHJcbiAgdmFyIG1lcmdlJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcclxuICAgIGlmICghIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpKSB7XHJcbiAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBvYmosIG9iaiQxO1xuXHJcbiAgICAgIGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcclxuICAgICAgICBpZiAoISB0YXJnZXRba2V5XSkge1xyXG4gICAgICAgICAgYXNzaWduKHRhcmdldCwgKCBvYmogPSB7fSwgb2JqW2tleV0gPSB7fSwgb2JqICkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWVyZ2UkMSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXNzaWduKHRhcmdldCwgKCBvYmokMSA9IHt9LCBvYmokMVtrZXldID0gc291cmNlW2tleV0sIG9iaiQxICkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9O1xyXG5cclxuICB2YXIgZmlsbFJ1bGVzRnJvbUVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIHJ1bGVzKSB7XHJcbiAgICBpZiAoZWwucmVxdWlyZWQpIHtcclxuICAgICAgcnVsZXMgPSBhcHBlbmRSdWxlKCdyZXF1aXJlZCcsIHJ1bGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNUZXh0SW5wdXQoZWwpKSB7XHJcbiAgICAgIGlmIChlbC50eXBlID09PSAnZW1haWwnKSB7XHJcbiAgICAgICAgcnVsZXMgPSBhcHBlbmRSdWxlKChcImVtYWlsXCIgKyAoZWwubXVsdGlwbGUgPyAnOm11bHRpcGxlJyA6ICcnKSksIHJ1bGVzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVsLnBhdHRlcm4pIHtcclxuICAgICAgICBydWxlcyA9IGFwcGVuZFJ1bGUoeyByZWdleDogZWwucGF0dGVybiB9LCBydWxlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDUyNDI4OCBpcyB0aGUgbWF4IG9uIHNvbWUgYnJvd3NlcnMgYW5kIHRlc3QgZW52aXJvbm1lbnRzLlxyXG4gICAgICBpZiAoZWwubWF4TGVuZ3RoID49IDAgJiYgZWwubWF4TGVuZ3RoIDwgNTI0Mjg4KSB7XHJcbiAgICAgICAgcnVsZXMgPSBhcHBlbmRSdWxlKChcIm1heDpcIiArIChlbC5tYXhMZW5ndGgpKSwgcnVsZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZWwubWluTGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJ1bGVzID0gYXBwZW5kUnVsZSgoXCJtaW46XCIgKyAoZWwubWluTGVuZ3RoKSksIHJ1bGVzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVsLnR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcnVsZXMgPSBhcHBlbmRSdWxlKCdkZWNpbWFsJywgcnVsZXMpO1xyXG4gICAgICAgIGlmIChlbC5taW4gIT09ICcnKSB7XHJcbiAgICAgICAgICBydWxlcyA9IGFwcGVuZFJ1bGUoKFwibWluX3ZhbHVlOlwiICsgKGVsLm1pbikpLCBydWxlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZWwubWF4ICE9PSAnJykge1xyXG4gICAgICAgICAgcnVsZXMgPSBhcHBlbmRSdWxlKChcIm1heF92YWx1ZTpcIiArIChlbC5tYXgpKSwgcnVsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJ1bGVzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0RhdGVJbnB1dChlbCkpIHtcclxuICAgICAgdmFyIHRpbWVGb3JtYXQgPSBlbC5zdGVwICYmIE51bWJlcihlbC5zdGVwKSA8IDYwID8gJ0hIOm1tOnNzJyA6ICdISDptbSc7XHJcblxyXG4gICAgICBpZiAoZWwudHlwZSA9PT0gJ2RhdGUnKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcGVuZFJ1bGUoJ2RhdGVfZm9ybWF0OllZWVktTU0tREQnLCBydWxlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbC50eXBlID09PSAnZGF0ZXRpbWUtbG9jYWwnKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcGVuZFJ1bGUoKFwiZGF0ZV9mb3JtYXQ6WVlZWS1NTS1ERFRcIiArIHRpbWVGb3JtYXQpLCBydWxlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbC50eXBlID09PSAnbW9udGgnKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcGVuZFJ1bGUoJ2RhdGVfZm9ybWF0OllZWVktTU0nLCBydWxlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbC50eXBlID09PSAnd2VlaycpIHtcclxuICAgICAgICByZXR1cm4gYXBwZW5kUnVsZSgnZGF0ZV9mb3JtYXQ6WVlZWS1bV11XVycsIHJ1bGVzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVsLnR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgIHJldHVybiBhcHBlbmRSdWxlKChcImRhdGVfZm9ybWF0OlwiICsgdGltZUZvcm1hdCksIHJ1bGVzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBydWxlcztcclxuICB9O1xyXG5cclxuICB2YXIgdmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgaWYgKGlzQ2FsbGFibGUoT2JqZWN0LnZhbHVlcykpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMob2JqKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmYWxsYmFjayB0byBrZXlzKClcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIG9ialtrXTsgfSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHBhcnNlU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgIHZhciBydWxlID0gbnVsbDtcclxuICAgIGlmIChpbmNsdWRlcyhzZWxlY3RvciwgJzonKSkge1xyXG4gICAgICBydWxlID0gc2VsZWN0b3Iuc3BsaXQoJzonKS5wb3AoKTtcclxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKChcIjpcIiArIHJ1bGUpLCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlbGVjdG9yWzBdID09PSAnIycpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogc2VsZWN0b3Iuc2xpY2UoMSksXHJcbiAgICAgICAgcnVsZTogcnVsZSxcclxuICAgICAgICBuYW1lOiBudWxsLFxyXG4gICAgICAgIHNjb3BlOiBudWxsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNjb3BlID0gbnVsbDtcclxuICAgIHZhciBuYW1lID0gc2VsZWN0b3I7XHJcbiAgICBpZiAoaW5jbHVkZXMoc2VsZWN0b3IsICcuJykpIHtcclxuICAgICAgdmFyIHBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoJy4nKTtcclxuICAgICAgc2NvcGUgPSBwYXJ0c1swXTtcclxuICAgICAgbmFtZSA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJy4nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogbnVsbCxcclxuICAgICAgc2NvcGU6IHNjb3BlLFxyXG4gICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICBydWxlOiBydWxlXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIHZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpdGVtKSB7XHJcbiAgICByZXR1cm4gY29sbGVjdGlvbi5pbmRleE9mKGl0ZW0pICE9PSAtMTtcclxuICB9O1xyXG5cclxuICB2YXIgaXNFbXB0eUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSAmJiBhcnIubGVuZ3RoID09PSAwO1xyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJGUgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkZSh2YWwsIG9wdGlvbnMpOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdG9BcnJheShvcHRpb25zKS5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICByZXR1cm4gaXRlbSA9PSB2YWx1ZTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIHZhciBpbmNsdWRlZCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRlXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cclxuICAgIHJldHVybiAhdmFsaWRhdGUkZS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xyXG4gIH07XHJcblxyXG4gIHZhciBleGNsdWRlZCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRmXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkZyA9IGZ1bmN0aW9uIChmaWxlcywgZXh0ZW5zaW9ucykge1xyXG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgoXCIuKFwiICsgKGV4dGVuc2lvbnMuam9pbignfCcpKSArIFwiKSRcIiksICdpJyk7XHJcblxyXG4gICAgcmV0dXJuIGZpbGVzLmV2ZXJ5KGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiByZWdleC50ZXN0KGZpbGUubmFtZSk7IH0pO1xyXG4gIH07XHJcblxyXG4gIHZhciBleHQgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkZ1xyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJGggPSBmdW5jdGlvbiAoZmlsZXMpIHsgcmV0dXJuIGZpbGVzLmV2ZXJ5KGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiAvXFwuKGpwZ3xzdmd8anBlZ3xwbmd8Ym1wfGdpZikkL2kudGVzdChmaWxlLm5hbWUpOyB9KTsgfTtcclxuXHJcbiAgdmFyIGltYWdlID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJGhcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSRpID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIC9eLT9bMC05XSskLy50ZXN0KFN0cmluZyh2YWwpKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIC9eLT9bMC05XSskLy50ZXN0KFN0cmluZyh2YWx1ZSkpO1xyXG4gIH07XHJcblxyXG4gIHZhciBpbnRlZ2VyID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJGlcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSRqID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gICAgdmFyIHZlcnNpb24gPSByZWYudmVyc2lvbjsgaWYgKCB2ZXJzaW9uID09PSB2b2lkIDAgKSB2ZXJzaW9uID0gNDtcblxyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICB2YWx1ZSA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gaXNJUCh2YWwsIHZlcnNpb24pOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXNJUCh2YWx1ZSwgdmVyc2lvbik7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHBhcmFtTmFtZXMkYiA9IFsndmVyc2lvbiddO1xyXG5cclxuICB2YXIgaXAgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkaixcclxuICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMkYlxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJGsgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSBbXTtcbiAgICB2YXIgb3RoZXIgPSByZWZbMF07XG5cclxuICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXI7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGlzID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJGtcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSRsID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0gW107XG4gICAgdmFyIG90aGVyID0gcmVmWzBdO1xuXHJcbiAgICByZXR1cm4gdmFsdWUgIT09IG90aGVyO1xyXG4gIH07XHJcblxyXG4gIHZhciBpc19ub3QgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkbFxyXG4gIH07XG5cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHZhbHVlXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcclxuICAgKi9cclxuICB2YXIgY29tcGFyZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbGVuZ3RoLCBtYXgpIHtcclxuICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSBsZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FzdCB0byBudW1iZXIuXHJcbiAgICBtYXggPSBOdW1iZXIobWF4KTtcclxuXHJcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoID49IGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggPD0gbWF4O1xyXG4gIH07XHJcblxyXG4gIHZhciB2YWxpZGF0ZSRtID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgICB2YXIgbGVuZ3RoID0gcmVmWzBdO1xuICAgIHZhciBtYXggPSByZWZbMV07IGlmICggbWF4ID09PSB2b2lkIDAgKSBtYXggPSB1bmRlZmluZWQ7XG5cclxuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xyXG4gICAgICB2YWx1ZSA9IHRvQXJyYXkodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb21wYXJlKHZhbHVlLCBsZW5ndGgsIG1heCk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGxlbmd0aCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRtXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkbiA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gICAgdmFyIGxlbmd0aCA9IHJlZlswXTtcblxyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGxlbmd0aCA+PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkbih2YWwsIFtsZW5ndGhdKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSkubGVuZ3RoIDw9IGxlbmd0aDtcclxuICB9O1xyXG5cclxuICB2YXIgbWF4JDEgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkblxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJG8gPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICAgIHZhciBtYXggPSByZWZbMF07XG5cclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJG8odmFsLCBbbWF4XSk7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBOdW1iZXIodmFsdWUpIDw9IG1heDtcclxuICB9O1xyXG5cclxuICB2YXIgbWF4X3ZhbHVlID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJG9cclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSRwID0gZnVuY3Rpb24gKGZpbGVzLCBtaW1lcykge1xyXG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgoKG1pbWVzLmpvaW4oJ3wnKS5yZXBsYWNlKCcqJywgJy4rJykpICsgXCIkXCIpLCAnaScpO1xyXG5cclxuICAgIHJldHVybiBmaWxlcy5ldmVyeShmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gcmVnZXgudGVzdChmaWxlLnR5cGUpOyB9KTtcclxuICB9O1xyXG5cclxuICB2YXIgbWltZXMgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkcFxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJHEgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICAgIHZhciBsZW5ndGggPSByZWZbMF07XG5cclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJHEodmFsLCBbbGVuZ3RoXSk7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpLmxlbmd0aCA+PSBsZW5ndGg7XHJcbiAgfTtcclxuXHJcbiAgdmFyIG1pbiQxID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJHFcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSRyID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgICB2YXIgbWluID0gcmVmWzBdO1xuXHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSRyKHZhbCwgW21pbl0pOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKSA+PSBtaW47XHJcbiAgfTtcclxuXHJcbiAgdmFyIG1pbl92YWx1ZSA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRyXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiAvXlswLTldKyQvLnRlc3QoU3RyaW5nKHZhbCkpOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gL15bMC05XSskLy50ZXN0KFN0cmluZyh2YWx1ZSkpO1xyXG4gIH07XHJcblxyXG4gIHZhciBudW1lcmljID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJHNcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSR0ID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHJlZi5leHByZXNzaW9uO1xuXHJcbiAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKGV4cHJlc3Npb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkdCh2YWwsIHsgZXhwcmVzc2lvbjogZXhwcmVzc2lvbiB9KTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGV4cHJlc3Npb24udGVzdChTdHJpbmcodmFsdWUpKTtcclxuICB9O1xyXG5cclxuICB2YXIgcGFyYW1OYW1lcyRjID0gWydleHByZXNzaW9uJ107XHJcblxyXG4gIHZhciByZWdleCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSR0LFxyXG4gICAgcGFyYW1OYW1lczogcGFyYW1OYW1lcyRjXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkdSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtdO1xuICAgIHZhciBpbnZhbGlkYXRlRmFsc2UgPSByZWZbMF07IGlmICggaW52YWxpZGF0ZUZhbHNlID09PSB2b2lkIDAgKSBpbnZhbGlkYXRlRmFsc2UgPSBmYWxzZTtcblxyXG4gICAgaWYgKGlzRW1wdHlBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGluY2FzZSBhIGZpZWxkIGNvbnNpZGVycyBgZmFsc2VgIGFzIGFuIGVtcHR5IHZhbHVlIGxpa2UgY2hlY2tib3hlcy5cclxuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgJiYgaW52YWxpZGF0ZUZhbHNlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICEhU3RyaW5nKHZhbHVlKS50cmltKCkubGVuZ3RoO1xyXG4gIH07XHJcblxyXG4gIHZhciByZXF1aXJlZCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSR1XHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkdiA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XG4gICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtdO1xuICAgIHZhciBvdGhlckZpZWxkVmFsID0gcmVmWzBdO1xuICAgIHZhciBwb3NzaWJsZVZhbHMgPSByZWYuc2xpY2UoMSk7XG5cclxuICAgIHZhciByZXF1aXJlZCA9IHBvc3NpYmxlVmFscy5pbmNsdWRlcyhTdHJpbmcob3RoZXJGaWVsZFZhbCkudHJpbSgpKTtcclxuXHJcbiAgICBpZiAoIXJlcXVpcmVkKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsaWQ6IHRydWUsXHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbnZhbGlkID0gKGlzRW1wdHlBcnJheSh2YWx1ZSkgfHwgW2ZhbHNlLCBudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKHZhbHVlKSk7XHJcblxyXG4gICAgaW52YWxpZCA9IGludmFsaWQgfHwgIVN0cmluZyh2YWx1ZSkudHJpbSgpLmxlbmd0aDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB2YWxpZDogIWludmFsaWQsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICByZXF1aXJlZDogcmVxdWlyZWRcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICB2YXIgb3B0aW9ucyQ1ID0ge1xyXG4gICAgaGFzVGFyZ2V0OiB0cnVlLFxyXG4gICAgY29tcHV0ZXNSZXF1aXJlZDogdHJ1ZVxyXG4gIH07XHJcblxyXG4gIHZhciByZXF1aXJlZF9pZiA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSR2LFxyXG4gICAgb3B0aW9uczogb3B0aW9ucyQ1XHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkdyA9IGZ1bmN0aW9uIChmaWxlcywgcmVmKSB7XG4gICAgdmFyIHNpemUgPSByZWZbMF07XG5cclxuICAgIGlmIChpc05hTihzaXplKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5TaXplID0gTnVtYmVyKHNpemUpICogMTAyNDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGZpbGVzW2ldLnNpemUgPiBuU2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcblxyXG4gIHZhciBzaXplID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJHdcclxuICB9O1xuXG4gIHZhciBpc1VSTF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzLmRlZmF1bHQgPSBpc1VSTDtcblxuXG5cbiAgdmFyIF9hc3NlcnRTdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XG5cblxuXG4gIHZhciBfaXNGUUROMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXNGUUROXzEpO1xuXG5cblxuICB2YXIgX2lzSVAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0lQXzEpO1xuXG5cblxuICB2YXIgX21lcmdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobWVyZ2VfMSk7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuICB2YXIgZGVmYXVsdF91cmxfb3B0aW9ucyA9IHtcbiAgICBwcm90b2NvbHM6IFsnaHR0cCcsICdodHRwcycsICdmdHAnXSxcbiAgICByZXF1aXJlX3RsZDogdHJ1ZSxcbiAgICByZXF1aXJlX3Byb3RvY29sOiBmYWxzZSxcbiAgICByZXF1aXJlX2hvc3Q6IHRydWUsXG4gICAgcmVxdWlyZV92YWxpZF9wcm90b2NvbDogdHJ1ZSxcbiAgICBhbGxvd191bmRlcnNjb3JlczogZmFsc2UsXG4gICAgYWxsb3dfdHJhaWxpbmdfZG90OiBmYWxzZSxcbiAgICBhbGxvd19wcm90b2NvbF9yZWxhdGl2ZV91cmxzOiBmYWxzZVxuICB9O1xuXG4gIHZhciB3cmFwcGVkX2lwdjYgPSAvXlxcWyhbXlxcXV0rKVxcXSg/OjooWzAtOV0rKSk/JC87XG5cbiAgZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrSG9zdChob3N0LCBtYXRjaGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBtYXRjaGVzW2ldO1xuICAgICAgaWYgKGhvc3QgPT09IG1hdGNoIHx8IGlzUmVnRXhwKG1hdGNoKSAmJiBtYXRjaC50ZXN0KGhvc3QpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc1VSTCh1cmwsIG9wdGlvbnMpIHtcbiAgICAoMCwgX2Fzc2VydFN0cmluZzIuZGVmYXVsdCkodXJsKTtcbiAgICBpZiAoIXVybCB8fCB1cmwubGVuZ3RoID49IDIwODMgfHwgL1tcXHM8Pl0vLnRlc3QodXJsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodXJsLmluZGV4T2YoJ21haWx0bzonKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvcHRpb25zID0gKDAsIF9tZXJnZTIuZGVmYXVsdCkob3B0aW9ucywgZGVmYXVsdF91cmxfb3B0aW9ucyk7XG4gICAgdmFyIHByb3RvY29sID0gdm9pZCAwLFxuICAgICAgICBhdXRoID0gdm9pZCAwLFxuICAgICAgICBob3N0ID0gdm9pZCAwLFxuICAgICAgICBob3N0bmFtZSA9IHZvaWQgMCxcbiAgICAgICAgcG9ydCA9IHZvaWQgMCxcbiAgICAgICAgcG9ydF9zdHIgPSB2b2lkIDAsXG4gICAgICAgIHNwbGl0ID0gdm9pZCAwLFxuICAgICAgICBpcHY2ID0gdm9pZCAwO1xuXG4gICAgc3BsaXQgPSB1cmwuc3BsaXQoJyMnKTtcbiAgICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuXG4gICAgc3BsaXQgPSB1cmwuc3BsaXQoJz8nKTtcbiAgICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuXG4gICAgc3BsaXQgPSB1cmwuc3BsaXQoJzovLycpO1xuICAgIGlmIChzcGxpdC5sZW5ndGggPiAxKSB7XG4gICAgICBwcm90b2NvbCA9IHNwbGl0LnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChvcHRpb25zLnJlcXVpcmVfdmFsaWRfcHJvdG9jb2wgJiYgb3B0aW9ucy5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZV9wcm90b2NvbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodXJsLnN1YnN0cigwLCAyKSA9PT0gJy8vJykge1xuICAgICAgaWYgKCFvcHRpb25zLmFsbG93X3Byb3RvY29sX3JlbGF0aXZlX3VybHMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3BsaXRbMF0gPSB1cmwuc3Vic3RyKDIpO1xuICAgIH1cbiAgICB1cmwgPSBzcGxpdC5qb2luKCc6Ly8nKTtcblxuICAgIGlmICh1cmwgPT09ICcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3BsaXQgPSB1cmwuc3BsaXQoJy8nKTtcbiAgICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuXG4gICAgaWYgKHVybCA9PT0gJycgJiYgIW9wdGlvbnMucmVxdWlyZV9ob3N0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzcGxpdCA9IHVybC5zcGxpdCgnQCcpO1xuICAgIGlmIChzcGxpdC5sZW5ndGggPiAxKSB7XG4gICAgICBhdXRoID0gc3BsaXQuc2hpZnQoKTtcbiAgICAgIGlmIChhdXRoLmluZGV4T2YoJzonKSA+PSAwICYmIGF1dGguc3BsaXQoJzonKS5sZW5ndGggPiAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaG9zdG5hbWUgPSBzcGxpdC5qb2luKCdAJyk7XG5cbiAgICBwb3J0X3N0ciA9IG51bGw7XG4gICAgaXB2NiA9IG51bGw7XG4gICAgdmFyIGlwdjZfbWF0Y2ggPSBob3N0bmFtZS5tYXRjaCh3cmFwcGVkX2lwdjYpO1xuICAgIGlmIChpcHY2X21hdGNoKSB7XG4gICAgICBob3N0ID0gJyc7XG4gICAgICBpcHY2ID0gaXB2Nl9tYXRjaFsxXTtcbiAgICAgIHBvcnRfc3RyID0gaXB2Nl9tYXRjaFsyXSB8fCBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcGxpdCA9IGhvc3RuYW1lLnNwbGl0KCc6Jyk7XG4gICAgICBob3N0ID0gc3BsaXQuc2hpZnQoKTtcbiAgICAgIGlmIChzcGxpdC5sZW5ndGgpIHtcbiAgICAgICAgcG9ydF9zdHIgPSBzcGxpdC5qb2luKCc6Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvcnRfc3RyICE9PSBudWxsKSB7XG4gICAgICBwb3J0ID0gcGFyc2VJbnQocG9ydF9zdHIsIDEwKTtcbiAgICAgIGlmICghL15bMC05XSskLy50ZXN0KHBvcnRfc3RyKSB8fCBwb3J0IDw9IDAgfHwgcG9ydCA+IDY1NTM1KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISgwLCBfaXNJUDIuZGVmYXVsdCkoaG9zdCkgJiYgISgwLCBfaXNGUUROMi5kZWZhdWx0KShob3N0LCBvcHRpb25zKSAmJiAoIWlwdjYgfHwgISgwLCBfaXNJUDIuZGVmYXVsdCkoaXB2NiwgNikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaG9zdCA9IGhvc3QgfHwgaXB2NjtcblxuICAgIGlmIChvcHRpb25zLmhvc3Rfd2hpdGVsaXN0ICYmICFjaGVja0hvc3QoaG9zdCwgb3B0aW9ucy5ob3N0X3doaXRlbGlzdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9zdF9ibGFja2xpc3QgJiYgY2hlY2tIb3N0KGhvc3QsIG9wdGlvbnMuaG9zdF9ibGFja2xpc3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4gIH0pO1xuXG4gIHZhciBpc1VSTCA9IHVud3JhcEV4cG9ydHMoaXNVUkxfMSk7XG5cbiAgdmFyIHZhbGlkYXRlJHggPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICB2YWx1ZSA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gaXNVUkwodmFsLCBvcHRpb25zKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGlzVVJMKHZhbHVlLCBvcHRpb25zKTtcclxuICB9O1xyXG5cclxuICB2YXIgdXJsID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJHhcclxuICB9O1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuXG4gIHZhciBSdWxlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBhZnRlcjogYWZ0ZXIsXG4gICAgYWxwaGFfZGFzaDogYWxwaGFfZGFzaCxcbiAgICBhbHBoYV9udW06IGFscGhhX251bSxcbiAgICBhbHBoYV9zcGFjZXM6IGFscGhhX3NwYWNlcyxcbiAgICBhbHBoYTogYWxwaGEkMSxcbiAgICBiZWZvcmU6IGJlZm9yZSxcbiAgICBiZXR3ZWVuOiBiZXR3ZWVuLFxuICAgIGNvbmZpcm1lZDogY29uZmlybWVkLFxuICAgIGNyZWRpdF9jYXJkOiBjcmVkaXRfY2FyZCxcbiAgICBkYXRlX2JldHdlZW46IGRhdGVfYmV0d2VlbixcbiAgICBkYXRlX2Zvcm1hdDogZGF0ZV9mb3JtYXQsXG4gICAgZGVjaW1hbDogZGVjaW1hbCxcbiAgICBkaWdpdHM6IGRpZ2l0cyxcbiAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgIGVtYWlsOiBlbWFpbCxcbiAgICBleHQ6IGV4dCxcbiAgICBpbWFnZTogaW1hZ2UsXG4gICAgaW5jbHVkZWQ6IGluY2x1ZGVkLFxuICAgIGludGVnZXI6IGludGVnZXIsXG4gICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgaXA6IGlwLFxuICAgIGlzX25vdDogaXNfbm90LFxuICAgIGlzOiBpcyxcbiAgICBtYXg6IG1heCQxLFxuICAgIG1heF92YWx1ZTogbWF4X3ZhbHVlLFxuICAgIG1pbWVzOiBtaW1lcyxcbiAgICBtaW46IG1pbiQxLFxuICAgIG1pbl92YWx1ZTogbWluX3ZhbHVlLFxuICAgIGV4Y2x1ZGVkOiBleGNsdWRlZCxcbiAgICBudW1lcmljOiBudW1lcmljLFxuICAgIHJlZ2V4OiByZWdleCxcbiAgICByZXF1aXJlZDogcmVxdWlyZWQsXG4gICAgcmVxdWlyZWRfaWY6IHJlcXVpcmVkX2lmLFxuICAgIHNpemU6IHNpemUsXG4gICAgdXJsOiB1cmxcbiAgfSk7XG5cbiAgLy8gXHJcblxyXG4gIHZhciBMT0NBTEUgPSAnZW4nO1xyXG5cclxuICB2YXIgRGljdGlvbmFyeSA9IGZ1bmN0aW9uIERpY3Rpb25hcnkgKGRpY3Rpb25hcnkpIHtcbiAgICBpZiAoIGRpY3Rpb25hcnkgPT09IHZvaWQgMCApIGRpY3Rpb25hcnkgPSB7fTtcblxyXG4gICAgdGhpcy5jb250YWluZXIgPSB7fTtcclxuICAgIHRoaXMubWVyZ2UoZGljdGlvbmFyeSk7XHJcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBsb2NhbGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcclxuXHJcbiAgcHJvdG90eXBlQWNjZXNzb3JzLmxvY2FsZS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gTE9DQUxFO1xyXG4gIH07XHJcblxyXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5sb2NhbGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBMT0NBTEUgPSB2YWx1ZSB8fCAnZW4nO1xyXG4gIH07XHJcblxyXG4gIERpY3Rpb25hcnkucHJvdG90eXBlLmhhc0xvY2FsZSA9IGZ1bmN0aW9uIGhhc0xvY2FsZSAobG9jYWxlKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmNvbnRhaW5lcltsb2NhbGVdO1xyXG4gIH07XHJcblxyXG4gIERpY3Rpb25hcnkucHJvdG90eXBlLnNldERhdGVGb3JtYXQgPSBmdW5jdGlvbiBzZXREYXRlRm9ybWF0IChsb2NhbGUsIGZvcm1hdCkge1xyXG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcltsb2NhbGVdKSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVyW2xvY2FsZV0gPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmRhdGVGb3JtYXQgPSBmb3JtYXQ7XHJcbiAgfTtcclxuXHJcbiAgRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0RGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIGdldERhdGVGb3JtYXQgKGxvY2FsZSkge1xyXG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcltsb2NhbGVdIHx8ICF0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmRhdGVGb3JtYXQpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyW2xvY2FsZV0uZGF0ZUZvcm1hdDtcclxuICB9O1xyXG5cclxuICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRNZXNzYWdlID0gZnVuY3Rpb24gZ2V0TWVzc2FnZSAobG9jYWxlLCBrZXksIGRhdGEpIHtcclxuICAgIHZhciBtZXNzYWdlID0gbnVsbDtcclxuICAgIGlmICghdGhpcy5oYXNNZXNzYWdlKGxvY2FsZSwga2V5KSkge1xyXG4gICAgICBtZXNzYWdlID0gdGhpcy5fZ2V0RGVmYXVsdE1lc3NhZ2UobG9jYWxlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1lc3NhZ2UgPSB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLm1lc3NhZ2VzW2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGlzQ2FsbGFibGUobWVzc2FnZSkgPyBtZXNzYWdlLmFwcGx5KHZvaWQgMCwgZGF0YSkgOiBtZXNzYWdlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSBzcGVjaWZpYyBtZXNzYWdlIGZvciBmaWVsZC4gZmFsbHMgYmFjayB0byB0aGUgcnVsZSBtZXNzYWdlLlxyXG4gICAqL1xyXG4gIERpY3Rpb25hcnkucHJvdG90eXBlLmdldEZpZWxkTWVzc2FnZSA9IGZ1bmN0aW9uIGdldEZpZWxkTWVzc2FnZSAobG9jYWxlLCBmaWVsZCwga2V5LCBkYXRhKSB7XHJcbiAgICBpZiAoIXRoaXMuaGFzTG9jYWxlKGxvY2FsZSkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TWVzc2FnZShsb2NhbGUsIGtleSwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRpY3QgPSB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmN1c3RvbSAmJiB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmN1c3RvbVtmaWVsZF07XHJcbiAgICBpZiAoIWRpY3QgfHwgIWRpY3Rba2V5XSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRNZXNzYWdlKGxvY2FsZSwga2V5LCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWVzc2FnZSA9IGRpY3Rba2V5XTtcclxuICAgIHJldHVybiBpc0NhbGxhYmxlKG1lc3NhZ2UpID8gbWVzc2FnZS5hcHBseSh2b2lkIDAsIGRhdGEpIDogbWVzc2FnZTtcclxuICB9O1xyXG5cclxuICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5fZ2V0RGVmYXVsdE1lc3NhZ2UgPSBmdW5jdGlvbiBfZ2V0RGVmYXVsdE1lc3NhZ2UgKGxvY2FsZSkge1xyXG4gICAgaWYgKHRoaXMuaGFzTWVzc2FnZShsb2NhbGUsICdfZGVmYXVsdCcpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLm1lc3NhZ2VzLl9kZWZhdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5lbi5tZXNzYWdlcy5fZGVmYXVsdDtcclxuICB9O1xyXG5cclxuICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUgKGxvY2FsZSwga2V5LCBmYWxsYmFjaykge1xuICAgICAgaWYgKCBmYWxsYmFjayA9PT0gdm9pZCAwICkgZmFsbGJhY2sgPSAnJztcblxyXG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZShsb2NhbGUsIGtleSkpIHtcclxuICAgICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmF0dHJpYnV0ZXNba2V5XTtcclxuICB9O1xyXG5cclxuICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5oYXNNZXNzYWdlID0gZnVuY3Rpb24gaGFzTWVzc2FnZSAobG9jYWxlLCBrZXkpIHtcclxuICAgIHJldHVybiAhISAoXHJcbiAgICAgIHRoaXMuaGFzTG9jYWxlKGxvY2FsZSkgJiZcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJbbG9jYWxlXS5tZXNzYWdlcyAmJlxyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLm1lc3NhZ2VzW2tleV1cclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgRGljdGlvbmFyeS5wcm90b3R5cGUuaGFzQXR0cmlidXRlID0gZnVuY3Rpb24gaGFzQXR0cmlidXRlIChsb2NhbGUsIGtleSkge1xyXG4gICAgcmV0dXJuICEhIChcclxuICAgICAgdGhpcy5oYXNMb2NhbGUobG9jYWxlKSAmJlxyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmF0dHJpYnV0ZXMgJiZcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJbbG9jYWxlXS5hdHRyaWJ1dGVzW2tleV1cclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgRGljdGlvbmFyeS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSQxJCQxIChkaWN0aW9uYXJ5KSB7XHJcbiAgICBtZXJnZSQxKHRoaXMuY29udGFpbmVyLCBkaWN0aW9uYXJ5KTtcclxuICB9O1xyXG5cclxuICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXRNZXNzYWdlID0gZnVuY3Rpb24gc2V0TWVzc2FnZSAobG9jYWxlLCBrZXksIG1lc3NhZ2UpIHtcclxuICAgIGlmICghIHRoaXMuaGFzTG9jYWxlKGxvY2FsZSkpIHtcclxuICAgICAgdGhpcy5jb250YWluZXJbbG9jYWxlXSA9IHtcclxuICAgICAgICBtZXNzYWdlczoge30sXHJcbiAgICAgICAgYXR0cmlidXRlczoge31cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLm1lc3NhZ2VzW2tleV0gPSBtZXNzYWdlO1xyXG4gIH07XHJcblxyXG4gIERpY3Rpb25hcnkucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobG9jYWxlLCBrZXksIGF0dHJpYnV0ZSkge1xyXG4gICAgaWYgKCEgdGhpcy5oYXNMb2NhbGUobG9jYWxlKSkge1xyXG4gICAgICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdID0ge1xyXG4gICAgICAgIG1lc3NhZ2VzOiB7fSxcclxuICAgICAgICBhdHRyaWJ1dGVzOiB7fVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29udGFpbmVyW2xvY2FsZV0uYXR0cmlidXRlc1trZXldID0gYXR0cmlidXRlO1xyXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIERpY3Rpb25hcnkucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuICB2YXIgZHJpdmVycyA9IHtcclxuICAgIGRlZmF1bHQ6IG5ldyBEaWN0aW9uYXJ5KHtcclxuICAgICAgZW46IHtcclxuICAgICAgICBtZXNzYWdlczoge30sXHJcbiAgICAgICAgYXR0cmlidXRlczoge30sXHJcbiAgICAgICAgY3VzdG9tOiB7fVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH07XHJcblxyXG4gIHZhciBjdXJyZW50RHJpdmVyID0gJ2RlZmF1bHQnO1xyXG5cclxuICB2YXIgRGljdGlvbmFyeVJlc29sdmVyID0gZnVuY3Rpb24gRGljdGlvbmFyeVJlc29sdmVyICgpIHt9O1xuXG4gIERpY3Rpb25hcnlSZXNvbHZlci5fY2hlY2tEcml2ZXJOYW1lID0gZnVuY3Rpb24gX2NoZWNrRHJpdmVyTmFtZSAoZHJpdmVyKSB7XHJcbiAgICBpZiAoIWRyaXZlcikge1xyXG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcigneW91IG11c3QgcHJvdmlkZSBhIG5hbWUgdG8gdGhlIGRpY3Rpb25hcnkgZHJpdmVyJyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgRGljdGlvbmFyeVJlc29sdmVyLnNldERyaXZlciA9IGZ1bmN0aW9uIHNldERyaXZlciAoZHJpdmVyLCBpbXBsZW1lbnRhdGlvbikge1xuICAgICAgaWYgKCBpbXBsZW1lbnRhdGlvbiA9PT0gdm9pZCAwICkgaW1wbGVtZW50YXRpb24gPSBudWxsO1xuXHJcbiAgICB0aGlzLl9jaGVja0RyaXZlck5hbWUoZHJpdmVyKTtcclxuICAgIGlmIChpbXBsZW1lbnRhdGlvbikge1xyXG4gICAgICBkcml2ZXJzW2RyaXZlcl0gPSBpbXBsZW1lbnRhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyZW50RHJpdmVyID0gZHJpdmVyO1xyXG4gIH07XHJcblxyXG4gIERpY3Rpb25hcnlSZXNvbHZlci5nZXREcml2ZXIgPSBmdW5jdGlvbiBnZXREcml2ZXIgKCkge1xyXG4gICAgcmV0dXJuIGRyaXZlcnNbY3VycmVudERyaXZlcl07XHJcbiAgfTtcblxuICAvLyBcclxuXHJcbiAgdmFyIEVycm9yQmFnID0gZnVuY3Rpb24gRXJyb3JCYWcgKGVycm9yQmFnLCBpZCkge1xuICAgIGlmICggZXJyb3JCYWcgPT09IHZvaWQgMCApIGVycm9yQmFnID0gbnVsbDtcbiAgICBpZiAoIGlkID09PSB2b2lkIDAgKSBpZCA9IG51bGw7XG5cclxuICAgIHRoaXMudm1JZCA9IGlkIHx8IG51bGw7XHJcbiAgICAvLyBtYWtlIHRoaXMgYmFnIGEgbWlycm9yIG9mIHRoZSBwcm92aWRlZCBvbmUsIHNoYXJpbmcgdGhlIHNhbWUgaXRlbXMgcmVmZXJlbmNlLlxyXG4gICAgaWYgKGVycm9yQmFnICYmIGVycm9yQmFnIGluc3RhbmNlb2YgRXJyb3JCYWcpIHtcclxuICAgICAgdGhpcy5pdGVtcyA9IGVycm9yQmFnLml0ZW1zO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5pdGVtcyA9IFtdO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIEVycm9yQmFnLnByb3RvdHlwZVt0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nID8gU3ltYm9sLml0ZXJhdG9yIDogJ0BAaXRlcmF0b3InXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzJDEuaXRlbXNbaW5kZXgrK10sIGRvbmU6IGluZGV4ID4gdGhpcyQxLml0ZW1zLmxlbmd0aCB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYW4gZXJyb3IgdG8gdGhlIGludGVybmFsIGFycmF5LlxyXG4gICAqL1xyXG4gIEVycm9yQmFnLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGVycm9yKSB7XG4gICAgICB2YXIgcmVmO1xuXHJcbiAgICAocmVmID0gdGhpcy5pdGVtcykucHVzaC5hcHBseShcclxuICAgICAgcmVmLCB0aGlzLl9ub3JtYWxpemVFcnJvcihlcnJvcilcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplcyBwYXNzZWQgZXJyb3JzIHRvIGFuIGVycm9yIGFycmF5LlxyXG4gICAqL1xyXG4gIEVycm9yQmFnLnByb3RvdHlwZS5fbm9ybWFsaXplRXJyb3IgPSBmdW5jdGlvbiBfbm9ybWFsaXplRXJyb3IgKGVycm9yKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpKSB7XHJcbiAgICAgIHJldHVybiBlcnJvci5tYXAoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBlLnNjb3BlID0gIWlzTnVsbE9yVW5kZWZpbmVkKGUuc2NvcGUpID8gZS5zY29wZSA6IG51bGw7XHJcbiAgICAgICAgZS52bUlkID0gIWlzTnVsbE9yVW5kZWZpbmVkKGUudm1JZCkgPyBlLnZtSWQgOiAodGhpcyQxLnZtSWQgfHwgbnVsbCk7XHJcblxyXG4gICAgICAgIHJldHVybiBlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBlcnJvci5zY29wZSA9ICFpc051bGxPclVuZGVmaW5lZChlcnJvci5zY29wZSkgPyBlcnJvci5zY29wZSA6IG51bGw7XHJcbiAgICBlcnJvci52bUlkID0gIWlzTnVsbE9yVW5kZWZpbmVkKGVycm9yLnZtSWQpID8gZXJyb3Iudm1JZCA6ICh0aGlzLnZtSWQgfHwgbnVsbCk7XHJcblxyXG4gICAgcmV0dXJuIFtlcnJvcl07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVnZW5yYXRlcyBlcnJvciBtZXNzYWdlcyBpZiB0aGV5IGhhdmUgYSBnZW5lcmF0b3IgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgRXJyb3JCYWcucHJvdG90eXBlLnJlZ2VuZXJhdGUgPSBmdW5jdGlvbiByZWdlbmVyYXRlICgpIHtcclxuICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xyXG4gICAgICBpLm1zZyA9IGlzQ2FsbGFibGUoaS5yZWdlbmVyYXRlKSA/IGkucmVnZW5lcmF0ZSgpIDogaS5tc2c7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIGEgZmllbGQgZXJyb3Igd2l0aCB0aGUgbmV3IGZpZWxkIHNjb3BlLlxyXG4gICAqL1xyXG4gIEVycm9yQmFnLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGlkLCBlcnJvcikge1xyXG4gICAgdmFyIGl0ZW0gPSBmaW5kKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLmlkID09PSBpZDsgfSk7XHJcbiAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpZHggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XHJcbiAgICB0aGlzLml0ZW1zLnNwbGljZShpZHgsIDEpO1xyXG4gICAgaXRlbS5zY29wZSA9IGVycm9yLnNjb3BlO1xyXG4gICAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYWxsIGVycm9yIG1lc3NhZ2VzIGZyb20gdGhlIGludGVybmFsIGFycmF5LlxyXG4gICAqL1xyXG4gIEVycm9yQmFnLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiBhbGwgKHNjb3BlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgdmFyIGZpbHRlckZuID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgdmFyIG1hdGNoZXNTY29wZSA9IHRydWU7XHJcbiAgICAgIHZhciBtYXRjaGVzVk0gPSB0cnVlO1xyXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSkge1xyXG4gICAgICAgIG1hdGNoZXNTY29wZSA9IGl0ZW0uc2NvcGUgPT09IHNjb3BlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRoaXMkMS52bUlkKSkge1xyXG4gICAgICAgIG1hdGNoZXNWTSA9IGl0ZW0udm1JZCA9PT0gdGhpcyQxLnZtSWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtYXRjaGVzVk0gJiYgbWF0Y2hlc1Njb3BlO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoZmlsdGVyRm4pLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5tc2c7IH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGVyZSBhcmUgYW55IGVycm9ycyBpbiB0aGUgaW50ZXJuYWwgYXJyYXkuXHJcbiAgICovXHJcbiAgRXJyb3JCYWcucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uIGFueSAoc2NvcGUpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICB2YXIgZmlsdGVyRm4gPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICB2YXIgbWF0Y2hlc1Njb3BlID0gdHJ1ZTtcclxuICAgICAgdmFyIG1hdGNoZXNWTSA9IHRydWU7XHJcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpKSB7XHJcbiAgICAgICAgbWF0Y2hlc1Njb3BlID0gaXRlbS5zY29wZSA9PT0gc2NvcGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodGhpcyQxLnZtSWQpKSB7XHJcbiAgICAgICAgbWF0Y2hlc1ZNID0gaXRlbS52bUlkID09PSB0aGlzJDEudm1JZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG1hdGNoZXNWTSAmJiBtYXRjaGVzU2NvcGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAhIXRoaXMuaXRlbXMuZmlsdGVyKGZpbHRlckZuKS5sZW5ndGg7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbGwgaXRlbXMgZnJvbSB0aGUgaW50ZXJuYWwgYXJyYXkuXHJcbiAgICovXHJcbiAgRXJyb3JCYWcucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKHNjb3BlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgdmFyIG1hdGNoZXNWTSA9IGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMudm1JZCkgPyBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9IDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkudm1JZCA9PT0gdGhpcyQxLnZtSWQ7IH07XHJcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpKSB7XHJcbiAgICAgIHNjb3BlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgaWYgKG1hdGNoZXNWTSh0aGlzLml0ZW1zW2ldKSAmJiB0aGlzLml0ZW1zW2ldLnNjb3BlID09PSBzY29wZSkge1xyXG4gICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIC0taTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbGxlY3RzIGVycm9ycyBpbnRvIGdyb3VwcyBvciBmb3IgYSBzcGVjaWZpYyBmaWVsZC5cclxuICAgKi9cclxuICBFcnJvckJhZy5wcm90b3R5cGUuY29sbGVjdCA9IGZ1bmN0aW9uIGNvbGxlY3QgKGZpZWxkLCBzY29wZSwgbWFwKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgIGlmICggbWFwID09PSB2b2lkIDAgKSBtYXAgPSB0cnVlO1xuXHJcbiAgICB2YXIgaXNTaW5nbGVGaWVsZCA9ICFpc051bGxPclVuZGVmaW5lZChmaWVsZCkgJiYgIWZpZWxkLmluY2x1ZGVzKCcqJyk7XHJcbiAgICB2YXIgZ3JvdXBFcnJvcnMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcclxuICAgICAgdmFyIGVycm9ycyA9IGl0ZW1zLnJlZHVjZShmdW5jdGlvbiAoY29sbGVjdGlvbiwgZXJyb3IpIHtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRoaXMkMS52bUlkKSAmJiBlcnJvci52bUlkICE9PSB0aGlzJDEudm1JZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbGxlY3Rpb25bZXJyb3IuZmllbGRdKSB7XHJcbiAgICAgICAgICBjb2xsZWN0aW9uW2Vycm9yLmZpZWxkXSA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29sbGVjdGlvbltlcnJvci5maWVsZF0ucHVzaChtYXAgPyBlcnJvci5tc2cgOiBlcnJvcik7XHJcblxyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xyXG4gICAgICB9LCB7fSk7XHJcblxyXG4gICAgICAvLyByZWR1Y2UgdGhlIGNvbGxlY3Rpb24gdG8gYmUgYSBzaW5nbGUgYXJyYXkuXHJcbiAgICAgIGlmIChpc1NpbmdsZUZpZWxkKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcyhlcnJvcnMpWzBdIHx8IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZXJyb3JzO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoZmllbGQpKSB7XHJcbiAgICAgIHJldHVybiBncm91cEVycm9ycyh0aGlzLml0ZW1zKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2VsZWN0b3IgPSBpc051bGxPclVuZGVmaW5lZChzY29wZSkgPyBTdHJpbmcoZmllbGQpIDogKHNjb3BlICsgXCIuXCIgKyBmaWVsZCk7XHJcbiAgICB2YXIgcmVmID0gdGhpcy5fbWFrZUNhbmRpZGF0ZUZpbHRlcnMoc2VsZWN0b3IpO1xuICAgICAgdmFyIGlzUHJpbWFyeSA9IHJlZi5pc1ByaW1hcnk7XG4gICAgICB2YXIgaXNBbHQgPSByZWYuaXNBbHQ7XHJcblxyXG4gICAgdmFyIGNvbGxlY3RlZCA9IHRoaXMuaXRlbXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgIGlmIChpc1ByaW1hcnkoY3VycikpIHtcclxuICAgICAgICBwcmV2LnByaW1hcnkucHVzaChjdXJyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzQWx0KGN1cnIpKSB7XHJcbiAgICAgICAgcHJldi5hbHQucHVzaChjdXJyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICB9LCB7IHByaW1hcnk6IFtdLCBhbHQ6IFtdIH0pO1xyXG5cclxuICAgIGNvbGxlY3RlZCA9IGNvbGxlY3RlZC5wcmltYXJ5Lmxlbmd0aCA/IGNvbGxlY3RlZC5wcmltYXJ5IDogY29sbGVjdGVkLmFsdDtcclxuXHJcbiAgICByZXR1cm4gZ3JvdXBFcnJvcnMoY29sbGVjdGVkKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBpbnRlcm5hbCBhcnJheSBsZW5ndGguXHJcbiAgICovXHJcbiAgRXJyb3JCYWcucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gY291bnQgKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgIGlmICh0aGlzLnZtSWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnZtSWQgPT09IHRoaXMkMS52bUlkOyB9KS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmRzIGFuZCBmZXRjaGVzIHRoZSBmaXJzdCBlcnJvciBtZXNzYWdlIGZvciB0aGUgc3BlY2lmaWVkIGZpZWxkIGlkLlxyXG4gICAqL1xyXG4gIEVycm9yQmFnLnByb3RvdHlwZS5maXJzdEJ5SWQgPSBmdW5jdGlvbiBmaXJzdEJ5SWQgKGlkKSB7XHJcbiAgICB2YXIgZXJyb3IgPSBmaW5kKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLmlkID09PSBpZDsgfSk7XHJcblxyXG4gICAgcmV0dXJuIGVycm9yID8gZXJyb3IubXNnIDogdW5kZWZpbmVkO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGZpcnN0IGVycm9yIG1lc3NhZ2UgZm9yIGEgc3BlY2lmaWMgZmllbGQuXHJcbiAgICovXHJcbiAgRXJyb3JCYWcucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gZmlyc3QgKGZpZWxkLCBzY29wZSkge1xuICAgICAgaWYgKCBzY29wZSA9PT0gdm9pZCAwICkgc2NvcGUgPSBudWxsO1xuXHJcbiAgICB2YXIgc2VsZWN0b3IgPSBpc051bGxPclVuZGVmaW5lZChzY29wZSkgPyBmaWVsZCA6IChzY29wZSArIFwiLlwiICsgZmllbGQpO1xyXG4gICAgdmFyIG1hdGNoID0gdGhpcy5fbWF0Y2goc2VsZWN0b3IpO1xyXG5cclxuICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaC5tc2c7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZXJyb3IgcnVsZSBmb3IgdGhlIHNwZWNpZmllZCBmaWVsZFxyXG4gICAqL1xyXG4gIEVycm9yQmFnLnByb3RvdHlwZS5maXJzdFJ1bGUgPSBmdW5jdGlvbiBmaXJzdFJ1bGUgKGZpZWxkLCBzY29wZSkge1xyXG4gICAgdmFyIGVycm9ycyA9IHRoaXMuY29sbGVjdChmaWVsZCwgc2NvcGUsIGZhbHNlKTtcclxuXHJcbiAgICByZXR1cm4gKGVycm9ycy5sZW5ndGggJiYgZXJyb3JzWzBdLnJ1bGUpIHx8IHVuZGVmaW5lZDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgdGhlIGludGVybmFsIGFycmF5IGhhcyBhdCBsZWFzdCBvbmUgZXJyb3IgZm9yIHRoZSBzcGVjaWZpZWQgZmllbGQuXHJcbiAgICovXHJcbiAgRXJyb3JCYWcucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoZmllbGQsIHNjb3BlKSB7XG4gICAgICBpZiAoIHNjb3BlID09PSB2b2lkIDAgKSBzY29wZSA9IG51bGw7XG5cclxuICAgIHJldHVybiAhIXRoaXMuZmlyc3QoZmllbGQsIHNjb3BlKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBmaXJzdCBlcnJvciBtZXNzYWdlIGZvciBhIHNwZWNpZmljIGZpZWxkIGFuZCBhIHJ1bGUuXHJcbiAgICovXHJcbiAgRXJyb3JCYWcucHJvdG90eXBlLmZpcnN0QnlSdWxlID0gZnVuY3Rpb24gZmlyc3RCeVJ1bGUgKG5hbWUsIHJ1bGUsIHNjb3BlKSB7XG4gICAgICBpZiAoIHNjb3BlID09PSB2b2lkIDAgKSBzY29wZSA9IG51bGw7XG5cclxuICAgIHZhciBlcnJvciA9IHRoaXMuY29sbGVjdChuYW1lLCBzY29wZSwgZmFsc2UpLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5ydWxlID09PSBydWxlOyB9KVswXTtcclxuXHJcbiAgICByZXR1cm4gKGVycm9yICYmIGVycm9yLm1zZykgfHwgdW5kZWZpbmVkO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGZpcnN0IGVycm9yIG1lc3NhZ2UgZm9yIGEgc3BlY2lmaWMgZmllbGQgdGhhdCBub3QgbWF0Y2ggdGhlIHJ1bGUuXHJcbiAgICovXHJcbiAgRXJyb3JCYWcucHJvdG90eXBlLmZpcnN0Tm90ID0gZnVuY3Rpb24gZmlyc3ROb3QgKG5hbWUsIHJ1bGUsIHNjb3BlKSB7XG4gICAgICBpZiAoIHJ1bGUgPT09IHZvaWQgMCApIHJ1bGUgPSAncmVxdWlyZWQnO1xuICAgICAgaWYgKCBzY29wZSA9PT0gdm9pZCAwICkgc2NvcGUgPSBudWxsO1xuXHJcbiAgICB2YXIgZXJyb3IgPSB0aGlzLmNvbGxlY3QobmFtZSwgc2NvcGUsIGZhbHNlKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucnVsZSAhPT0gcnVsZTsgfSlbMF07XHJcblxyXG4gICAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5tc2cpIHx8IHVuZGVmaW5lZDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGVycm9ycyBieSBtYXRjaGluZyBhZ2FpbnN0IHRoZSBpZCBvciBpZHMuXHJcbiAgICovXHJcbiAgRXJyb3JCYWcucHJvdG90eXBlLnJlbW92ZUJ5SWQgPSBmdW5jdGlvbiByZW1vdmVCeUlkIChpZCkge1xyXG4gICAgdmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmlkID09PSBpZDsgfTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xyXG4gICAgICBjb25kaXRpb24gPSBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaWQuaW5kZXhPZihpdGVtLmlkKSAhPT0gLTE7IH07XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGlmIChjb25kaXRpb24odGhpcy5pdGVtc1tpXSkpIHtcclxuICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCAxKTtcclxuICAgICAgICAtLWk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGFsbCBlcnJvciBtZXNzYWdlcyBhc3NvY2lhdGVkIHdpdGggYSBzcGVjaWZpYyBmaWVsZC5cclxuICAgKi9cclxuICBFcnJvckJhZy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChmaWVsZCwgc2NvcGUsIHZtSWQpIHtcclxuICAgIGlmIChpc051bGxPclVuZGVmaW5lZChmaWVsZCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzZWxlY3RvciA9IGlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSA/IFN0cmluZyhmaWVsZCkgOiAoc2NvcGUgKyBcIi5cIiArIGZpZWxkKTtcclxuICAgIHZhciByZWYgPSB0aGlzLl9tYWtlQ2FuZGlkYXRlRmlsdGVycyhzZWxlY3Rvcik7XG4gICAgICB2YXIgaXNQcmltYXJ5ID0gcmVmLmlzUHJpbWFyeTtcbiAgICAgIHZhciBpc0FsdCA9IHJlZi5pc0FsdDtcclxuICAgIHZhciBtYXRjaGVzID0gZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGlzUHJpbWFyeShpdGVtKSB8fCBpc0FsdChpdGVtKTsgfTtcclxuICAgIHZhciBzaG91bGRSZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodm1JZCkpIHsgcmV0dXJuIG1hdGNoZXMoaXRlbSk7IH1cclxuXHJcbiAgICAgIHJldHVybiBtYXRjaGVzKGl0ZW0pICYmIGl0ZW0udm1JZCA9PT0gdm1JZDtcclxuICAgIH07XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGlmIChzaG91bGRSZW1vdmUodGhpcy5pdGVtc1tpXSkpIHtcclxuICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCAxKTtcclxuICAgICAgICAtLWk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBFcnJvckJhZy5wcm90b3R5cGUuX21ha2VDYW5kaWRhdGVGaWx0ZXJzID0gZnVuY3Rpb24gX21ha2VDYW5kaWRhdGVGaWx0ZXJzIChzZWxlY3Rvcikge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgIHZhciBtYXRjaGVzUnVsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICB2YXIgbWF0Y2hlc1Njb3BlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuICAgIHZhciBtYXRjaGVzTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICB2YXIgbWF0Y2hlc1ZNID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuXHJcbiAgICB2YXIgcmVmID0gcGFyc2VTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB2YXIgaWQgPSByZWYuaWQ7XG4gICAgICB2YXIgcnVsZSA9IHJlZi5ydWxlO1xuICAgICAgdmFyIHNjb3BlID0gcmVmLnNjb3BlO1xuICAgICAgdmFyIG5hbWUgPSByZWYubmFtZTtcclxuXHJcbiAgICBpZiAocnVsZSkge1xyXG4gICAgICBtYXRjaGVzUnVsZSA9IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnJ1bGUgPT09IHJ1bGU7IH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWF0Y2ggYnkgaWQsIGNhbiBiZSBjb21iaW5lZCB3aXRoIHJ1bGUgc2VsZWN0aW9uLlxyXG4gICAgaWYgKGlkKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaXNQcmltYXJ5OiBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gbWF0Y2hlc1J1bGUoaXRlbSkgJiYgKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpZCA9PT0gaXRlbS5pZDsgfSk7IH0sXHJcbiAgICAgICAgaXNBbHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSkge1xyXG4gICAgICAvLyBpZiBubyBzY29wZSBzcGVjaWZpZWQsIG1ha2Ugc3VyZSB0aGUgZm91bmQgZXJyb3IgaGFzIG5vIHNjb3BlLlxyXG4gICAgICBtYXRjaGVzU2NvcGUgPSBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQoaXRlbS5zY29wZSk7IH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtYXRjaGVzU2NvcGUgPSBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5zY29wZSA9PT0gc2NvcGU7IH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChuYW1lKSAmJiBuYW1lICE9PSAnKicpIHtcclxuICAgICAgbWF0Y2hlc05hbWUgPSBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5maWVsZCA9PT0gbmFtZTsgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRoaXMudm1JZCkpIHtcclxuICAgICAgbWF0Y2hlc1ZNID0gZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0udm1JZCA9PT0gdGhpcyQxLnZtSWQ7IH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWF0Y2hlcyB0aGUgZmlyc3QgY2FuZGlkYXRlLlxyXG4gICAgdmFyIGlzUHJpbWFyeSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgIHJldHVybiBtYXRjaGVzVk0oaXRlbSkgJiYgbWF0Y2hlc05hbWUoaXRlbSkgJiYgbWF0Y2hlc1J1bGUoaXRlbSkgJiYgbWF0Y2hlc1Njb3BlKGl0ZW0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBtYXRjaGVzIGEgc2Vjb25kIGNhbmRpZGF0ZSwgd2hpY2ggaXMgYSBmaWVsZCB3aXRoIGEgbmFtZSBjb250YWluaW5nIHRoZSAnLicgY2hhcmFjdGVyLlxyXG4gICAgdmFyIGlzQWx0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgcmV0dXJuIG1hdGNoZXNWTShpdGVtKSAmJiBtYXRjaGVzUnVsZShpdGVtKSAmJiBpdGVtLmZpZWxkID09PSAoc2NvcGUgKyBcIi5cIiArIG5hbWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpc1ByaW1hcnk6IGlzUHJpbWFyeSxcclxuICAgICAgaXNBbHQ6IGlzQWx0XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIEVycm9yQmFnLnByb3RvdHlwZS5fbWF0Y2ggPSBmdW5jdGlvbiBfbWF0Y2ggKHNlbGVjdG9yKSB7XHJcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoc2VsZWN0b3IpKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlZiA9IHRoaXMuX21ha2VDYW5kaWRhdGVGaWx0ZXJzKHNlbGVjdG9yKTtcbiAgICAgIHZhciBpc1ByaW1hcnkgPSByZWYuaXNQcmltYXJ5O1xuICAgICAgdmFyIGlzQWx0ID0gcmVmLmlzQWx0O1xyXG5cclxuICAgIHJldHVybiB0aGlzLml0ZW1zLnJlZHVjZShmdW5jdGlvbiAocHJldiwgaXRlbSwgaWR4LCBhcnIpIHtcclxuICAgICAgdmFyIGlzTGFzdCA9IGlkeCA9PT0gYXJyLmxlbmd0aCAtIDE7XHJcbiAgICAgIGlmIChwcmV2LnByaW1hcnkpIHtcclxuICAgICAgICByZXR1cm4gaXNMYXN0ID8gcHJldi5wcmltYXJ5IDogcHJldjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzUHJpbWFyeShpdGVtKSkge1xyXG4gICAgICAgIHByZXYucHJpbWFyeSA9IGl0ZW07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0FsdChpdGVtKSkge1xyXG4gICAgICAgIHByZXYuYWx0ID0gaXRlbTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8ga2VlcCBnb2luZy5cclxuICAgICAgaWYgKCFpc0xhc3QpIHtcclxuICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHByZXYucHJpbWFyeSB8fCBwcmV2LmFsdDtcclxuICAgIH0sIHt9KTtcclxuICB9O1xuXG4gIC8vIFZOb2RlIFV0aWxzXHJcblxyXG4gIC8vIEdldHMgdGhlIG1vZGVsIG9iamVjdCBvbiB0aGUgdm5vZGUuXHJcbiAgZnVuY3Rpb24gZmluZE1vZGVsICh2bm9kZSkge1xyXG4gICAgaWYgKCF2bm9kZS5kYXRhKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbXBvbmVudCBNb2RlbFxyXG4gICAgaWYgKHZub2RlLmRhdGEubW9kZWwpIHtcclxuICAgICAgcmV0dXJuIHZub2RlLmRhdGEubW9kZWw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICEhKHZub2RlLmRhdGEuZGlyZWN0aXZlcykgJiYgZmluZCh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdtb2RlbCc7IH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZXh0cmFjdENoaWxkcmVuICh2bm9kZSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XHJcbiAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcclxuICAgICAgcmV0dXJuIHZub2RlLmNoaWxkcmVuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2bm9kZS5jb21wb25lbnRPcHRpb25zICYmIEFycmF5LmlzQXJyYXkodm5vZGUuY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbikpIHtcclxuICAgICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZXh0cmFjdFZOb2RlcyAodm5vZGUpIHtcclxuICAgIGlmIChmaW5kTW9kZWwodm5vZGUpKSB7XHJcbiAgICAgIHJldHVybiBbdm5vZGVdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjaGlsZHJlbiA9IGV4dHJhY3RDaGlsZHJlbih2bm9kZSk7XHJcblxyXG4gICAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAobm9kZXMsIG5vZGUpIHtcclxuICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBleHRyYWN0Vk5vZGVzKG5vZGUpO1xyXG4gICAgICBpZiAoY2FuZGlkYXRlcy5sZW5ndGgpIHtcclxuICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBjYW5kaWRhdGVzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfSwgW10pO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVzb2x2ZXMgdi1tb2RlbCBjb25maWcgaWYgZXhpc3RzLlxyXG4gIGZ1bmN0aW9uIGZpbmRNb2RlbENvbmZpZyAodm5vZGUpIHtcclxuICAgIGlmICghdm5vZGUuY29tcG9uZW50T3B0aW9ucykgeyByZXR1cm4gbnVsbDsgfVxyXG5cclxuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iub3B0aW9ucy5tb2RlbDtcclxuICB9XHJcbiAgLy8gQWRkcyBhIGxpc3RlbmVyIHRvIHZub2RlIGxpc3RlbmVyIG9iamVjdC5cclxuICBmdW5jdGlvbiBtZXJnZVZOb2RlTGlzdGVuZXJzIChvYmosIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgLy8gSGFzIGEgc2luZ2xlIGxpc3RlbmVyLlxyXG4gICAgaWYgKGlzQ2FsbGFibGUob2JqW2V2ZW50TmFtZV0pKSB7XHJcbiAgICAgIHZhciBwcmV2SGFuZGxlciA9IG9ialtldmVudE5hbWVdO1xyXG4gICAgICBvYmpbZXZlbnROYW1lXSA9IFtwcmV2SGFuZGxlcl07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaGFzIG90aGVyIGxpc3RlbmVycy5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtldmVudE5hbWVdKSkge1xyXG4gICAgICBvYmpbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbm8gbGlzdGVuZXIgYXQgYWxsLlxyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG9ialtldmVudE5hbWVdKSkge1xyXG4gICAgICBvYmpbZXZlbnROYW1lXSA9IFtoYW5kbGVyXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZHMgYSBsaXN0ZW5lciB0byBhIG5hdGl2ZSBIVE1MIHZub2RlLlxyXG4gIGZ1bmN0aW9uIGFkZE5hdGl2ZU5vZGVMaXN0ZW5lciAobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQobm9kZS5kYXRhLm9uKSkge1xyXG4gICAgICBub2RlLmRhdGEub24gPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBtZXJnZVZOb2RlTGlzdGVuZXJzKG5vZGUuZGF0YS5vbiwgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICB9XHJcblxyXG4gIC8vIEFkZHMgYSBsaXN0ZW5lciB0byBhIFZ1ZSBjb21wb25lbnQgdm5vZGUuXHJcbiAgZnVuY3Rpb24gYWRkQ29tcG9uZW50Tm9kZUxpc3RlbmVyIChub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAoIW5vZGUuY29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMpIHtcclxuICAgICAgbm9kZS5jb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIG1lcmdlVk5vZGVMaXN0ZW5lcnMobm9kZS5jb21wb25lbnRPcHRpb25zLmxpc3RlbmVycywgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYWRkVk5vZGVMaXN0ZW5lciAodm5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgaWYgKHZub2RlLmNvbXBvbmVudE9wdGlvbnMpIHtcclxuICAgICAgYWRkQ29tcG9uZW50Tm9kZUxpc3RlbmVyKHZub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZE5hdGl2ZU5vZGVMaXN0ZW5lcih2bm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICB9XHJcbiAgLy8gRGV0ZXJtaW5lcyBpZiBgY2hhbmdlYCBzaG91bGQgYmUgdXNlZCBvdmVyIGBpbnB1dGAgZm9yIGxpc3RlbmVycy5cclxuICBmdW5jdGlvbiBnZXRJbnB1dEV2ZW50TmFtZSAodm5vZGUsIG1vZGVsKSB7XHJcbiAgICAvLyBJcyBhIGNvbXBvbmVudC5cclxuICAgIGlmICh2bm9kZS5jb21wb25lbnRPcHRpb25zKSB7XHJcbiAgICAgIHZhciByZWYgPSBmaW5kTW9kZWxDb25maWcodm5vZGUpIHx8IHsgZXZlbnQ6ICdpbnB1dCcgfTtcbiAgICAgIHZhciBldmVudCA9IHJlZi5ldmVudDtcclxuXHJcbiAgICAgIHJldHVybiBldmVudDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMYXp5IE1vZGVscyB0eXBpY2FsbHkgdXNlIGNoYW5nZSBldmVudFxyXG4gICAgaWYgKG1vZGVsICYmIG1vZGVsLm1vZGlmaWVycyAmJiBtb2RlbC5tb2RpZmllcnMubGF6eSkge1xyXG4gICAgICByZXR1cm4gJ2NoYW5nZSc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaXMgYSB0ZXh0dWFsLXR5cGUgaW5wdXQuXHJcbiAgICBpZiAodm5vZGUuZGF0YS5hdHRycyAmJiBpc1RleHRJbnB1dCh7IHR5cGU6IHZub2RlLmRhdGEuYXR0cnMudHlwZSB8fCAndGV4dCcgfSkpIHtcclxuICAgICAgcmV0dXJuICdpbnB1dCc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICdjaGFuZ2UnO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbm9ybWFsaXplU2xvdHMgKHNsb3RzLCBjdHgpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhzbG90cykucmVkdWNlKGZ1bmN0aW9uIChhcnIsIGtleSkge1xyXG4gICAgICBzbG90c1trZXldLmZvckVhY2goZnVuY3Rpb24gKHZub2RlKSB7XHJcbiAgICAgICAgaWYgKCF2bm9kZS5jb250ZXh0KSB7XHJcbiAgICAgICAgICBzbG90c1trZXldLmNvbnRleHQgPSBjdHg7XHJcbiAgICAgICAgICBpZiAoIXZub2RlLmRhdGEpIHtcclxuICAgICAgICAgICAgdm5vZGUuZGF0YSA9IHt9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdm5vZGUuZGF0YS5zbG90ID0ga2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gYXJyLmNvbmNhdChzbG90c1trZXldKTtcclxuICAgIH0sIFtdKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmxlc3MgKGgsIHZub2RlKSB7XHJcbiAgICAvLyBhIHNpbmdsZS1yb290IHNsb3QgeWF5IVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZub2RlKSkge1xyXG4gICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZub2RlLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gdm5vZGVbMF07XHJcbiAgICB9XHJcblxyXG4gICAge1xyXG4gICAgICB3YXJuKCdZb3VyIHNsb3Qgc2hvdWxkIGhhdmUgb25lIHJvb3QgZWxlbWVudC4gUmVuZGVyaW5nIGEgc3BhbiBhcyB0aGUgcm9vdC4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW5kZXJzIGEgbXVsdGktcm9vdCBub2RlLCBzaG91bGQgdGhyb3cgYSBWdWUgZXJyb3IuXHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyB0aGUgb3B0aW9ucyByZXF1aXJlZCB0byBjb25zdHJ1Y3QgYSBmaWVsZC5cclxuICAgKi9cclxuICB2YXIgUmVzb2x2ZXIgPSBmdW5jdGlvbiBSZXNvbHZlciAoKSB7fTtcblxuICBSZXNvbHZlci5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlIChlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgIHZhciBtb2RlbCA9IFJlc29sdmVyLnJlc29sdmVNb2RlbChiaW5kaW5nLCB2bm9kZSk7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHBsdWdpbkluc3RhbmNlLnJlc29sdmVDb25maWcodm5vZGUuY29udGV4dCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZTogUmVzb2x2ZXIucmVzb2x2ZU5hbWUoZWwsIHZub2RlKSxcclxuICAgICAgZWw6IGVsLFxyXG4gICAgICBsaXN0ZW46ICFiaW5kaW5nLm1vZGlmaWVycy5kaXNhYmxlLFxyXG4gICAgICBiYWlsczogYmluZGluZy5tb2RpZmllcnMuYmFpbHMgPyB0cnVlIDogKGJpbmRpbmcubW9kaWZpZXJzLmNvbnRpbnVlcyA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkKSxcclxuICAgICAgc2NvcGU6IFJlc29sdmVyLnJlc29sdmVTY29wZShlbCwgYmluZGluZywgdm5vZGUpLFxyXG4gICAgICB2bTogUmVzb2x2ZXIubWFrZVZNKHZub2RlLmNvbnRleHQpLFxyXG4gICAgICBleHByZXNzaW9uOiBiaW5kaW5nLnZhbHVlLFxyXG4gICAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLFxyXG4gICAgICBjbGFzc2VzOiBvcHRpb25zLmNsYXNzZXMsXHJcbiAgICAgIGNsYXNzTmFtZXM6IG9wdGlvbnMuY2xhc3NOYW1lcyxcclxuICAgICAgZ2V0dGVyOiBSZXNvbHZlci5yZXNvbHZlR2V0dGVyKGVsLCB2bm9kZSwgbW9kZWwpLFxyXG4gICAgICBldmVudHM6IFJlc29sdmVyLnJlc29sdmVFdmVudHMoZWwsIHZub2RlKSB8fCBvcHRpb25zLmV2ZW50cyxcclxuICAgICAgbW9kZWw6IG1vZGVsLFxyXG4gICAgICBkZWxheTogUmVzb2x2ZXIucmVzb2x2ZURlbGF5KGVsLCB2bm9kZSwgb3B0aW9ucyksXHJcbiAgICAgIHJ1bGVzOiBSZXNvbHZlci5yZXNvbHZlUnVsZXMoZWwsIGJpbmRpbmcsIHZub2RlKSxcclxuICAgICAgaW1tZWRpYXRlOiAhIWJpbmRpbmcubW9kaWZpZXJzLmluaXRpYWwgfHwgISFiaW5kaW5nLm1vZGlmaWVycy5pbW1lZGlhdGUsXHJcbiAgICAgIHBlcnNpc3Q6ICEhYmluZGluZy5tb2RpZmllcnMucGVyc2lzdCxcclxuICAgICAgdmFsaWRpdHk6IG9wdGlvbnMudmFsaWRpdHksXHJcbiAgICAgIGFyaWE6IG9wdGlvbnMuYXJpYSxcclxuICAgICAgaW5pdGlhbFZhbHVlOiBSZXNvbHZlci5yZXNvbHZlSW5pdGlhbFZhbHVlKHZub2RlKVxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICBSZXNvbHZlci5nZXRDdG9yQ29uZmlnID0gZnVuY3Rpb24gZ2V0Q3RvckNvbmZpZyAodm5vZGUpIHtcclxuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcbiAgICB2YXIgY29uZmlnID0gZ2V0UGF0aCgnY29tcG9uZW50SW5zdGFuY2UuJG9wdGlvbnMuJF92ZWVWYWxpZGF0ZScsIHZub2RlKTtcclxuXHJcbiAgICByZXR1cm4gY29uZmlnO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc29sdmVzIHRoZSBydWxlcyBkZWZpbmVkIG9uIGFuIGVsZW1lbnQuXHJcbiAgICovXHJcbiAgUmVzb2x2ZXIucmVzb2x2ZVJ1bGVzID0gZnVuY3Rpb24gcmVzb2x2ZVJ1bGVzIChlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgIHZhciBydWxlcyA9ICcnO1xyXG4gICAgaWYgKCFiaW5kaW5nLnZhbHVlICYmICghYmluZGluZyB8fCAhYmluZGluZy5leHByZXNzaW9uKSkge1xyXG4gICAgICBydWxlcyA9IGdldERhdGFBdHRyaWJ1dGUoZWwsICdydWxlcycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiaW5kaW5nLnZhbHVlICYmIGluY2x1ZGVzKFsnc3RyaW5nJywgJ29iamVjdCddLCB0eXBlb2YgYmluZGluZy52YWx1ZS5ydWxlcykpIHtcclxuICAgICAgcnVsZXMgPSBiaW5kaW5nLnZhbHVlLnJ1bGVzO1xyXG4gICAgfSBlbHNlIGlmIChiaW5kaW5nLnZhbHVlKSB7XHJcbiAgICAgIHJ1bGVzID0gYmluZGluZy52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgcmV0dXJuIHJ1bGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHZhbGlkaXR5IGlzIGRpc2FibGVkLCBpZ25vcmUgZmllbGQgcnVsZXMuXHJcbiAgICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVJ1bGVzKHJ1bGVzKTtcclxuICAgIGlmICghcGx1Z2luSW5zdGFuY2UuY29uZmlnLnVzZUNvbnN0cmFpbnRBdHRycykge1xyXG4gICAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXNzaWduKHt9LCBmaWxsUnVsZXNGcm9tRWxlbWVudChlbCwge30pLCBub3JtYWxpemVkKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0geyp9IHZub2RlXHJcbiAgICovXHJcbiAgUmVzb2x2ZXIucmVzb2x2ZUluaXRpYWxWYWx1ZSA9IGZ1bmN0aW9uIHJlc29sdmVJbml0aWFsVmFsdWUgKHZub2RlKSB7XHJcbiAgICB2YXIgbW9kZWwgPSB2bm9kZS5kYXRhLm1vZGVsIHx8IGZpbmQodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnbW9kZWwnOyB9KTtcclxuXHJcbiAgICByZXR1cm4gbW9kZWwgJiYgbW9kZWwudmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5vbi1jaXJjdWxhciBwYXJ0aWFsIFZNIGluc3RhbmNlIGZyb20gYSBWdWUgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIHsqfSB2bVxyXG4gICAqL1xyXG4gIFJlc29sdmVyLm1ha2VWTSA9IGZ1bmN0aW9uIG1ha2VWTSAodm0pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdldCAkZWwgKCkge1xyXG4gICAgICAgIHJldHVybiB2bS4kZWw7XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldCAkcmVmcyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZtLiRyZWZzO1xyXG4gICAgICB9LFxyXG4gICAgICAkd2F0Y2g6IHZtLiR3YXRjaCA/IHZtLiR3YXRjaC5iaW5kKHZtKSA6IGZ1bmN0aW9uICgpIHt9LFxyXG4gICAgICAkdmFsaWRhdG9yOiB2bS4kdmFsaWRhdG9yID8ge1xyXG4gICAgICAgIGVycm9yczogdm0uJHZhbGlkYXRvci5lcnJvcnMsXHJcbiAgICAgICAgdmFsaWRhdGU6IHZtLiR2YWxpZGF0b3IudmFsaWRhdGUuYmluZCh2bS4kdmFsaWRhdG9yKSxcclxuICAgICAgICB1cGRhdGU6IHZtLiR2YWxpZGF0b3IudXBkYXRlLmJpbmQodm0uJHZhbGlkYXRvcilcclxuICAgICAgfSA6IG51bGxcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzb2x2ZXMgdGhlIGRlbGF5IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7Kn0gZWxcclxuICAgKiBAcGFyYW0geyp9IHZub2RlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgKi9cclxuICBSZXNvbHZlci5yZXNvbHZlRGVsYXkgPSBmdW5jdGlvbiByZXNvbHZlRGVsYXkgKGVsLCB2bm9kZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGRlbGF5ID0gZ2V0RGF0YUF0dHJpYnV0ZShlbCwgJ2RlbGF5Jyk7XHJcbiAgICB2YXIgZ2xvYmFsRGVsYXkgPSAob3B0aW9ucyAmJiAnZGVsYXknIGluIG9wdGlvbnMpID8gb3B0aW9ucy5kZWxheSA6IDA7XHJcblxyXG4gICAgaWYgKCFkZWxheSAmJiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kYXR0cnMpIHtcclxuICAgICAgZGVsYXkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kYXR0cnNbJ2RhdGEtdnYtZGVsYXknXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzT2JqZWN0KGdsb2JhbERlbGF5KSkge1xyXG4gICAgICByZXR1cm4gZGVlcFBhcnNlSW50KGRlbGF5IHx8IGdsb2JhbERlbGF5KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGRlbGF5KSkge1xyXG4gICAgICBnbG9iYWxEZWxheS5pbnB1dCA9IGRlbGF5O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkZWVwUGFyc2VJbnQoZ2xvYmFsRGVsYXkpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc29sdmVzIHRoZSBldmVudHMgdG8gdmFsaWRhdGUgaW4gcmVzcG9uc2UgdG8uXHJcbiAgICogQHBhcmFtIHsqfSBlbFxyXG4gICAqIEBwYXJhbSB7Kn0gdm5vZGVcclxuICAgKi9cclxuICBSZXNvbHZlci5yZXNvbHZlRXZlbnRzID0gZnVuY3Rpb24gcmVzb2x2ZUV2ZW50cyAoZWwsIHZub2RlKSB7XHJcbiAgICAvLyByZXNvbHZlIGl0IGZyb20gdGhlIHJvb3QgZWxlbWVudC5cclxuICAgIHZhciBldmVudHMgPSBnZXREYXRhQXR0cmlidXRlKGVsLCAndmFsaWRhdGUtb24nKTtcclxuXHJcbiAgICAvLyByZXNvbHZlIGZyb20gZGF0YS12di12YWxpZGF0ZS1vbiBpZiBpdHMgYSB2dWUgY29tcG9uZW50LlxyXG4gICAgaWYgKCFldmVudHMgJiYgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGF0dHJzKSB7XHJcbiAgICAgIGV2ZW50cyA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRhdHRyc1snZGF0YS12di12YWxpZGF0ZS1vbiddO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlc29sdmUgaXQgZnJvbSAkX3ZlZVZhbGlkYXRlIG9wdGlvbnMuXHJcbiAgICBpZiAoIWV2ZW50cyAmJiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xyXG4gICAgICB2YXIgY29uZmlnID0gUmVzb2x2ZXIuZ2V0Q3RvckNvbmZpZyh2bm9kZSk7XHJcbiAgICAgIGV2ZW50cyA9IGNvbmZpZyAmJiBjb25maWcuZXZlbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZXZlbnRzICYmIHBsdWdpbkluc3RhbmNlLmNvbmZpZy5ldmVudHMpIHtcclxuICAgICAgZXZlbnRzID0gcGx1Z2luSW5zdGFuY2UuY29uZmlnLmV2ZW50cztcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXNvbHZlIHRoZSBtb2RlbCBldmVudCBpZiBpdHMgY29uZmlndXJlZCBmb3IgY3VzdG9tIGNvbXBvbmVudHMuXHJcbiAgICBpZiAoZXZlbnRzICYmIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmIGluY2x1ZGVzKGV2ZW50cywgJ2lucHV0JykpIHtcclxuICAgICAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRvcHRpb25zLm1vZGVsIHx8IHsgZXZlbnQ6ICdpbnB1dCcgfTtcbiAgICAgICAgdmFyIGV2ZW50ID0gcmVmLmV2ZW50O1xyXG4gICAgICAvLyBpZiB0aGUgcHJvcCB3YXMgY29uZmlndXJlZCBidXQgbm90IHRoZSBtb2RlbC5cclxuICAgICAgaWYgKCFldmVudCkge1xyXG4gICAgICAgIHJldHVybiBldmVudHM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGV2ZW50cyA9IGV2ZW50cy5yZXBsYWNlKCdpbnB1dCcsIGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc29sdmVzIHRoZSBzY29wZSBmb3IgdGhlIGZpZWxkLlxyXG4gICAqIEBwYXJhbSB7Kn0gZWxcclxuICAgKiBAcGFyYW0geyp9IGJpbmRpbmdcclxuICAgKi9cclxuICBSZXNvbHZlci5yZXNvbHZlU2NvcGUgPSBmdW5jdGlvbiByZXNvbHZlU2NvcGUgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgaWYgKCB2bm9kZSA9PT0gdm9pZCAwICkgdm5vZGUgPSB7fTtcblxyXG4gICAgdmFyIHNjb3BlID0gbnVsbDtcclxuICAgIGlmICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiBpc051bGxPclVuZGVmaW5lZChzY29wZSkpIHtcclxuICAgICAgc2NvcGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kYXR0cnMgJiYgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGF0dHJzWydkYXRhLXZ2LXNjb3BlJ107XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICFpc051bGxPclVuZGVmaW5lZChzY29wZSkgPyBzY29wZSA6IGdldFNjb3BlKGVsKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgdGhlIG5vZGUgZGlyZWN0aXZlcyBjb250YWlucyBhIHYtbW9kZWwgb3IgYSBzcGVjaWZpZWQgYXJnLlxyXG4gICAqIEFyZ3MgdGFrZSBwcmlvcml0eSBvdmVyIG1vZGVscy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBSZXNvbHZlci5yZXNvbHZlTW9kZWwgPSBmdW5jdGlvbiByZXNvbHZlTW9kZWwgKGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICBpZiAoYmluZGluZy5hcmcpIHtcclxuICAgICAgcmV0dXJuIHsgZXhwcmVzc2lvbjogYmluZGluZy5hcmcgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbW9kZWwgPSBmaW5kTW9kZWwodm5vZGUpO1xyXG4gICAgaWYgKCFtb2RlbCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL2Jsb2IvZGV2L3NyYy9jb3JlL3V0aWwvbGFuZy5qcyNMMjZcclxuICAgIHZhciB3YXRjaGFibGUgPSAhL1teXFx3LiRdLy50ZXN0KG1vZGVsLmV4cHJlc3Npb24pICYmIGhhc1BhdGgobW9kZWwuZXhwcmVzc2lvbiwgdm5vZGUuY29udGV4dCk7XHJcbiAgICB2YXIgbGF6eSA9ICEhKG1vZGVsLm1vZGlmaWVycyAmJiBtb2RlbC5tb2RpZmllcnMubGF6eSk7XHJcblxyXG4gICAgaWYgKCF3YXRjaGFibGUpIHtcclxuICAgICAgcmV0dXJuIHsgZXhwcmVzc2lvbjogbnVsbCwgbGF6eTogbGF6eSB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGV4cHJlc3Npb246IG1vZGVsLmV4cHJlc3Npb24sIGxhenk6IGxhenkgfTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXNvbHZlcyB0aGUgZmllbGQgbmFtZSB0byB0cmlnZ2VyIHZhbGlkYXRpb25zLlxyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGZpZWxkIG5hbWUuXHJcbiAgICovXHJcbiAgUmVzb2x2ZXIucmVzb2x2ZU5hbWUgPSBmdW5jdGlvbiByZXNvbHZlTmFtZSAoZWwsIHZub2RlKSB7XHJcbiAgICB2YXIgbmFtZSA9IGdldERhdGFBdHRyaWJ1dGUoZWwsICduYW1lJyk7XHJcblxyXG4gICAgaWYgKCFuYW1lICYmICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xyXG4gICAgICByZXR1cm4gZWwubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW5hbWUgJiYgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGF0dHJzKSB7XHJcbiAgICAgIG5hbWUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kYXR0cnNbJ2RhdGEtdnYtbmFtZSddIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRhdHRyc1snbmFtZSddO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbmFtZSAmJiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xyXG4gICAgICB2YXIgY29uZmlnID0gUmVzb2x2ZXIuZ2V0Q3RvckNvbmZpZyh2bm9kZSk7XHJcbiAgICAgIGlmIChjb25maWcgJiYgaXNDYWxsYWJsZShjb25maWcubmFtZSkpIHtcclxuICAgICAgICB2YXIgYm91bmRHZXR0ZXIgPSBjb25maWcubmFtZS5iaW5kKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJvdW5kR2V0dGVyKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuYW1lO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSB2YWx1ZSBnZXR0ZXIgaW5wdXQgdHlwZS5cclxuICAgKi9cclxuICBSZXNvbHZlci5yZXNvbHZlR2V0dGVyID0gZnVuY3Rpb24gcmVzb2x2ZUdldHRlciAoZWwsIHZub2RlLCBtb2RlbCkge1xyXG4gICAgaWYgKG1vZGVsICYmIG1vZGVsLmV4cHJlc3Npb24pIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZ2V0UGF0aChtb2RlbC5leHByZXNzaW9uLCB2bm9kZS5jb250ZXh0KTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgdmFyIHBhdGggPSBnZXREYXRhQXR0cmlidXRlKGVsLCAndmFsdWUtcGF0aCcpIHx8ICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kYXR0cnMgJiYgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGF0dHJzWydkYXRhLXZ2LXZhbHVlLXBhdGgnXSk7XHJcbiAgICAgIGlmIChwYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBnZXRQYXRoKHBhdGgsIHZub2RlLmNvbXBvbmVudEluc3RhbmNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgY29uZmlnID0gUmVzb2x2ZXIuZ2V0Q3RvckNvbmZpZyh2bm9kZSk7XHJcbiAgICAgIGlmIChjb25maWcgJiYgaXNDYWxsYWJsZShjb25maWcudmFsdWUpKSB7XHJcbiAgICAgICAgdmFyIGJvdW5kR2V0dGVyID0gY29uZmlnLnZhbHVlLmJpbmQodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGJvdW5kR2V0dGVyKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRvcHRpb25zLm1vZGVsIHx8IHsgcHJvcDogJ3ZhbHVlJyB9O1xuICAgICAgICB2YXIgcHJvcCA9IHJlZi5wcm9wO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2VbcHJvcF07XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChlbC50eXBlKSB7XHJcbiAgICBjYXNlICdjaGVja2JveCc6IHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBlbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKChcImlucHV0W25hbWU9XFxcIlwiICsgKGVsLm5hbWUpICsgXCJcXFwiXVwiKSk7XHJcblxyXG4gICAgICBlbHMgPSB0b0FycmF5KGVscykuZmlsdGVyKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuY2hlY2tlZDsgfSk7XHJcbiAgICAgIGlmICghZWxzLmxlbmd0aCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XHJcblxyXG4gICAgICByZXR1cm4gZWxzLm1hcChmdW5jdGlvbiAoY2hlY2tib3gpIHsgcmV0dXJuIGNoZWNrYm94LnZhbHVlOyB9KTtcclxuICAgIH07XHJcbiAgICBjYXNlICdyYWRpbyc6IHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBlbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKChcImlucHV0W25hbWU9XFxcIlwiICsgKGVsLm5hbWUpICsgXCJcXFwiXVwiKSk7XHJcbiAgICAgIHZhciBlbG0gPSBmaW5kKGVscywgZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jaGVja2VkOyB9KTtcclxuXHJcbiAgICAgIHJldHVybiBlbG0gJiYgZWxtLnZhbHVlO1xyXG4gICAgfTtcclxuICAgIGNhc2UgJ2ZpbGUnOiByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgcmV0dXJuIHRvQXJyYXkoZWwuZmlsZXMpO1xyXG4gICAgfTtcclxuICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6IHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0b0FycmF5KGVsLm9wdGlvbnMpLmZpbHRlcihmdW5jdGlvbiAob3B0KSB7IHJldHVybiBvcHQuc2VsZWN0ZWQ7IH0pLm1hcChmdW5jdGlvbiAob3B0KSB7IHJldHVybiBvcHQudmFsdWU7IH0pO1xyXG4gICAgfTtcclxuICAgIGRlZmF1bHQ6IHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBlbCAmJiBlbC52YWx1ZTtcclxuICAgIH07XHJcbiAgICB9XHJcbiAgfTtcblxuICB2YXIgUlVMRVMgPSB7fTtcclxuXHJcbiAgdmFyIFJ1bGVDb250YWluZXIgPSBmdW5jdGlvbiBSdWxlQ29udGFpbmVyICgpIHt9O1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IHJ1bGVzOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgUnVsZUNvbnRhaW5lci5hZGQgPSBmdW5jdGlvbiBhZGQgKG5hbWUsIHJlZikge1xuICAgICAgdmFyIHZhbGlkYXRlID0gcmVmLnZhbGlkYXRlO1xuICAgICAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcbiAgICAgIHZhciBwYXJhbU5hbWVzID0gcmVmLnBhcmFtTmFtZXM7XG5cclxuICAgIFJVTEVTW25hbWVdID0ge1xyXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGUsXHJcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXHJcbiAgICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXNcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgc3RhdGljQWNjZXNzb3JzLnJ1bGVzLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBSVUxFUztcclxuICB9O1xyXG5cclxuICBSdWxlQ29udGFpbmVyLmhhcyA9IGZ1bmN0aW9uIGhhcyAobmFtZSkge1xyXG4gICAgcmV0dXJuICEhUlVMRVNbbmFtZV07XHJcbiAgfTtcclxuXHJcbiAgUnVsZUNvbnRhaW5lci5pc0ltbWVkaWF0ZSA9IGZ1bmN0aW9uIGlzSW1tZWRpYXRlIChuYW1lKSB7XHJcbiAgICByZXR1cm4gISEoUlVMRVNbbmFtZV0gJiYgUlVMRVNbbmFtZV0ub3B0aW9ucy5pbW1lZGlhdGUpO1xyXG4gIH07XHJcblxyXG4gIFJ1bGVDb250YWluZXIuaXNSZXF1aXJlUnVsZSA9IGZ1bmN0aW9uIGlzUmVxdWlyZVJ1bGUgKG5hbWUpIHtcclxuICAgIHJldHVybiAhIShSVUxFU1tuYW1lXSAmJiBSVUxFU1tuYW1lXS5vcHRpb25zLmNvbXB1dGVzUmVxdWlyZWQpO1xyXG4gIH07XHJcblxyXG4gIFJ1bGVDb250YWluZXIuaXNUYXJnZXRSdWxlID0gZnVuY3Rpb24gaXNUYXJnZXRSdWxlIChuYW1lKSB7XHJcbiAgICByZXR1cm4gISEoUlVMRVNbbmFtZV0gJiYgUlVMRVNbbmFtZV0ub3B0aW9ucy5oYXNUYXJnZXQpO1xyXG4gIH07XHJcblxyXG4gIFJ1bGVDb250YWluZXIucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChydWxlTmFtZSkge1xyXG4gICAgZGVsZXRlIFJVTEVTW3J1bGVOYW1lXTtcclxuICB9O1xyXG5cclxuICBSdWxlQ29udGFpbmVyLmdldFBhcmFtTmFtZXMgPSBmdW5jdGlvbiBnZXRQYXJhbU5hbWVzIChydWxlTmFtZSkge1xyXG4gICAgcmV0dXJuIFJVTEVTW3J1bGVOYW1lXSAmJiBSVUxFU1tydWxlTmFtZV0ucGFyYW1OYW1lcztcclxuICB9O1xyXG5cclxuICBSdWxlQ29udGFpbmVyLmdldE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRPcHRpb25zIChydWxlTmFtZSkge1xyXG4gICAgcmV0dXJuIFJVTEVTW3J1bGVOYW1lXSAmJiBSVUxFU1tydWxlTmFtZV0ub3B0aW9ucztcclxuICB9O1xyXG5cclxuICBSdWxlQ29udGFpbmVyLmdldFZhbGlkYXRvck1ldGhvZCA9IGZ1bmN0aW9uIGdldFZhbGlkYXRvck1ldGhvZCAocnVsZU5hbWUpIHtcclxuICAgIHJldHVybiBSVUxFU1tydWxlTmFtZV0gPyBSVUxFU1tydWxlTmFtZV0udmFsaWRhdGUgOiBudWxsO1xyXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFJ1bGVDb250YWluZXIsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIC8vIFxyXG5cclxuICB2YXIgaXNFdmVudCA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIHJldHVybiAodHlwZW9mIEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0NhbGxhYmxlKEV2ZW50KSAmJiBldnQgaW5zdGFuY2VvZiBFdmVudCkgfHwgKGV2dCAmJiBldnQuc3JjRWxlbWVudCk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIG5vcm1hbGl6ZUV2ZW50cyA9IGZ1bmN0aW9uIChldnRzKSB7XHJcbiAgICBpZiAoIWV2dHMpIHsgcmV0dXJuIFtdOyB9XHJcblxyXG4gICAgcmV0dXJuICh0eXBlb2YgZXZ0cyA9PT0gJ3N0cmluZycgPyBldnRzLnNwbGl0KCd8JykgOiBldnRzKTtcclxuICB9O1xyXG5cclxuICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcclxuXHJcbiAgdmFyIGRldGVjdFBhc3NpdmVTdXBwb3J0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcclxuICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlJywgbnVsbCwgb3B0cyk7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG51bGwsIG9wdHMpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdXBwb3J0c1Bhc3NpdmU7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWwsIGV2ZW50TmFtZSwgY2IpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYiwgc3VwcG9ydHNQYXNzaXZlID8geyBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZSk7XHJcbiAgfTtcblxuICAvLyBcclxuXHJcbiAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcclxuICAgIHRhcmdldE9mOiBudWxsLFxyXG4gICAgaW1tZWRpYXRlOiBmYWxzZSxcclxuICAgIHBlcnNpc3Q6IGZhbHNlLFxyXG4gICAgc2NvcGU6IG51bGwsXHJcbiAgICBsaXN0ZW46IHRydWUsXHJcbiAgICBuYW1lOiBudWxsLFxyXG4gICAgcnVsZXM6IHt9LFxyXG4gICAgdm06IG51bGwsXHJcbiAgICBjbGFzc2VzOiBmYWxzZSxcclxuICAgIHZhbGlkaXR5OiB0cnVlLFxyXG4gICAgYXJpYTogdHJ1ZSxcclxuICAgIGV2ZW50czogJ2lucHV0fGJsdXInLFxyXG4gICAgZGVsYXk6IDAsXHJcbiAgICBjbGFzc05hbWVzOiB7XHJcbiAgICAgIHRvdWNoZWQ6ICd0b3VjaGVkJywgLy8gdGhlIGNvbnRyb2wgaGFzIGJlZW4gYmx1cnJlZFxyXG4gICAgICB1bnRvdWNoZWQ6ICd1bnRvdWNoZWQnLCAvLyB0aGUgY29udHJvbCBoYXNuJ3QgYmVlbiBibHVycmVkXHJcbiAgICAgIHZhbGlkOiAndmFsaWQnLCAvLyBtb2RlbCBpcyB2YWxpZFxyXG4gICAgICBpbnZhbGlkOiAnaW52YWxpZCcsIC8vIG1vZGVsIGlzIGludmFsaWRcclxuICAgICAgcHJpc3RpbmU6ICdwcmlzdGluZScsIC8vIGNvbnRyb2wgaGFzIG5vdCBiZWVuIGludGVyYWN0ZWQgd2l0aFxyXG4gICAgICBkaXJ0eTogJ2RpcnR5JyAvLyBjb250cm9sIGhhcyBiZWVuIGludGVyYWN0ZWQgd2l0aFxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBGaWVsZCA9IGZ1bmN0aW9uIEZpZWxkIChvcHRpb25zKSB7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cclxuICAgIHRoaXMuaWQgPSB1bmlxSWQoKTtcclxuICAgIHRoaXMuZWwgPSBvcHRpb25zLmVsO1xyXG4gICAgdGhpcy51cGRhdGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xyXG4gICAgdGhpcy52bUlkID0gb3B0aW9ucy52bUlkO1xyXG4gICAgdGhpcy53YXRjaGVycyA9IFtdO1xyXG4gICAgdGhpcy5ldmVudHMgPSBbXTtcclxuICAgIHRoaXMuZGVsYXkgPSAwO1xyXG4gICAgdGhpcy5ydWxlcyA9IHt9O1xyXG4gICAgdGhpcy5mb3JjZVJlcXVpcmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9jYWNoZUlkKG9wdGlvbnMpO1xyXG4gICAgdGhpcy5jbGFzc05hbWVzID0gYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMuY2xhc3NOYW1lcyk7XHJcbiAgICBvcHRpb25zID0gYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xyXG4gICAgdGhpcy5fZGVsYXkgPSAhaXNOdWxsT3JVbmRlZmluZWQob3B0aW9ucy5kZWxheSkgPyBvcHRpb25zLmRlbGF5IDogMDsgLy8gY2FjaGUgaW5pdGlhbCBkZWxheVxyXG4gICAgdGhpcy52YWxpZGl0eSA9IG9wdGlvbnMudmFsaWRpdHk7XHJcbiAgICB0aGlzLmFyaWEgPSBvcHRpb25zLmFyaWE7XHJcbiAgICB0aGlzLmZsYWdzID0gb3B0aW9ucy5mbGFncyB8fCBjcmVhdGVGbGFncygpO1xyXG4gICAgdGhpcy52bSA9IG9wdGlvbnMudm07XHJcbiAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gb3B0aW9ucy5jb21wb25lbnQ7XHJcbiAgICB0aGlzLmN0b3JDb25maWcgPSB0aGlzLmNvbXBvbmVudEluc3RhbmNlID8gZ2V0UGF0aCgnJG9wdGlvbnMuJF92ZWVWYWxpZGF0ZScsIHRoaXMuY29tcG9uZW50SW5zdGFuY2UpIDogdW5kZWZpbmVkO1xyXG4gICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XHJcbiAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZS5cclxuICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgIHRoaXMudXBkYXRlZCA9IGZhbHNlO1xyXG4gIH07XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxID0geyB2YWxpZGF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saXNSZXF1aXJlZDogeyBjb25maWd1cmFibGU6IHRydWUgfSxpc0Rpc2FibGVkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsaWFzOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHZhbHVlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGJhaWxzOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHJlamVjdHNGYWxzZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xyXG5cclxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMS52YWxpZGF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLnZtIHx8ICF0aGlzLnZtLiR2YWxpZGF0b3IpIHtcclxuICAgICAgcmV0dXJuIHsgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHt9IH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudm0uJHZhbGlkYXRvcjtcclxuICB9O1xyXG5cclxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMS5pc1JlcXVpcmVkLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMucnVsZXMucmVxdWlyZWQgfHwgdGhpcy5mb3JjZVJlcXVpcmVkO1xyXG4gIH07XHJcblxyXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQxLmlzRGlzYWJsZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhKHRoaXMuY29tcG9uZW50SW5zdGFuY2UgJiYgdGhpcy5jb21wb25lbnRJbnN0YW5jZS5kaXNhYmxlZCkgfHwgISEodGhpcy5lbCAmJiB0aGlzLmVsLmRpc2FibGVkKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBkaXNwbGF5IG5hbWUgKHVzZXItZnJpZW5kbHkgbmFtZSkuXHJcbiAgICovXHJcbiAgcHJvdG90eXBlQWNjZXNzb3JzJDEuYWxpYXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuX2FsaWFzKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9hbGlhcztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWxpYXMgPSBudWxsO1xyXG4gICAgaWYgKHRoaXMuY3RvckNvbmZpZyAmJiB0aGlzLmN0b3JDb25maWcuYWxpYXMpIHtcclxuICAgICAgYWxpYXMgPSBpc0NhbGxhYmxlKHRoaXMuY3RvckNvbmZpZy5hbGlhcykgPyB0aGlzLmN0b3JDb25maWcuYWxpYXMuY2FsbCh0aGlzLmNvbXBvbmVudEluc3RhbmNlKSA6IHRoaXMuY3RvckNvbmZpZy5hbGlhcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWFsaWFzICYmIHRoaXMuZWwpIHtcclxuICAgICAgYWxpYXMgPSBnZXREYXRhQXR0cmlidXRlKHRoaXMuZWwsICdhcycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghYWxpYXMgJiYgdGhpcy5jb21wb25lbnRJbnN0YW5jZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZS4kYXR0cnMgJiYgdGhpcy5jb21wb25lbnRJbnN0YW5jZS4kYXR0cnNbJ2RhdGEtdnYtYXMnXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYWxpYXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgaW5wdXQgdmFsdWUuXHJcbiAgICovXHJcblxyXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQxLnZhbHVlLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghaXNDYWxsYWJsZSh0aGlzLmdldHRlcikpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5nZXR0ZXIoKTtcclxuICB9O1xyXG5cclxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMS5iYWlscy5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmFpbHM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSWYgdGhlIGZpZWxkIHJlamVjdHMgZmFsc2UgYXMgYSB2YWxpZCB2YWx1ZSBmb3IgdGhlIHJlcXVpcmVkIHJ1bGUuXHJcbiAgICovXHJcblxyXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQxLnJlamVjdHNGYWxzZS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5jb21wb25lbnRJbnN0YW5jZSAmJiB0aGlzLmN0b3JDb25maWcpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jdG9yQ29uZmlnLnJlamVjdHNGYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuZWwpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmVsLnR5cGUgPT09ICdjaGVja2JveCc7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5zdGFuY2UgbWF0Y2hlcyB0aGUgb3B0aW9ucyBwcm92aWRlZC5cclxuICAgKi9cclxuICBGaWVsZC5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXMgKG9wdGlvbnMpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaWQgPT09IG9wdGlvbnMuaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1hdGNoZXNDb21wb25lbnRJZCA9IGlzTnVsbE9yVW5kZWZpbmVkKG9wdGlvbnMudm1JZCkgPyBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9IDogZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZCA9PT0gdGhpcyQxLnZtSWQ7IH07XHJcbiAgICBpZiAoIW1hdGNoZXNDb21wb25lbnRJZChvcHRpb25zLnZtSWQpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5uYW1lID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5zY29wZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zLnNjb3BlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gb3B0aW9ucy5uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zLm5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY29wZSA9PT0gb3B0aW9ucy5zY29wZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3B0aW9ucy5uYW1lID09PSB0aGlzLm5hbWUgJiYgb3B0aW9ucy5zY29wZSA9PT0gdGhpcy5zY29wZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDYWNoZXMgdGhlIGZpZWxkIGlkLlxyXG4gICAqL1xyXG4gIEZpZWxkLnByb3RvdHlwZS5fY2FjaGVJZCA9IGZ1bmN0aW9uIF9jYWNoZUlkIChvcHRpb25zKSB7XHJcbiAgICBpZiAodGhpcy5lbCAmJiAhb3B0aW9ucy50YXJnZXRPZikge1xyXG4gICAgICB0aGlzLmVsLl92ZWVWYWxpZGF0ZUlkID0gdGhpcy5pZDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBLZWVwcyBhIHJlZmVyZW5jZSBvZiB0aGUgbW9zdCBjdXJyZW50IHZhbGlkYXRpb24gcnVuLlxyXG4gICAqL1xyXG4gIEZpZWxkLnByb3RvdHlwZS53YWl0Rm9yID0gZnVuY3Rpb24gd2FpdEZvciAocGVuZGluZ1Byb21pc2UpIHtcclxuICAgIHRoaXMuX3dhaXRpbmdGb3IgPSBwZW5kaW5nUHJvbWlzZTtcclxuICB9O1xyXG5cclxuICBGaWVsZC5wcm90b3R5cGUuaXNXYWl0aW5nRm9yID0gZnVuY3Rpb24gaXNXYWl0aW5nRm9yIChwcm9taXNlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd2FpdGluZ0ZvciA9PT0gcHJvbWlzZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBmaWVsZCB3aXRoIGNoYW5nZWQgZGF0YS5cclxuICAgKi9cclxuICBGaWVsZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvcHRpb25zKSB7XHJcbiAgICB0aGlzLnRhcmdldE9mID0gb3B0aW9ucy50YXJnZXRPZiB8fCBudWxsO1xyXG4gICAgdGhpcy5pbW1lZGlhdGUgPSBvcHRpb25zLmltbWVkaWF0ZSB8fCB0aGlzLmltbWVkaWF0ZSB8fCBmYWxzZTtcclxuICAgIHRoaXMucGVyc2lzdCA9IG9wdGlvbnMucGVyc2lzdCB8fCB0aGlzLnBlcnNpc3QgfHwgZmFsc2U7XHJcblxyXG4gICAgLy8gdXBkYXRlIGVycm9ycyBzY29wZSBpZiB0aGUgZmllbGQgc2NvcGUgd2FzIGNoYW5nZWQuXHJcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG9wdGlvbnMuc2NvcGUpICYmIG9wdGlvbnMuc2NvcGUgIT09IHRoaXMuc2NvcGUgJiYgaXNDYWxsYWJsZSh0aGlzLnZhbGlkYXRvci51cGRhdGUpKSB7XHJcbiAgICAgIHRoaXMudmFsaWRhdG9yLnVwZGF0ZSh0aGlzLmlkLCB7IHNjb3BlOiBvcHRpb25zLnNjb3BlIH0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zY29wZSA9ICFpc051bGxPclVuZGVmaW5lZChvcHRpb25zLnNjb3BlKSA/IG9wdGlvbnMuc2NvcGVcclxuICAgICAgOiAhaXNOdWxsT3JVbmRlZmluZWQodGhpcy5zY29wZSkgPyB0aGlzLnNjb3BlIDogbnVsbDtcclxuICAgIHRoaXMubmFtZSA9ICghaXNOdWxsT3JVbmRlZmluZWQob3B0aW9ucy5uYW1lKSA/IFN0cmluZyhvcHRpb25zLm5hbWUpIDogb3B0aW9ucy5uYW1lKSB8fCB0aGlzLm5hbWUgfHwgbnVsbDtcclxuICAgIHRoaXMucnVsZXMgPSBvcHRpb25zLnJ1bGVzICE9PSB1bmRlZmluZWQgPyBub3JtYWxpemVSdWxlcyhvcHRpb25zLnJ1bGVzKSA6IHRoaXMucnVsZXM7XHJcbiAgICB0aGlzLl9iYWlscyA9IG9wdGlvbnMuYmFpbHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmFpbHMgOiB0aGlzLl9iYWlscztcclxuICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsIHx8IHRoaXMubW9kZWw7XHJcbiAgICB0aGlzLmxpc3RlbiA9IG9wdGlvbnMubGlzdGVuICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxpc3RlbiA6IHRoaXMubGlzdGVuO1xyXG4gICAgdGhpcy5jbGFzc2VzID0gKG9wdGlvbnMuY2xhc3NlcyB8fCB0aGlzLmNsYXNzZXMgfHwgZmFsc2UpICYmICF0aGlzLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgdGhpcy5jbGFzc05hbWVzID0gaXNPYmplY3Qob3B0aW9ucy5jbGFzc05hbWVzKSA/IG1lcmdlJDEodGhpcy5jbGFzc05hbWVzLCBvcHRpb25zLmNsYXNzTmFtZXMpIDogdGhpcy5jbGFzc05hbWVzO1xyXG4gICAgdGhpcy5nZXR0ZXIgPSBpc0NhbGxhYmxlKG9wdGlvbnMuZ2V0dGVyKSA/IG9wdGlvbnMuZ2V0dGVyIDogdGhpcy5nZXR0ZXI7XHJcbiAgICB0aGlzLl9hbGlhcyA9IG9wdGlvbnMuYWxpYXMgfHwgdGhpcy5fYWxpYXM7XHJcbiAgICB0aGlzLmV2ZW50cyA9IChvcHRpb25zLmV2ZW50cykgPyBub3JtYWxpemVFdmVudHMob3B0aW9ucy5ldmVudHMpIDogdGhpcy5ldmVudHM7XHJcbiAgICB0aGlzLmRlbGF5ID0gbWFrZURlbGF5T2JqZWN0KHRoaXMuZXZlbnRzLCBvcHRpb25zLmRlbGF5IHx8IHRoaXMuZGVsYXksIHRoaXMuX2RlbGF5KTtcclxuICAgIHRoaXMudXBkYXRlRGVwZW5kZW5jaWVzKCk7XHJcbiAgICB0aGlzLmFkZEFjdGlvbkxpc3RlbmVycygpO1xyXG5cclxuICAgIGlmICghdGhpcy5uYW1lICYmICF0aGlzLnRhcmdldE9mKSB7XHJcbiAgICAgIHdhcm4oJ0EgZmllbGQgaXMgbWlzc2luZyBhIFwibmFtZVwiIG9yIFwiZGF0YS12di1uYW1lXCIgYXR0cmlidXRlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdXBkYXRlIHJlcXVpcmVkIGZsYWcgZmxhZ3NcclxuICAgIGlmIChvcHRpb25zLnJ1bGVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5mbGFncy5yZXF1aXJlZCA9IHRoaXMuaXNSZXF1aXJlZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyB2YWxpZGF0ZSBpZiBpdCB3YXMgdmFsaWRhdGVkIGJlZm9yZSBhbmQgZmllbGQgd2FzIHVwZGF0ZWQgYW5kIHRoZXJlIHdhcyBhIHJ1bGVzIG11dGF0aW9uLlxyXG4gICAgaWYgKHRoaXMuZmxhZ3MudmFsaWRhdGVkICYmIG9wdGlvbnMucnVsZXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnVwZGF0ZWQpIHtcclxuICAgICAgdGhpcy52YWxpZGF0b3IudmFsaWRhdGUoKFwiI1wiICsgKHRoaXMuaWQpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcclxuICAgIHRoaXMuYWRkVmFsdWVMaXN0ZW5lcnMoKTtcclxuXHJcbiAgICAvLyBubyBuZWVkIHRvIGNvbnRpbnVlLlxyXG4gICAgaWYgKCF0aGlzLmVsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlQ2xhc3NlcygpO1xyXG4gICAgdGhpcy51cGRhdGVBcmlhQXR0cnMoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXNldHMgZmllbGQgZmxhZ3MgYW5kIGVycm9ycy5cclxuICAgKi9cclxuICBGaWVsZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgaWYgKHRoaXMuX2NhbmNlbGxhdGlvblRva2VuKSB7XHJcbiAgICAgIHRoaXMuX2NhbmNlbGxhdGlvblRva2VuLmNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLl9jYW5jZWxsYXRpb25Ub2tlbjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVmYXVsdHMgPSBjcmVhdGVGbGFncygpO1xyXG4gICAgT2JqZWN0LmtleXModGhpcy5mbGFncykuZmlsdGVyKGZ1bmN0aW9uIChmbGFnKSB7IHJldHVybiBmbGFnICE9PSAncmVxdWlyZWQnOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChmbGFnKSB7XHJcbiAgICAgIHRoaXMkMS5mbGFnc1tmbGFnXSA9IGRlZmF1bHRzW2ZsYWddO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5hZGRWYWx1ZUxpc3RlbmVycygpO1xyXG4gICAgdGhpcy5hZGRBY3Rpb25MaXN0ZW5lcnMoKTtcclxuICAgIHRoaXMudXBkYXRlQ2xhc3Nlcyh0cnVlKTtcclxuICAgIHRoaXMudXBkYXRlQXJpYUF0dHJzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUN1c3RvbVZhbGlkaXR5KCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgZmxhZ3MgYW5kIHRoZWlyIG5lZ2F0ZWQgY291bnRlcnBhcnRzLCBhbmQgdXBkYXRlcyB0aGUgY2xhc3NlcyBhbmQgcmUtYWRkcyBhY3Rpb24gbGlzdGVuZXJzLlxyXG4gICAqL1xyXG4gIEZpZWxkLnByb3RvdHlwZS5zZXRGbGFncyA9IGZ1bmN0aW9uIHNldEZsYWdzIChmbGFncykge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgIHZhciBuZWdhdGVkID0ge1xyXG4gICAgICBwcmlzdGluZTogJ2RpcnR5JyxcclxuICAgICAgZGlydHk6ICdwcmlzdGluZScsXHJcbiAgICAgIHZhbGlkOiAnaW52YWxpZCcsXHJcbiAgICAgIGludmFsaWQ6ICd2YWxpZCcsXHJcbiAgICAgIHRvdWNoZWQ6ICd1bnRvdWNoZWQnLFxyXG4gICAgICB1bnRvdWNoZWQ6ICd0b3VjaGVkJ1xyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3Qua2V5cyhmbGFncykuZm9yRWFjaChmdW5jdGlvbiAoZmxhZykge1xyXG4gICAgICB0aGlzJDEuZmxhZ3NbZmxhZ10gPSBmbGFnc1tmbGFnXTtcclxuICAgICAgLy8gaWYgaXQgaGFzIGEgbmVnYXRpb24gYW5kIHdhcyBub3Qgc3BlY2lmaWVkLCBzZXQgaXQgYXMgd2VsbC5cclxuICAgICAgaWYgKG5lZ2F0ZWRbZmxhZ10gJiYgZmxhZ3NbbmVnYXRlZFtmbGFnXV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMkMS5mbGFnc1tuZWdhdGVkW2ZsYWddXSA9ICFmbGFnc1tmbGFnXTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBmbGFncy51bnRvdWNoZWQgIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICBmbGFncy50b3VjaGVkICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgZmxhZ3MuZGlydHkgIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICBmbGFncy5wcmlzdGluZSAhPT0gdW5kZWZpbmVkXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5hZGRBY3Rpb25MaXN0ZW5lcnMoKTtcclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlQ2xhc3NlcygpO1xyXG4gICAgdGhpcy51cGRhdGVBcmlhQXR0cnMoKTtcclxuICAgIHRoaXMudXBkYXRlQ3VzdG9tVmFsaWRpdHkoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBmaWVsZCByZXF1aXJlcyByZWZlcmVuY2VzIHRvIHRhcmdldCBmaWVsZHMuXHJcbiAgKi9cclxuICBGaWVsZC5wcm90b3R5cGUudXBkYXRlRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gdXBkYXRlRGVwZW5kZW5jaWVzICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICAvLyByZXNldCBkZXBlbmRlbmNpZXMuXHJcbiAgICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmZpZWxkLmRlc3Ryb3koKTsgfSk7XHJcbiAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xyXG5cclxuICAgIC8vIHdlIGdldCB0aGUgc2VsZWN0b3JzIGZvciBlYWNoIGZpZWxkLlxyXG4gICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMucnVsZXMpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgcikge1xyXG4gICAgICBpZiAoUnVsZUNvbnRhaW5lci5pc1RhcmdldFJ1bGUocikpIHtcclxuICAgICAgICBwcmV2LnB1c2goeyBzZWxlY3RvcjogdGhpcyQxLnJ1bGVzW3JdWzBdLCBuYW1lOiByIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcHJldjtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBpZiAoIWZpZWxkcy5sZW5ndGggfHwgIXRoaXMudm0gfHwgIXRoaXMudm0uJGVsKSB7IHJldHVybjsgfVxyXG5cclxuICAgIC8vIG11c3QgYmUgY29udGFpbmVkIHdpdGhpbiB0aGUgc2FtZSBjb21wb25lbnQsIHNvIHdlIHVzZSB0aGUgdm0gcm9vdCBlbGVtZW50IGNvbnN0cmFpbiBvdXIgZG9tIHNlYXJjaC5cclxuICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYkMSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSByZWYkMS5zZWxlY3RvcjtcbiAgICAgICAgdmFyIG5hbWUgPSByZWYkMS5uYW1lO1xuXHJcbiAgICAgIHZhciByZWYgPSB0aGlzJDEudm0uJHJlZnNbc2VsZWN0b3JdO1xyXG4gICAgICB2YXIgZWwgPSBBcnJheS5pc0FycmF5KHJlZikgPyByZWZbMF0gOiByZWY7XHJcbiAgICAgIGlmICghZWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgIHZtOiB0aGlzJDEudm0sXHJcbiAgICAgICAgY2xhc3NlczogdGhpcyQxLmNsYXNzZXMsXHJcbiAgICAgICAgY2xhc3NOYW1lczogdGhpcyQxLmNsYXNzTmFtZXMsXHJcbiAgICAgICAgZGVsYXk6IHRoaXMkMS5kZWxheSxcclxuICAgICAgICBzY29wZTogdGhpcyQxLnNjb3BlLFxyXG4gICAgICAgIGV2ZW50czogdGhpcyQxLmV2ZW50cy5qb2luKCd8JyksXHJcbiAgICAgICAgaW1tZWRpYXRlOiB0aGlzJDEuaW1tZWRpYXRlLFxyXG4gICAgICAgIHRhcmdldE9mOiB0aGlzJDEuaWRcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIHByb2JhYmx5IGEgY29tcG9uZW50LlxyXG4gICAgICBpZiAoaXNDYWxsYWJsZShlbC4kd2F0Y2gpKSB7XHJcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnQgPSBlbDtcclxuICAgICAgICBvcHRpb25zLmVsID0gZWwuJGVsO1xyXG4gICAgICAgIG9wdGlvbnMuZ2V0dGVyID0gUmVzb2x2ZXIucmVzb2x2ZUdldHRlcihlbC4kZWwsIGVsLiR2bm9kZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb3B0aW9ucy5lbCA9IGVsO1xyXG4gICAgICAgIG9wdGlvbnMuZ2V0dGVyID0gUmVzb2x2ZXIucmVzb2x2ZUdldHRlcihlbCwge30pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzJDEuZGVwZW5kZW5jaWVzLnB1c2goeyBuYW1lOiBuYW1lLCBmaWVsZDogbmV3IEZpZWxkKG9wdGlvbnMpIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBsaXN0ZW5lcnMuXHJcbiAgICovXHJcbiAgRmllbGQucHJvdG90eXBlLnVud2F0Y2ggPSBmdW5jdGlvbiB1bndhdGNoICh0YWcpIHtcbiAgICAgIGlmICggdGFnID09PSB2b2lkIDAgKSB0YWcgPSBudWxsO1xuXHJcbiAgICBpZiAoIXRhZykge1xyXG4gICAgICB0aGlzLndhdGNoZXJzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcudW53YXRjaCgpOyB9KTtcclxuICAgICAgdGhpcy53YXRjaGVycyA9IFtdO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy53YXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHRhZy50ZXN0KHcudGFnKTsgfSkuZm9yRWFjaChmdW5jdGlvbiAodykgeyByZXR1cm4gdy51bndhdGNoKCk7IH0pO1xyXG4gICAgdGhpcy53YXRjaGVycyA9IHRoaXMud2F0Y2hlcnMuZmlsdGVyKGZ1bmN0aW9uICh3KSB7IHJldHVybiAhdGFnLnRlc3Qody50YWcpOyB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBlbGVtZW50IGNsYXNzZXMgZGVwZW5kaW5nIG9uIGVhY2ggZmllbGQgZmxhZyBzdGF0dXMuXHJcbiAgICovXHJcbiAgRmllbGQucHJvdG90eXBlLnVwZGF0ZUNsYXNzZXMgPSBmdW5jdGlvbiB1cGRhdGVDbGFzc2VzIChpc1Jlc2V0KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgIGlmICggaXNSZXNldCA9PT0gdm9pZCAwICkgaXNSZXNldCA9IGZhbHNlO1xuXHJcbiAgICBpZiAoIXRoaXMuY2xhc3NlcyB8fCB0aGlzLmlzRGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcbiAgICB2YXIgYXBwbHlDbGFzc2VzID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzJDEuY2xhc3NOYW1lcy5kaXJ0eSwgdGhpcyQxLmZsYWdzLmRpcnR5KTtcclxuICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMkMS5jbGFzc05hbWVzLnByaXN0aW5lLCB0aGlzJDEuZmxhZ3MucHJpc3RpbmUpO1xyXG4gICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcyQxLmNsYXNzTmFtZXMudG91Y2hlZCwgdGhpcyQxLmZsYWdzLnRvdWNoZWQpO1xyXG4gICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcyQxLmNsYXNzTmFtZXMudW50b3VjaGVkLCB0aGlzJDEuZmxhZ3MudW50b3VjaGVkKTtcclxuXHJcbiAgICAgIC8vIHJlbW92ZSB2YWxpZC9pbnZhbGlkIGNsYXNzZXMgb24gcmVzZXQuXHJcbiAgICAgIGlmIChpc1Jlc2V0KSB7XHJcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMkMS5jbGFzc05hbWVzLnZhbGlkLCBmYWxzZSk7XHJcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMkMS5jbGFzc05hbWVzLmludmFsaWQsIGZhbHNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IHNldCBhbnkgY2xhc3NlcyBpZiB0aGUgc3RhdGUgaXMgdW5kZXRlcm1pbmVkLlxyXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRoaXMkMS5mbGFncy52YWxpZCkgJiYgdGhpcyQxLmZsYWdzLnZhbGlkYXRlZCkge1xyXG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzJDEuY2xhc3NOYW1lcy52YWxpZCwgdGhpcyQxLmZsYWdzLnZhbGlkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0aGlzJDEuZmxhZ3MuaW52YWxpZCkgJiYgdGhpcyQxLmZsYWdzLnZhbGlkYXRlZCkge1xyXG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzJDEuY2xhc3NOYW1lcy5pbnZhbGlkLCB0aGlzJDEuZmxhZ3MuaW52YWxpZCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKCFpc0NoZWNrYm94T3JSYWRpb0lucHV0KHRoaXMuZWwpKSB7XHJcbiAgICAgIGFwcGx5Q2xhc3Nlcyh0aGlzLmVsKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKChcImlucHV0W25hbWU9XFxcIlwiICsgKHRoaXMuZWwubmFtZSkgKyBcIlxcXCJdXCIpKTtcclxuICAgIHRvQXJyYXkoZWxzKS5mb3JFYWNoKGFwcGx5Q2xhc3Nlcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyB0aGUgbGlzdGVuZXJzIHJlcXVpcmVkIGZvciBhdXRvbWF0aWMgY2xhc3NlcyBhbmQgc29tZSBmbGFncy5cclxuICAgKi9cclxuICBGaWVsZC5wcm90b3R5cGUuYWRkQWN0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkQWN0aW9uTGlzdGVuZXJzICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICAvLyByZW1vdmUgcHJldmlvdXMgbGlzdGVuZXJzLlxyXG4gICAgdGhpcy51bndhdGNoKC9jbGFzcy8pO1xyXG5cclxuICAgIGlmICghdGhpcy5lbCkgeyByZXR1cm47IH1cclxuXHJcbiAgICB2YXIgb25CbHVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzJDEuZmxhZ3MudG91Y2hlZCA9IHRydWU7XHJcbiAgICAgIHRoaXMkMS5mbGFncy51bnRvdWNoZWQgPSBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMkMS5jbGFzc2VzKSB7XHJcbiAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcyQxLmVsLCB0aGlzJDEuY2xhc3NOYW1lcy50b3VjaGVkLCB0cnVlKTtcclxuICAgICAgICB0b2dnbGVDbGFzcyh0aGlzJDEuZWwsIHRoaXMkMS5jbGFzc05hbWVzLnVudG91Y2hlZCwgZmFsc2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBvbmx5IG5lZWRlZCBvbmNlLlxyXG4gICAgICB0aGlzJDEudW53YXRjaCgvXmNsYXNzX2JsdXIkLyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpbnB1dEV2ZW50ID0gaXNUZXh0SW5wdXQodGhpcy5lbCkgPyAnaW5wdXQnIDogJ2NoYW5nZSc7XHJcbiAgICB2YXIgb25JbnB1dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcyQxLmZsYWdzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcyQxLmZsYWdzLnByaXN0aW5lID0gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzJDEuY2xhc3Nlcykge1xyXG4gICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMkMS5lbCwgdGhpcyQxLmNsYXNzTmFtZXMucHJpc3RpbmUsIGZhbHNlKTtcclxuICAgICAgICB0b2dnbGVDbGFzcyh0aGlzJDEuZWwsIHRoaXMkMS5jbGFzc05hbWVzLmRpcnR5LCB0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gb25seSBuZWVkZWQgb25jZS5cclxuICAgICAgdGhpcyQxLnVud2F0Y2goL15jbGFzc19pbnB1dCQvKTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHRoaXMuY29tcG9uZW50SW5zdGFuY2UgJiYgaXNDYWxsYWJsZSh0aGlzLmNvbXBvbmVudEluc3RhbmNlLiRvbmNlKSkge1xyXG4gICAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlLiRvbmNlKCdpbnB1dCcsIG9uSW5wdXQpO1xyXG4gICAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlLiRvbmNlKCdibHVyJywgb25CbHVyKTtcclxuICAgICAgdGhpcy53YXRjaGVycy5wdXNoKHtcclxuICAgICAgICB0YWc6ICdjbGFzc19pbnB1dCcsXHJcbiAgICAgICAgdW53YXRjaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdGhpcyQxLmNvbXBvbmVudEluc3RhbmNlLiRvZmYoJ2lucHV0Jywgb25JbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy53YXRjaGVycy5wdXNoKHtcclxuICAgICAgICB0YWc6ICdjbGFzc19ibHVyJyxcclxuICAgICAgICB1bndhdGNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICB0aGlzJDEuY29tcG9uZW50SW5zdGFuY2UuJG9mZignYmx1cicsIG9uQmx1cik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5lbCkgeyByZXR1cm47IH1cclxuXHJcbiAgICBhZGRFdmVudExpc3RlbmVyKHRoaXMuZWwsIGlucHV0RXZlbnQsIG9uSW5wdXQpO1xyXG4gICAgLy8gQ2hlY2tib3hlcyBhbmQgcmFkaW8gYnV0dG9ucyBvbiBNYWMgZG9uJ3QgZW1pdCBibHVyIG5hdHVyYWxseSwgc28gd2UgbGlzdGVuIG9uIGNsaWNrIGluc3RlYWQuXHJcbiAgICB2YXIgYmx1ckV2ZW50ID0gaXNDaGVja2JveE9yUmFkaW9JbnB1dCh0aGlzLmVsKSA/ICdjaGFuZ2UnIDogJ2JsdXInO1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmVsLCBibHVyRXZlbnQsIG9uQmx1cik7XHJcbiAgICB0aGlzLndhdGNoZXJzLnB1c2goe1xyXG4gICAgICB0YWc6ICdjbGFzc19pbnB1dCcsXHJcbiAgICAgIHVud2F0Y2g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzJDEuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihpbnB1dEV2ZW50LCBvbklucHV0KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy53YXRjaGVycy5wdXNoKHtcclxuICAgICAgdGFnOiAnY2xhc3NfYmx1cicsXHJcbiAgICAgIHVud2F0Y2g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzJDEuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihibHVyRXZlbnQsIG9uQmx1cik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIEZpZWxkLnByb3RvdHlwZS5jaGVja1ZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uIGNoZWNrVmFsdWVDaGFuZ2VkICgpIHtcclxuICAgIC8vIGhhbmRsZSBzb21lIHBlb3BsZSBpbml0aWFsaXplIHRoZSB2YWx1ZSB0byBudWxsLCBzaW5jZSB0ZXh0IGlucHV0cyBoYXZlIGVtcHR5IHN0cmluZyB2YWx1ZS5cclxuICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSA9PT0gbnVsbCAmJiB0aGlzLnZhbHVlID09PSAnJyAmJiBpc1RleHRJbnB1dCh0aGlzLmVsKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudmFsdWUgIT09IHRoaXMuaW5pdGlhbFZhbHVlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgdGhlIHN1aXRhYmxlIHByaW1hcnkgZXZlbnQgdG8gbGlzdGVuIGZvci5cclxuICAgKi9cclxuICBGaWVsZC5wcm90b3R5cGUuX2RldGVybWluZUlucHV0RXZlbnQgPSBmdW5jdGlvbiBfZGV0ZXJtaW5lSW5wdXRFdmVudCAoKSB7XHJcbiAgICAvLyBpZiBpdHMgYSBjdXN0b20gY29tcG9uZW50LCB1c2UgdGhlIGN1c3RvbWl6ZWQgbW9kZWwgZXZlbnQgb3IgdGhlIGlucHV0IGV2ZW50LlxyXG4gICAgaWYgKHRoaXMuY29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgcmV0dXJuICh0aGlzLmNvbXBvbmVudEluc3RhbmNlLiRvcHRpb25zLm1vZGVsICYmIHRoaXMuY29tcG9uZW50SW5zdGFuY2UuJG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5sYXp5KSB7XHJcbiAgICAgIHJldHVybiAnY2hhbmdlJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNUZXh0SW5wdXQodGhpcy5lbCkpIHtcclxuICAgICAgcmV0dXJuICdpbnB1dCc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICdjaGFuZ2UnO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgdGhlIGxpc3Qgb2YgZXZlbnRzIHRvIGxpc3RlbiB0by5cclxuICAgKi9cclxuICBGaWVsZC5wcm90b3R5cGUuX2RldGVybWluZUV2ZW50TGlzdCA9IGZ1bmN0aW9uIF9kZXRlcm1pbmVFdmVudExpc3QgKGRlZmF1bHRJbnB1dEV2ZW50KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgLy8gaWYgbm8gZXZlbnQgaXMgY29uZmlndXJlZCwgb3IgaXQgaXMgYSBjb21wb25lbnQgb3IgYSB0ZXh0IGlucHV0IHRoZW4gcmVzcGVjdCB0aGUgdXNlciBjaG9pY2UuXHJcbiAgICBpZiAoIXRoaXMuZXZlbnRzLmxlbmd0aCB8fCB0aGlzLmNvbXBvbmVudEluc3RhbmNlIHx8IGlzVGV4dElucHV0KHRoaXMuZWwpKSB7XHJcbiAgICAgIHJldHVybiBbXS5jb25jYXQoIHRoaXMuZXZlbnRzICkubWFwKGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBpZiAoZXZ0ID09PSAnaW5wdXQnICYmIHRoaXMkMS5tb2RlbCAmJiB0aGlzJDEubW9kZWwubGF6eSkge1xyXG4gICAgICAgICAgcmV0dXJuICdjaGFuZ2UnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGV2dDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZm9yY2Ugc3VpdGFibGUgZXZlbnQgZm9yIG5vbi10ZXh0IHR5cGUgZmllbGRzLlxyXG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzLm1hcChmdW5jdGlvbiAoZSkge1xyXG4gICAgICBpZiAoZSA9PT0gJ2lucHV0Jykge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0SW5wdXRFdmVudDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGU7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHRoZSBsaXN0ZW5lcnMgcmVxdWlyZWQgZm9yIHZhbGlkYXRpb24uXHJcbiAgICovXHJcbiAgRmllbGQucHJvdG90eXBlLmFkZFZhbHVlTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkVmFsdWVMaXN0ZW5lcnMgKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgIHRoaXMudW53YXRjaCgvXmlucHV0Xy4rLyk7XHJcbiAgICBpZiAoIXRoaXMubGlzdGVuIHx8ICF0aGlzLmVsKSB7IHJldHVybjsgfVxyXG5cclxuICAgIHZhciB0b2tlbiA9IHsgY2FuY2VsbGVkOiBmYWxzZSB9O1xyXG4gICAgdmFyIGZuID0gdGhpcy50YXJnZXRPZiA/IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcyQxLmZsYWdzLmNoYW5nZWQgPSB0aGlzJDEuY2hlY2tWYWx1ZUNoYW5nZWQoKTsgICAgdGhpcyQxLnZhbGlkYXRvci52YWxpZGF0ZSgoXCIjXCIgKyAodGhpcyQxLnRhcmdldE9mKSkpO1xyXG4gICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxyXG4gICAgICAvLyBpZiBpdHMgYSBET00gZXZlbnQsIHJlc29sdmUgdGhlIHZhbHVlLCBvdGhlcndpc2UgdXNlIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYXMgdGhlIHZhbHVlLlxyXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDAgfHwgaXNFdmVudChhcmdzWzBdKSkge1xyXG4gICAgICAgIGFyZ3NbMF0gPSB0aGlzJDEudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMkMS5mbGFncy5jaGFuZ2VkID0gdGhpcyQxLmNoZWNrVmFsdWVDaGFuZ2VkKCk7XHJcbiAgICAgIHRoaXMkMS52YWxpZGF0b3IudmFsaWRhdGUoKFwiI1wiICsgKHRoaXMkMS5pZCkpLCBhcmdzWzBdKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGlucHV0RXZlbnQgPSB0aGlzLl9kZXRlcm1pbmVJbnB1dEV2ZW50KCk7XHJcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZGV0ZXJtaW5lRXZlbnRMaXN0KGlucHV0RXZlbnQpO1xyXG5cclxuICAgIC8vIGlmIHRoZXJlIGlzIGEgbW9kZWwgYW5kIGFuIG9uIGlucHV0IHZhbGlkYXRpb24gaXMgcmVxdWVzdGVkLlxyXG4gICAgaWYgKHRoaXMubW9kZWwgJiYgaW5jbHVkZXMoZXZlbnRzLCBpbnB1dEV2ZW50KSkge1xyXG4gICAgICB2YXIgY3R4ID0gbnVsbDtcclxuICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLm1vZGVsLmV4cHJlc3Npb247XHJcbiAgICAgIC8vIGlmIGl0cyB3YXRjaGFibGUgZnJvbSB0aGUgY29udGV4dCB2bS5cclxuICAgICAgaWYgKHRoaXMubW9kZWwuZXhwcmVzc2lvbikge1xyXG4gICAgICAgIGN0eCA9IHRoaXMudm07XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMubW9kZWwuZXhwcmVzc2lvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gd2F0Y2ggaXQgZnJvbSB0aGUgY3VzdG9tIGNvbXBvbmVudCB2bSBpbnN0ZWFkLlxyXG4gICAgICBpZiAoIWV4cHJlc3Npb24gJiYgdGhpcy5jb21wb25lbnRJbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudEluc3RhbmNlLiRvcHRpb25zLm1vZGVsKSB7XHJcbiAgICAgICAgY3R4ID0gdGhpcy5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgICAgICBleHByZXNzaW9uID0gdGhpcy5jb21wb25lbnRJbnN0YW5jZS4kb3B0aW9ucy5tb2RlbC5wcm9wIHx8ICd2YWx1ZSc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjdHggJiYgZXhwcmVzc2lvbikge1xyXG4gICAgICAgIHZhciBkZWJvdW5jZWRGbiA9IGRlYm91bmNlKGZuLCB0aGlzLmRlbGF5W2lucHV0RXZlbnRdLCB0b2tlbik7XHJcbiAgICAgICAgdmFyIHVud2F0Y2ggPSBjdHguJHdhdGNoKGV4cHJlc3Npb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXHJcbiAgICAgICAgICB0aGlzJDEuZmxhZ3MucGVuZGluZyA9IHRydWU7XHJcbiAgICAgICAgICB0aGlzJDEuX2NhbmNlbGxhdGlvblRva2VuID0gdG9rZW47XHJcbiAgICAgICAgICBkZWJvdW5jZWRGbi5hcHBseSh2b2lkIDAsIGFyZ3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMud2F0Y2hlcnMucHVzaCh7XHJcbiAgICAgICAgICB0YWc6ICdpbnB1dF9tb2RlbCcsXHJcbiAgICAgICAgICB1bndhdGNoOiB1bndhdGNoXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGZpbHRlciBvdXQgaW5wdXQgZXZlbnQgYXMgaXQgaXMgYWxyZWFkeSBoYW5kbGVkIGJ5IHRoZSB3YXRjaGVyIEFQSS5cclxuICAgICAgICBldmVudHMgPSBldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlICE9PSBpbnB1dEV2ZW50OyB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBldmVudHMuXHJcbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICB2YXIgZGVib3VuY2VkRm4gPSBkZWJvdW5jZShmbiwgdGhpcyQxLmRlbGF5W2VdLCB0b2tlbik7XHJcbiAgICAgIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cclxuICAgICAgICB0aGlzJDEuZmxhZ3MucGVuZGluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcyQxLl9jYW5jZWxsYXRpb25Ub2tlbiA9IHRva2VuO1xyXG4gICAgICAgIGRlYm91bmNlZEZuLmFwcGx5KHZvaWQgMCwgYXJncyk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzJDEuX2FkZENvbXBvbmVudEV2ZW50TGlzdGVuZXIoZSwgdmFsaWRhdGUpO1xyXG4gICAgICB0aGlzJDEuX2FkZEhUTUxFdmVudExpc3RlbmVyKGUsIHZhbGlkYXRlKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIEZpZWxkLnByb3RvdHlwZS5fYWRkQ29tcG9uZW50RXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRDb21wb25lbnRFdmVudExpc3RlbmVyIChldnQsIHZhbGlkYXRlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgaWYgKCF0aGlzLmNvbXBvbmVudEluc3RhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UuJG9uKGV2dCwgdmFsaWRhdGUpO1xyXG4gICAgdGhpcy53YXRjaGVycy5wdXNoKHtcclxuICAgICAgdGFnOiAnaW5wdXRfdnVlJyxcclxuICAgICAgdW53YXRjaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMkMS5jb21wb25lbnRJbnN0YW5jZS4kb2ZmKGV2dCwgdmFsaWRhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBGaWVsZC5wcm90b3R5cGUuX2FkZEhUTUxFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZEhUTUxFdmVudExpc3RlbmVyIChldnQsIHZhbGlkYXRlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgaWYgKCF0aGlzLmVsIHx8IHRoaXMuY29tcG9uZW50SW5zdGFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgLy8gbGlzdGVuIGZvciB0aGUgY3VycmVudCBlbGVtZW50LlxyXG4gICAgdmFyIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2dCwgdmFsaWRhdGUpO1xyXG4gICAgICB0aGlzJDEud2F0Y2hlcnMucHVzaCh7XHJcbiAgICAgICAgdGFnOiAnaW5wdXRfbmF0aXZlJyxcclxuICAgICAgICB1bndhdGNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgdmFsaWRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFkZExpc3RlbmVyKHRoaXMuZWwpO1xyXG4gICAgaWYgKCFpc0NoZWNrYm94T3JSYWRpb0lucHV0KHRoaXMuZWwpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgoXCJpbnB1dFtuYW1lPVxcXCJcIiArICh0aGlzLmVsLm5hbWUpICsgXCJcXFwiXVwiKSk7XHJcbiAgICB0b0FycmF5KGVscykuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgLy8gc2tpcCBpZiBpdCBpcyBhZGRlZCBieSB2LXZhbGlkYXRlIGFuZCBpcyBub3QgdGhlIGN1cnJlbnQgZWxlbWVudC5cclxuICAgICAgaWYgKGVsLl92ZWVWYWxpZGF0ZUlkICYmIGVsICE9PSB0aGlzJDEuZWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFkZExpc3RlbmVyKGVsKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgYXJpYSBhdHRyaWJ1dGVzIG9uIHRoZSBlbGVtZW50LlxyXG4gICAqL1xyXG4gIEZpZWxkLnByb3RvdHlwZS51cGRhdGVBcmlhQXR0cnMgPSBmdW5jdGlvbiB1cGRhdGVBcmlhQXR0cnMgKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgIGlmICghdGhpcy5hcmlhIHx8ICF0aGlzLmVsIHx8ICFpc0NhbGxhYmxlKHRoaXMuZWwuc2V0QXR0cmlidXRlKSkgeyByZXR1cm47IH1cclxuXHJcbiAgICB2YXIgYXBwbHlBcmlhQXR0cnMgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLXJlcXVpcmVkJywgdGhpcyQxLmlzUmVxdWlyZWQgPyAndHJ1ZScgOiAnZmFsc2UnKTtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCB0aGlzJDEuZmxhZ3MuaW52YWxpZCA/ICd0cnVlJyA6ICdmYWxzZScpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIWlzQ2hlY2tib3hPclJhZGlvSW5wdXQodGhpcy5lbCkpIHtcclxuICAgICAgYXBwbHlBcmlhQXR0cnModGhpcy5lbCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgoXCJpbnB1dFtuYW1lPVxcXCJcIiArICh0aGlzLmVsLm5hbWUpICsgXCJcXFwiXVwiKSk7XHJcbiAgICB0b0FycmF5KGVscykuZm9yRWFjaChhcHBseUFyaWFBdHRycyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgY3VzdG9tIHZhbGlkaXR5IGZvciB0aGUgZmllbGQuXHJcbiAgICovXHJcbiAgRmllbGQucHJvdG90eXBlLnVwZGF0ZUN1c3RvbVZhbGlkaXR5ID0gZnVuY3Rpb24gdXBkYXRlQ3VzdG9tVmFsaWRpdHkgKCkge1xyXG4gICAgaWYgKCF0aGlzLnZhbGlkaXR5IHx8ICF0aGlzLmVsIHx8ICFpc0NhbGxhYmxlKHRoaXMuZWwuc2V0Q3VzdG9tVmFsaWRpdHkpIHx8ICF0aGlzLnZhbGlkYXRvci5lcnJvcnMpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgdGhpcy5lbC5zZXRDdXN0b21WYWxpZGl0eSh0aGlzLmZsYWdzLnZhbGlkID8gJycgOiAodGhpcy52YWxpZGF0b3IuZXJyb3JzLmZpcnN0QnlJZCh0aGlzLmlkKSB8fCAnJykpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycy5cclxuICAgKi9cclxuICBGaWVsZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xyXG4gICAgLy8gaWdub3JlIHRoZSByZXN1bHQgb2YgYW55IG9uZ29pbmcgdmFsaWRhdGlvbi5cclxuICAgIGlmICh0aGlzLl9jYW5jZWxsYXRpb25Ub2tlbikge1xyXG4gICAgICB0aGlzLl9jYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudW53YXRjaCgpO1xyXG4gICAgdGhpcy5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5maWVsZC5kZXN0cm95KCk7IH0pO1xyXG4gICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcclxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBGaWVsZC5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbiAgLy8gXHJcblxyXG4gIHZhciBGaWVsZEJhZyA9IGZ1bmN0aW9uIEZpZWxkQmFnIChpdGVtcykge1xuICAgIGlmICggaXRlbXMgPT09IHZvaWQgMCApIGl0ZW1zID0gW107XG5cclxuICAgIHRoaXMuaXRlbXMgPSBpdGVtcyB8fCBbXTtcclxuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMiA9IHsgbGVuZ3RoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XHJcblxyXG4gIEZpZWxkQmFnLnByb3RvdHlwZVt0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nID8gU3ltYm9sLml0ZXJhdG9yIDogJ0BAaXRlcmF0b3InXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzJDEuaXRlbXNbaW5kZXgrK10sIGRvbmU6IGluZGV4ID4gdGhpcyQxLml0ZW1zLmxlbmd0aCB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgaXRlbXMgbGVuZ3RoLlxyXG4gICAqL1xyXG5cclxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMi5sZW5ndGguZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmRzIHRoZSBmaXJzdCBmaWVsZCB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIG1hdGNoZXIgb2JqZWN0LlxyXG4gICAqL1xyXG4gIEZpZWxkQmFnLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gZmluZCQxIChtYXRjaGVyKSB7XHJcbiAgICByZXR1cm4gZmluZCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5tYXRjaGVzKG1hdGNoZXIpOyB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBGaWx0ZXJzIHRoZSBpdGVtcyBkb3duIHRvIHRoZSBtYXRjaGVkIGZpZWxkcy5cclxuICAgKi9cclxuICBGaWVsZEJhZy5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChtYXRjaGVyKSB7XHJcbiAgICAvLyBtdWx0aXBsZSBtYXRjaGVycyB0byBiZSB0cmllZC5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGNoZXIpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gbWF0Y2hlci5zb21lKGZ1bmN0aW9uIChtKSB7IHJldHVybiBpdGVtLm1hdGNoZXMobSk7IH0pOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ubWF0Y2hlcyhtYXRjaGVyKTsgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTWFwcyB0aGUgZmllbGQgaXRlbXMgdXNpbmcgdGhlIG1hcHBpbmcgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgRmllbGRCYWcucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAobWFwcGVyKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBGaW5kcyBhbmQgcmVtb3ZlcyB0aGUgZmlyc3QgZmllbGQgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBtYXRjaGVyIG9iamVjdCwgcmV0dXJucyB0aGUgcmVtb3ZlZCBpdGVtLlxyXG4gICAqL1xyXG4gIEZpZWxkQmFnLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKG1hdGNoZXIpIHtcclxuICAgIHZhciBpdGVtID0gbnVsbDtcclxuICAgIGlmIChtYXRjaGVyIGluc3RhbmNlb2YgRmllbGQpIHtcclxuICAgICAgaXRlbSA9IG1hdGNoZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpdGVtID0gdGhpcy5maW5kKG1hdGNoZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXRlbSkgeyByZXR1cm4gbnVsbDsgfVxyXG5cclxuICAgIHZhciBpbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKTtcclxuICAgIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICByZXR1cm4gaXRlbTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgZmllbGQgaXRlbSB0byB0aGUgbGlzdC5cclxuICAgKi9cclxuICBGaWVsZEJhZy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGl0ZW0pIHtcclxuICAgIGlmICghIChpdGVtIGluc3RhbmNlb2YgRmllbGQpKSB7XHJcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdGaWVsZEJhZyBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZpZWxkIHRoYXQgaGFzIGFuIGlkIGRlZmluZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpdGVtLmlkKSB7XHJcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdGaWVsZCBpZCBtdXN0IGJlIGRlZmluZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZmluZCh7IGlkOiBpdGVtLmlkIH0pKSB7XHJcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKChcIkZpZWxkIHdpdGggaWQgXCIgKyAoaXRlbS5pZCkgKyBcIiBpcyBhbHJlYWR5IGFkZGVkLlwiKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xyXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEZpZWxkQmFnLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDIgKTtcblxuICB2YXIgU2NvcGVkVmFsaWRhdG9yID0gZnVuY3Rpb24gU2NvcGVkVmFsaWRhdG9yIChiYXNlLCB2bSkge1xyXG4gICAgdGhpcy5pZCA9IHZtLl91aWQ7XHJcbiAgICB0aGlzLl9iYXNlID0gYmFzZTtcclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBhIG1pcnJvciBiYWcgd2l0aCBsaW1pdGVkIGNvbXBvbmVudCBzY29wZS5cclxuICAgIHRoaXMuZXJyb3JzID0gbmV3IEVycm9yQmFnKGJhc2UuZXJyb3JzLCB0aGlzLmlkKTtcclxuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMyA9IHsgZmxhZ3M6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0scnVsZXM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZmllbGRzOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGRpY3Rpb25hcnk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sbG9jYWxlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XHJcblxyXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQzLmZsYWdzLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICByZXR1cm4gdGhpcy5fYmFzZS5maWVsZHMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLnZtSWQgPT09IHRoaXMkMS5pZDsgfSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZpZWxkKSB7XHJcbiAgICAgIGlmIChmaWVsZC5zY29wZSkge1xyXG4gICAgICAgIGlmICghYWNjWyhcIiRcIiArIChmaWVsZC5zY29wZSkpXSkge1xyXG4gICAgICAgICAgYWNjWyhcIiRcIiArIChmaWVsZC5zY29wZSkpXSA9IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWNjWyhcIiRcIiArIChmaWVsZC5zY29wZSkpXVtmaWVsZC5uYW1lXSA9IGZpZWxkLmZsYWdzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhY2NbZmllbGQubmFtZV0gPSBmaWVsZC5mbGFncztcclxuXHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcbiAgfTtcclxuXHJcbiAgcHJvdG90eXBlQWNjZXNzb3JzJDMucnVsZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Jhc2UucnVsZXM7XHJcbiAgfTtcclxuXHJcbiAgcHJvdG90eXBlQWNjZXNzb3JzJDMuZmllbGRzLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuZXcgRmllbGRCYWcodGhpcy5fYmFzZS5maWVsZHMuZmlsdGVyKHsgdm1JZDogdGhpcy5pZCB9KSk7XHJcbiAgfTtcclxuXHJcbiAgcHJvdG90eXBlQWNjZXNzb3JzJDMuZGljdGlvbmFyeS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmFzZS5kaWN0aW9uYXJ5O1xyXG4gIH07XHJcblxyXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQzLmxvY2FsZS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmFzZS5sb2NhbGU7XHJcbiAgfTtcclxuXHJcbiAgcHJvdG90eXBlQWNjZXNzb3JzJDMubG9jYWxlLnNldCA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIHRoaXMuX2Jhc2UubG9jYWxlID0gdmFsO1xyXG4gIH07XHJcblxyXG4gIFNjb3BlZFZhbGlkYXRvci5wcm90b3R5cGUubG9jYWxpemUgPSBmdW5jdGlvbiBsb2NhbGl6ZSAoKSB7XG4gICAgICB2YXIgcmVmO1xuXG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcclxuICAgIHJldHVybiAocmVmID0gdGhpcy5fYmFzZSkubG9jYWxpemUuYXBwbHkocmVmLCBhcmdzKTtcclxuICB9O1xyXG5cclxuICBTY29wZWRWYWxpZGF0b3IucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgICB2YXIgcmVmO1xuXG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcclxuICAgIHJldHVybiAocmVmID0gdGhpcy5fYmFzZSkudXBkYXRlLmFwcGx5KHJlZiwgYXJncyk7XHJcbiAgfTtcclxuXHJcbiAgU2NvcGVkVmFsaWRhdG9yLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2ggKG9wdHMpIHtcclxuICAgIHZhciBhdHRhY2hPcHRzID0gYXNzaWduKHt9LCBvcHRzLCB7IHZtSWQ6IHRoaXMuaWQgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2Jhc2UuYXR0YWNoKGF0dGFjaE9wdHMpO1xyXG4gIH07XHJcblxyXG4gIFNjb3BlZFZhbGlkYXRvci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSAoKSB7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xyXG4gIH07XHJcblxyXG4gIFNjb3BlZFZhbGlkYXRvci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lICgpIHtcclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIFNjb3BlZFZhbGlkYXRvci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChydWxlTmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Jhc2UucmVtb3ZlKHJ1bGVOYW1lKTtcclxuICB9O1xyXG5cclxuICBTY29wZWRWYWxpZGF0b3IucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCAobmFtZSwgc2NvcGUpIHtcclxuICAgIHJldHVybiB0aGlzLl9iYXNlLmRldGFjaChuYW1lLCBzY29wZSwgdGhpcy5pZCk7XHJcbiAgfTtcclxuXHJcbiAgU2NvcGVkVmFsaWRhdG9yLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKCkge1xuICAgICAgdmFyIHJlZjtcblxuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XHJcbiAgICByZXR1cm4gKHJlZiA9IHRoaXMuX2Jhc2UpLmV4dGVuZC5hcHBseShyZWYsIGFyZ3MpO1xyXG4gIH07XHJcblxyXG4gIFNjb3BlZFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSAoZGVzY3JpcHRvciwgdmFsdWUsIG9wdHMpIHtcbiAgICAgIGlmICggb3B0cyA9PT0gdm9pZCAwICkgb3B0cyA9IHt9O1xuXHJcbiAgICBpZiAodGhpcy5fcGF1c2VkKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7IH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fYmFzZS52YWxpZGF0ZShkZXNjcmlwdG9yLCB2YWx1ZSwgYXNzaWduKHt9LCB7IHZtSWQ6IHRoaXMuaWQgfSwgb3B0cyB8fCB7fSkpO1xyXG4gIH07XHJcblxyXG4gIFNjb3BlZFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVBbGwgPSBmdW5jdGlvbiB2YWxpZGF0ZUFsbCAodmFsdWVzJCQxLCBvcHRzKSB7XG4gICAgICBpZiAoIG9wdHMgPT09IHZvaWQgMCApIG9wdHMgPSB7fTtcblxyXG4gICAgaWYgKHRoaXMuX3BhdXNlZCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpOyB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2Jhc2UudmFsaWRhdGVBbGwodmFsdWVzJCQxLCBhc3NpZ24oe30sIHsgdm1JZDogdGhpcy5pZCB9LCBvcHRzIHx8IHt9KSk7XHJcbiAgfTtcclxuXHJcbiAgU2NvcGVkVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZVNjb3BlcyA9IGZ1bmN0aW9uIHZhbGlkYXRlU2NvcGVzIChvcHRzKSB7XG4gICAgICBpZiAoIG9wdHMgPT09IHZvaWQgMCApIG9wdHMgPSB7fTtcblxyXG4gICAgaWYgKHRoaXMuX3BhdXNlZCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpOyB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2Jhc2UudmFsaWRhdGVTY29wZXMoYXNzaWduKHt9LCB7IHZtSWQ6IHRoaXMuaWQgfSwgb3B0cyB8fCB7fSkpO1xyXG4gIH07XHJcblxyXG4gIFNjb3BlZFZhbGlkYXRvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xyXG4gICAgZGVsZXRlIHRoaXMuaWQ7XHJcbiAgICBkZWxldGUgdGhpcy5fYmFzZTtcclxuICB9O1xyXG5cclxuICBTY29wZWRWYWxpZGF0b3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKG1hdGNoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLl9iYXNlLnJlc2V0KE9iamVjdC5hc3NpZ24oe30sIG1hdGNoZXIgfHwge30sIHsgdm1JZDogdGhpcy5pZCB9KSk7XHJcbiAgfTtcclxuXHJcbiAgU2NvcGVkVmFsaWRhdG9yLnByb3RvdHlwZS5mbGFnID0gZnVuY3Rpb24gZmxhZyAoKSB7XG4gICAgICB2YXIgcmVmO1xuXG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcclxuICAgIHJldHVybiAocmVmID0gdGhpcy5fYmFzZSkuZmxhZy5hcHBseShyZWYsIGFyZ3MuY29uY2F0KCBbdGhpcy5pZF0gKSk7XHJcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggU2NvcGVkVmFsaWRhdG9yLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDMgKTtcblxuICAvLyBcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGEgcGFyZW50IHZhbGlkYXRvciBpbnN0YW5jZSB3YXMgcmVxdWVzdGVkLlxyXG4gICAqL1xyXG4gIHZhciByZXF1ZXN0c1ZhbGlkYXRvciA9IGZ1bmN0aW9uIChpbmplY3Rpb25zKSB7XHJcbiAgICBpZiAoaXNPYmplY3QoaW5qZWN0aW9ucykgJiYgaW5qZWN0aW9ucy4kdmFsaWRhdG9yKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9O1xyXG5cclxuICB2YXIgbWl4aW4gPSB7XHJcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlICgpIHtcclxuICAgICAgaWYgKHRoaXMuJHZhbGlkYXRvciAmJiAhaXNCdWlsdEluQ29tcG9uZW50KHRoaXMuJHZub2RlKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAkdmFsaWRhdG9yOiB0aGlzLiR2YWxpZGF0b3JcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiBiZWZvcmVDcmVhdGUgKCkge1xyXG4gICAgICAvLyBpZiBidWlsdCBpbiBkbyBub3RoaW5nLlxyXG4gICAgICBpZiAoaXNCdWlsdEluQ29tcG9uZW50KHRoaXMuJHZub2RlKSB8fCB0aGlzLiRvcHRpb25zLiRfX3ZlZUluamVjdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGlmIGl0cyBhIHJvb3QgaW5zdGFuY2Ugc2V0IHRoZSBjb25maWcgaWYgaXQgZXhpc3RzLlxyXG4gICAgICBpZiAoIXRoaXMuJHBhcmVudCkge1xyXG4gICAgICAgIHBsdWdpbkluc3RhbmNlLmNvbmZpZ3VyZSh0aGlzLiRvcHRpb25zLiRfdmVlVmFsaWRhdGUgfHwge30pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgb3B0aW9ucyA9IHBsdWdpbkluc3RhbmNlLnJlc29sdmVDb25maWcodGhpcyk7XHJcblxyXG4gICAgICAvLyBpZiBpdHMgYSByb290IGluc3RhbmNlLCBpbmplY3QgYW55d2F5cywgb3IgaWYgaXQgcmVxdWVzdGVkIGEgbmV3IGluc3RhbmNlLlxyXG4gICAgICBpZiAoIXRoaXMuJHBhcmVudCB8fCAodGhpcy4kb3B0aW9ucy4kX3ZlZVZhbGlkYXRlICYmIC9uZXcvLnRlc3QodGhpcy4kb3B0aW9ucy4kX3ZlZVZhbGlkYXRlLnZhbGlkYXRvcikpKSB7XHJcbiAgICAgICAgdGhpcy4kdmFsaWRhdG9yID0gbmV3IFNjb3BlZFZhbGlkYXRvcihwbHVnaW5JbnN0YW5jZS5fdmFsaWRhdG9yLCB0aGlzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlcXVlc3RlZCA9IHJlcXVlc3RzVmFsaWRhdG9yKHRoaXMuJG9wdGlvbnMuaW5qZWN0KTtcclxuXHJcbiAgICAgIC8vIGlmIGF1dG9tYXRpYyBpbmplY3Rpb24gaXMgZW5hYmxlZCBhbmQgbm8gaW5zdGFuY2Ugd2FzIHJlcXVlc3RlZC5cclxuICAgICAgaWYgKCEgdGhpcy4kdmFsaWRhdG9yICYmIG9wdGlvbnMuaW5qZWN0ICYmICFyZXF1ZXN0ZWQpIHtcclxuICAgICAgICB0aGlzLiR2YWxpZGF0b3IgPSBuZXcgU2NvcGVkVmFsaWRhdG9yKHBsdWdpbkluc3RhbmNlLl92YWxpZGF0b3IsIHRoaXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBkb24ndCBpbmplY3QgZXJyb3JzIG9yIGZpZWxkQmFnIGFzIG5vIHZhbGlkYXRvciB3YXMgcmVzb2x2ZWQuXHJcbiAgICAgIGlmICghIHJlcXVlc3RlZCAmJiAhIHRoaXMuJHZhbGlkYXRvcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhlcmUgaXMgYSB2YWxpZGF0b3IgYnV0IGl0IGlzbid0IGluamVjdGVkLCBtYXJrIGFzIHJlYWN0aXZlLlxyXG4gICAgICBpZiAoIXJlcXVlc3RlZCAmJiB0aGlzLiR2YWxpZGF0b3IpIHtcclxuICAgICAgICB2YXIgVnVlID0gdGhpcy4kb3B0aW9ucy5fYmFzZTsgLy8gdGhlIHZ1ZSBjb25zdHJ1Y3Rvci5cclxuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLiR2YWxpZGF0b3IsICdlcnJvcnMnLCB0aGlzLiR2YWxpZGF0b3IuZXJyb3JzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEgdGhpcy4kb3B0aW9ucy5jb21wdXRlZCkge1xyXG4gICAgICAgIHRoaXMuJG9wdGlvbnMuY29tcHV0ZWQgPSB7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy4kb3B0aW9ucy5jb21wdXRlZFtvcHRpb25zLmVycm9yQmFnTmFtZSB8fCAnZXJyb3JzJ10gPSBmdW5jdGlvbiBlcnJvckJhZ0dldHRlciAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJHZhbGlkYXRvci5lcnJvcnM7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuJG9wdGlvbnMuY29tcHV0ZWRbb3B0aW9ucy5maWVsZHNCYWdOYW1lIHx8ICdmaWVsZHMnXSA9IGZ1bmN0aW9uIGZpZWxkQmFnR2V0dGVyICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kdmFsaWRhdG9yLmZpZWxkcy5pdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZmllbGQpIHtcclxuICAgICAgICAgIGlmIChmaWVsZC5zY29wZSkge1xyXG4gICAgICAgICAgICBpZiAoIWFjY1soXCIkXCIgKyAoZmllbGQuc2NvcGUpKV0pIHtcclxuICAgICAgICAgICAgICBhY2NbKFwiJFwiICsgKGZpZWxkLnNjb3BlKSldID0ge307XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFjY1soXCIkXCIgKyAoZmllbGQuc2NvcGUpKV1bZmllbGQubmFtZV0gPSBmaWVsZC5mbGFncztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYWNjW2ZpZWxkLm5hbWVdID0gZmllbGQuZmxhZ3M7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSAoKSB7XHJcbiAgICAgIGlmICh0aGlzLiR2YWxpZGF0b3IgJiYgdGhpcy5fdWlkID09PSB0aGlzLiR2YWxpZGF0b3IuaWQpIHtcclxuICAgICAgICB0aGlzLiR2YWxpZGF0b3IuZXJyb3JzLmNsZWFyKCk7IC8vIHJlbW92ZSBlcnJvcnMgZ2VuZXJhdGVkIGJ5IHRoaXMgY29tcG9uZW50LlxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcblxuICAvLyBcclxuXHJcbiAgLyoqXHJcbiAgICogRmluZHMgdGhlIHJlcXVlc3RlZCBmaWVsZCBieSBpZCBmcm9tIHRoZSBjb250ZXh0IG9iamVjdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBmaW5kRmllbGQgKGVsLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoIWNvbnRleHQgfHwgIWNvbnRleHQuJHZhbGlkYXRvcikge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGV4dC4kdmFsaWRhdG9yLmZpZWxkcy5maW5kKHsgaWQ6IGVsLl92ZWVWYWxpZGF0ZUlkIH0pO1xyXG4gIH1cclxuICB2YXIgZGlyZWN0aXZlID0ge1xyXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgIHZhciB2YWxpZGF0b3IgPSB2bm9kZS5jb250ZXh0LiR2YWxpZGF0b3I7XHJcbiAgICAgIGlmICghdmFsaWRhdG9yKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgd2FybihcIk5vIHZhbGlkYXRvciBpbnN0YW5jZSBpcyBwcmVzZW50IG9uIHZtLCBkaWQgeW91IGZvcmdldCB0byBpbmplY3QgJyR2YWxpZGF0b3InP1wiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGZpZWxkT3B0aW9ucyA9IFJlc29sdmVyLmdlbmVyYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSk7XHJcbiAgICAgIHZhbGlkYXRvci5hdHRhY2goZmllbGRPcHRpb25zKTtcclxuICAgIH0sXHJcbiAgICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICB2YXIgZmllbGQgPSBmaW5kRmllbGQoZWwsIHZub2RlLmNvbnRleHQpO1xyXG4gICAgICB2YXIgc2NvcGUgPSBSZXNvbHZlci5yZXNvbHZlU2NvcGUoZWwsIGJpbmRpbmcsIHZub2RlKTtcclxuXHJcbiAgICAgIC8vIHNraXAgaWYgc2NvcGUgaGFzbid0IGNoYW5nZWQuXHJcbiAgICAgIGlmICghZmllbGQgfHwgc2NvcGUgPT09IGZpZWxkLnNjb3BlKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgLy8gb25seSB1cGRhdGUgc2NvcGUuXHJcbiAgICAgIGZpZWxkLnVwZGF0ZSh7IHNjb3BlOiBzY29wZSB9KTtcclxuXHJcbiAgICAgIC8vIGFsbG93cyB0aGUgZmllbGQgdG8gcmUtZXZhbHVhdGVkIG9uY2UgbW9yZSBpbiB0aGUgdXBkYXRlIGhvb2suXHJcbiAgICAgIGZpZWxkLnVwZGF0ZWQgPSBmYWxzZTtcclxuICAgIH0sXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgIHZhciBmaWVsZCA9IGZpbmRGaWVsZChlbCwgdm5vZGUuY29udGV4dCk7XHJcblxyXG4gICAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgZG8gdW5uZWNjYXNhcnkgd29yayBpZiBubyBpbXBvcnRhbnQgY2hhbmdlIHdhcyBkb25lLlxyXG4gICAgICBpZiAoIWZpZWxkIHx8IChmaWVsZC51cGRhdGVkICYmIGlzRXF1YWwkMShiaW5kaW5nLnZhbHVlLCBiaW5kaW5nLm9sZFZhbHVlKSkpIHsgcmV0dXJuOyB9XHJcbiAgICAgIHZhciBzY29wZSA9IFJlc29sdmVyLnJlc29sdmVTY29wZShlbCwgYmluZGluZywgdm5vZGUpO1xyXG4gICAgICB2YXIgcnVsZXMgPSBSZXNvbHZlci5yZXNvbHZlUnVsZXMoZWwsIGJpbmRpbmcsIHZub2RlKTtcclxuXHJcbiAgICAgIGZpZWxkLnVwZGF0ZSh7XHJcbiAgICAgICAgc2NvcGU6IHNjb3BlLFxyXG4gICAgICAgIHJ1bGVzOiBydWxlc1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoZWwsIGJpbmRpbmcsIHJlZikge1xuICAgICAgdmFyIGNvbnRleHQgPSByZWYuY29udGV4dDtcblxyXG4gICAgICB2YXIgZmllbGQgPSBmaW5kRmllbGQoZWwsIGNvbnRleHQpO1xyXG4gICAgICBpZiAoIWZpZWxkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgY29udGV4dC4kdmFsaWRhdG9yLmRldGFjaChmaWVsZCk7XHJcbiAgICB9XHJcbiAgfTtcblxuICAvLyBcclxuXHJcbiAgdmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uIFZhbGlkYXRvciAodmFsaWRhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7IGZhc3RFeGl0OiB0cnVlIH07XG5cclxuICAgIHRoaXMuZXJyb3JzID0gbmV3IEVycm9yQmFnKCk7XHJcbiAgICB0aGlzLmZpZWxkcyA9IG5ldyBGaWVsZEJhZygpO1xyXG4gICAgdGhpcy5fY3JlYXRlRmllbGRzKHZhbGlkYXRpb25zKTtcclxuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLmZhc3RFeGl0ID0gIWlzTnVsbE9yVW5kZWZpbmVkKG9wdGlvbnMgJiYgb3B0aW9ucy5mYXN0RXhpdCkgPyBvcHRpb25zLmZhc3RFeGl0IDogdHJ1ZTtcclxuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMkNCA9IHsgcnVsZXM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZGljdGlvbmFyeTogeyBjb25maWd1cmFibGU6IHRydWUgfSxmbGFnczogeyBjb25maWd1cmFibGU6IHRydWUgfSxsb2NhbGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyQxID0geyBydWxlczogeyBjb25maWd1cmFibGU6IHRydWUgfSxkaWN0aW9uYXJ5OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGxvY2FsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xyXG5cclxuICBzdGF0aWNBY2Nlc3NvcnMkMS5ydWxlcy5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gUnVsZUNvbnRhaW5lci5ydWxlcztcclxuICB9O1xyXG5cclxuICBwcm90b3R5cGVBY2Nlc3NvcnMkNC5ydWxlcy5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gUnVsZUNvbnRhaW5lci5ydWxlcztcclxuICB9O1xyXG5cclxuICBwcm90b3R5cGVBY2Nlc3NvcnMkNC5kaWN0aW9uYXJ5LmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBWZWVWYWxpZGF0ZSQxLmkxOG5Ecml2ZXI7XHJcbiAgfTtcclxuXHJcbiAgc3RhdGljQWNjZXNzb3JzJDEuZGljdGlvbmFyeS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gVmVlVmFsaWRhdGUkMS5pMThuRHJpdmVyO1xyXG4gIH07XHJcblxyXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQ0LmZsYWdzLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmZpZWxkcy5pdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZmllbGQpIHtcbiAgICAgICAgdmFyIG9iajtcblxyXG4gICAgICBpZiAoZmllbGQuc2NvcGUpIHtcclxuICAgICAgICBhY2NbKFwiJFwiICsgKGZpZWxkLnNjb3BlKSldID0gKCBvYmogPSB7fSwgb2JqW2ZpZWxkLm5hbWVdID0gZmllbGQuZmxhZ3MsIG9iaiApO1xyXG5cclxuICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhY2NbZmllbGQubmFtZV0gPSBmaWVsZC5mbGFncztcclxuXHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciB0aGUgY3VycmVudCBsb2NhbGUuXHJcbiAgICovXHJcbiAgcHJvdG90eXBlQWNjZXNzb3JzJDQubG9jYWxlLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBWYWxpZGF0b3IubG9jYWxlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgdGhlIHZhbGlkYXRvciBsb2NhbGUuXHJcbiAgICovXHJcbiAgcHJvdG90eXBlQWNjZXNzb3JzJDQubG9jYWxlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgVmFsaWRhdG9yLmxvY2FsZSA9IHZhbHVlO1xyXG4gIH07XHJcblxyXG4gIHN0YXRpY0FjY2Vzc29ycyQxLmxvY2FsZS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gVmVlVmFsaWRhdGUkMS5pMThuRHJpdmVyLmxvY2FsZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHRoZSB2YWxpZGF0b3IgbG9jYWxlLlxyXG4gICAqL1xyXG4gIHN0YXRpY0FjY2Vzc29ycyQxLmxvY2FsZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciBoYXNDaGFuZ2VkID0gdmFsdWUgIT09IFZlZVZhbGlkYXRlJDEuaTE4bkRyaXZlci5sb2NhbGU7XHJcbiAgICBWZWVWYWxpZGF0ZSQxLmkxOG5Ecml2ZXIubG9jYWxlID0gdmFsdWU7XHJcbiAgICBpZiAoaGFzQ2hhbmdlZCAmJiBWZWVWYWxpZGF0ZSQxLmluc3RhbmNlICYmIFZlZVZhbGlkYXRlJDEuaW5zdGFuY2UuX3ZtKSB7XHJcbiAgICAgIFZlZVZhbGlkYXRlJDEuaW5zdGFuY2UuX3ZtLiRlbWl0KCdsb2NhbGVDaGFuZ2VkJyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU3RhdGljIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIFZhbGlkYXRvci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUgKHZhbGlkYXRpb25zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IFZhbGlkYXRvcih2YWxpZGF0aW9ucywgb3B0aW9ucyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIGN1c3RvbSB2YWxpZGF0b3IgdG8gdGhlIGxpc3Qgb2YgdmFsaWRhdGlvbiBydWxlcy5cclxuICAgKi9cclxuICBWYWxpZGF0b3IuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChuYW1lLCB2YWxpZGF0b3IsIG9wdGlvbnMpIHtcbiAgICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXHJcbiAgICBWYWxpZGF0b3IuX2d1YXJkRXh0ZW5kKG5hbWUsIHZhbGlkYXRvcik7XHJcbiAgICBWYWxpZGF0b3IuX21lcmdlKG5hbWUsIHtcclxuICAgICAgdmFsaWRhdG9yOiB2YWxpZGF0b3IsXHJcbiAgICAgIHBhcmFtTmFtZXM6IG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJhbU5hbWVzLFxyXG4gICAgICBvcHRpb25zOiBhc3NpZ24oe30sIHsgaGFzVGFyZ2V0OiBmYWxzZSwgaW1tZWRpYXRlOiB0cnVlIH0sIG9wdGlvbnMgfHwge30pXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGEgcnVsZSBmcm9tIHRoZSBsaXN0IG9mIHZhbGlkYXRvcnMuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAobmFtZSkge1xyXG4gICAgUnVsZUNvbnRhaW5lci5yZW1vdmUobmFtZSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBydWxlIG5hbWUgaXMgYSBydWxlIHRoYXQgdGFyZ2V0cyBvdGhlciBmaWVsZHMuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLmlzVGFyZ2V0UnVsZSA9IGZ1bmN0aW9uIGlzVGFyZ2V0UnVsZSAobmFtZSkge1xyXG4gICAgcmV0dXJuIFJ1bGVDb250YWluZXIuaXNUYXJnZXRSdWxlKG5hbWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYW5kIHNldHMgdGhlIGN1cnJlbnQgbG9jYWxlIGZvciB0aGUgdmFsaWRhdG9yLlxyXG4gICAqL1xyXG4gIFZhbGlkYXRvci5wcm90b3R5cGUubG9jYWxpemUgPSBmdW5jdGlvbiBsb2NhbGl6ZSAobGFuZywgZGljdGlvbmFyeSkge1xyXG4gICAgVmFsaWRhdG9yLmxvY2FsaXplKGxhbmcsIGRpY3Rpb25hcnkpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYW5kIHNldHMgdGhlIGN1cnJlbnQgbG9jYWxlIGZvciB0aGUgdmFsaWRhdG9yLlxyXG4gICAqL1xyXG4gIFZhbGlkYXRvci5sb2NhbGl6ZSA9IGZ1bmN0aW9uIGxvY2FsaXplIChsYW5nLCBkaWN0aW9uYXJ5KSB7XG4gICAgICB2YXIgb2JqO1xuXHJcbiAgICBpZiAoaXNPYmplY3QobGFuZykpIHtcclxuICAgICAgVmVlVmFsaWRhdGUkMS5pMThuRHJpdmVyLm1lcmdlKGxhbmcpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWVyZ2UgdGhlIGRpY3Rpb25hcnkuXHJcbiAgICBpZiAoZGljdGlvbmFyeSkge1xyXG4gICAgICB2YXIgbG9jYWxlID0gbGFuZyB8fCBkaWN0aW9uYXJ5Lm5hbWU7XHJcbiAgICAgIGRpY3Rpb25hcnkgPSBhc3NpZ24oe30sIGRpY3Rpb25hcnkpO1xyXG4gICAgICBWZWVWYWxpZGF0ZSQxLmkxOG5Ecml2ZXIubWVyZ2UoKCBvYmogPSB7fSwgb2JqW2xvY2FsZV0gPSBkaWN0aW9uYXJ5LCBvYmogKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxhbmcpIHtcclxuICAgICAgLy8gc2V0IHRoZSBsb2NhbGUuXHJcbiAgICAgIFZhbGlkYXRvci5sb2NhbGUgPSBsYW5nO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyBhIGZpZWxkIHRvIGJlIHZhbGlkYXRlZC5cclxuICAgKi9cclxuICBWYWxpZGF0b3IucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIGF0dGFjaCAoZmllbGRPcHRzKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgLy8gV2Ugc2VhcmNoIGZvciBhIGZpZWxkIHdpdGggdGhlIHNhbWUgbmFtZSAmIHNjb3BlLCBoYXZpbmcgcGVyc2lzdCBlbmFibGVkXHJcbiAgICB2YXIgb2xkRmllbGRNYXRjaGVyID0geyBuYW1lOiBmaWVsZE9wdHMubmFtZSwgc2NvcGU6IGZpZWxkT3B0cy5zY29wZSwgcGVyc2lzdDogdHJ1ZSB9O1xyXG4gICAgdmFyIG9sZEZpZWxkID0gZmllbGRPcHRzLnBlcnNpc3QgPyB0aGlzLmZpZWxkcy5maW5kKG9sZEZpZWxkTWF0Y2hlcikgOiBudWxsO1xyXG5cclxuICAgIGlmIChvbGRGaWVsZCkge1xyXG4gICAgICAvLyBXZSBrZWVwIHRoZSBmbGFncyBvZiB0aGUgb2xkIGZpZWxkLCB0aGVuIHdlIHJlbW92ZSBpdHMgaW5zdGFuY2VcclxuICAgICAgZmllbGRPcHRzLmZsYWdzID0gb2xkRmllbGQuZmxhZ3M7XHJcbiAgICAgIG9sZEZpZWxkLmRlc3Ryb3koKTtcclxuICAgICAgdGhpcy5maWVsZHMucmVtb3ZlKG9sZEZpZWxkKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmaXhlcyBpbml0aWFsIHZhbHVlIGRldGVjdGlvbiB3aXRoIHYtbW9kZWwgYW5kIHNlbGVjdCBlbGVtZW50cy5cclxuICAgIHZhciB2YWx1ZSA9IGZpZWxkT3B0cy5pbml0aWFsVmFsdWU7XHJcbiAgICB2YXIgZmllbGQgPSBuZXcgRmllbGQoZmllbGRPcHRzKTtcclxuICAgIHRoaXMuZmllbGRzLnB1c2goZmllbGQpO1xyXG5cclxuICAgIC8vIHZhbGlkYXRlIHRoZSBmaWVsZCBpbml0aWFsbHlcclxuICAgIGlmIChmaWVsZC5pbW1lZGlhdGUpIHtcclxuICAgICAgVmVlVmFsaWRhdGUkMS5pbnN0YW5jZS5fdm0uJG5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS52YWxpZGF0ZSgoXCIjXCIgKyAoZmllbGQuaWQpKSwgdmFsdWUgfHwgZmllbGQudmFsdWUsIHsgdm1JZDogZmllbGRPcHRzLnZtSWQgfSk7IH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fdmFsaWRhdGUoZmllbGQsIHZhbHVlIHx8IGZpZWxkLnZhbHVlLCB7IGluaXRpYWw6IHRydWUgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgZmllbGQuZmxhZ3MudmFsaWQgPSByZXN1bHQudmFsaWQ7XHJcbiAgICAgICAgZmllbGQuZmxhZ3MuaW52YWxpZCA9ICFyZXN1bHQudmFsaWQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmaWVsZDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBmbGFncyBvbiBhIGZpZWxkLlxyXG4gICAqL1xyXG4gIFZhbGlkYXRvci5wcm90b3R5cGUuZmxhZyA9IGZ1bmN0aW9uIGZsYWcgKG5hbWUsIGZsYWdzLCB1aWQpIHtcbiAgICAgIGlmICggdWlkID09PSB2b2lkIDAgKSB1aWQgPSBudWxsO1xuXHJcbiAgICB2YXIgZmllbGQgPSB0aGlzLl9yZXNvbHZlRmllbGQobmFtZSwgdW5kZWZpbmVkLCB1aWQpO1xyXG4gICAgaWYgKCFmaWVsZCB8fCAhZmxhZ3MpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGZpZWxkLnNldEZsYWdzKGZsYWdzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGEgZmllbGQgZnJvbSB0aGUgdmFsaWRhdG9yLlxyXG4gICAqL1xyXG4gIFZhbGlkYXRvci5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoIChuYW1lLCBzY29wZSwgdWlkKSB7XHJcbiAgICB2YXIgZmllbGQgPSBpc0NhbGxhYmxlKG5hbWUuZGVzdHJveSkgPyBuYW1lIDogdGhpcy5fcmVzb2x2ZUZpZWxkKG5hbWUsIHNjb3BlLCB1aWQpO1xyXG4gICAgaWYgKCFmaWVsZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAvLyBXZSBkZXN0cm95L3JlbW92ZSB0aGUgZmllbGQgJiBlcnJvciBpbnN0YW5jZXMgaWYgaXQncyBub3QgYSBgcGVyc2lzdGAgb25lXHJcbiAgICBpZiAoIWZpZWxkLnBlcnNpc3QpIHtcclxuICAgICAgZmllbGQuZGVzdHJveSgpO1xyXG4gICAgICB0aGlzLmVycm9ycy5yZW1vdmUoZmllbGQubmFtZSwgZmllbGQuc2NvcGUsIGZpZWxkLnZtSWQpO1xyXG4gICAgICB0aGlzLmZpZWxkcy5yZW1vdmUoZmllbGQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBjdXN0b20gdmFsaWRhdG9yIHRvIHRoZSBsaXN0IG9mIHZhbGlkYXRpb24gcnVsZXMuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKG5hbWUsIHZhbGlkYXRvciwgb3B0aW9ucykge1xuICAgICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cclxuICAgIFZhbGlkYXRvci5leHRlbmQobmFtZSwgdmFsaWRhdG9yLCBvcHRpb25zKTtcclxuICB9O1xyXG5cclxuICBWYWxpZGF0b3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKG1hdGNoZXIpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICAvLyB0d28gdGlja3NcclxuICAgIHJldHVybiBWZWVWYWxpZGF0ZSQxLmluc3RhbmNlLl92bS4kbmV4dFRpY2soKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIFZlZVZhbGlkYXRlJDEuaW5zdGFuY2UuX3ZtLiRuZXh0VGljaygpO1xyXG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMkMS5maWVsZHMuZmlsdGVyKG1hdGNoZXIpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XHJcbiAgICAgICAgZmllbGQud2FpdEZvcihudWxsKTtcclxuICAgICAgICBmaWVsZC5yZXNldCgpOyAvLyByZXNldCBmaWVsZCBmbGFncy5cclxuICAgICAgICB0aGlzJDEuZXJyb3JzLnJlbW92ZShmaWVsZC5uYW1lLCBmaWVsZC5zY29wZSwgbWF0Y2hlciAmJiBtYXRjaGVyLnZtSWQpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgYSBmaWVsZCwgdXBkYXRpbmcgYm90aCBlcnJvcnMgYW5kIGZsYWdzLlxyXG4gICAqL1xyXG4gIFZhbGlkYXRvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChpZCwgcmVmKSB7XG4gICAgICB2YXIgc2NvcGUgPSByZWYuc2NvcGU7XG5cclxuICAgIHZhciBmaWVsZCA9IHRoaXMuX3Jlc29sdmVGaWVsZCgoXCIjXCIgKyBpZCkpO1xyXG4gICAgaWYgKCFmaWVsZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAvLyByZW1vdmUgb2xkIHNjb3BlLlxyXG4gICAgdGhpcy5lcnJvcnMudXBkYXRlKGlkLCB7IHNjb3BlOiBzY29wZSB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGEgcnVsZSBmcm9tIHRoZSBsaXN0IG9mIHZhbGlkYXRvcnMuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKG5hbWUpIHtcclxuICAgIFZhbGlkYXRvci5yZW1vdmUobmFtZSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGVzIGEgdmFsdWUgYWdhaW5zdCBhIHJlZ2lzdGVyZWQgZmllbGQgdmFsaWRhdGlvbnMuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlIChmaWVsZERlc2NyaXB0b3IsIHZhbHVlLCByZWYpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICAgICAgdmFyIHNpbGVudCA9IHJlZi5zaWxlbnQ7XG4gICAgICB2YXIgdm1JZCA9IHJlZi52bUlkO1xuXHJcbiAgICBpZiAodGhpcy5wYXVzZWQpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTsgfVxyXG5cclxuICAgIC8vIG92ZXJsb2FkIHRvIHZhbGlkYXRlIGFsbC5cclxuICAgIGlmIChpc051bGxPclVuZGVmaW5lZChmaWVsZERlc2NyaXB0b3IpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU2NvcGVzKHsgc2lsZW50OiBzaWxlbnQsIHZtSWQ6IHZtSWQgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gb3ZlcmxvYWQgdG8gdmFsaWRhdGUgc2NvcGUtbGVzcyBmaWVsZHMuXHJcbiAgICBpZiAoZmllbGREZXNjcmlwdG9yID09PSAnKicpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBbGwodW5kZWZpbmVkLCB7IHNpbGVudDogc2lsZW50LCB2bUlkOiB2bUlkIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHNjb3BlIHZhbGlkYXRpb24gd2FzIHJlcXVlc3RlZC5cclxuICAgIGlmICgvXiguKylcXC5cXCokLy50ZXN0KGZpZWxkRGVzY3JpcHRvcikpIHtcclxuICAgICAgdmFyIG1hdGNoZWQgPSBmaWVsZERlc2NyaXB0b3IubWF0Y2goL14oLispXFwuXFwqJC8pWzFdO1xyXG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUFsbChtYXRjaGVkKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZmllbGQgPSB0aGlzLl9yZXNvbHZlRmllbGQoZmllbGREZXNjcmlwdG9yKTtcclxuICAgIGlmICghZmllbGQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUZpZWxkTm90Rm91bmQobmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzaWxlbnQpIHsgZmllbGQuZmxhZ3MucGVuZGluZyA9IHRydWU7IH1cclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHZhbGlkYXRpb25Qcm9taXNlID0gdGhpcy5fdmFsaWRhdGUoZmllbGQsIHZhbHVlKTtcclxuICAgIGZpZWxkLndhaXRGb3IodmFsaWRhdGlvblByb21pc2UpO1xyXG5cclxuICAgIHJldHVybiB2YWxpZGF0aW9uUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgaWYgKCFzaWxlbnQgJiYgZmllbGQuaXNXYWl0aW5nRm9yKHZhbGlkYXRpb25Qcm9taXNlKSkge1xyXG4gICAgICAgIC8vIGFsbG93IG5leHQgdmFsaWRhdGlvbiB0byBtdXRhdGUgdGhlIHN0YXRlLlxyXG4gICAgICAgIGZpZWxkLndhaXRGb3IobnVsbCk7XHJcbiAgICAgICAgdGhpcyQxLl9oYW5kbGVWYWxpZGF0aW9uUmVzdWx0cyhbcmVzdWx0XSwgdm1JZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQudmFsaWQ7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBQYXVzZXMgdGhlIHZhbGlkYXRvci5cclxuICAgKi9cclxuICBWYWxpZGF0b3IucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UgKCkge1xyXG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3VtZXMgdGhlIHZhbGlkYXRvci5cclxuICAgKi9cclxuICBWYWxpZGF0b3IucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSAoKSB7XHJcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlcyBlYWNoIHZhbHVlIGFnYWluc3QgdGhlIGNvcnJlc3BvbmRpbmcgZmllbGQgdmFsaWRhdGlvbnMuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZUFsbCA9IGZ1bmN0aW9uIHZhbGlkYXRlQWxsICh2YWx1ZXMkJDEsIHJlZikge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gICAgICB2YXIgc2lsZW50ID0gcmVmLnNpbGVudDtcbiAgICAgIHZhciB2bUlkID0gcmVmLnZtSWQ7XG5cclxuICAgIGlmICh0aGlzLnBhdXNlZCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpOyB9XHJcblxyXG4gICAgdmFyIG1hdGNoZXIgPSBudWxsO1xyXG4gICAgdmFyIHByb3ZpZGVkVmFsdWVzID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZXMkJDEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIG1hdGNoZXIgPSB7IHNjb3BlOiB2YWx1ZXMkJDEsIHZtSWQ6IHZtSWQgfTtcclxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVzJCQxKSkge1xyXG4gICAgICBtYXRjaGVyID0gT2JqZWN0LmtleXModmFsdWVzJCQxKS5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiB7IG5hbWU6IGtleSwgdm1JZDogdm1JZCwgc2NvcGU6IG51bGwgfTtcclxuICAgICAgfSk7XHJcbiAgICAgIHByb3ZpZGVkVmFsdWVzID0gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMkJDEpKSB7XHJcbiAgICAgIG1hdGNoZXIgPSB2YWx1ZXMkJDEubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4geyBuYW1lOiBrZXksIHZtSWQ6IHZtSWQgfTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtYXRjaGVyID0geyBzY29wZTogbnVsbCwgdm1JZDogdm1JZCB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLmFsbChcclxuICAgICAgdGhpcy5maWVsZHMuZmlsdGVyKG1hdGNoZXIpLm1hcChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIHRoaXMkMS5fdmFsaWRhdGUoZmllbGQsIHByb3ZpZGVkVmFsdWVzID8gdmFsdWVzJCQxW2ZpZWxkLm5hbWVdIDogZmllbGQudmFsdWUpOyB9KVxyXG4gICAgKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XHJcbiAgICAgIGlmICghc2lsZW50KSB7XHJcbiAgICAgICAgdGhpcyQxLl9oYW5kbGVWYWxpZGF0aW9uUmVzdWx0cyhyZXN1bHRzLCB2bUlkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdHMuZXZlcnkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudmFsaWQ7IH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGVzIGFsbCBzY29wZXMuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZVNjb3BlcyA9IGZ1bmN0aW9uIHZhbGlkYXRlU2NvcGVzIChyZWYpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICAgICAgdmFyIHNpbGVudCA9IHJlZi5zaWxlbnQ7XG4gICAgICB2YXIgdm1JZCA9IHJlZi52bUlkO1xuXHJcbiAgICBpZiAodGhpcy5wYXVzZWQpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTsgfVxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLmFsbChcclxuICAgICAgdGhpcy5maWVsZHMuZmlsdGVyKHsgdm1JZDogdm1JZCB9KS5tYXAoZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiB0aGlzJDEuX3ZhbGlkYXRlKGZpZWxkLCBmaWVsZC52YWx1ZSk7IH0pXHJcbiAgICApLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgaWYgKCFzaWxlbnQpIHtcclxuICAgICAgICB0aGlzJDEuX2hhbmRsZVZhbGlkYXRpb25SZXN1bHRzKHJlc3VsdHMsIHZtSWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0cy5ldmVyeShmdW5jdGlvbiAodCkgeyByZXR1cm4gdC52YWxpZDsgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBWYWxpZGF0ZXMgYSB2YWx1ZSBhZ2FpbnN0IHRoZSBydWxlcy5cclxuICAgKi9cclxuICBWYWxpZGF0b3IucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeSAodmFsdWUsIHJ1bGVzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxyXG4gICAgdmFyIGZpZWxkID0ge1xyXG4gICAgICBuYW1lOiAob3B0aW9ucyAmJiBvcHRpb25zLm5hbWUpIHx8ICd7ZmllbGR9JyxcclxuICAgICAgcnVsZXM6IG5vcm1hbGl6ZVJ1bGVzKHJ1bGVzKSxcclxuICAgICAgYmFpbHM6IGdldFBhdGgoJ2JhaWxzJywgb3B0aW9ucywgdHJ1ZSksXHJcbiAgICAgIGZvcmNlUmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgICBnZXQgaXNSZXF1aXJlZCAoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5ydWxlcy5yZXF1aXJlZCB8fCB0aGlzLmZvcmNlUmVxdWlyZWQ7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHRhcmdldFJ1bGVzID0gT2JqZWN0LmtleXMoZmllbGQucnVsZXMpLmZpbHRlcihWYWxpZGF0b3IuaXNUYXJnZXRSdWxlKTtcclxuICAgIGlmICh0YXJnZXRSdWxlcy5sZW5ndGggJiYgb3B0aW9ucyAmJiBpc09iamVjdChvcHRpb25zLnZhbHVlcykpIHtcclxuICAgICAgZmllbGQuZGVwZW5kZW5jaWVzID0gdGFyZ2V0UnVsZXMubWFwKGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgdmFyIHJlZiA9IGZpZWxkLnJ1bGVzW3J1bGVdO1xuICAgICAgICAgIHZhciB0YXJnZXRLZXkgPSByZWZbMF07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBuYW1lOiBydWxlLFxyXG4gICAgICAgICAgZmllbGQ6IHsgdmFsdWU6IG9wdGlvbnMudmFsdWVzW3RhcmdldEtleV0gfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZShmaWVsZCwgdmFsdWUpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICByZXR1cm4geyB2YWxpZDogcmVzdWx0LnZhbGlkLCBlcnJvcnM6IHJlc3VsdC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLm1zZzsgfSkgfTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm0gY2xlYW51cC5cclxuICAgKi9cclxuICBWYWxpZGF0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcclxuICAgIFZlZVZhbGlkYXRlJDEuaW5zdGFuY2UuX3ZtLiRvZmYoJ2xvY2FsZUNoYW5nZWQnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIHRoZSBmaWVsZHMgdG8gYmUgdmFsaWRhdGVkLlxyXG4gICAqL1xyXG4gIFZhbGlkYXRvci5wcm90b3R5cGUuX2NyZWF0ZUZpZWxkcyA9IGZ1bmN0aW9uIF9jcmVhdGVGaWVsZHMgKHZhbGlkYXRpb25zKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgaWYgKCF2YWxpZGF0aW9ucykgeyByZXR1cm47IH1cclxuXHJcbiAgICBPYmplY3Qua2V5cyh2YWxpZGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcclxuICAgICAgdmFyIG9wdGlvbnMgPSBhc3NpZ24oe30sIHsgbmFtZTogZmllbGQsIHJ1bGVzOiB2YWxpZGF0aW9uc1tmaWVsZF0gfSk7XHJcbiAgICAgIHRoaXMkMS5hdHRhY2gob3B0aW9ucyk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBEYXRlIHJ1bGVzIG5lZWQgdGhlIGV4aXN0ZW5jZSBvZiBhIGZvcm1hdCwgc28gZGF0ZV9mb3JtYXQgbXVzdCBiZSBzdXBwbGllZC5cclxuICAgKi9cclxuICBWYWxpZGF0b3IucHJvdG90eXBlLl9nZXREYXRlRm9ybWF0ID0gZnVuY3Rpb24gX2dldERhdGVGb3JtYXQgKHZhbGlkYXRpb25zKSB7XHJcbiAgICB2YXIgZm9ybWF0ID0gbnVsbDtcclxuICAgIGlmICh2YWxpZGF0aW9ucy5kYXRlX2Zvcm1hdCAmJiBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25zLmRhdGVfZm9ybWF0KSkge1xyXG4gICAgICBmb3JtYXQgPSB2YWxpZGF0aW9ucy5kYXRlX2Zvcm1hdFswXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZm9ybWF0IHx8IFZlZVZhbGlkYXRlJDEuaTE4bkRyaXZlci5nZXREYXRlRm9ybWF0KHRoaXMubG9jYWxlKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBGb3JtYXRzIGFuIGVycm9yIG1lc3NhZ2UgZm9yIGZpZWxkIGFuZCBhIHJ1bGUuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS5fZm9ybWF0RXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gX2Zvcm1hdEVycm9yTWVzc2FnZSAoZmllbGQsIHJ1bGUsIGRhdGEsIHRhcmdldE5hbWUpIHtcbiAgICAgIGlmICggZGF0YSA9PT0gdm9pZCAwICkgZGF0YSA9IHt9O1xuICAgICAgaWYgKCB0YXJnZXROYW1lID09PSB2b2lkIDAgKSB0YXJnZXROYW1lID0gbnVsbDtcblxyXG4gICAgdmFyIG5hbWUgPSB0aGlzLl9nZXRGaWVsZERpc3BsYXlOYW1lKGZpZWxkKTtcclxuICAgIHZhciBwYXJhbXMgPSB0aGlzLl9nZXRMb2NhbGl6ZWRQYXJhbXMocnVsZSwgdGFyZ2V0TmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIFZlZVZhbGlkYXRlJDEuaTE4bkRyaXZlci5nZXRGaWVsZE1lc3NhZ2UodGhpcy5sb2NhbGUsIGZpZWxkLm5hbWUsIHJ1bGUubmFtZSwgW25hbWUsIHBhcmFtcywgZGF0YV0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFdlIG5lZWQgdG8gY29udmVydCBhbnkgb2JqZWN0IHBhcmFtIHRvIGFuIGFycmF5IGZvcm1hdCBzaW5jZSB0aGUgbG9jYWxlcyBkbyBub3QgaGFuZGxlIHBhcmFtcyBhcyBvYmplY3RzIHlldC5cclxuICAgKi9cclxuICBWYWxpZGF0b3IucHJvdG90eXBlLl9jb252ZXJ0UGFyYW1PYmplY3RUb0FycmF5ID0gZnVuY3Rpb24gX2NvbnZlcnRQYXJhbU9iamVjdFRvQXJyYXkgKG9iaiwgcnVsZU5hbWUpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFyYW1OYW1lcyA9IFJ1bGVDb250YWluZXIuZ2V0UGFyYW1OYW1lcyhydWxlTmFtZSk7XHJcbiAgICBpZiAoIXBhcmFtTmFtZXMgfHwgIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyYW1OYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHBhcmFtTmFtZSkge1xyXG4gICAgICBpZiAocGFyYW1OYW1lIGluIG9iaikge1xyXG4gICAgICAgIHByZXYucHVzaChvYmpbcGFyYW1OYW1lXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgfSwgW10pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zbGF0ZXMgdGhlIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHRoZSBydWxlIChtYWlubHkgZm9yIHRhcmdldCBmaWVsZHMpLlxyXG4gICAqL1xyXG4gIFZhbGlkYXRvci5wcm90b3R5cGUuX2dldExvY2FsaXplZFBhcmFtcyA9IGZ1bmN0aW9uIF9nZXRMb2NhbGl6ZWRQYXJhbXMgKHJ1bGUsIHRhcmdldE5hbWUpIHtcbiAgICAgIGlmICggdGFyZ2V0TmFtZSA9PT0gdm9pZCAwICkgdGFyZ2V0TmFtZSA9IG51bGw7XG5cclxuICAgIHZhciBwYXJhbXMgPSB0aGlzLl9jb252ZXJ0UGFyYW1PYmplY3RUb0FycmF5KHJ1bGUucGFyYW1zLCBydWxlLm5hbWUpO1xyXG4gICAgaWYgKHJ1bGUub3B0aW9ucy5oYXNUYXJnZXQgJiYgcGFyYW1zICYmIHBhcmFtc1swXSkge1xyXG4gICAgICB2YXIgbG9jYWxpemVkTmFtZSA9IHRhcmdldE5hbWUgfHwgVmVlVmFsaWRhdGUkMS5pMThuRHJpdmVyLmdldEF0dHJpYnV0ZSh0aGlzLmxvY2FsZSwgcGFyYW1zWzBdLCBwYXJhbXNbMF0pO1xyXG4gICAgICByZXR1cm4gW2xvY2FsaXplZE5hbWVdLmNvbmNhdChwYXJhbXMuc2xpY2UoMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJhbXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzb2x2ZXMgYW4gYXBwcm9wcmlhdGUgZGlzcGxheSBuYW1lLCBmaXJzdCBjaGVja2luZyAnZGF0YS1hcycgb3IgdGhlIHJlZ2lzdGVyZWQgJ3ByZXR0eU5hbWUnXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS5fZ2V0RmllbGREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIF9nZXRGaWVsZERpc3BsYXlOYW1lIChmaWVsZCkge1xyXG4gICAgcmV0dXJuIGZpZWxkLmFsaWFzIHx8IFZlZVZhbGlkYXRlJDEuaTE4bkRyaXZlci5nZXRBdHRyaWJ1dGUodGhpcy5sb2NhbGUsIGZpZWxkLm5hbWUsIGZpZWxkLm5hbWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIGFuIGFycmF5IG9mIHBhcmFtcyB0byBhbiBvYmplY3Qgd2l0aCBuYW1lZCBwcm9wZXJ0aWVzLlxyXG4gICAqIE9ubHkgd29ya3MgaWYgdGhlIHJ1bGUgaXMgY29uZmlndXJlZCB3aXRoIGEgcGFyYW1OYW1lcyBhcnJheS5cclxuICAgKiBSZXR1cm5zIHRoZSBzYW1lIHBhcmFtcyBpZiBpdCBjYW5ub3QgY29udmVydCBpdC5cclxuICAgKi9cclxuICBWYWxpZGF0b3IucHJvdG90eXBlLl9jb252ZXJ0UGFyYW1BcnJheVRvT2JqID0gZnVuY3Rpb24gX2NvbnZlcnRQYXJhbUFycmF5VG9PYmogKHBhcmFtcywgcnVsZU5hbWUpIHtcclxuICAgIHZhciBwYXJhbU5hbWVzID0gUnVsZUNvbnRhaW5lci5nZXRQYXJhbU5hbWVzKHJ1bGVOYW1lKTtcclxuICAgIGlmICghcGFyYW1OYW1lcykge1xyXG4gICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc09iamVjdChwYXJhbXMpKSB7XHJcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBvYmplY3QgaXMgZWl0aGVyIGEgY29uZmlnIG9iamVjdCBvciBhIHNpbmdsZSBwYXJhbWV0ZXIgdGhhdCBpcyBhbiBvYmplY3QuXHJcbiAgICAgIHZhciBoYXNLZXlzID0gcGFyYW1OYW1lcy5zb21lKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpLmluZGV4T2YobmFtZSkgIT09IC0xOyB9KTtcclxuICAgICAgLy8gaWYgaXQgaGFzIHNvbWUgb2YgdGhlIGtleXMsIHJldHVybiBpdCBhcyBpcy5cclxuICAgICAgaWYgKGhhc0tleXMpIHtcclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIG90aGVyd2lzZSB3cmFwIHRoZSBvYmplY3QgaW4gYW4gYXJyYXkuXHJcbiAgICAgIHBhcmFtcyA9IFtwYXJhbXNdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlZHVjZSB0aGUgcGFyYW1zTmFtZXMgdG8gYSBwYXJhbSBvYmplY3QuXHJcbiAgICByZXR1cm4gcGFyYW1zLnJlZHVjZShmdW5jdGlvbiAocHJldiwgdmFsdWUsIGlkeCkge1xyXG4gICAgICBwcmV2W3BhcmFtTmFtZXNbaWR4XV0gPSB2YWx1ZTtcclxuXHJcbiAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgfSwge30pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRlc3RzIGEgc2luZ2xlIGlucHV0IHZhbHVlIGFnYWluc3QgYSBydWxlLlxyXG4gICAqL1xyXG4gIFZhbGlkYXRvci5wcm90b3R5cGUuX3Rlc3QgPSBmdW5jdGlvbiBfdGVzdCAoZmllbGQsIHZhbHVlLCBydWxlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgdmFyIHZhbGlkYXRvciA9IFJ1bGVDb250YWluZXIuZ2V0VmFsaWRhdG9yTWV0aG9kKHJ1bGUubmFtZSk7XHJcbiAgICB2YXIgcGFyYW1zID0gQXJyYXkuaXNBcnJheShydWxlLnBhcmFtcykgPyB0b0FycmF5KHJ1bGUucGFyYW1zKSA6IHJ1bGUucGFyYW1zO1xyXG4gICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgcGFyYW1zID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRhcmdldE5hbWUgPSBudWxsO1xyXG4gICAgaWYgKCF2YWxpZGF0b3IgfHwgdHlwZW9mIHZhbGlkYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY3JlYXRlRXJyb3IoKFwiTm8gc3VjaCB2YWxpZGF0b3IgJ1wiICsgKHJ1bGUubmFtZSkgKyBcIicgZXhpc3RzLlwiKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGhhcyBmaWVsZCBkZXBlbmRlbmNpZXMuXHJcbiAgICBpZiAocnVsZS5vcHRpb25zLmhhc1RhcmdldCAmJiBmaWVsZC5kZXBlbmRlbmNpZXMpIHtcclxuICAgICAgdmFyIHRhcmdldCA9IGZpbmQoZmllbGQuZGVwZW5kZW5jaWVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSBydWxlLm5hbWU7IH0pO1xyXG4gICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0TmFtZSA9IHRhcmdldC5maWVsZC5hbGlhcztcclxuICAgICAgICBwYXJhbXMgPSBbdGFyZ2V0LmZpZWxkLnZhbHVlXS5jb25jYXQocGFyYW1zLnNsaWNlKDEpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChydWxlLm5hbWUgPT09ICdyZXF1aXJlZCcgJiYgZmllbGQucmVqZWN0c0ZhbHNlKSB7XHJcbiAgICAgIC8vIGludmFsaWRhdGUgZmFsc2UgaWYgbm8gYXJncyB3ZXJlIHNwZWNpZmllZCBhbmQgdGhlIGZpZWxkIHJlamVjdHMgZmFsc2UgYnkgZGVmYXVsdC5cclxuICAgICAgcGFyYW1zID0gcGFyYW1zLmxlbmd0aCA/IHBhcmFtcyA6IFt0cnVlXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocnVsZS5vcHRpb25zLmlzRGF0ZSkge1xyXG4gICAgICB2YXIgZGF0ZUZvcm1hdCA9IHRoaXMuX2dldERhdGVGb3JtYXQoZmllbGQucnVsZXMpO1xyXG4gICAgICBpZiAocnVsZS5uYW1lICE9PSAnZGF0ZV9mb3JtYXQnKSB7XHJcbiAgICAgICAgcGFyYW1zLnB1c2goZGF0ZUZvcm1hdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCB0aGlzLl9jb252ZXJ0UGFyYW1BcnJheVRvT2JqKHBhcmFtcywgcnVsZS5uYW1lKSk7XHJcblxyXG4gICAgLy8gSWYgaXQgaXMgYSBwcm9taXNlLlxyXG4gICAgaWYgKGlzQ2FsbGFibGUocmVzdWx0LnRoZW4pKSB7XHJcbiAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAodmFsdWVzJCQxKSB7XHJcbiAgICAgICAgdmFyIGFsbFZhbGlkID0gdHJ1ZTtcclxuICAgICAgICB2YXIgZGF0YSA9IHt9O1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcyQkMSkpIHtcclxuICAgICAgICAgIGFsbFZhbGlkID0gdmFsdWVzJCQxLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7IHJldHVybiAoaXNPYmplY3QodCkgPyB0LnZhbGlkIDogdCk7IH0pO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIElzIGEgc2luZ2xlIG9iamVjdC9ib29sZWFuLlxyXG4gICAgICAgICAgYWxsVmFsaWQgPSBpc09iamVjdCh2YWx1ZXMkJDEpID8gdmFsdWVzJCQxLnZhbGlkIDogdmFsdWVzJCQxO1xyXG4gICAgICAgICAgZGF0YSA9IHZhbHVlcyQkMS5kYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHZhbGlkOiBhbGxWYWxpZCxcclxuICAgICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxyXG4gICAgICAgICAgZXJyb3JzOiBhbGxWYWxpZCA/IFtdIDogW3RoaXMkMS5fY3JlYXRlRmllbGRFcnJvcihmaWVsZCwgcnVsZSwgZGF0YSwgdGFyZ2V0TmFtZSldXHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc09iamVjdChyZXN1bHQpKSB7XHJcbiAgICAgIHJlc3VsdCA9IHsgdmFsaWQ6IHJlc3VsdCwgZGF0YToge30gfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB2YWxpZDogcmVzdWx0LnZhbGlkLFxyXG4gICAgICBkYXRhOiByZXN1bHQuZGF0YSxcclxuICAgICAgZXJyb3JzOiByZXN1bHQudmFsaWQgPyBbXSA6IFt0aGlzLl9jcmVhdGVGaWVsZEVycm9yKGZpZWxkLCBydWxlLCByZXN1bHQuZGF0YSwgdGFyZ2V0TmFtZSldXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlcyBhIHZhbGlkYXRvciBvYmplY3QgaW50byB0aGUgUlVMRVMgYW5kIE1lc3NhZ2VzLlxyXG4gICAqL1xyXG4gIFZhbGlkYXRvci5fbWVyZ2UgPSBmdW5jdGlvbiBfbWVyZ2UgKG5hbWUsIHJlZikge1xuICAgICAgdmFyIHZhbGlkYXRvciA9IHJlZi52YWxpZGF0b3I7XG4gICAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuICAgICAgdmFyIHBhcmFtTmFtZXMgPSByZWYucGFyYW1OYW1lcztcblxyXG4gICAgdmFyIHZhbGlkYXRlID0gaXNDYWxsYWJsZSh2YWxpZGF0b3IpID8gdmFsaWRhdG9yIDogdmFsaWRhdG9yLnZhbGlkYXRlO1xyXG4gICAgaWYgKHZhbGlkYXRvci5nZXRNZXNzYWdlKSB7XHJcbiAgICAgIFZlZVZhbGlkYXRlJDEuaTE4bkRyaXZlci5zZXRNZXNzYWdlKFZhbGlkYXRvci5sb2NhbGUsIG5hbWUsIHZhbGlkYXRvci5nZXRNZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICBSdWxlQ29udGFpbmVyLmFkZChuYW1lLCB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSxcclxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcclxuICAgICAgcGFyYW1OYW1lczogcGFyYW1OYW1lc1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR3VhcmRzIGZyb20gZXh0ZW5zaW9uIHZpb2xhdGlvbnMuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLl9ndWFyZEV4dGVuZCA9IGZ1bmN0aW9uIF9ndWFyZEV4dGVuZCAobmFtZSwgdmFsaWRhdG9yKSB7XHJcbiAgICBpZiAoaXNDYWxsYWJsZSh2YWxpZGF0b3IpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzQ2FsbGFibGUodmFsaWRhdG9yLnZhbGlkYXRlKSkge1xyXG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcihcclxuICAgICAgICAoXCJFeHRlbnNpb24gRXJyb3I6IFRoZSB2YWxpZGF0b3IgJ1wiICsgbmFtZSArIFwiJyBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgaGF2ZSBhICd2YWxpZGF0ZScgbWV0aG9kLlwiKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBGaWVsZCBFcnJvciBPYmplY3QuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlRmllbGRFcnJvciA9IGZ1bmN0aW9uIF9jcmVhdGVGaWVsZEVycm9yIChmaWVsZCwgcnVsZSwgZGF0YSwgdGFyZ2V0TmFtZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiBmaWVsZC5pZCxcclxuICAgICAgdm1JZDogZmllbGQudm1JZCxcclxuICAgICAgZmllbGQ6IGZpZWxkLm5hbWUsXHJcbiAgICAgIG1zZzogdGhpcy5fZm9ybWF0RXJyb3JNZXNzYWdlKGZpZWxkLCBydWxlLCBkYXRhLCB0YXJnZXROYW1lKSxcclxuICAgICAgcnVsZTogcnVsZS5uYW1lLFxyXG4gICAgICBzY29wZTogZmllbGQuc2NvcGUsXHJcbiAgICAgIHJlZ2VuZXJhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyQxLl9mb3JtYXRFcnJvck1lc3NhZ2UoZmllbGQsIHJ1bGUsIGRhdGEsIHRhcmdldE5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWVzIGRpZmZlcmVudCBzdHJhdGVnaWVzIHRvIGZpbmQgYSBmaWVsZC5cclxuICAgKi9cclxuICBWYWxpZGF0b3IucHJvdG90eXBlLl9yZXNvbHZlRmllbGQgPSBmdW5jdGlvbiBfcmVzb2x2ZUZpZWxkIChuYW1lLCBzY29wZSwgdWlkKSB7XHJcbiAgICBpZiAobmFtZVswXSA9PT0gJyMnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpZWxkcy5maW5kKHsgaWQ6IG5hbWUuc2xpY2UoMSkgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChzY29wZSkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLmZpbmQoeyBuYW1lOiBuYW1lLCBzY29wZTogc2NvcGUsIHZtSWQ6IHVpZCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5jbHVkZXMobmFtZSwgJy4nKSkge1xyXG4gICAgICB2YXIgcmVmID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgZmllbGRTY29wZSA9IHJlZlswXTtcbiAgICAgICAgdmFyIGZpZWxkTmFtZSA9IHJlZi5zbGljZSgxKTtcclxuICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZHMuZmluZCh7IG5hbWU6IGZpZWxkTmFtZS5qb2luKCcuJyksIHNjb3BlOiBmaWVsZFNjb3BlLCB2bUlkOiB1aWQgfSk7XHJcbiAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgIHJldHVybiBmaWVsZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmZpZWxkcy5maW5kKHsgbmFtZTogbmFtZSwgc2NvcGU6IG51bGwsIHZtSWQ6IHVpZCB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIHdoZW4gYSBmaWVsZCBpcyBub3QgZm91bmQuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS5faGFuZGxlRmllbGROb3RGb3VuZCA9IGZ1bmN0aW9uIF9oYW5kbGVGaWVsZE5vdEZvdW5kIChuYW1lLCBzY29wZSkge1xyXG4gICAgdmFyIGZ1bGxOYW1lID0gaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpID8gbmFtZSA6IChcIlwiICsgKCFpc051bGxPclVuZGVmaW5lZChzY29wZSkgPyBzY29wZSArICcuJyA6ICcnKSArIG5hbWUpO1xyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjcmVhdGVFcnJvcihcclxuICAgICAgKFwiVmFsaWRhdGluZyBhIG5vbi1leGlzdGVudCBmaWVsZDogXFxcIlwiICsgZnVsbE5hbWUgKyBcIlxcXCIuIFVzZSBcXFwiYXR0YWNoKClcXFwiIGZpcnN0LlwiKVxyXG4gICAgKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyB2YWxpZGF0aW9uIHJlc3VsdHMuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS5faGFuZGxlVmFsaWRhdGlvblJlc3VsdHMgPSBmdW5jdGlvbiBfaGFuZGxlVmFsaWRhdGlvblJlc3VsdHMgKHJlc3VsdHMsIHZtSWQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICB2YXIgbWF0Y2hlcnMgPSByZXN1bHRzLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiAoeyBpZDogcmVzdWx0LmlkIH0pOyB9KTtcclxuICAgIHRoaXMuZXJyb3JzLnJlbW92ZUJ5SWQobWF0Y2hlcnMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmlkOyB9KSk7XHJcbiAgICAvLyByZW1vdmUgYnkgbmFtZSBhbmQgc2NvcGUgdG8gcmVtb3ZlIGFueSBjdXN0b20gZXJyb3JzIGFkZGVkLlxyXG4gICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgdGhpcyQxLmVycm9ycy5yZW1vdmUocmVzdWx0LmZpZWxkLCByZXN1bHQuc2NvcGUsIHZtSWQpO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgYWxsRXJyb3JzID0gcmVzdWx0cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgcHJldi5wdXNoLmFwcGx5KHByZXYsIGN1cnIuZXJyb3JzKTtcclxuXHJcbiAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHRoaXMuZXJyb3JzLmFkZChhbGxFcnJvcnMpO1xyXG5cclxuICAgIC8vIGhhbmRsZSBmbGFncy5cclxuICAgIHRoaXMuZmllbGRzLmZpbHRlcihtYXRjaGVycykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IGZpbmQocmVzdWx0cywgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuaWQgPT09IGZpZWxkLmlkOyB9KTtcclxuICAgICAgZmllbGQuc2V0RmxhZ3Moe1xyXG4gICAgICAgIHBlbmRpbmc6IGZhbHNlLFxyXG4gICAgICAgIHZhbGlkOiByZXN1bHQudmFsaWQsXHJcbiAgICAgICAgdmFsaWRhdGVkOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS5fc2hvdWxkU2tpcCA9IGZ1bmN0aW9uIF9zaG91bGRTa2lwIChmaWVsZCwgdmFsdWUpIHtcclxuICAgIC8vIGZpZWxkIGlzIGNvbmZpZ3VyZWQgdG8gcnVuIHRocm91Z2ggdGhlIHBpcGVsaW5lIHJlZ2FyZGxlc3NcclxuICAgIGlmIChmaWVsZC5iYWlscyA9PT0gZmFsc2UpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRpc2FibGVkIGZpZWxkcyBhcmUgc2tpcHBlZFxyXG4gICAgaWYgKGZpZWxkLmlzRGlzYWJsZWQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2tpcCBpZiB0aGUgZmllbGQgaXMgbm90IHJlcXVpcmVkIGFuZCBoYXMgYW4gZW1wdHkgdmFsdWUuXHJcbiAgICByZXR1cm4gIWZpZWxkLmlzUmVxdWlyZWQgJiYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycgfHwgaXNFbXB0eUFycmF5KHZhbHVlKSk7XHJcbiAgfTtcclxuXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS5fc2hvdWxkQmFpbCA9IGZ1bmN0aW9uIF9zaG91bGRCYWlsIChmaWVsZCkge1xyXG4gICAgLy8gaWYgdGhlIGZpZWxkIHdhcyBjb25maWd1cmVkIGV4cGxpY2l0bHkuXHJcbiAgICBpZiAoZmllbGQuYmFpbHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZmllbGQuYmFpbHM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZmFzdEV4aXQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnRzIHRoZSB2YWxpZGF0aW9uIHByb2Nlc3MuXHJcbiAgICovXHJcbiAgVmFsaWRhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGUgPSBmdW5jdGlvbiBfdmFsaWRhdGUgKGZpZWxkLCB2YWx1ZSwgcmVmKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgICAgIHZhciBpbml0aWFsID0gcmVmLmluaXRpYWw7XG5cclxuICAgIHZhciByZXF1aXJlUnVsZXMgPSBPYmplY3Qua2V5cyhmaWVsZC5ydWxlcykuZmlsdGVyKFJ1bGVDb250YWluZXIuaXNSZXF1aXJlUnVsZSk7XHJcblxyXG4gICAgZmllbGQuZm9yY2VSZXF1aXJlZCA9IGZhbHNlO1xyXG4gICAgcmVxdWlyZVJ1bGVzLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcclxuICAgICAgdmFyIHJ1bGVPcHRpb25zID0gUnVsZUNvbnRhaW5lci5nZXRPcHRpb25zKHJ1bGUpO1xyXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcyQxLl90ZXN0KGZpZWxkLCB2YWx1ZSwgeyBuYW1lOiBydWxlLCBwYXJhbXM6IGZpZWxkLnJ1bGVzW3J1bGVdLCBvcHRpb25zOiBydWxlT3B0aW9ucyB9KTtcclxuXHJcbiAgICAgIGlmIChpc0NhbGxhYmxlKHJlc3VsdC50aGVuKSkgeyB0aHJvdyBjcmVhdGVFcnJvcignUmVxdWlyZSBydWxlcyBjYW5ub3QgYmUgYXN5bmMnKTsgfVxyXG4gICAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkpIHsgdGhyb3cgY3JlYXRlRXJyb3IoJ1JlcXVpcmUgcnVsZXMgaGFzIHRvIHJldHVybiBhbiBvYmplY3QgKHNlZSBkb2NzKScpOyB9XHJcblxyXG4gICAgICBpZiAocmVzdWx0LmRhdGEucmVxdWlyZWQgPT09IHRydWUpIHtcclxuICAgICAgICBmaWVsZC5mb3JjZVJlcXVpcmVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX3Nob3VsZFNraXAoZmllbGQsIHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsaWQ6IHRydWUsIGlkOiBmaWVsZC5pZCwgZmllbGQ6IGZpZWxkLm5hbWUsIHNjb3BlOiBmaWVsZC5zY29wZSwgZXJyb3JzOiBbXSB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuICAgIHZhciBlcnJvcnMgPSBbXTtcclxuICAgIHZhciBpc0V4aXRFYXJseSA9IGZhbHNlO1xyXG4gICAgLy8gdXNlIG9mICcuc29tZSgpJyBpcyB0byBicmVhayBpdGVyYXRpb24gaW4gbWlkZGxlIGJ5IHJldHVybmluZyB0cnVlXHJcbiAgICBPYmplY3Qua2V5cyhmaWVsZC5ydWxlcykuZmlsdGVyKGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgIGlmICghaW5pdGlhbCB8fCAhUnVsZUNvbnRhaW5lci5oYXMocnVsZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgICAgIHJldHVybiBSdWxlQ29udGFpbmVyLmlzSW1tZWRpYXRlKHJ1bGUpO1xyXG4gICAgfSkuc29tZShmdW5jdGlvbiAocnVsZSkge1xyXG4gICAgICB2YXIgcnVsZU9wdGlvbnMgPSBSdWxlQ29udGFpbmVyLmdldE9wdGlvbnMocnVsZSk7XHJcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzJDEuX3Rlc3QoZmllbGQsIHZhbHVlLCB7IG5hbWU6IHJ1bGUsIHBhcmFtczogZmllbGQucnVsZXNbcnVsZV0sIG9wdGlvbnM6IHJ1bGVPcHRpb25zIH0pO1xyXG4gICAgICBpZiAoaXNDYWxsYWJsZShyZXN1bHQudGhlbikpIHtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXJlc3VsdC52YWxpZCAmJiB0aGlzJDEuX3Nob3VsZEJhaWwoZmllbGQpKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCByZXN1bHQuZXJyb3JzKTtcclxuICAgICAgICBpc0V4aXRFYXJseSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gcHJvbWlzaWZ5IHRoZSByZXN1bHQuXHJcbiAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gcmVzb2x2ZShyZXN1bHQpOyB9KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBpc0V4aXRFYXJseTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChpc0V4aXRFYXJseSkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsaWQ6IGZhbHNlLCBlcnJvcnM6IGVycm9ycywgaWQ6IGZpZWxkLmlkLCBmaWVsZDogZmllbGQubmFtZSwgc2NvcGU6IGZpZWxkLnNjb3BlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xyXG4gICAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHYpIHtcbiAgICAgICAgICB2YXIgcmVmO1xuXHJcbiAgICAgICAgaWYgKCF2LnZhbGlkKSB7XHJcbiAgICAgICAgICAocmVmID0gcHJldi5lcnJvcnMpLnB1c2guYXBwbHkocmVmLCB2LmVycm9ycyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcmV2LnZhbGlkID0gcHJldi52YWxpZCAmJiB2LnZhbGlkO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgfSwgeyB2YWxpZDogdHJ1ZSwgZXJyb3JzOiBlcnJvcnMsIGlkOiBmaWVsZC5pZCwgZmllbGQ6IGZpZWxkLm5hbWUsIHNjb3BlOiBmaWVsZC5zY29wZSB9KTtcclxuICAgIH0pO1xyXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZhbGlkYXRvci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQ0ICk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWYWxpZGF0b3IsIHN0YXRpY0FjY2Vzc29ycyQxICk7XG5cbiAgLy8gXHJcblxyXG4gIHZhciBub3JtYWxpemUgPSBmdW5jdGlvbiAoZmllbGRzKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XHJcbiAgICAgIHJldHVybiBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVzKGN1cnIsICcuJykpIHtcclxuICAgICAgICAgIHByZXZbY3Vyci5zcGxpdCgnLicpWzFdXSA9IGN1cnI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHByZXZbY3Vycl0gPSBjdXJyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICAgIH0sIHt9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmllbGRzO1xyXG4gIH07XHJcblxyXG4gIC8vIENvbWJpbmVzIHR3byBmbGFncyB1c2luZyBlaXRoZXIgQU5EIG9yIE9SIGRlcGVuZGluZyBvbiB0aGUgZmxhZyB0eXBlLlxyXG4gIHZhciBjb21iaW5lID0gZnVuY3Rpb24gKGxocywgcmhzKSB7XHJcbiAgICB2YXIgbWFwcGVyID0ge1xyXG4gICAgICBwcmlzdGluZTogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgJiYgcmhzOyB9LFxyXG4gICAgICBkaXJ0eTogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgfHwgcmhzOyB9LFxyXG4gICAgICB0b3VjaGVkOiBmdW5jdGlvbiAobGhzLCByaHMpIHsgcmV0dXJuIGxocyB8fCByaHM7IH0sXHJcbiAgICAgIHVudG91Y2hlZDogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgJiYgcmhzOyB9LFxyXG4gICAgICB2YWxpZDogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgJiYgcmhzOyB9LFxyXG4gICAgICBpbnZhbGlkOiBmdW5jdGlvbiAobGhzLCByaHMpIHsgcmV0dXJuIGxocyB8fCByaHM7IH0sXHJcbiAgICAgIHBlbmRpbmc6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzIHx8IHJoczsgfSxcclxuICAgICAgcmVxdWlyZWQ6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzIHx8IHJoczsgfSxcclxuICAgICAgdmFsaWRhdGVkOiBmdW5jdGlvbiAobGhzLCByaHMpIHsgcmV0dXJuIGxocyAmJiByaHM7IH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcHBlcikucmVkdWNlKGZ1bmN0aW9uIChmbGFncywgZmxhZykge1xyXG4gICAgICBmbGFnc1tmbGFnXSA9IG1hcHBlcltmbGFnXShsaHNbZmxhZ10sIHJoc1tmbGFnXSk7XHJcblxyXG4gICAgICByZXR1cm4gZmxhZ3M7XHJcbiAgICB9LCB7fSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIG1hcFNjb3BlID0gZnVuY3Rpb24gKHNjb3BlLCBkZWVwKSB7XG4gICAgaWYgKCBkZWVwID09PSB2b2lkIDAgKSBkZWVwID0gdHJ1ZTtcblxyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNjb3BlKS5yZWR1Y2UoZnVuY3Rpb24gKGZsYWdzLCBmaWVsZCkge1xyXG4gICAgICBpZiAoIWZsYWdzKSB7XHJcbiAgICAgICAgZmxhZ3MgPSBhc3NpZ24oe30sIHNjb3BlW2ZpZWxkXSk7XHJcbiAgICAgICAgcmV0dXJuIGZsYWdzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzY29wZS5cclxuICAgICAgdmFyIGlzU2NvcGUgPSBmaWVsZC5pbmRleE9mKCckJykgPT09IDA7XHJcbiAgICAgIGlmIChkZWVwICYmIGlzU2NvcGUpIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZShtYXBTY29wZShzY29wZVtmaWVsZF0pLCBmbGFncyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWRlZXAgJiYgaXNTY29wZSkge1xyXG4gICAgICAgIHJldHVybiBmbGFncztcclxuICAgICAgfVxyXG5cclxuICAgICAgZmxhZ3MgPSBjb21iaW5lKGZsYWdzLCBzY29wZVtmaWVsZF0pO1xyXG5cclxuICAgICAgcmV0dXJuIGZsYWdzO1xyXG4gICAgfSwgbnVsbCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTWFwcyBmaWVsZHMgdG8gY29tcHV0ZWQgZnVuY3Rpb25zLlxyXG4gICAqL1xyXG4gIHZhciBtYXBGaWVsZHMgPSBmdW5jdGlvbiAoZmllbGRzKSB7XHJcbiAgICBpZiAoIWZpZWxkcykge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBtYXBTY29wZSh0aGlzLiR2YWxpZGF0b3IuZmxhZ3MpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplKGZpZWxkcyk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobm9ybWFsaXplZCkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgIHZhciBmaWVsZCA9IG5vcm1hbGl6ZWRbY3Vycl07XHJcbiAgICAgIHByZXZbY3Vycl0gPSBmdW5jdGlvbiBtYXBwZWRGaWVsZCAoKSB7XHJcbiAgICAgICAgLy8gaWYgZmllbGQgZXhpc3RzXHJcbiAgICAgICAgaWYgKHRoaXMuJHZhbGlkYXRvci5mbGFnc1tmaWVsZF0pIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLiR2YWxpZGF0b3IuZmxhZ3NbZmllbGRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2NvcGVsZXNzIGZpZWxkcyB3ZXJlIHNlbGVjdGVkLlxyXG4gICAgICAgIGlmIChub3JtYWxpemVkW2N1cnJdID09PSAnKicpIHtcclxuICAgICAgICAgIHJldHVybiBtYXBTY29wZSh0aGlzLiR2YWxpZGF0b3IuZmxhZ3MsIGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIGl0IGhhcyBhIHNjb3BlIGRlZmluZWRcclxuICAgICAgICB2YXIgaW5kZXggPSBmaWVsZC5pbmRleE9mKCcuJyk7XHJcbiAgICAgICAgaWYgKGluZGV4IDw9IDApIHtcclxuICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZWYgPSBmaWVsZC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgc2NvcGUgPSByZWZbMF07XG4gICAgICAgIHZhciBuYW1lID0gcmVmLnNsaWNlKDEpO1xyXG5cclxuICAgICAgICBzY29wZSA9IHRoaXMuJHZhbGlkYXRvci5mbGFnc1soXCIkXCIgKyBzY29wZSldO1xyXG4gICAgICAgIG5hbWUgPSBuYW1lLmpvaW4oJy4nKTtcclxuXHJcbiAgICAgICAgLy8gYW4gZW50aXJlIHNjb3BlIHdhcyBzZWxlY3RlZDogc2NvcGUuKlxyXG4gICAgICAgIGlmIChuYW1lID09PSAnKicgJiYgc2NvcGUpIHtcclxuICAgICAgICAgIHJldHVybiBtYXBTY29wZShzY29wZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2NvcGUgJiYgc2NvcGVbbmFtZV0pIHtcclxuICAgICAgICAgIHJldHVybiBzY29wZVtuYW1lXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgfSwge30pO1xyXG4gIH07XG5cbiAgdmFyICR2YWxpZGF0b3IgPSBudWxsO1xyXG5cclxuICB2YXIgUFJPVklERVJfQ09VTlRFUiA9IDA7XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRpb25DdHggKGN0eCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZXJyb3JzOiBjdHgubWVzc2FnZXMsXHJcbiAgICAgIGZsYWdzOiBjdHguZmxhZ3MsXHJcbiAgICAgIGNsYXNzZXM6IGN0eC5jbGFzc2VzLFxyXG4gICAgICB2YWxpZDogY3R4LmlzVmFsaWQsXHJcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjdHgucmVzZXQoKTsgfSxcclxuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gY3R4LnZhbGlkYXRlLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgfSxcclxuICAgICAgYXJpYToge1xyXG4gICAgICAgICdhcmlhLWludmFsaWQnOiBjdHguZmxhZ3MuaW52YWxpZCA/ICd0cnVlJyA6ICdmYWxzZScsXHJcbiAgICAgICAgJ2FyaWEtcmVxdWlyZWQnOiBjdHguaXNSZXF1aXJlZCA/ICd0cnVlJyA6ICdmYWxzZSdcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgaWYgYSBwcm92aWRlciBuZWVkcyB0byBydW4gdmFsaWRhdGlvbi5cclxuICAgKi9cclxuICBmdW5jdGlvbiBzaG91bGRWYWxpZGF0ZSAoY3R4LCBtb2RlbCkge1xyXG4gICAgLy8gd2hlbiBhbiBpbW1lZGlhdGUvaW5pdGlhbCB2YWxpZGF0aW9uIGlzIG5lZWRlZCBhbmQgd2Fzbid0IGRvbmUgYmVmb3JlLlxyXG4gICAgaWYgKCFjdHguX2lnbm9yZUltbWVkaWF0ZSAmJiBjdHguaW1tZWRpYXRlKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgZm9yIHdoYXRldmVyIHJlYXNvbi5cclxuICAgIGlmIChjdHgudmFsdWUgIT09IG1vZGVsLnZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gaXQgbmVlZHMgdmFsaWRhdGlvbiBkdWUgdG8gcHJvcHMvY3Jvc3MtZmllbGRzIGNoYW5nZXMuXHJcbiAgICBpZiAoY3R4Ll9uZWVkc1ZhbGlkYXRpb24pIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2hlbiB0aGUgaW5pdGlhbCB2YWx1ZSBpcyB1bmRlZmluZWQgYW5kIHRoZSBmaWVsZCB3YXNuJ3QgcmVuZGVyZWQgeWV0LlxyXG4gICAgaWYgKCFjdHguaW5pdGlhbGl6ZWQgJiYgbW9kZWwudmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvblJlbmRlclVwZGF0ZSAobW9kZWwpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gbW9kZWwudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHZhbGlkYXRlTm93ID0gc2hvdWxkVmFsaWRhdGUodGhpcywgbW9kZWwpO1xyXG4gICAgdGhpcy5fbmVlZHNWYWxpZGF0aW9uID0gZmFsc2U7XHJcbiAgICB0aGlzLnZhbHVlID0gbW9kZWwudmFsdWU7XHJcbiAgICB0aGlzLl9pZ25vcmVJbW1lZGlhdGUgPSB0cnVlO1xyXG5cclxuICAgIGlmICghdmFsaWRhdGVOb3cpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzaWxlbnRIYW5kbGVyID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIHZhbGlkID0gcmVmLnZhbGlkO1xuXHJcbiAgICAgIC8vIGluaXRpYWxseSBhc3NpZ24gdGhlIHZhbGlkL2ludmFsaWQgZmxhZ3MuXHJcbiAgICAgIHRoaXMkMS5zZXRGbGFncyh7XHJcbiAgICAgICAgdmFsaWQ6IHZhbGlkLFxyXG4gICAgICAgIGludmFsaWQ6ICF2YWxpZFxyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy52YWxpZGF0ZVNpbGVudCgpLnRoZW4odGhpcy5pbW1lZGlhdGUgfHwgdGhpcy5mbGFncy52YWxpZGF0ZWQgPyB0aGlzLmFwcGx5UmVzdWx0IDogc2lsZW50SGFuZGxlcik7XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGVzIHRoZSBjb21tb24gaGFuZGxlcnMgZm9yIGEgdmFsaWRhdGFibGUgY29udGV4dC5cclxuICBmdW5jdGlvbiBjcmVhdGVDb21tb25IYW5kbGVycyAoY3R4KSB7XHJcbiAgICB2YXIgb25JbnB1dCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGN0eC5zeW5jVmFsdWUoZSk7IC8vIHRyYWNrIGFuZCBrZWVwIHRoZSB2YWx1ZSB1cGRhdGVkLlxyXG4gICAgICBjdHguc2V0RmxhZ3MoeyBkaXJ0eTogdHJ1ZSwgcHJpc3RpbmU6IGZhbHNlIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBCbHVyIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgdmFyIG9uQmx1ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgY3R4LnNldEZsYWdzKHsgdG91Y2hlZDogdHJ1ZSwgdW50b3VjaGVkOiBmYWxzZSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIG9uVmFsaWRhdGUgPSBkZWJvdW5jZShcclxuICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwZW5kaW5nUHJvbWlzZSA9IGN0eC52YWxpZGF0ZSgpO1xyXG4gICAgICAgIC8vIGF2b2lkcyByYWNlIGNvbmRpdGlvbnMgYmV0d2VlbiBzdWNjZXNzaXZlIHZhbGlkYXRpb25zLlxyXG4gICAgICAgIGN0eC5fcGVuZGluZ1ZhbGlkYXRpb24gPSBwZW5kaW5nUHJvbWlzZTtcclxuICAgICAgICBwZW5kaW5nUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSA9PT0gY3R4Ll9wZW5kaW5nVmFsaWRhdGlvbikge1xyXG4gICAgICAgICAgICBjdHguYXBwbHlSZXN1bHQocmVzdWx0KTtcclxuICAgICAgICAgICAgY3R4Ll9wZW5kaW5nVmFsaWRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGN0eC5kZWJvdW5jZVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4geyBvbklucHV0OiBvbklucHV0LCBvbkJsdXI6IG9uQmx1ciwgb25WYWxpZGF0ZTogb25WYWxpZGF0ZSB9O1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkcyBhbGwgcGx1Z2luIGxpc3RlbmVycyB0byB0aGUgdm5vZGUuXHJcbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzIChub2RlKSB7XHJcbiAgICB2YXIgbW9kZWwgPSBmaW5kTW9kZWwobm9kZSk7XHJcbiAgICAvLyBjYWNoZSB0aGUgaW5wdXQgZXZlbnROYW1lLlxyXG4gICAgdGhpcy5faW5wdXRFdmVudE5hbWUgPSB0aGlzLl9pbnB1dEV2ZW50TmFtZSB8fCBnZXRJbnB1dEV2ZW50TmFtZShub2RlLCBtb2RlbCk7XHJcblxyXG4gICAgb25SZW5kZXJVcGRhdGUuY2FsbCh0aGlzLCBtb2RlbCk7XHJcblxyXG4gICAgdmFyIHJlZiA9IGNyZWF0ZUNvbW1vbkhhbmRsZXJzKHRoaXMpO1xuICAgIHZhciBvbklucHV0ID0gcmVmLm9uSW5wdXQ7XG4gICAgdmFyIG9uQmx1ciA9IHJlZi5vbkJsdXI7XG4gICAgdmFyIG9uVmFsaWRhdGUgPSByZWYub25WYWxpZGF0ZTtcclxuICAgIGFkZFZOb2RlTGlzdGVuZXIobm9kZSwgdGhpcy5faW5wdXRFdmVudE5hbWUsIG9uSW5wdXQpO1xyXG4gICAgYWRkVk5vZGVMaXN0ZW5lcihub2RlLCAnYmx1cicsIG9uQmx1cik7XHJcblxyXG4gICAgLy8gYWRkIHRoZSB2YWxpZGF0aW9uIGxpc3RlbmVycy5cclxuICAgIHRoaXMubm9ybWFsaXplZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgYWRkVk5vZGVMaXN0ZW5lcihub2RlLCBldnQsIG9uVmFsaWRhdGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVWYWx1ZXNMb29rdXAgKGN0eCkge1xyXG4gICAgdmFyIHByb3ZpZGVycyA9IGN0eC4kX3ZlZU9ic2VydmVyLnJlZnM7XHJcblxyXG4gICAgcmV0dXJuIGN0eC5maWVsZERlcHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGRlcE5hbWUpIHtcclxuICAgICAgaWYgKCFwcm92aWRlcnNbZGVwTmFtZV0pIHtcclxuICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhY2NbZGVwTmFtZV0gPSBwcm92aWRlcnNbZGVwTmFtZV0udmFsdWU7XHJcblxyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlUmVuZGVyaW5nQ29udGV4dFJlZnMgKGN0eCkge1xyXG4gICAgLy8gSURzIHNob3VsZCBub3QgYmUgbnVsbGFibGUuXHJcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoY3R4LmlkKSAmJiBjdHguaWQgPT09IGN0eC52aWQpIHtcclxuICAgICAgY3R4LmlkID0gUFJPVklERVJfQ09VTlRFUjtcclxuICAgICAgUFJPVklERVJfQ09VTlRFUisrO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpZCA9IGN0eC5pZDtcbiAgICB2YXIgdmlkID0gY3R4LnZpZDtcclxuICAgIC8vIE5vdGhpbmcgaGFzIGNoYW5nZWQuXHJcbiAgICBpZiAoaWQgPT09IHZpZCAmJiBjdHguJF92ZWVPYnNlcnZlci5yZWZzW2lkXSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdmlkIHdhcyBjaGFuZ2VkLlxyXG4gICAgaWYgKGlkICE9PSB2aWQgJiYgY3R4LiRfdmVlT2JzZXJ2ZXIucmVmc1tpZF0gPT09IGN0eCkge1xyXG4gICAgICBjdHguJF92ZWVPYnNlcnZlci4kdW5zdWJzY3JpYmUoY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICBjdHguJF92ZWVPYnNlcnZlci4kc3Vic2NyaWJlKGN0eCk7XHJcbiAgICBjdHguaWQgPSB2aWQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVPYnNlcnZlciAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZWZzOiB7fSxcclxuICAgICAgJHN1YnNjcmliZTogZnVuY3Rpb24gJHN1YnNjcmliZSAoY3R4KSB7XHJcbiAgICAgICAgdGhpcy5yZWZzW2N0eC52aWRdID0gY3R4O1xyXG4gICAgICB9LFxyXG4gICAgICAkdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICR1bnN1YnNjcmliZSAoY3R4KSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tjdHgudmlkXTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHZhciBWYWxpZGF0aW9uUHJvdmlkZXIgPSB7XHJcbiAgICAkX192ZWVJbmplY3Q6IGZhbHNlLFxyXG4gICAgaW5qZWN0OiB7XHJcbiAgICAgICRfdmVlT2JzZXJ2ZXI6IHtcclxuICAgICAgICBmcm9tOiAnJF92ZWVPYnNlcnZlcicsXHJcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gZGVmYXVsdCQxICgpIHtcclxuICAgICAgICAgIGlmICghdGhpcy4kdm5vZGUuY29udGV4dC4kX3ZlZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJHZub2RlLmNvbnRleHQuJF92ZWVPYnNlcnZlciA9IGNyZWF0ZU9ic2VydmVyKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHZub2RlLmNvbnRleHQuJF92ZWVPYnNlcnZlcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBwcm9wczoge1xyXG4gICAgICB2aWQ6IHtcclxuICAgICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxyXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIFBST1ZJREVSX0NPVU5URVIrKztcclxuXHJcbiAgICAgICAgICByZXR1cm4gUFJPVklERVJfQ09VTlRFUjtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIG5hbWU6IHtcclxuICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgZGVmYXVsdDogbnVsbFxyXG4gICAgICB9LFxyXG4gICAgICBldmVudHM6IHtcclxuICAgICAgICB0eXBlOiBbQXJyYXksIFN0cmluZ10sXHJcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gWydpbnB1dCddOyB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgdHlwZTogW09iamVjdCwgU3RyaW5nXSxcclxuICAgICAgICBkZWZhdWx0OiBudWxsXHJcbiAgICAgIH0sXHJcbiAgICAgIGltbWVkaWF0ZToge1xyXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuICAgICAgfSxcclxuICAgICAgcGVyc2lzdDoge1xyXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuICAgICAgfSxcclxuICAgICAgYmFpbHM6IHtcclxuICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFZlZVZhbGlkYXRlJDEuY29uZmlnLmZhc3RFeGl0OyB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGRlYm91bmNlOiB7XHJcbiAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFZlZVZhbGlkYXRlJDEuY29uZmlnLmRlbGF5IHx8IDA7IH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdhdGNoOiB7XHJcbiAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgZGVlcDogdHJ1ZSxcclxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyICgpIHtcclxuICAgICAgICAgIHRoaXMuX25lZWRzVmFsaWRhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGF0YTogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcclxuICAgICAgbWVzc2FnZXM6IFtdLFxyXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICBpbml0aWFsaXplZDogZmFsc2UsXHJcbiAgICAgIGluaXRpYWxWYWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICBmbGFnczogY3JlYXRlRmxhZ3MoKSxcclxuICAgICAgZm9yY2VSZXF1aXJlZDogZmFsc2UsXHJcbiAgICAgIGlkOiBudWxsXHJcbiAgICB9KTsgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgc2V0RmxhZ3M6IGZ1bmN0aW9uIHNldEZsYWdzIChmbGFncykge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgICAgIE9iamVjdC5rZXlzKGZsYWdzKS5mb3JFYWNoKGZ1bmN0aW9uIChmbGFnKSB7XHJcbiAgICAgICAgICB0aGlzJDEuZmxhZ3NbZmxhZ10gPSBmbGFnc1tmbGFnXTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgc3luY1ZhbHVlOiBmdW5jdGlvbiBzeW5jVmFsdWUgKGUpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBpc0V2ZW50KGUpID8gZS50YXJnZXQudmFsdWUgOiBlO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmZsYWdzLmNoYW5nZWQgPSB0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdmFsdWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCAoKSB7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdWYWxpZGF0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgdmFyIGZsYWdzID0gY3JlYXRlRmxhZ3MoKTtcclxuICAgICAgICB0aGlzLnNldEZsYWdzKGZsYWdzKTtcclxuICAgICAgfSxcclxuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlICgpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cclxuICAgICAgICBpZiAoYXJnc1swXSkge1xyXG4gICAgICAgICAgdGhpcy5zeW5jVmFsdWUoYXJnc1swXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVNpbGVudCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgdGhpcyQxLmFwcGx5UmVzdWx0KHJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgdmFsaWRhdGVTaWxlbnQ6IGZ1bmN0aW9uIHZhbGlkYXRlU2lsZW50ICgpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgICAgICB0aGlzLnNldEZsYWdzKHsgcGVuZGluZzogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuICR2YWxpZGF0b3IudmVyaWZ5KHRoaXMudmFsdWUsIHRoaXMucnVsZXMsIHtcclxuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgIHZhbHVlczogY3JlYXRlVmFsdWVzTG9va3VwKHRoaXMpLFxyXG4gICAgICAgICAgYmFpbHM6IHRoaXMuYmFpbHNcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgIHRoaXMkMS5zZXRGbGFncyh7IHBlbmRpbmc6IGZhbHNlIH0pO1xyXG5cclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGFwcGx5UmVzdWx0OiBmdW5jdGlvbiBhcHBseVJlc3VsdCAocmVmKSB7XG4gICAgICAgIHZhciBlcnJvcnMgPSByZWYuZXJyb3JzO1xuXHJcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IGVycm9ycztcclxuICAgICAgICB0aGlzLnNldEZsYWdzKHtcclxuICAgICAgICAgIHZhbGlkOiAhZXJyb3JzLmxlbmd0aCxcclxuICAgICAgICAgIGNoYW5nZWQ6IHRoaXMudmFsdWUgIT09IHRoaXMuaW5pdGlhbFZhbHVlLFxyXG4gICAgICAgICAgaW52YWxpZDogISFlcnJvcnMubGVuZ3RoLFxyXG4gICAgICAgICAgdmFsaWRhdGVkOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHJlZ2lzdGVyRmllbGQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRmllbGQgKCkge1xyXG4gICAgICAgIGlmICghJHZhbGlkYXRvcikge1xyXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFWZWVWYWxpZGF0ZSQxLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgd2FybignWW91IG11c3QgaW5zdGFsbCB2ZWUtdmFsaWRhdGUgZmlyc3QgYmVmb3JlIHVzaW5nIHRoaXMgY29tcG9uZW50LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgJHZhbGlkYXRvciA9IFZlZVZhbGlkYXRlJDEuaW5zdGFuY2UuX3ZhbGlkYXRvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVwZGF0ZVJlbmRlcmluZ0NvbnRleHRSZWZzKHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgaXNWYWxpZDogZnVuY3Rpb24gaXNWYWxpZCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MudmFsaWQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIGZpZWxkRGVwczogZnVuY3Rpb24gZmllbGREZXBzICgpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgICAgICB2YXIgcnVsZXMgPSBub3JtYWxpemVSdWxlcyh0aGlzLnJ1bGVzKTtcclxuICAgICAgICB2YXIgcHJvdmlkZXJzID0gdGhpcy4kX3ZlZU9ic2VydmVyLnJlZnM7XHJcblxyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhydWxlcykuZmlsdGVyKFJ1bGVDb250YWluZXIuaXNUYXJnZXRSdWxlKS5tYXAoZnVuY3Rpb24gKHJ1bGUpIHtcclxuICAgICAgICAgIHZhciBkZXBOYW1lID0gcnVsZXNbcnVsZV1bMF07XHJcbiAgICAgICAgICB2YXIgd2F0Y2hlck5hbWUgPSBcIiRfX1wiICsgZGVwTmFtZTtcclxuICAgICAgICAgIGlmICghaXNDYWxsYWJsZSh0aGlzJDFbd2F0Y2hlck5hbWVdKSkge1xyXG4gICAgICAgICAgICB0aGlzJDFbd2F0Y2hlck5hbWVdID0gcHJvdmlkZXJzW2RlcE5hbWVdLiR3YXRjaCgndmFsdWUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgdGhpcyQxLl9uZWVkc1ZhbGlkYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgIHRoaXMkMS52YWxpZGF0ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gZGVwTmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgbm9ybWFsaXplZEV2ZW50czogZnVuY3Rpb24gbm9ybWFsaXplZEV2ZW50cyAoKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUV2ZW50cyh0aGlzLmV2ZW50cykubWFwKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICBpZiAoZSA9PT0gJ2lucHV0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcyQxLl9pbnB1dEV2ZW50TmFtZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgaXNSZXF1aXJlZDogZnVuY3Rpb24gaXNSZXF1aXJlZCAoKSB7XHJcbiAgICAgICAgdmFyIHJ1bGVzID0gbm9ybWFsaXplUnVsZXModGhpcy5ydWxlcyk7XHJcbiAgICAgICAgdmFyIGZvcmNlUmVxdWlyZWQgPSB0aGlzLmZvcmNlUmVxdWlyZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiAhIXJ1bGVzLnJlcXVpcmVkIHx8IGZvcmNlUmVxdWlyZWQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMgKCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgICAgIHZhciBuYW1lcyA9IFZlZVZhbGlkYXRlJDEuY29uZmlnLmNsYXNzTmFtZXM7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZmxhZ3MpLnJlZHVjZShmdW5jdGlvbiAoY2xhc3NlcywgZmxhZykge1xyXG4gICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IChuYW1lcyAmJiBuYW1lc1tmbGFnXSkgfHwgZmxhZztcclxuICAgICAgICAgIGlmIChmbGFnID09PSAnaW52YWxpZCcpIHtcclxuICAgICAgICAgICAgY2xhc3Nlc1tjbGFzc05hbWVdID0gISF0aGlzJDEubWVzc2FnZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXM7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGZsYWcgPT09ICd2YWxpZCcpIHtcclxuICAgICAgICAgICAgY2xhc3Nlc1tjbGFzc05hbWVdID0gIXRoaXMkMS5tZXNzYWdlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXNbY2xhc3NOYW1lXSA9IHRoaXMkMS5mbGFnc1tmbGFnXTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgICAgdGhpcy5yZWdpc3RlckZpZWxkKCk7XHJcbiAgICAgIHZhciBjdHggPSBjcmVhdGVWYWxpZGF0aW9uQ3R4KHRoaXMpO1xyXG5cclxuICAgICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgbm9uLWV4aXN0ZW50IHNjb3BlZCBzbG90cy5cclxuICAgICAgdmFyIHNsb3QgPSB0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0O1xyXG4gICAgICBpZiAoIWlzQ2FsbGFibGUoc2xvdCkpIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICB3YXJuKCdWYWxpZGF0aW9uUHJvdmlkZXIgZXhwZWN0cyBhIHNjb3BlZCBzbG90LiBEaWQgeW91IGZvcmdldCB0byBhZGQgXCJzbG90LXNjb3BlXCIgdG8geW91ciBzbG90PycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlcmxlc3MoaCwgdGhpcy4kc2xvdHMuZGVmYXVsdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBub2RlcyA9IHNsb3QoY3R4KTtcclxuICAgICAgLy8gSGFuZGxlIHNpbmdsZS1yb290IHNsb3QuXHJcbiAgICAgIGV4dHJhY3RWTm9kZXMobm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgYWRkTGlzdGVuZXJzLmNhbGwodGhpcyQxLCBpbnB1dCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlcmxlc3MoaCwgbm9kZXMpO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3kgKCkge1xyXG4gICAgICAvLyBjbGVhbnVwIHJlZmVyZW5jZS5cclxuICAgICAgdGhpcy4kX3ZlZU9ic2VydmVyLiR1bnN1YnNjcmliZSh0aGlzKTtcclxuICAgIH1cclxuICB9O1xuXG4gIHZhciBmbGFnTWVyZ2luZ1N0cmF0ZWd5ID0ge1xyXG4gICAgcHJpc3RpbmU6ICdldmVyeScsXHJcbiAgICBkaXJ0eTogJ3NvbWUnLFxyXG4gICAgdG91Y2hlZDogJ3NvbWUnLFxyXG4gICAgdW50b3VjaGVkOiAnZXZlcnknLFxyXG4gICAgdmFsaWQ6ICdldmVyeScsXHJcbiAgICBpbnZhbGlkOiAnc29tZScsXHJcbiAgICBwZW5kaW5nOiAnc29tZScsXHJcbiAgICB2YWxpZGF0ZWQ6ICdldmVyeSdcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBtZXJnZUZsYWdzIChsaHMsIHJocywgc3RyYXRlZ3kpIHtcclxuICAgIHZhciBzdHJhdE5hbWUgPSBmbGFnTWVyZ2luZ1N0cmF0ZWd5W3N0cmF0ZWd5XTtcclxuXHJcbiAgICByZXR1cm4gW2xocywgcmhzXVtzdHJhdE5hbWVdKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmOyB9KTtcclxuICB9XHJcblxyXG4gIHZhciBWYWxpZGF0aW9uT2JzZXJ2ZXIgPSB7XHJcbiAgICBuYW1lOiAnVmFsaWRhdGlvbk9ic2VydmVyJyxcclxuICAgIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUgKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgICRfdmVlT2JzZXJ2ZXI6IHRoaXNcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBkYXRhOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xyXG4gICAgICByZWZzOiB7fVxyXG4gICAgfSk7IH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICRzdWJzY3JpYmU6IGZ1bmN0aW9uICRzdWJzY3JpYmUgKHByb3ZpZGVyKSB7XG4gICAgICAgIHZhciBvYmo7XG5cclxuICAgICAgICB0aGlzLnJlZnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJlZnMsICggb2JqID0ge30sIG9ialtwcm92aWRlci52aWRdID0gcHJvdmlkZXIsIG9iaiApKTtcclxuICAgICAgfSxcclxuICAgICAgJHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAkdW5zdWJzY3JpYmUgKHJlZikge1xuICAgICAgICB2YXIgdmlkID0gcmVmLnZpZDtcblxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbdmlkXTtcclxuICAgICAgICB0aGlzLnJlZnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJlZnMpO1xyXG4gICAgICB9LFxyXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUgKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcclxuICAgICAgICAgIHZhbHVlcyh0aGlzLnJlZnMpLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiByZWYudmFsaWRhdGUoKTsgfSlcclxuICAgICAgICApLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHsgcmV0dXJuIHJlc3VsdHMuZXZlcnkoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudmFsaWQ7IH0pOyB9KTtcclxuICAgICAgfSxcclxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0ICgpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWVzKHRoaXMucmVmcykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7IHJldHVybiByZWYucmVzZXQoKTsgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICBjdHg6IGZ1bmN0aW9uIGN0eCAoKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICAgICAgdmFyIGN0eCA9IHtcclxuICAgICAgICAgIGVycm9yczoge30sXHJcbiAgICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMkMS52YWxpZGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiB0aGVuICh0aGVuYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzICYmIGlzQ2FsbGFibGUodGhlbmFibGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGVuYWJsZSgpKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdWNjZXNzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICByZXNldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLnJlc2V0KCk7IH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWVzKHRoaXMucmVmcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgICBPYmplY3Qua2V5cyhmbGFnTWVyZ2luZ1N0cmF0ZWd5KS5mb3JFYWNoKGZ1bmN0aW9uIChmbGFnKSB7XHJcbiAgICAgICAgICAgIGlmICghKGZsYWcgaW4gYWNjKSkge1xyXG4gICAgICAgICAgICAgIGFjY1tmbGFnXSA9IHByb3ZpZGVyLmZsYWdzW2ZsYWddO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYWNjW2ZsYWddID0gbWVyZ2VGbGFncyhhY2NbZmxhZ10sIHByb3ZpZGVyLmZsYWdzW2ZsYWddLCBmbGFnKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGFjYy5lcnJvcnNbcHJvdmlkZXIudmlkXSA9IHByb3ZpZGVyLm1lc3NhZ2VzO1xyXG5cclxuICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgfSwgY3R4KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XHJcbiAgICAgIHZhciBzbG90cyA9IHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQ7XHJcbiAgICAgIGlmICghaXNDYWxsYWJsZShzbG90cykpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlUmVuZGVybGVzcyhoLCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlcmxlc3MoaCwgc2xvdHModGhpcy5jdHgpKTtcclxuICAgIH1cclxuICB9O1xuXG4gIGZ1bmN0aW9uIHdpdGhWYWxpZGF0aW9uIChjb21wb25lbnQsIGN0eFRvUHJvcHMpIHtcbiAgICBpZiAoIGN0eFRvUHJvcHMgPT09IHZvaWQgMCApIGN0eFRvUHJvcHMgPSBudWxsO1xuXHJcbiAgICB2YXIgb3B0aW9ucyA9IGlzQ2FsbGFibGUoY29tcG9uZW50KSA/IGNvbXBvbmVudC5vcHRpb25zIDogY29tcG9uZW50O1xyXG4gICAgb3B0aW9ucy4kX192ZWVJbmplY3QgPSBmYWxzZTtcclxuICAgIHZhciBob2MgPSB7XHJcbiAgICAgIG5hbWU6ICgob3B0aW9ucy5uYW1lIHx8ICdBbm9ueW1vdXNIb2MnKSArIFwiV2l0aFZhbGlkYXRpb25cIiksXHJcbiAgICAgIHByb3BzOiBhc3NpZ24oe30sIFZhbGlkYXRpb25Qcm92aWRlci5wcm9wcyksXHJcbiAgICAgIGRhdGE6IFZhbGlkYXRpb25Qcm92aWRlci5kYXRhLFxyXG4gICAgICBjb21wdXRlZDogYXNzaWduKHt9LCBWYWxpZGF0aW9uUHJvdmlkZXIuY29tcHV0ZWQpLFxyXG4gICAgICBtZXRob2RzOiBhc3NpZ24oe30sIFZhbGlkYXRpb25Qcm92aWRlci5tZXRob2RzKSxcclxuICAgICAgJF9fdmVlSW5qZWN0OiBmYWxzZSxcclxuICAgICAgYmVmb3JlRGVzdHJveTogVmFsaWRhdGlvblByb3ZpZGVyLmJlZm9yZURlc3Ryb3ksXHJcbiAgICAgIGluamVjdDogVmFsaWRhdGlvblByb3ZpZGVyLmluamVjdFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBEZWZhdWx0IGN0eCBjb252ZXJ0cyBjdHggcHJvcHMgdG8gY29tcG9uZW50IHByb3BzLlxyXG4gICAgaWYgKCFjdHhUb1Byb3BzKSB7XHJcbiAgICAgIGN0eFRvUHJvcHMgPSBmdW5jdGlvbiAoY3R4KSB7IHJldHVybiBjdHg7IH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGV2ZW50TmFtZSA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7XHJcblxyXG4gICAgaG9jLnJlbmRlciA9IGZ1bmN0aW9uIChoKSB7XG4gICAgICB2YXIgb2JqO1xuXHJcbiAgICAgIHRoaXMucmVnaXN0ZXJGaWVsZCgpO1xyXG4gICAgICB2YXIgdmN0eCA9IGNyZWF0ZVZhbGlkYXRpb25DdHgodGhpcyk7XHJcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBhc3NpZ24oe30sIHRoaXMuJGxpc3RlbmVycyk7XHJcblxyXG4gICAgICB2YXIgbW9kZWwgPSBmaW5kTW9kZWwodGhpcy4kdm5vZGUpO1xyXG4gICAgICB0aGlzLl9pbnB1dEV2ZW50TmFtZSA9IHRoaXMuX2lucHV0RXZlbnROYW1lIHx8IGdldElucHV0RXZlbnROYW1lKHRoaXMuJHZub2RlLCBtb2RlbCk7XHJcbiAgICAgIG9uUmVuZGVyVXBkYXRlLmNhbGwodGhpcywgbW9kZWwpO1xyXG5cclxuICAgICAgdmFyIHJlZiA9IGNyZWF0ZUNvbW1vbkhhbmRsZXJzKHRoaXMpO1xuICAgICAgdmFyIG9uSW5wdXQgPSByZWYub25JbnB1dDtcbiAgICAgIHZhciBvbkJsdXIgPSByZWYub25CbHVyO1xuICAgICAgdmFyIG9uVmFsaWRhdGUgPSByZWYub25WYWxpZGF0ZTtcclxuXHJcbiAgICAgIG1lcmdlVk5vZGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBldmVudE5hbWUsIG9uSW5wdXQpO1xyXG4gICAgICBtZXJnZVZOb2RlTGlzdGVuZXJzKGxpc3RlbmVycywgJ2JsdXInLCBvbkJsdXIpO1xyXG4gICAgICB0aGlzLm5vcm1hbGl6ZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZ0LCBpZHgpIHtcclxuICAgICAgICBtZXJnZVZOb2RlTGlzdGVuZXJzKGxpc3RlbmVycywgZXZ0LCBvblZhbGlkYXRlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBQcm9wcyBhcmUgYW55IGF0dHJzIG5vdCBhc3NvY2lhdGVkIHdpdGggVmFsaWRhdGlvblByb3ZpZGVyIFBsdXMgdGhlIG1vZGVsIHByb3AuXHJcbiAgICAgIC8vIFdBUk5JTkc6IEFjY2lkZW50YWwgcHJvcCBvdmVyd3JpdGUgd2lsbCBwcm9iYWJseSBoYXBwZW4uXHJcbiAgICAgIHZhciByZWYkMSA9IGZpbmRNb2RlbENvbmZpZyh0aGlzLiR2bm9kZSkgfHwgeyBwcm9wOiAndmFsdWUnIH07XG4gICAgICB2YXIgcHJvcCA9IHJlZiQxLnByb3A7XHJcbiAgICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgdGhpcy4kYXR0cnMsICggb2JqID0ge30sIG9ialtwcm9wXSA9IG1vZGVsLnZhbHVlLCBvYmogKSwgY3R4VG9Qcm9wcyh2Y3R4KSk7XHJcblxyXG4gICAgICByZXR1cm4gaChvcHRpb25zLCB7XHJcbiAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzLFxyXG4gICAgICAgIHByb3BzOiBwcm9wcyxcclxuICAgICAgICBvbjogbGlzdGVuZXJzXHJcbiAgICAgIH0sIG5vcm1hbGl6ZVNsb3RzKHRoaXMuJHNsb3RzLCB0aGlzLiR2bm9kZS5jb250ZXh0KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBob2M7XHJcbiAgfVxuXG4gIC8vIFxyXG5cclxuICB2YXIgbm9ybWFsaXplVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGtleSkge1xyXG4gICAgICAgIHByZXZba2V5XSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlW2tleV0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgfSwge30pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0NhbGxhYmxlKHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUoJ3swfScsIFsnezF9JywgJ3syfScsICd7M30nXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH07XHJcblxyXG4gIHZhciBub3JtYWxpemVGb3JtYXQgPSBmdW5jdGlvbiAobG9jYWxlKSB7XHJcbiAgICAvLyBub3JtYWxpemUgbWVzc2FnZXNcclxuICAgIHZhciBkaWN0aW9uYXJ5ID0ge307XHJcbiAgICBpZiAobG9jYWxlLm1lc3NhZ2VzKSB7XHJcbiAgICAgIGRpY3Rpb25hcnkubWVzc2FnZXMgPSBub3JtYWxpemVWYWx1ZShsb2NhbGUubWVzc2FnZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsb2NhbGUuY3VzdG9tKSB7XHJcbiAgICAgIGRpY3Rpb25hcnkuY3VzdG9tID0gbm9ybWFsaXplVmFsdWUobG9jYWxlLmN1c3RvbSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxvY2FsZS5hdHRyaWJ1dGVzKSB7XHJcbiAgICAgIGRpY3Rpb25hcnkuYXR0cmlidXRlcyA9IGxvY2FsZS5hdHRyaWJ1dGVzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobG9jYWxlLmRhdGVGb3JtYXQpKSB7XHJcbiAgICAgIGRpY3Rpb25hcnkuZGF0ZUZvcm1hdCA9IGxvY2FsZS5kYXRlRm9ybWF0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkaWN0aW9uYXJ5O1xyXG4gIH07XHJcblxyXG4gIHZhciBJMThuRGljdGlvbmFyeSA9IGZ1bmN0aW9uIEkxOG5EaWN0aW9uYXJ5IChpMThuLCByb290S2V5KSB7XHJcbiAgICB0aGlzLmkxOG4gPSBpMThuO1xyXG4gICAgdGhpcy5yb290S2V5ID0gcm9vdEtleTtcclxuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMkNSA9IHsgbG9jYWxlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XHJcblxyXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQ1LmxvY2FsZS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pMThuLmxvY2FsZTtcclxuICB9O1xyXG5cclxuICBwcm90b3R5cGVBY2Nlc3NvcnMkNS5sb2NhbGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB3YXJuKCdDYW5ub3Qgc2V0IGxvY2FsZSBmcm9tIHRoZSB2YWxpZGF0b3Igd2hlbiB1c2luZyB2dWUtaTE4biwgdXNlIGkxOG4ubG9jYWxlIHNldHRlciBpbnN0ZWFkJyk7XHJcbiAgfTtcclxuXHJcbiAgSTE4bkRpY3Rpb25hcnkucHJvdG90eXBlLmdldERhdGVGb3JtYXQgPSBmdW5jdGlvbiBnZXREYXRlRm9ybWF0IChsb2NhbGUpIHtcclxuICAgIHJldHVybiB0aGlzLmkxOG4uZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlIHx8IHRoaXMubG9jYWxlKTtcclxuICB9O1xyXG5cclxuICBJMThuRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0RGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHNldERhdGVGb3JtYXQgKGxvY2FsZSwgdmFsdWUpIHtcclxuICAgIHRoaXMuaTE4bi5zZXREYXRlVGltZUZvcm1hdChsb2NhbGUgfHwgdGhpcy5sb2NhbGUsIHZhbHVlKTtcclxuICB9O1xyXG5cclxuICBJMThuRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0TWVzc2FnZSA9IGZ1bmN0aW9uIGdldE1lc3NhZ2UgKF8sIGtleSwgZGF0YSkge1xyXG4gICAgdmFyIHBhdGggPSAodGhpcy5yb290S2V5KSArIFwiLm1lc3NhZ2VzLlwiICsga2V5O1xyXG4gICAgaWYgKHRoaXMuaTE4bi50ZShwYXRoKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pMThuLnQocGF0aCwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmFsbGJhY2sgdG8gdGhlIGZhbGxiYWNrIG1lc3NhZ2VcclxuICAgIGlmICh0aGlzLmkxOG4udGUocGF0aCwgdGhpcy5pMThuLmZhbGxiYWNrTG9jYWxlKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pMThuLnQocGF0aCwgdGhpcy5pMThuLmZhbGxiYWNrTG9jYWxlLCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmYWxsYmFjayB0byB0aGUgcm9vdCBtZXNzYWdlXHJcbiAgICByZXR1cm4gdGhpcy5pMThuLnQoKCh0aGlzLnJvb3RLZXkpICsgXCIubWVzc2FnZXMuX2RlZmF1bHRcIiksIGRhdGEpO1xyXG4gIH07XHJcblxyXG4gIEkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUgKF8sIGtleSwgZmFsbGJhY2spIHtcbiAgICAgIGlmICggZmFsbGJhY2sgPT09IHZvaWQgMCApIGZhbGxiYWNrID0gJyc7XG5cclxuICAgIHZhciBwYXRoID0gKHRoaXMucm9vdEtleSkgKyBcIi5hdHRyaWJ1dGVzLlwiICsga2V5O1xyXG4gICAgaWYgKHRoaXMuaTE4bi50ZShwYXRoKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pMThuLnQocGF0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gIH07XHJcblxyXG4gIEkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRGaWVsZE1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRGaWVsZE1lc3NhZ2UgKF8sIGZpZWxkLCBrZXksIGRhdGEpIHtcclxuICAgIHZhciBwYXRoID0gKHRoaXMucm9vdEtleSkgKyBcIi5jdXN0b20uXCIgKyBmaWVsZCArIFwiLlwiICsga2V5O1xyXG4gICAgaWYgKHRoaXMuaTE4bi50ZShwYXRoKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pMThuLnQocGF0aCwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0TWVzc2FnZShfLCBrZXksIGRhdGEpO1xyXG4gIH07XHJcblxyXG4gIEkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlJDEkJDEgKGRpY3Rpb25hcnkpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICBPYmplY3Qua2V5cyhkaWN0aW9uYXJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbGVLZXkpIHtcbiAgICAgICAgdmFyIG9iajtcblxyXG4gICAgICAvLyBpMThuIGRvZXNuJ3QgZGVlcCBtZXJnZVxyXG4gICAgICAvLyBmaXJzdCBjbG9uZSB0aGUgZXhpc3RpbmcgbG9jYWxlIChhdm9pZCBtdXRhdGlvbnMgdG8gbG9jYWxlKVxyXG4gICAgICB2YXIgY2xvbmUgPSBtZXJnZSQxKHt9LCBnZXRQYXRoKChsb2NhbGVLZXkgKyBcIi5cIiArICh0aGlzJDEucm9vdEtleSkpLCB0aGlzJDEuaTE4bi5tZXNzYWdlcywge30pKTtcclxuICAgICAgLy8gTWVyZ2UgY2xvbmVkIGxvY2FsZSB3aXRoIG5ldyBvbmVcclxuICAgICAgdmFyIGxvY2FsZSA9IG1lcmdlJDEoY2xvbmUsIG5vcm1hbGl6ZUZvcm1hdChkaWN0aW9uYXJ5W2xvY2FsZUtleV0pKTtcclxuICAgICAgdGhpcyQxLmkxOG4ubWVyZ2VMb2NhbGVNZXNzYWdlKGxvY2FsZUtleSwgKCBvYmogPSB7fSwgb2JqW3RoaXMkMS5yb290S2V5XSA9IGxvY2FsZSwgb2JqICkpO1xyXG4gICAgICBpZiAobG9jYWxlLmRhdGVGb3JtYXQpIHtcclxuICAgICAgICB0aGlzJDEuaTE4bi5zZXREYXRlVGltZUZvcm1hdChsb2NhbGVLZXksIGxvY2FsZS5kYXRlRm9ybWF0KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgSTE4bkRpY3Rpb25hcnkucHJvdG90eXBlLnNldE1lc3NhZ2UgPSBmdW5jdGlvbiBzZXRNZXNzYWdlIChsb2NhbGUsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmosIG9iaiQxO1xuXHJcbiAgICB0aGlzLm1lcmdlKCggb2JqJDEgPSB7fSwgb2JqJDFbbG9jYWxlXSA9IHtcclxuICAgICAgICBtZXNzYWdlczogKCBvYmogPSB7fSwgb2JqW2tleV0gPSB2YWx1ZSwgb2JqIClcclxuICAgICAgfSwgb2JqJDEgKSk7XHJcbiAgfTtcclxuXHJcbiAgSTE4bkRpY3Rpb25hcnkucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobG9jYWxlLCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqLCBvYmokMTtcblxyXG4gICAgdGhpcy5tZXJnZSgoIG9iaiQxID0ge30sIG9iaiQxW2xvY2FsZV0gPSB7XHJcbiAgICAgICAgYXR0cmlidXRlczogKCBvYmogPSB7fSwgb2JqW2tleV0gPSB2YWx1ZSwgb2JqIClcclxuICAgICAgfSwgb2JqJDEgKSk7XHJcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggSTE4bkRpY3Rpb25hcnkucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkNSApO1xuXG4gIC8vIFxyXG5cclxuICB2YXIgZGVmYXVsdENvbmZpZyA9IHtcclxuICAgIGxvY2FsZTogJ2VuJyxcclxuICAgIGRlbGF5OiAwLFxyXG4gICAgZXJyb3JCYWdOYW1lOiAnZXJyb3JzJyxcclxuICAgIGRpY3Rpb25hcnk6IG51bGwsXHJcbiAgICBmaWVsZHNCYWdOYW1lOiAnZmllbGRzJyxcclxuICAgIGNsYXNzZXM6IGZhbHNlLFxyXG4gICAgY2xhc3NOYW1lczogbnVsbCxcclxuICAgIGV2ZW50czogJ2lucHV0JyxcclxuICAgIGluamVjdDogdHJ1ZSxcclxuICAgIGZhc3RFeGl0OiB0cnVlLFxyXG4gICAgYXJpYTogdHJ1ZSxcclxuICAgIHZhbGlkaXR5OiBmYWxzZSxcclxuICAgIHVzZUNvbnN0cmFpbnRBdHRyczogdHJ1ZSxcclxuICAgIGkxOG46IG51bGwsXHJcbiAgICBpMThuUm9vdEtleTogJ3ZhbGlkYXRpb24nXHJcbiAgfTtcclxuXHJcbiAgdmFyIFZ1ZTtcclxuICB2YXIgcGVuZGluZ1BsdWdpbnM7XHJcbiAgdmFyIGN1cnJlbnRDb25maWcgPSBhc3NpZ24oe30sIGRlZmF1bHRDb25maWcpO1xyXG4gIHZhciBwbHVnaW5JbnN0YW5jZTtcclxuXHJcbiAgdmFyIFZlZVZhbGlkYXRlJDEgPSBmdW5jdGlvbiBWZWVWYWxpZGF0ZSAoY29uZmlnLCBfVnVlKSB7XHJcbiAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xyXG4gICAgcGx1Z2luSW5zdGFuY2UgPSB0aGlzO1xyXG4gICAgaWYgKF9WdWUpIHtcclxuICAgICAgVnVlID0gX1Z1ZTtcclxuICAgIH1cclxuICAgIHRoaXMuX3ZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3IobnVsbCwgeyBmYXN0RXhpdDogY29uZmlnICYmIGNvbmZpZy5mYXN0RXhpdCB9KTtcclxuICAgIHRoaXMuX2luaXRWTSh0aGlzLmNvbmZpZyk7XHJcbiAgICB0aGlzLl9pbml0STE4bih0aGlzLmNvbmZpZyk7XHJcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzJDYgPSB7IGkxOG5Ecml2ZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY29uZmlnOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMkMiA9IHsgaW5zdGFuY2U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saTE4bkRyaXZlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxjb25maWc6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcclxuXHJcbiAgVmVlVmFsaWRhdGUkMS5zZXRJMThuRHJpdmVyID0gZnVuY3Rpb24gc2V0STE4bkRyaXZlciAoZHJpdmVyLCBpbnN0YW5jZSkge1xyXG4gICAgRGljdGlvbmFyeVJlc29sdmVyLnNldERyaXZlcihkcml2ZXIsIGluc3RhbmNlKTtcclxuICB9O1xyXG5cclxuICBWZWVWYWxpZGF0ZSQxLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIGNvbmZpZ3VyZSAoY2ZnKSB7XHJcbiAgICBjdXJyZW50Q29uZmlnID0gYXNzaWduKHt9LCBjdXJyZW50Q29uZmlnLCBjZmcpO1xyXG4gIH07XHJcblxyXG4gIFZlZVZhbGlkYXRlJDEudXNlID0gZnVuY3Rpb24gdXNlIChwbHVnaW4sIG9wdGlvbnMpIHtcbiAgICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXHJcbiAgICBpZiAoIWlzQ2FsbGFibGUocGx1Z2luKSkge1xyXG4gICAgICByZXR1cm4gd2FybignVGhlIHBsdWdpbiBtdXN0IGJlIGEgY2FsbGFibGUgZnVuY3Rpb24nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEb24ndCBpbnN0YWxsIHBsdWdpbnMgdW50aWwgdmVlLXZhbGlkYXRlIGlzIGluc3RhbGxlZC5cclxuICAgIGlmICghcGx1Z2luSW5zdGFuY2UpIHtcclxuICAgICAgaWYgKCFwZW5kaW5nUGx1Z2lucykge1xyXG4gICAgICAgIHBlbmRpbmdQbHVnaW5zID0gW107XHJcbiAgICAgIH1cclxuICAgICAgcGVuZGluZ1BsdWdpbnMucHVzaCh7IHBsdWdpbjogcGx1Z2luLCBvcHRpb25zOiBvcHRpb25zIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgcGx1Z2luKHsgVmFsaWRhdG9yOiBWYWxpZGF0b3IsIEVycm9yQmFnOiBFcnJvckJhZywgUnVsZXM6IFZhbGlkYXRvci5ydWxlcyB9LCBvcHRpb25zKTtcclxuICB9O1xyXG4gIFZlZVZhbGlkYXRlJDEuaW5zdGFsbCA9IGZ1bmN0aW9uIGluc3RhbGwgKF9WdWUsIG9wdHMpIHtcclxuICAgIGlmIChWdWUgJiYgX1Z1ZSA9PT0gVnVlKSB7XHJcbiAgICAgIHtcclxuICAgICAgICB3YXJuKCdhbHJlYWR5IGluc3RhbGxlZCwgVnVlLnVzZShWZWVWYWxpZGF0ZSkgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UuJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIFZ1ZSA9IF9WdWU7XHJcbiAgICBwbHVnaW5JbnN0YW5jZSA9IG5ldyBWZWVWYWxpZGF0ZSQxKG9wdHMpO1xyXG5cclxuICAgIGRldGVjdFBhc3NpdmVTdXBwb3J0KCk7XHJcblxyXG4gICAgVnVlLm1peGluKG1peGluKTtcclxuICAgIFZ1ZS5kaXJlY3RpdmUoJ3ZhbGlkYXRlJywgZGlyZWN0aXZlKTtcclxuICAgIGlmIChwZW5kaW5nUGx1Z2lucykge1xyXG4gICAgICBwZW5kaW5nUGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICB2YXIgcGx1Z2luID0gcmVmLnBsdWdpbjtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuXHJcbiAgICAgICAgVmVlVmFsaWRhdGUkMS51c2UocGx1Z2luLCBvcHRpb25zKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHBlbmRpbmdQbHVnaW5zID0gbnVsbDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBzdGF0aWNBY2Nlc3NvcnMkMi5pbnN0YW5jZS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gcGx1Z2luSW5zdGFuY2U7XHJcbiAgfTtcclxuXHJcbiAgcHJvdG90eXBlQWNjZXNzb3JzJDYuaTE4bkRyaXZlci5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gRGljdGlvbmFyeVJlc29sdmVyLmdldERyaXZlcigpO1xyXG4gIH07XHJcblxyXG4gIHN0YXRpY0FjY2Vzc29ycyQyLmkxOG5Ecml2ZXIuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIERpY3Rpb25hcnlSZXNvbHZlci5nZXREcml2ZXIoKTtcclxuICB9O1xyXG5cclxuICBwcm90b3R5cGVBY2Nlc3NvcnMkNi5jb25maWcuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGN1cnJlbnRDb25maWc7XHJcbiAgfTtcclxuXHJcbiAgc3RhdGljQWNjZXNzb3JzJDIuY29uZmlnLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBjdXJyZW50Q29uZmlnO1xyXG4gIH07XHJcblxyXG4gIFZlZVZhbGlkYXRlJDEucHJvdG90eXBlLl9pbml0Vk0gPSBmdW5jdGlvbiBfaW5pdFZNIChjb25maWcpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICB0aGlzLl92bSA9IG5ldyBWdWUoe1xyXG4gICAgICBkYXRhOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xyXG4gICAgICAgIGVycm9yczogdGhpcyQxLl92YWxpZGF0b3IuZXJyb3JzLFxyXG4gICAgICAgIGZpZWxkczogdGhpcyQxLl92YWxpZGF0b3IuZmllbGRzXHJcbiAgICAgIH0pOyB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBWZWVWYWxpZGF0ZSQxLnByb3RvdHlwZS5faW5pdEkxOG4gPSBmdW5jdGlvbiBfaW5pdEkxOG4gKGNvbmZpZykge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgIHZhciBkaWN0aW9uYXJ5ID0gY29uZmlnLmRpY3Rpb25hcnk7XG4gICAgICB2YXIgaTE4biA9IGNvbmZpZy5pMThuO1xuICAgICAgdmFyIGkxOG5Sb290S2V5ID0gY29uZmlnLmkxOG5Sb290S2V5O1xuICAgICAgdmFyIGxvY2FsZSA9IGNvbmZpZy5sb2NhbGU7XHJcbiAgICB2YXIgb25Mb2NhbGVDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzJDEuX3ZhbGlkYXRvci5lcnJvcnMucmVnZW5lcmF0ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBpMTggaXMgYmVpbmcgdXNlZCBmb3IgbG9jYWxpemF0aW9uLlxyXG4gICAgaWYgKGkxOG4pIHtcclxuICAgICAgVmVlVmFsaWRhdGUkMS5zZXRJMThuRHJpdmVyKCdpMThuJywgbmV3IEkxOG5EaWN0aW9uYXJ5KGkxOG4sIGkxOG5Sb290S2V5KSk7XHJcbiAgICAgIGkxOG4uX3ZtLiR3YXRjaCgnbG9jYWxlJywgb25Mb2NhbGVDaGFuZ2VkKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdGhpcy5fdm0uJG9uKCdsb2NhbGVDaGFuZ2VkJywgb25Mb2NhbGVDaGFuZ2VkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGljdGlvbmFyeSkge1xyXG4gICAgICB0aGlzLmkxOG5Ecml2ZXIubWVyZ2UoZGljdGlvbmFyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxvY2FsZSAmJiAhaTE4bikge1xyXG4gICAgICB0aGlzLl92YWxpZGF0b3IubG9jYWxpemUobG9jYWxlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBWZWVWYWxpZGF0ZSQxLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiBjb25maWd1cmUgKGNmZykge1xyXG4gICAgVmVlVmFsaWRhdGUkMS5jb25maWd1cmUoY2ZnKTtcclxuICB9O1xyXG5cclxuICBWZWVWYWxpZGF0ZSQxLnByb3RvdHlwZS5yZXNvbHZlQ29uZmlnID0gZnVuY3Rpb24gcmVzb2x2ZUNvbmZpZyAoY3R4KSB7XHJcbiAgICB2YXIgc2VsZkNvbmZpZyA9IGdldFBhdGgoJyRvcHRpb25zLiRfdmVlVmFsaWRhdGUnLCBjdHgsIHt9KTtcclxuXHJcbiAgICByZXR1cm4gYXNzaWduKHt9LCB0aGlzLmNvbmZpZywgc2VsZkNvbmZpZyk7XHJcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVmVlVmFsaWRhdGUkMS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQ2ICk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWZWVWYWxpZGF0ZSQxLCBzdGF0aWNBY2Nlc3NvcnMkMiApO1xyXG5cclxuICBWZWVWYWxpZGF0ZSQxLnZlcnNpb24gPSAnMi4xLjcnO1xyXG4gIFZlZVZhbGlkYXRlJDEubWl4aW4gPSBtaXhpbjtcclxuICBWZWVWYWxpZGF0ZSQxLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuICBWZWVWYWxpZGF0ZSQxLlZhbGlkYXRvciA9IFZhbGlkYXRvcjtcclxuICBWZWVWYWxpZGF0ZSQxLkVycm9yQmFnID0gRXJyb3JCYWc7XHJcbiAgVmVlVmFsaWRhdGUkMS5tYXBGaWVsZHMgPSBtYXBGaWVsZHM7XHJcbiAgVmVlVmFsaWRhdGUkMS5WYWxpZGF0aW9uUHJvdmlkZXIgPSBWYWxpZGF0aW9uUHJvdmlkZXI7XHJcbiAgVmVlVmFsaWRhdGUkMS5WYWxpZGF0aW9uT2JzZXJ2ZXIgPSBWYWxpZGF0aW9uT2JzZXJ2ZXI7XHJcbiAgVmVlVmFsaWRhdGUkMS53aXRoVmFsaWRhdGlvbiA9IHdpdGhWYWxpZGF0aW9uO1xuXG4gIC8qKlxyXG4gICAqIEZvcm1hdGVzIGZpbGUgc2l6ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gc2l6ZVxyXG4gICAqL1xyXG4gIHZhciBmb3JtYXRGaWxlU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICB2YXIgdW5pdHMgPSBbJ0J5dGUnLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXTtcclxuICAgIHZhciB0aHJlc2hvbGQgPSAxMDI0O1xyXG4gICAgc2l6ZSA9IE51bWJlcihzaXplKSAqIHRocmVzaG9sZDtcclxuICAgIHZhciBpID0gc2l6ZSA9PT0gMCA/IDAgOiBNYXRoLmZsb29yKE1hdGgubG9nKHNpemUpIC8gTWF0aC5sb2codGhyZXNob2xkKSk7XHJcbiAgICByZXR1cm4gKCgoc2l6ZSAvIE1hdGgucG93KHRocmVzaG9sZCwgaSkpLnRvRml4ZWQoMikgKiAxKSArIFwiIFwiICsgKHVuaXRzW2ldKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHZlZS12YWxpZGF0ZSBpcyBkZWZpbmVkIGdsb2JhbGx5LlxyXG4gICAqL1xyXG4gIHZhciBpc0RlZmluZWRHbG9iYWxseSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0eXBlb2YgVmVlVmFsaWRhdGUgIT09ICd1bmRlZmluZWQnO1xyXG4gIH07XG5cbiAgdmFyIG9iajtcblxyXG4gIHZhciBtZXNzYWdlcyA9IHtcclxuICAgIF9kZWZhdWx0OiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgdmFsdWUgaXMgbm90IHZhbGlkLlwiKTsgfSxcclxuICAgIGFmdGVyOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgICAgdmFyIHRhcmdldCA9IHJlZlswXTtcbiAgICAgIHZhciBpbmNsdXNpb24gPSByZWZbMV07XG5cbiAgICAgIHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIG11c3QgYmUgYWZ0ZXIgXCIgKyAoaW5jbHVzaW9uID8gJ29yIGVxdWFsIHRvICcgOiAnJykgKyB0YXJnZXQgKyBcIi5cIik7XG4gIH0sXHJcbiAgICBhbHBoYTogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gYWxwaGFiZXRpYyBjaGFyYWN0ZXJzLlwiKTsgfSxcclxuICAgIGFscGhhX2Rhc2g6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtYXkgY29udGFpbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMgYXMgd2VsbCBhcyBkYXNoZXMgYW5kIHVuZGVyc2NvcmVzLlwiKTsgfSxcclxuICAgIGFscGhhX251bTogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLlwiKTsgfSxcclxuICAgIGFscGhhX3NwYWNlczogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gYWxwaGFiZXRpYyBjaGFyYWN0ZXJzIGFzIHdlbGwgYXMgc3BhY2VzLlwiKTsgfSxcclxuICAgIGJlZm9yZTogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICAgIHZhciB0YXJnZXQgPSByZWZbMF07XG4gICAgICB2YXIgaW5jbHVzaW9uID0gcmVmWzFdO1xuXG4gICAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBtdXN0IGJlIGJlZm9yZSBcIiArIChpbmNsdXNpb24gPyAnb3IgZXF1YWwgdG8gJyA6ICcnKSArIHRhcmdldCArIFwiLlwiKTtcbiAgfSxcclxuICAgIGJldHdlZW46IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgICB2YXIgbWluID0gcmVmWzBdO1xuICAgICAgdmFyIG1heCA9IHJlZlsxXTtcblxuICAgICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBiZXR3ZWVuIFwiICsgbWluICsgXCIgYW5kIFwiICsgbWF4ICsgXCIuXCIpO1xuICB9LFxyXG4gICAgY29uZmlybWVkOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgY29uZmlybWF0aW9uIGRvZXMgbm90IG1hdGNoLlwiKTsgfSxcclxuICAgIGNyZWRpdF9jYXJkOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgaXMgaW52YWxpZC5cIik7IH0sXHJcbiAgICBkYXRlX2JldHdlZW46IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgICB2YXIgbWluID0gcmVmWzBdO1xuICAgICAgdmFyIG1heCA9IHJlZlsxXTtcblxuICAgICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgbXVzdCBiZSBiZXR3ZWVuIFwiICsgbWluICsgXCIgYW5kIFwiICsgbWF4ICsgXCIuXCIpO1xuICB9LFxyXG4gICAgZGF0ZV9mb3JtYXQ6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgICB2YXIgZm9ybWF0ID0gcmVmWzBdO1xuXG4gICAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBtdXN0IGJlIGluIHRoZSBmb3JtYXQgXCIgKyBmb3JtYXQgKyBcIi5cIik7XG4gIH0sXHJcbiAgICBkZWNpbWFsOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtdO1xuICAgICAgdmFyIGRlY2ltYWxzID0gcmVmWzBdOyBpZiAoIGRlY2ltYWxzID09PSB2b2lkIDAgKSBkZWNpbWFscyA9ICcqJztcblxuICAgICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBudW1lcmljIGFuZCBtYXkgY29udGFpbiBcIiArICghZGVjaW1hbHMgfHwgZGVjaW1hbHMgPT09ICcqJyA/ICcnIDogZGVjaW1hbHMpICsgXCIgZGVjaW1hbCBwb2ludHMuXCIpO1xuICB9LFxyXG4gICAgZGlnaXRzOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgICAgdmFyIGxlbmd0aCA9IHJlZlswXTtcblxuICAgICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBudW1lcmljIGFuZCBleGFjdGx5IGNvbnRhaW4gXCIgKyBsZW5ndGggKyBcIiBkaWdpdHMuXCIpO1xuICB9LFxyXG4gICAgZGltZW5zaW9uczogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICAgIHZhciB3aWR0aCA9IHJlZlswXTtcbiAgICAgIHZhciBoZWlnaHQgPSByZWZbMV07XG5cbiAgICAgIHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgXCIgKyB3aWR0aCArIFwiIHBpeGVscyBieSBcIiArIGhlaWdodCArIFwiIHBpeGVscy5cIik7XG4gIH0sXHJcbiAgICBlbWFpbDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgYSB2YWxpZCBlbWFpbC5cIik7IH0sXHJcbiAgICBleGNsdWRlZDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgYSB2YWxpZCB2YWx1ZS5cIik7IH0sXHJcbiAgICBleHQ6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgZmlsZS5cIik7IH0sXHJcbiAgICBpbWFnZTogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgYW4gaW1hZ2UuXCIpOyB9LFxyXG4gICAgaW5jbHVkZWQ6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgdmFsdWUuXCIpOyB9LFxyXG4gICAgaW50ZWdlcjogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgYW4gaW50ZWdlci5cIik7IH0sXHJcbiAgICBpcDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG11c3QgYmUgYSB2YWxpZCBpcCBhZGRyZXNzLlwiKTsgfSxcclxuICAgIGxlbmd0aDogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICAgIHZhciBsZW5ndGggPSByZWZbMF07XG4gICAgICB2YXIgbWF4ID0gcmVmWzFdO1xuXHJcbiAgICAgIGlmIChtYXgpIHtcclxuICAgICAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBsZW5ndGggbXVzdCBiZSBiZXR3ZWVuIFwiICsgbGVuZ3RoICsgXCIgYW5kIFwiICsgbWF4ICsgXCIuXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBsZW5ndGggbXVzdCBiZSBcIiArIGxlbmd0aCArIFwiLlwiKTtcclxuICAgIH0sXHJcbiAgICBtYXg6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcmVmWzBdO1xuXG4gICAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiBcIiArIGxlbmd0aCArIFwiIGNoYXJhY3RlcnMuXCIpO1xuICB9LFxyXG4gICAgbWF4X3ZhbHVlOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgICAgdmFyIG1heCA9IHJlZlswXTtcblxuICAgICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBcIiArIG1heCArIFwiIG9yIGxlc3MuXCIpO1xuICB9LFxyXG4gICAgbWltZXM6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBtdXN0IGhhdmUgYSB2YWxpZCBmaWxlIHR5cGUuXCIpOyB9LFxyXG4gICAgbWluOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgICAgdmFyIGxlbmd0aCA9IHJlZlswXTtcblxuICAgICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBhdCBsZWFzdCBcIiArIGxlbmd0aCArIFwiIGNoYXJhY3RlcnMuXCIpO1xuICB9LFxyXG4gICAgbWluX3ZhbHVlOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xuICAgICAgdmFyIG1pbiA9IHJlZlswXTtcblxuICAgICAgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgbXVzdCBiZSBcIiArIG1pbiArIFwiIG9yIG1vcmUuXCIpO1xuICB9LFxyXG4gICAgbnVtZXJpYzogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gbnVtZXJpYyBjaGFyYWN0ZXJzLlwiKTsgfSxcclxuICAgIHJlZ2V4OiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcIlRoZSBcIiArIGZpZWxkICsgXCIgZmllbGQgZm9ybWF0IGlzIGludmFsaWQuXCIpOyB9LFxyXG4gICAgcmVxdWlyZWQ6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBmaWVsZCBpcyByZXF1aXJlZC5cIik7IH0sXHJcbiAgICByZXF1aXJlZF9pZjogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICAgIHZhciB0YXJnZXQgPSByZWZbMF07XG5cbiAgICAgIHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIGlzIHJlcXVpcmVkIHdoZW4gdGhlIFwiICsgdGFyZ2V0ICsgXCIgZmllbGQgaGFzIHRoaXMgdmFsdWUuXCIpO1xuICB9LFxyXG4gICAgc2l6ZTogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcbiAgICAgIHZhciBzaXplID0gcmVmWzBdO1xuXG4gICAgICByZXR1cm4gKFwiVGhlIFwiICsgZmllbGQgKyBcIiBzaXplIG11c3QgYmUgbGVzcyB0aGFuIFwiICsgKGZvcm1hdEZpbGVTaXplKHNpemUpKSArIFwiLlwiKTtcbiAgfSxcclxuICAgIHVybDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXCJUaGUgXCIgKyBmaWVsZCArIFwiIGZpZWxkIGlzIG5vdCBhIHZhbGlkIFVSTC5cIik7IH1cclxuICB9O1xyXG5cclxuICB2YXIgbG9jYWxlJDEgPSB7XHJcbiAgICBuYW1lOiAnZW4nLFxyXG4gICAgbWVzc2FnZXM6IG1lc3NhZ2VzLFxyXG4gICAgYXR0cmlidXRlczoge31cclxuICB9O1xyXG5cclxuICBpZiAoaXNEZWZpbmVkR2xvYmFsbHkoKSkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICBWZWVWYWxpZGF0ZS5WYWxpZGF0b3IubG9jYWxpemUoKCBvYmogPSB7fSwgb2JqW2xvY2FsZSQxLm5hbWVdID0gbG9jYWxlJDEsIG9iaiApKTtcclxuICB9XG5cbiAgLy8gcnVsZXMgcGx1Z2luIGRlZmluaXRpb24uXHJcblxyXG4gIE9iamVjdC5rZXlzKFJ1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICBWZWVWYWxpZGF0ZSQxLlZhbGlkYXRvci5leHRlbmQocnVsZSwgUnVsZXNbcnVsZV0udmFsaWRhdGUsIGFzc2lnbih7fSwgUnVsZXNbcnVsZV0ub3B0aW9ucywgeyBwYXJhbU5hbWVzOiBSdWxlc1tydWxlXS5wYXJhbU5hbWVzIH0pKTtcclxuICB9KTtcclxuXHJcbiAgLy8gTWVyZ2UgdGhlIGVuZ2xpc2ggbWVzc2FnZXMuXHJcbiAgVmVlVmFsaWRhdGUkMS5WYWxpZGF0b3IubG9jYWxpemUoe1xyXG4gICAgZW46IGxvY2FsZSQxXHJcbiAgfSk7XHJcblxyXG4gIFZlZVZhbGlkYXRlJDEuUnVsZXMgPSBSdWxlcztcblxuICByZXR1cm4gVmVlVmFsaWRhdGUkMTtcblxufSkpO1xuIiwiLyoqXG4gICogdnVlLXJvdXRlciB2My4wLjFcbiAgKiAoYykgMjAxNyBFdmFuIFlvdVxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25kaXRpb24pIHtcbiAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yIChlcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpLmluZGV4T2YoJ0Vycm9yJykgPiAtMVxufVxuXG52YXIgVmlldyA9IHtcbiAgbmFtZTogJ3JvdXRlci12aWV3JyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGVmYXVsdCdcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChfLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG5cbiAgICBkYXRhLnJvdXRlclZpZXcgPSB0cnVlO1xuXG4gICAgLy8gZGlyZWN0bHkgdXNlIHBhcmVudCBjb250ZXh0J3MgY3JlYXRlRWxlbWVudCgpIGZ1bmN0aW9uXG4gICAgLy8gc28gdGhhdCBjb21wb25lbnRzIHJlbmRlcmVkIGJ5IHJvdXRlci12aWV3IGNhbiByZXNvbHZlIG5hbWVkIHNsb3RzXG4gICAgdmFyIGggPSBwYXJlbnQuJGNyZWF0ZUVsZW1lbnQ7XG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICAgIHZhciByb3V0ZSA9IHBhcmVudC4kcm91dGU7XG4gICAgdmFyIGNhY2hlID0gcGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgfHwgKHBhcmVudC5fcm91dGVyVmlld0NhY2hlID0ge30pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGN1cnJlbnQgdmlldyBkZXB0aCwgYWxzbyBjaGVjayB0byBzZWUgaWYgdGhlIHRyZWVcbiAgICAvLyBoYXMgYmVlbiB0b2dnbGVkIGluYWN0aXZlIGJ1dCBrZXB0LWFsaXZlLlxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIGluYWN0aXZlID0gZmFsc2U7XG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuX3JvdXRlclJvb3QgIT09IHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC4kdm5vZGUgJiYgcGFyZW50LiR2bm9kZS5kYXRhLnJvdXRlclZpZXcpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuX2luYWN0aXZlKSB7XG4gICAgICAgIGluYWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBkYXRhLnJvdXRlclZpZXdEZXB0aCA9IGRlcHRoO1xuXG4gICAgLy8gcmVuZGVyIHByZXZpb3VzIHZpZXcgaWYgdGhlIHRyZWUgaXMgaW5hY3RpdmUgYW5kIGtlcHQtYWxpdmVcbiAgICBpZiAoaW5hY3RpdmUpIHtcbiAgICAgIHJldHVybiBoKGNhY2hlW25hbWVdLCBkYXRhLCBjaGlsZHJlbilcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IHJvdXRlLm1hdGNoZWRbZGVwdGhdO1xuICAgIC8vIHJlbmRlciBlbXB0eSBub2RlIGlmIG5vIG1hdGNoZWQgcm91dGVcbiAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgIGNhY2hlW25hbWVdID0gbnVsbDtcbiAgICAgIHJldHVybiBoKClcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50ID0gY2FjaGVbbmFtZV0gPSBtYXRjaGVkLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgICAvLyBhdHRhY2ggaW5zdGFuY2UgcmVnaXN0cmF0aW9uIGhvb2tcbiAgICAvLyB0aGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBpbnN0YW5jZSdzIGluamVjdGVkIGxpZmVjeWNsZSBob29rc1xuICAgIGRhdGEucmVnaXN0ZXJSb3V0ZUluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCB2YWwpIHtcbiAgICAgIC8vIHZhbCBjb3VsZCBiZSB1bmRlZmluZWQgZm9yIHVucmVnaXN0cmF0aW9uXG4gICAgICB2YXIgY3VycmVudCA9IG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICAodmFsICYmIGN1cnJlbnQgIT09IHZtKSB8fFxuICAgICAgICAoIXZhbCAmJiBjdXJyZW50ID09PSB2bSlcbiAgICAgICkge1xuICAgICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbHNvIHJlZ2lzdGVyIGluc3RhbmNlIGluIHByZXBhdGNoIGhvb2tcbiAgICAvLyBpbiBjYXNlIHRoZSBzYW1lIGNvbXBvbmVudCBpbnN0YW5jZSBpcyByZXVzZWQgYWNyb3NzIGRpZmZlcmVudCByb3V0ZXNcbiAgICA7KGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pKS5wcmVwYXRjaCA9IGZ1bmN0aW9uIChfLCB2bm9kZSkge1xuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgLy8gcmVzb2x2ZSBwcm9wc1xuICAgIHZhciBwcm9wc1RvUGFzcyA9IGRhdGEucHJvcHMgPSByZXNvbHZlUHJvcHMocm91dGUsIG1hdGNoZWQucHJvcHMgJiYgbWF0Y2hlZC5wcm9wc1tuYW1lXSk7XG4gICAgaWYgKHByb3BzVG9QYXNzKSB7XG4gICAgICAvLyBjbG9uZSB0byBwcmV2ZW50IG11dGF0aW9uXG4gICAgICBwcm9wc1RvUGFzcyA9IGRhdGEucHJvcHMgPSBleHRlbmQoe30sIHByb3BzVG9QYXNzKTtcbiAgICAgIC8vIHBhc3Mgbm9uLWRlY2xhcmVkIHByb3BzIGFzIGF0dHJzXG4gICAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzID0gZGF0YS5hdHRycyB8fCB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wc1RvUGFzcykge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5wcm9wcyB8fCAhKGtleSBpbiBjb21wb25lbnQucHJvcHMpKSB7XG4gICAgICAgICAgYXR0cnNba2V5XSA9IHByb3BzVG9QYXNzW2tleV07XG4gICAgICAgICAgZGVsZXRlIHByb3BzVG9QYXNzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaChjb21wb25lbnQsIGRhdGEsIGNoaWxkcmVuKVxuICB9XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlUHJvcHMgKHJvdXRlLCBjb25maWcpIHtcbiAgc3dpdGNoICh0eXBlb2YgY29uZmlnKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVyblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gY29uZmlnXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIGNvbmZpZyhyb3V0ZSlcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBjb25maWcgPyByb3V0ZS5wYXJhbXMgOiB1bmRlZmluZWRcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcInByb3BzIGluIFxcXCJcIiArIChyb3V0ZS5wYXRoKSArIFwiXFxcIiBpcyBhIFwiICsgKHR5cGVvZiBjb25maWcpICsgXCIsIFwiICtcbiAgICAgICAgICBcImV4cGVjdGluZyBhbiBvYmplY3QsIGZ1bmN0aW9uIG9yIGJvb2xlYW4uXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyogICovXG5cbnZhciBlbmNvZGVSZXNlcnZlUkUgPSAvWyEnKCkqXS9nO1xudmFyIGVuY29kZVJlc2VydmVSZXBsYWNlciA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpOyB9O1xudmFyIGNvbW1hUkUgPSAvJTJDL2c7XG5cbi8vIGZpeGVkIGVuY29kZVVSSUNvbXBvbmVudCB3aGljaCBpcyBtb3JlIGNvbmZvcm1hbnQgdG8gUkZDMzk4Njpcbi8vIC0gZXNjYXBlcyBbIScoKSpdXG4vLyAtIHByZXNlcnZlIGNvbW1hc1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIC5yZXBsYWNlKGVuY29kZVJlc2VydmVSRSwgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyKVxuICAucmVwbGFjZShjb21tYVJFLCAnLCcpOyB9O1xuXG52YXIgZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xuXG5mdW5jdGlvbiByZXNvbHZlUXVlcnkgKFxuICBxdWVyeSxcbiAgZXh0cmFRdWVyeSxcbiAgX3BhcnNlUXVlcnlcbikge1xuICBpZiAoIGV4dHJhUXVlcnkgPT09IHZvaWQgMCApIGV4dHJhUXVlcnkgPSB7fTtcblxuICB2YXIgcGFyc2UgPSBfcGFyc2VRdWVyeSB8fCBwYXJzZVF1ZXJ5O1xuICB2YXIgcGFyc2VkUXVlcnk7XG4gIHRyeSB7XG4gICAgcGFyc2VkUXVlcnkgPSBwYXJzZShxdWVyeSB8fCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIGUubWVzc2FnZSk7XG4gICAgcGFyc2VkUXVlcnkgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gZXh0cmFRdWVyeSkge1xuICAgIHBhcnNlZFF1ZXJ5W2tleV0gPSBleHRyYVF1ZXJ5W2tleV07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZFF1ZXJ5XG59XG5cbmZ1bmN0aW9uIHBhcnNlUXVlcnkgKHF1ZXJ5KSB7XG4gIHZhciByZXMgPSB7fTtcblxuICBxdWVyeSA9IHF1ZXJ5LnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpO1xuXG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBxdWVyeS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRzLnNoaWZ0KCkpO1xuICAgIHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwXG4gICAgICA/IGRlY29kZShwYXJ0cy5qb2luKCc9JykpXG4gICAgICA6IG51bGw7XG5cbiAgICBpZiAocmVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzW2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc1trZXldKSkge1xuICAgICAgcmVzW2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNba2V5XSA9IFtyZXNba2V5XSwgdmFsXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkgKG9iaikge1xuICB2YXIgcmVzID0gb2JqID8gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSBvYmpba2V5XTtcblxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVuY29kZShrZXkpXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24gKHZhbDIpIHtcbiAgICAgICAgaWYgKHZhbDIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbDIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyYnKVxuICAgIH1cblxuICAgIHJldHVybiBlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwpXG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5sZW5ndGggPiAwOyB9KS5qb2luKCcmJykgOiBudWxsO1xuICByZXR1cm4gcmVzID8gKFwiP1wiICsgcmVzKSA6ICcnXG59XG5cbi8qICAqL1xuXG5cbnZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvPyQvO1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZSAoXG4gIHJlY29yZCxcbiAgbG9jYXRpb24sXG4gIHJlZGlyZWN0ZWRGcm9tLFxuICByb3V0ZXJcbikge1xuICB2YXIgc3RyaW5naWZ5UXVlcnkkJDEgPSByb3V0ZXIgJiYgcm91dGVyLm9wdGlvbnMuc3RyaW5naWZ5UXVlcnk7XG5cbiAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnkgfHwge307XG4gIHRyeSB7XG4gICAgcXVlcnkgPSBjbG9uZShxdWVyeSk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJvdXRlID0ge1xuICAgIG5hbWU6IGxvY2F0aW9uLm5hbWUgfHwgKHJlY29yZCAmJiByZWNvcmQubmFtZSksXG4gICAgbWV0YTogKHJlY29yZCAmJiByZWNvcmQubWV0YSkgfHwge30sXG4gICAgcGF0aDogbG9jYXRpb24ucGF0aCB8fCAnLycsXG4gICAgaGFzaDogbG9jYXRpb24uaGFzaCB8fCAnJyxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgcGFyYW1zOiBsb2NhdGlvbi5wYXJhbXMgfHwge30sXG4gICAgZnVsbFBhdGg6IGdldEZ1bGxQYXRoKGxvY2F0aW9uLCBzdHJpbmdpZnlRdWVyeSQkMSksXG4gICAgbWF0Y2hlZDogcmVjb3JkID8gZm9ybWF0TWF0Y2gocmVjb3JkKSA6IFtdXG4gIH07XG4gIGlmIChyZWRpcmVjdGVkRnJvbSkge1xuICAgIHJvdXRlLnJlZGlyZWN0ZWRGcm9tID0gZ2V0RnVsbFBhdGgocmVkaXJlY3RlZEZyb20sIHN0cmluZ2lmeVF1ZXJ5JCQxKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyb3V0ZSlcbn1cblxuZnVuY3Rpb24gY2xvbmUgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoY2xvbmUpXG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIHJlc1trZXldID0gY2xvbmUodmFsdWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG4vLyB0aGUgc3RhcnRpbmcgcm91dGUgdGhhdCByZXByZXNlbnRzIHRoZSBpbml0aWFsIHN0YXRlXG52YXIgU1RBUlQgPSBjcmVhdGVSb3V0ZShudWxsLCB7XG4gIHBhdGg6ICcvJ1xufSk7XG5cbmZ1bmN0aW9uIGZvcm1hdE1hdGNoIChyZWNvcmQpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB3aGlsZSAocmVjb3JkKSB7XG4gICAgcmVzLnVuc2hpZnQocmVjb3JkKTtcbiAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0RnVsbFBhdGggKFxuICByZWYsXG4gIF9zdHJpbmdpZnlRdWVyeVxuKSB7XG4gIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gIHZhciBxdWVyeSA9IHJlZi5xdWVyeTsgaWYgKCBxdWVyeSA9PT0gdm9pZCAwICkgcXVlcnkgPSB7fTtcbiAgdmFyIGhhc2ggPSByZWYuaGFzaDsgaWYgKCBoYXNoID09PSB2b2lkIDAgKSBoYXNoID0gJyc7XG5cbiAgdmFyIHN0cmluZ2lmeSA9IF9zdHJpbmdpZnlRdWVyeSB8fCBzdHJpbmdpZnlRdWVyeTtcbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnkocXVlcnkpICsgaGFzaFxufVxuXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZSAoYSwgYikge1xuICBpZiAoYiA9PT0gU1RBUlQpIHtcbiAgICByZXR1cm4gYSA9PT0gYlxuICB9IGVsc2UgaWYgKCFiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoYS5wYXRoICYmIGIucGF0aCkge1xuICAgIHJldHVybiAoXG4gICAgICBhLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSA9PT0gYi5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpXG4gICAgKVxuICB9IGVsc2UgaWYgKGEubmFtZSAmJiBiLm5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5uYW1lID09PSBiLm5hbWUgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucGFyYW1zLCBiLnBhcmFtcylcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFcXVhbCAoYSwgYikge1xuICBpZiAoIGEgPT09IHZvaWQgMCApIGEgPSB7fTtcbiAgaWYgKCBiID09PSB2b2lkIDAgKSBiID0ge307XG5cbiAgLy8gaGFuZGxlIG51bGwgdmFsdWUgIzE1NjZcbiAgaWYgKCFhIHx8ICFiKSB7IHJldHVybiBhID09PSBiIH1cbiAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBhVmFsID0gYVtrZXldO1xuICAgIHZhciBiVmFsID0gYltrZXldO1xuICAgIC8vIGNoZWNrIG5lc3RlZCBlcXVhbGl0eVxuICAgIGlmICh0eXBlb2YgYVZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJWYWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RFcXVhbChhVmFsLCBiVmFsKVxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGFWYWwpID09PSBTdHJpbmcoYlZhbClcbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNJbmNsdWRlZFJvdXRlIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgcmV0dXJuIChcbiAgICBjdXJyZW50LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJykuaW5kZXhPZihcbiAgICAgIHRhcmdldC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpXG4gICAgKSA9PT0gMCAmJlxuICAgICghdGFyZ2V0Lmhhc2ggfHwgY3VycmVudC5oYXNoID09PSB0YXJnZXQuaGFzaCkgJiZcbiAgICBxdWVyeUluY2x1ZGVzKGN1cnJlbnQucXVlcnksIHRhcmdldC5xdWVyeSlcbiAgKVxufVxuXG5mdW5jdGlvbiBxdWVyeUluY2x1ZGVzIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgIGlmICghKGtleSBpbiBjdXJyZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qICAqL1xuXG4vLyB3b3JrIGFyb3VuZCB3ZWlyZCBmbG93IGJ1Z1xudmFyIHRvVHlwZXMgPSBbU3RyaW5nLCBPYmplY3RdO1xudmFyIGV2ZW50VHlwZXMgPSBbU3RyaW5nLCBBcnJheV07XG5cbnZhciBMaW5rID0ge1xuICBuYW1lOiAncm91dGVyLWxpbmsnLFxuICBwcm9wczoge1xuICAgIHRvOiB7XG4gICAgICB0eXBlOiB0b1R5cGVzLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2EnXG4gICAgfSxcbiAgICBleGFjdDogQm9vbGVhbixcbiAgICBhcHBlbmQ6IEJvb2xlYW4sXG4gICAgcmVwbGFjZTogQm9vbGVhbixcbiAgICBhY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV4YWN0QWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogZXZlbnRUeXBlcyxcbiAgICAgIGRlZmF1bHQ6ICdjbGljaydcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy4kcm91dGVyO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy4kcm91dGU7XG4gICAgdmFyIHJlZiA9IHJvdXRlci5yZXNvbHZlKHRoaXMudG8sIGN1cnJlbnQsIHRoaXMuYXBwZW5kKTtcbiAgICB2YXIgbG9jYXRpb24gPSByZWYubG9jYXRpb247XG4gICAgdmFyIHJvdXRlID0gcmVmLnJvdXRlO1xuICAgIHZhciBocmVmID0gcmVmLmhyZWY7XG5cbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xuICAgIHZhciBnbG9iYWxBY3RpdmVDbGFzcyA9IHJvdXRlci5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcztcbiAgICB2YXIgZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyA9IHJvdXRlci5vcHRpb25zLmxpbmtFeGFjdEFjdGl2ZUNsYXNzO1xuICAgIC8vIFN1cHBvcnQgZ2xvYmFsIGVtcHR5IGFjdGl2ZSBjbGFzc1xuICAgIHZhciBhY3RpdmVDbGFzc0ZhbGxiYWNrID0gZ2xvYmFsQWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyAncm91dGVyLWxpbmstYWN0aXZlJ1xuICAgICAgICAgICAgOiBnbG9iYWxBY3RpdmVDbGFzcztcbiAgICB2YXIgZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrID0gZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/ICdyb3V0ZXItbGluay1leGFjdC1hY3RpdmUnXG4gICAgICAgICAgICA6IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3M7XG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gdGhpcy5hY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/IGFjdGl2ZUNsYXNzRmFsbGJhY2tcbiAgICAgICAgICAgIDogdGhpcy5hY3RpdmVDbGFzcztcbiAgICB2YXIgZXhhY3RBY3RpdmVDbGFzcyA9IHRoaXMuZXhhY3RBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/IGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFja1xuICAgICAgICAgICAgOiB0aGlzLmV4YWN0QWN0aXZlQ2xhc3M7XG4gICAgdmFyIGNvbXBhcmVUYXJnZXQgPSBsb2NhdGlvbi5wYXRoXG4gICAgICA/IGNyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uLCBudWxsLCByb3V0ZXIpXG4gICAgICA6IHJvdXRlO1xuXG4gICAgY2xhc3Nlc1tleGFjdEFjdGl2ZUNsYXNzXSA9IGlzU2FtZVJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuICAgIGNsYXNzZXNbYWN0aXZlQ2xhc3NdID0gdGhpcy5leGFjdFxuICAgICAgPyBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdXG4gICAgICA6IGlzSW5jbHVkZWRSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcblxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChndWFyZEV2ZW50KGUpKSB7XG4gICAgICAgIGlmICh0aGlzJDEucmVwbGFjZSkge1xuICAgICAgICAgIHJvdXRlci5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXIucHVzaChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9uID0geyBjbGljazogZ3VhcmRFdmVudCB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXZlbnQpKSB7XG4gICAgICB0aGlzLmV2ZW50LmZvckVhY2goZnVuY3Rpb24gKGUpIHsgb25bZV0gPSBoYW5kbGVyOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25bdGhpcy5ldmVudF0gPSBoYW5kbGVyO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgY2xhc3M6IGNsYXNzZXNcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMudGFnID09PSAnYScpIHtcbiAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIGRhdGEuYXR0cnMgPSB7IGhyZWY6IGhyZWYgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmluZCB0aGUgZmlyc3QgPGE+IGNoaWxkIGFuZCBhcHBseSBsaXN0ZW5lciBhbmQgaHJlZlxuICAgICAgdmFyIGEgPSBmaW5kQW5jaG9yKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgPGE+IGlzIGEgc3RhdGljIG5vZGVcbiAgICAgICAgYS5pc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXh0ZW5kID0gX1Z1ZS51dGlsLmV4dGVuZDtcbiAgICAgICAgdmFyIGFEYXRhID0gYS5kYXRhID0gZXh0ZW5kKHt9LCBhLmRhdGEpO1xuICAgICAgICBhRGF0YS5vbiA9IG9uO1xuICAgICAgICB2YXIgYUF0dHJzID0gYS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhLmRhdGEuYXR0cnMpO1xuICAgICAgICBhQXR0cnMuaHJlZiA9IGhyZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgPGE+IGNoaWxkLCBhcHBseSBsaXN0ZW5lciB0byBzZWxmXG4gICAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaCh0aGlzLnRhZywgZGF0YSwgdGhpcy4kc2xvdHMuZGVmYXVsdClcbiAgfVxufTtcblxuZnVuY3Rpb24gZ3VhcmRFdmVudCAoZSkge1xuICAvLyBkb24ndCByZWRpcmVjdCB3aXRoIGNvbnRyb2wga2V5c1xuICBpZiAoZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcbiAgaWYgKGUuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b24gIT09IDApIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3QgaWYgYHRhcmdldD1cIl9ibGFua1wiYFxuICBpZiAoZS5jdXJyZW50VGFyZ2V0ICYmIGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgaWYgKC9cXGJfYmxhbmtcXGIvaS50ZXN0KHRhcmdldCkpIHsgcmV0dXJuIH1cbiAgfVxuICAvLyB0aGlzIG1heSBiZSBhIFdlZXggZXZlbnQgd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kXG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbmRBbmNob3IgKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIHZhciBjaGlsZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ2EnKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIChjaGlsZCA9IGZpbmRBbmNob3IoY2hpbGQuY2hpbGRyZW4pKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIF9WdWU7XG5cbmZ1bmN0aW9uIGluc3RhbGwgKFZ1ZSkge1xuICBpZiAoaW5zdGFsbC5pbnN0YWxsZWQgJiYgX1Z1ZSA9PT0gVnVlKSB7IHJldHVybiB9XG4gIGluc3RhbGwuaW5zdGFsbGVkID0gdHJ1ZTtcblxuICBfVnVlID0gVnVlO1xuXG4gIHZhciBpc0RlZiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH07XG5cbiAgdmFyIHJlZ2lzdGVySW5zdGFuY2UgPSBmdW5jdGlvbiAodm0sIGNhbGxWYWwpIHtcbiAgICB2YXIgaSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgICBpZiAoaXNEZWYoaSkgJiYgaXNEZWYoaSA9IGkuZGF0YSkgJiYgaXNEZWYoaSA9IGkucmVnaXN0ZXJSb3V0ZUluc3RhbmNlKSkge1xuICAgICAgaSh2bSwgY2FsbFZhbCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5taXhpbih7XG4gICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiBiZWZvcmVDcmVhdGUgKCkge1xuICAgICAgaWYgKGlzRGVmKHRoaXMuJG9wdGlvbnMucm91dGVyKSkge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gdGhpcztcbiAgICAgICAgdGhpcy5fcm91dGVyID0gdGhpcy4kb3B0aW9ucy5yb3V0ZXI7XG4gICAgICAgIHRoaXMuX3JvdXRlci5pbml0KHRoaXMpO1xuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCAnX3JvdXRlJywgdGhpcy5fcm91dGVyLmhpc3RvcnkuY3VycmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gKHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuX3JvdXRlclJvb3QpIHx8IHRoaXM7XG4gICAgICB9XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIHRoaXMpO1xuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlcicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZXIgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZSB9XG4gIH0pO1xuXG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci12aWV3JywgVmlldyk7XG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci1saW5rJywgTGluayk7XG5cbiAgdmFyIHN0cmF0cyA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuICAvLyB1c2UgdGhlIHNhbWUgaG9vayBtZXJnaW5nIHN0cmF0ZWd5IGZvciByb3V0ZSBob29rc1xuICBzdHJhdHMuYmVmb3JlUm91dGVFbnRlciA9IHN0cmF0cy5iZWZvcmVSb3V0ZUxlYXZlID0gc3RyYXRzLmJlZm9yZVJvdXRlVXBkYXRlID0gc3RyYXRzLmNyZWF0ZWQ7XG59XG5cbi8qICAqL1xuXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlUGF0aCAoXG4gIHJlbGF0aXZlLFxuICBiYXNlLFxuICBhcHBlbmRcbikge1xuICB2YXIgZmlyc3RDaGFyID0gcmVsYXRpdmUuY2hhckF0KDApO1xuICBpZiAoZmlyc3RDaGFyID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVcbiAgfVxuXG4gIGlmIChmaXJzdENoYXIgPT09ICc/JyB8fCBmaXJzdENoYXIgPT09ICcjJykge1xuICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmVcbiAgfVxuXG4gIHZhciBzdGFjayA9IGJhc2Uuc3BsaXQoJy8nKTtcblxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgLy8gLSBub3QgYXBwZW5kaW5nXG4gIC8vIC0gYXBwZW5kaW5nIHRvIHRyYWlsaW5nIHNsYXNoIChsYXN0IHNlZ21lbnQgaXMgZW1wdHkpXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBwYXRoXG4gIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gJy4nKSB7XG4gICAgICBzdGFjay5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICBzdGFjay51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjay5qb2luKCcvJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBoYXNoID0gJyc7XG4gIHZhciBxdWVyeSA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgaGFzaCA9IHBhdGguc2xpY2UoaGFzaEluZGV4KTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgIHF1ZXJ5ID0gcGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblBhdGggKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvXFwvL2csICcvJylcbn1cblxudmFyIGlzYXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xudmFyIHBhdGhUb1JlZ2V4cF8xID0gcGF0aFRvUmVnZXhwO1xudmFyIHBhcnNlXzEgPSBwYXJzZTtcbnZhciBjb21waWxlXzEgPSBjb21waWxlO1xudmFyIHRva2Vuc1RvRnVuY3Rpb25fMSA9IHRva2Vuc1RvRnVuY3Rpb247XG52YXIgdG9rZW5zVG9SZWdFeHBfMSA9IHRva2Vuc1RvUmVnRXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBrZXkgPSAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgcGF0aCA9ICcnO1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nO1xuICB2YXIgcmVzO1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF07XG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV07XG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleDtcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KTtcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoO1xuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdO1xuICAgIHZhciBwcmVmaXggPSByZXNbMl07XG4gICAgdmFyIG5hbWUgPSByZXNbM107XG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF07XG4gICAgdmFyIGdyb3VwID0gcmVzWzVdO1xuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XTtcbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN107XG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXg7XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyO1xuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cDtcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKTtcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJyc7XG4gICAgdmFyIGRhdGEgPSBvYmogfHwge307XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW47XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXTtcbiAgICAgIHZhciBzZWdtZW50O1xuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKTtcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpO1xuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9ICcnO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KTtcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknO1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKTtcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXI7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPyc7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5wYXRoVG9SZWdleHBfMS5wYXJzZSA9IHBhcnNlXzE7XG5wYXRoVG9SZWdleHBfMS5jb21waWxlID0gY29tcGlsZV8xO1xucGF0aFRvUmVnZXhwXzEudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25fMTtcbnBhdGhUb1JlZ2V4cF8xLnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBfMTtcblxuLyogICovXG5cbi8vICRmbG93LWRpc2FibGUtbGluZVxudmFyIHJlZ2V4cENvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGZpbGxQYXJhbXMgKFxuICBwYXRoLFxuICBwYXJhbXMsXG4gIHJvdXRlTXNnXG4pIHtcbiAgdHJ5IHtcbiAgICB2YXIgZmlsbGVyID1cbiAgICAgIHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSB8fFxuICAgICAgKHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSA9IHBhdGhUb1JlZ2V4cF8xLmNvbXBpbGUocGF0aCkpO1xuICAgIHJldHVybiBmaWxsZXIocGFyYW1zIHx8IHt9LCB7IHByZXR0eTogdHJ1ZSB9KVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oZmFsc2UsIChcIm1pc3NpbmcgcGFyYW0gZm9yIFwiICsgcm91dGVNc2cgKyBcIjogXCIgKyAoZS5tZXNzYWdlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVNYXAgKFxuICByb3V0ZXMsXG4gIG9sZFBhdGhMaXN0LFxuICBvbGRQYXRoTWFwLFxuICBvbGROYW1lTWFwXG4pIHtcbiAgLy8gdGhlIHBhdGggbGlzdCBpcyB1c2VkIHRvIGNvbnRyb2wgcGF0aCBtYXRjaGluZyBwcmlvcml0eVxuICB2YXIgcGF0aExpc3QgPSBvbGRQYXRoTGlzdCB8fCBbXTtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciBwYXRoTWFwID0gb2xkUGF0aE1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIG5hbWVNYXAgPSBvbGROYW1lTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcm91dGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIHJvdXRlKTtcbiAgfSk7XG5cbiAgLy8gZW5zdXJlIHdpbGRjYXJkIHJvdXRlcyBhcmUgYWx3YXlzIGF0IHRoZSBlbmRcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAocGF0aExpc3RbaV0gPT09ICcqJykge1xuICAgICAgcGF0aExpc3QucHVzaChwYXRoTGlzdC5zcGxpY2UoaSwgMSlbMF0pO1xuICAgICAgbC0tO1xuICAgICAgaS0tO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aExpc3Q6IHBhdGhMaXN0LFxuICAgIHBhdGhNYXA6IHBhdGhNYXAsXG4gICAgbmFtZU1hcDogbmFtZU1hcFxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJvdXRlUmVjb3JkIChcbiAgcGF0aExpc3QsXG4gIHBhdGhNYXAsXG4gIG5hbWVNYXAsXG4gIHJvdXRlLFxuICBwYXJlbnQsXG4gIG1hdGNoQXNcbikge1xuICB2YXIgcGF0aCA9IHJvdXRlLnBhdGg7XG4gIHZhciBuYW1lID0gcm91dGUubmFtZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQocGF0aCAhPSBudWxsLCBcIlxcXCJwYXRoXFxcIiBpcyByZXF1aXJlZCBpbiBhIHJvdXRlIGNvbmZpZ3VyYXRpb24uXCIpO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiByb3V0ZS5jb21wb25lbnQgIT09ICdzdHJpbmcnLFxuICAgICAgXCJyb3V0ZSBjb25maWcgXFxcImNvbXBvbmVudFxcXCIgZm9yIHBhdGg6IFwiICsgKFN0cmluZyhwYXRoIHx8IG5hbWUpKSArIFwiIGNhbm5vdCBiZSBhIFwiICtcbiAgICAgIFwic3RyaW5nIGlkLiBVc2UgYW4gYWN0dWFsIGNvbXBvbmVudCBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgfVxuXG4gIHZhciBwYXRoVG9SZWdleHBPcHRpb25zID0gcm91dGUucGF0aFRvUmVnZXhwT3B0aW9ucyB8fCB7fTtcbiAgdmFyIG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChcbiAgICBwYXRoLFxuICAgIHBhcmVudCxcbiAgICBwYXRoVG9SZWdleHBPcHRpb25zLnN0cmljdFxuICApO1xuXG4gIGlmICh0eXBlb2Ygcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcGF0aFRvUmVnZXhwT3B0aW9ucy5zZW5zaXRpdmUgPSByb3V0ZS5jYXNlU2Vuc2l0aXZlO1xuICB9XG5cbiAgdmFyIHJlY29yZCA9IHtcbiAgICBwYXRoOiBub3JtYWxpemVkUGF0aCxcbiAgICByZWdleDogY29tcGlsZVJvdXRlUmVnZXgobm9ybWFsaXplZFBhdGgsIHBhdGhUb1JlZ2V4cE9wdGlvbnMpLFxuICAgIGNvbXBvbmVudHM6IHJvdXRlLmNvbXBvbmVudHMgfHwgeyBkZWZhdWx0OiByb3V0ZS5jb21wb25lbnQgfSxcbiAgICBpbnN0YW5jZXM6IHt9LFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgbWF0Y2hBczogbWF0Y2hBcyxcbiAgICByZWRpcmVjdDogcm91dGUucmVkaXJlY3QsXG4gICAgYmVmb3JlRW50ZXI6IHJvdXRlLmJlZm9yZUVudGVyLFxuICAgIG1ldGE6IHJvdXRlLm1ldGEgfHwge30sXG4gICAgcHJvcHM6IHJvdXRlLnByb3BzID09IG51bGxcbiAgICAgID8ge31cbiAgICAgIDogcm91dGUuY29tcG9uZW50c1xuICAgICAgICA/IHJvdXRlLnByb3BzXG4gICAgICAgIDogeyBkZWZhdWx0OiByb3V0ZS5wcm9wcyB9XG4gIH07XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgLy8gV2FybiBpZiByb3V0ZSBpcyBuYW1lZCwgZG9lcyBub3QgcmVkaXJlY3QgYW5kIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuXG4gICAgLy8gSWYgdXNlcnMgbmF2aWdhdGUgdG8gdGhpcyByb3V0ZSBieSBuYW1lLCB0aGUgZGVmYXVsdCBjaGlsZCB3aWxsXG4gICAgLy8gbm90IGJlIHJlbmRlcmVkIChHSCBJc3N1ZSAjNjI5KVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocm91dGUubmFtZSAmJiAhcm91dGUucmVkaXJlY3QgJiYgcm91dGUuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIC9eXFwvPyQvLnRlc3QoY2hpbGQucGF0aCk7IH0pKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJOYW1lZCBSb3V0ZSAnXCIgKyAocm91dGUubmFtZSkgKyBcIicgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS4gXCIgK1xuICAgICAgICAgIFwiV2hlbiBuYXZpZ2F0aW5nIHRvIHRoaXMgbmFtZWQgcm91dGUgKDp0bz1cXFwie25hbWU6ICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJ1xcXCIpLCBcIiArXG4gICAgICAgICAgXCJ0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSB3aWxsIG5vdCBiZSByZW5kZXJlZC4gUmVtb3ZlIHRoZSBuYW1lIGZyb20gXCIgK1xuICAgICAgICAgIFwidGhpcyByb3V0ZSBhbmQgdXNlIHRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIGZvciBuYW1lZCBcIiArXG4gICAgICAgICAgXCJsaW5rcyBpbnN0ZWFkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJvdXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGRNYXRjaEFzID0gbWF0Y2hBc1xuICAgICAgICA/IGNsZWFuUGF0aCgobWF0Y2hBcyArIFwiL1wiICsgKGNoaWxkLnBhdGgpKSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBhZGRSb3V0ZVJlY29yZChwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCwgY2hpbGQsIHJlY29yZCwgY2hpbGRNYXRjaEFzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyb3V0ZS5hbGlhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGFsaWFzZXMgPSBBcnJheS5pc0FycmF5KHJvdXRlLmFsaWFzKVxuICAgICAgPyByb3V0ZS5hbGlhc1xuICAgICAgOiBbcm91dGUuYWxpYXNdO1xuXG4gICAgYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgdmFyIGFsaWFzUm91dGUgPSB7XG4gICAgICAgIHBhdGg6IGFsaWFzLFxuICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgIH07XG4gICAgICBhZGRSb3V0ZVJlY29yZChcbiAgICAgICAgcGF0aExpc3QsXG4gICAgICAgIHBhdGhNYXAsXG4gICAgICAgIG5hbWVNYXAsXG4gICAgICAgIGFsaWFzUm91dGUsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcmVjb3JkLnBhdGggfHwgJy8nIC8vIG1hdGNoQXNcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIXBhdGhNYXBbcmVjb3JkLnBhdGhdKSB7XG4gICAgcGF0aExpc3QucHVzaChyZWNvcmQucGF0aCk7XG4gICAgcGF0aE1hcFtyZWNvcmQucGF0aF0gPSByZWNvcmQ7XG4gIH1cblxuICBpZiAobmFtZSkge1xuICAgIGlmICghbmFtZU1hcFtuYW1lXSkge1xuICAgICAgbmFtZU1hcFtuYW1lXSA9IHJlY29yZDtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIW1hdGNoQXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIkR1cGxpY2F0ZSBuYW1lZCByb3V0ZXMgZGVmaW5pdGlvbjogXCIgK1xuICAgICAgICBcInsgbmFtZTogXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgcGF0aDogXFxcIlwiICsgKHJlY29yZC5wYXRoKSArIFwiXFxcIiB9XCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVSb3V0ZVJlZ2V4IChwYXRoLCBwYXRoVG9SZWdleHBPcHRpb25zKSB7XG4gIHZhciByZWdleCA9IHBhdGhUb1JlZ2V4cF8xKHBhdGgsIFtdLCBwYXRoVG9SZWdleHBPcHRpb25zKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmVnZXgua2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHdhcm4oIWtleXNba2V5Lm5hbWVdLCAoXCJEdXBsaWNhdGUgcGFyYW0ga2V5cyBpbiByb3V0ZSB3aXRoIHBhdGg6IFxcXCJcIiArIHBhdGggKyBcIlxcXCJcIikpO1xuICAgICAga2V5c1trZXkubmFtZV0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZWdleFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoIChwYXRoLCBwYXJlbnQsIHN0cmljdCkge1xuICBpZiAoIXN0cmljdCkgeyBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpOyB9XG4gIGlmIChwYXRoWzBdID09PSAnLycpIHsgcmV0dXJuIHBhdGggfVxuICBpZiAocGFyZW50ID09IG51bGwpIHsgcmV0dXJuIHBhdGggfVxuICByZXR1cm4gY2xlYW5QYXRoKCgocGFyZW50LnBhdGgpICsgXCIvXCIgKyBwYXRoKSlcbn1cblxuLyogICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYXRpb24gKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIGFwcGVuZCxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIG5leHQgPSB0eXBlb2YgcmF3ID09PSAnc3RyaW5nJyA/IHsgcGF0aDogcmF3IH0gOiByYXc7XG4gIC8vIG5hbWVkIHRhcmdldFxuICBpZiAobmV4dC5uYW1lIHx8IG5leHQuX25vcm1hbGl6ZWQpIHtcbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgLy8gcmVsYXRpdmUgcGFyYW1zXG4gIGlmICghbmV4dC5wYXRoICYmIG5leHQucGFyYW1zICYmIGN1cnJlbnQpIHtcbiAgICBuZXh0ID0gYXNzaWduKHt9LCBuZXh0KTtcbiAgICBuZXh0Ll9ub3JtYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgcGFyYW1zID0gYXNzaWduKGFzc2lnbih7fSwgY3VycmVudC5wYXJhbXMpLCBuZXh0LnBhcmFtcyk7XG4gICAgaWYgKGN1cnJlbnQubmFtZSkge1xuICAgICAgbmV4dC5uYW1lID0gY3VycmVudC5uYW1lO1xuICAgICAgbmV4dC5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50Lm1hdGNoZWQubGVuZ3RoKSB7XG4gICAgICB2YXIgcmF3UGF0aCA9IGN1cnJlbnQubWF0Y2hlZFtjdXJyZW50Lm1hdGNoZWQubGVuZ3RoIC0gMV0ucGF0aDtcbiAgICAgIG5leHQucGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJwYXRoIFwiICsgKGN1cnJlbnQucGF0aCkpKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oZmFsc2UsIFwicmVsYXRpdmUgcGFyYW1zIG5hdmlnYXRpb24gcmVxdWlyZXMgYSBjdXJyZW50IHJvdXRlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIHZhciBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKG5leHQucGF0aCB8fCAnJyk7XG4gIHZhciBiYXNlUGF0aCA9IChjdXJyZW50ICYmIGN1cnJlbnQucGF0aCkgfHwgJy8nO1xuICB2YXIgcGF0aCA9IHBhcnNlZFBhdGgucGF0aFxuICAgID8gcmVzb2x2ZVBhdGgocGFyc2VkUGF0aC5wYXRoLCBiYXNlUGF0aCwgYXBwZW5kIHx8IG5leHQuYXBwZW5kKVxuICAgIDogYmFzZVBhdGg7XG5cbiAgdmFyIHF1ZXJ5ID0gcmVzb2x2ZVF1ZXJ5KFxuICAgIHBhcnNlZFBhdGgucXVlcnksXG4gICAgbmV4dC5xdWVyeSxcbiAgICByb3V0ZXIgJiYgcm91dGVyLm9wdGlvbnMucGFyc2VRdWVyeVxuICApO1xuXG4gIHZhciBoYXNoID0gbmV4dC5oYXNoIHx8IHBhcnNlZFBhdGguaGFzaDtcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xuICAgIGhhc2ggPSBcIiNcIiArIGhhc2g7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24gKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBhW2tleV0gPSBiW2tleV07XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuLyogICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2hlciAoXG4gIHJvdXRlcyxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHJlZiA9IGNyZWF0ZVJvdXRlTWFwKHJvdXRlcyk7XG4gIHZhciBwYXRoTGlzdCA9IHJlZi5wYXRoTGlzdDtcbiAgdmFyIHBhdGhNYXAgPSByZWYucGF0aE1hcDtcbiAgdmFyIG5hbWVNYXAgPSByZWYubmFtZU1hcDtcblxuICBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICAgIGNyZWF0ZVJvdXRlTWFwKHJvdXRlcywgcGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2ggKFxuICAgIHJhdyxcbiAgICBjdXJyZW50Um91dGUsXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24ocmF3LCBjdXJyZW50Um91dGUsIGZhbHNlLCByb3V0ZXIpO1xuICAgIHZhciBuYW1lID0gbG9jYXRpb24ubmFtZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YXIgcmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4ocmVjb3JkLCAoXCJSb3V0ZSB3aXRoIG5hbWUgJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlY29yZCkgeyByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKSB9XG4gICAgICB2YXIgcGFyYW1OYW1lcyA9IHJlY29yZC5yZWdleC5rZXlzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIWtleS5vcHRpb25hbDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkubmFtZTsgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24ucGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRSb3V0ZSAmJiB0eXBlb2YgY3VycmVudFJvdXRlLnBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnRSb3V0ZS5wYXJhbXMpIHtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gbG9jYXRpb24ucGFyYW1zKSAmJiBwYXJhbU5hbWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICBsb2NhdGlvbi5wYXJhbXNba2V5XSA9IGN1cnJlbnRSb3V0ZS5wYXJhbXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICBsb2NhdGlvbi5wYXRoID0gZmlsbFBhcmFtcyhyZWNvcmQucGF0aCwgbG9jYXRpb24ucGFyYW1zLCAoXCJuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGgpIHtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhMaXN0W2ldO1xuICAgICAgICB2YXIgcmVjb3JkJDEgPSBwYXRoTWFwW3BhdGhdO1xuICAgICAgICBpZiAobWF0Y2hSb3V0ZShyZWNvcmQkMS5yZWdleCwgbG9jYXRpb24ucGF0aCwgbG9jYXRpb24ucGFyYW1zKSkge1xuICAgICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkJDEsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBubyBtYXRjaFxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiByZWRpcmVjdCAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uXG4gICkge1xuICAgIHZhciBvcmlnaW5hbFJlZGlyZWN0ID0gcmVjb3JkLnJlZGlyZWN0O1xuICAgIHZhciByZWRpcmVjdCA9IHR5cGVvZiBvcmlnaW5hbFJlZGlyZWN0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3JpZ2luYWxSZWRpcmVjdChjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCBudWxsLCByb3V0ZXIpKVxuICAgICAgICA6IG9yaWdpbmFsUmVkaXJlY3Q7XG5cbiAgICBpZiAodHlwZW9mIHJlZGlyZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmVkaXJlY3QgPSB7IHBhdGg6IHJlZGlyZWN0IH07XG4gICAgfVxuXG4gICAgaWYgKCFyZWRpcmVjdCB8fCB0eXBlb2YgcmVkaXJlY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuXG4gICAgdmFyIHJlID0gcmVkaXJlY3Q7XG4gICAgdmFyIG5hbWUgPSByZS5uYW1lO1xuICAgIHZhciBwYXRoID0gcmUucGF0aDtcbiAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhcmFtcyA9IGxvY2F0aW9uLnBhcmFtcztcbiAgICBxdWVyeSA9IHJlLmhhc093blByb3BlcnR5KCdxdWVyeScpID8gcmUucXVlcnkgOiBxdWVyeTtcbiAgICBoYXNoID0gcmUuaGFzT3duUHJvcGVydHkoJ2hhc2gnKSA/IHJlLmhhc2ggOiBoYXNoO1xuICAgIHBhcmFtcyA9IHJlLmhhc093blByb3BlcnR5KCdwYXJhbXMnKSA/IHJlLnBhcmFtcyA6IHBhcmFtcztcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAvLyByZXNvbHZlZCBuYW1lZCBkaXJlY3RcbiAgICAgIHZhciB0YXJnZXRSZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KHRhcmdldFJlY29yZCwgKFwicmVkaXJlY3QgZmFpbGVkOiBuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XG4gICAgICAvLyAyLiByZXNvbHZlIHBhcmFtc1xuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxpYXMgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICBtYXRjaEFzXG4gICkge1xuICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKTtcbiAgICB2YXIgYWxpYXNlZE1hdGNoID0gbWF0Y2goe1xuICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICBwYXRoOiBhbGlhc2VkUGF0aFxuICAgIH0pO1xuICAgIGlmIChhbGlhc2VkTWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gYWxpYXNlZE1hdGNoLm1hdGNoZWQ7XG4gICAgICB2YXIgYWxpYXNlZFJlY29yZCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IGFsaWFzZWRNYXRjaC5wYXJhbXM7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKGFsaWFzZWRSZWNvcmQsIGxvY2F0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQucmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZWRpcmVjdChyZWNvcmQsIHJlZGlyZWN0ZWRGcm9tIHx8IGxvY2F0aW9uKVxuICAgIH1cbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5tYXRjaEFzKSB7XG4gICAgICByZXR1cm4gYWxpYXMocmVjb3JkLCBsb2NhdGlvbiwgcmVjb3JkLm1hdGNoQXMpXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSwgcm91dGVyKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgYWRkUm91dGVzOiBhZGRSb3V0ZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlIChcbiAgcmVnZXgsXG4gIHBhdGgsXG4gIHBhcmFtc1xuKSB7XG4gIHZhciBtID0gcGF0aC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gbS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBrZXkgPSByZWdleC5rZXlzW2kgLSAxXTtcbiAgICB2YXIgdmFsID0gdHlwZW9mIG1baV0gPT09ICdzdHJpbmcnID8gZGVjb2RlVVJJQ29tcG9uZW50KG1baV0pIDogbVtpXTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBwYXJhbXNba2V5Lm5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZWNvcmRQYXRoIChwYXRoLCByZWNvcmQpIHtcbiAgcmV0dXJuIHJlc29sdmVQYXRoKHBhdGgsIHJlY29yZC5wYXJlbnQgPyByZWNvcmQucGFyZW50LnBhdGggOiAnLycsIHRydWUpXG59XG5cbi8qICAqL1xuXG5cbnZhciBwb3NpdGlvblN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gc2V0dXBTY3JvbGwgKCkge1xuICAvLyBGaXggZm9yICMxNTg1IGZvciBGaXJlZm94XG4gIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogZ2V0U3RhdGVLZXkoKSB9LCAnJyk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgaWYgKGUuc3RhdGUgJiYgZS5zdGF0ZS5rZXkpIHtcbiAgICAgIHNldFN0YXRlS2V5KGUuc3RhdGUua2V5KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTY3JvbGwgKFxuICByb3V0ZXIsXG4gIHRvLFxuICBmcm9tLFxuICBpc1BvcFxuKSB7XG4gIGlmICghcm91dGVyLmFwcCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJlaGF2aW9yID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gIGlmICghYmVoYXZpb3IpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiZWhhdmlvciA9PT0gJ2Z1bmN0aW9uJywgXCJzY3JvbGxCZWhhdmlvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICAvLyB3YWl0IHVudGlsIHJlLXJlbmRlciBmaW5pc2hlcyBiZWZvcmUgc2Nyb2xsaW5nXG4gIHJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIHZhciBzaG91bGRTY3JvbGwgPSBiZWhhdmlvcih0bywgZnJvbSwgaXNQb3AgPyBwb3NpdGlvbiA6IG51bGwpO1xuXG4gICAgaWYgKCFzaG91bGRTY3JvbGwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2hvdWxkU2Nyb2xsLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNob3VsZFNjcm9sbC50aGVuKGZ1bmN0aW9uIChzaG91bGRTY3JvbGwpIHtcbiAgICAgICAgc2Nyb2xsVG9Qb3NpdGlvbigoc2hvdWxkU2Nyb2xsKSwgcG9zaXRpb24pO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGFzc2VydChmYWxzZSwgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Nyb2xsVG9Qb3NpdGlvbihzaG91bGRTY3JvbGwsIHBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHBvc2l0aW9uU3RvcmVba2V5XSA9IHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHJldHVybiBwb3NpdGlvblN0b3JlW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24gKGVsLCBvZmZzZXQpIHtcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgZG9jUmVjdCA9IGRvY0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQgLSBvZmZzZXQueCxcbiAgICB5OiBlbFJlY3QudG9wIC0gZG9jUmVjdC50b3AgLSBvZmZzZXQueVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiBpc051bWJlcihvYmoueCkgfHwgaXNOdW1iZXIob2JqLnkpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9mZnNldCAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiAwLFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogMFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gc2Nyb2xsVG9Qb3NpdGlvbiAoc2hvdWxkU2Nyb2xsLCBwb3NpdGlvbikge1xuICB2YXIgaXNPYmplY3QgPSB0eXBlb2Ygc2hvdWxkU2Nyb2xsID09PSAnb2JqZWN0JztcbiAgaWYgKGlzT2JqZWN0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzaG91bGRTY3JvbGwuc2VsZWN0b3IpO1xuICAgIGlmIChlbCkge1xuICAgICAgdmFyIG9mZnNldCA9IHNob3VsZFNjcm9sbC5vZmZzZXQgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5vZmZzZXQgPT09ICdvYmplY3QnID8gc2hvdWxkU2Nyb2xsLm9mZnNldCA6IHt9O1xuICAgICAgb2Zmc2V0ID0gbm9ybWFsaXplT2Zmc2V0KG9mZnNldCk7XG4gICAgICBwb3NpdGlvbiA9IGdldEVsZW1lbnRQb3NpdGlvbihlbCwgb2Zmc2V0KTtcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0ICYmIGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9uKSB7XG4gICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSBpbkJyb3dzZXIgJiYgKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKFxuICAgICh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJlxuICAgIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5XG59KSgpO1xuXG4vLyB1c2UgVXNlciBUaW1pbmcgYXBpIChpZiBwcmVzZW50KSBmb3IgbW9yZSBhY2N1cmF0ZSBrZXkgcHJlY2lzaW9uXG52YXIgVGltZSA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vd1xuICA/IHdpbmRvdy5wZXJmb3JtYW5jZVxuICA6IERhdGU7XG5cbnZhciBfa2V5ID0gZ2VuS2V5KCk7XG5cbmZ1bmN0aW9uIGdlbktleSAoKSB7XG4gIHJldHVybiBUaW1lLm5vdygpLnRvRml4ZWQoMylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVLZXkgKCkge1xuICByZXR1cm4gX2tleVxufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZUtleSAoa2V5KSB7XG4gIF9rZXkgPSBrZXk7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGF0ZSAodXJsLCByZXBsYWNlKSB7XG4gIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAvLyB0cnkuLi5jYXRjaCB0aGUgcHVzaFN0YXRlIGNhbGwgdG8gZ2V0IGFyb3VuZCBTYWZhcmlcbiAgLy8gRE9NIEV4Y2VwdGlvbiAxOCB3aGVyZSBpdCBsaW1pdHMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxsc1xuICB2YXIgaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2tleSA9IGdlbktleSgpO1xuICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgd2luZG93LmxvY2F0aW9uW3JlcGxhY2UgPyAncmVwbGFjZScgOiAnYXNzaWduJ10odXJsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlU3RhdGUgKHVybCkge1xuICBwdXNoU3RhdGUodXJsLCB0cnVlKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJ1blF1ZXVlIChxdWV1ZSwgZm4sIGNiKSB7XG4gIHZhciBzdGVwID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHF1ZXVlW2luZGV4XSkge1xuICAgICAgICBmbihxdWV1ZVtpbmRleF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RlcCgwKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudHMgKG1hdGNoZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHZhciBoYXNBc3luYyA9IGZhbHNlO1xuICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgZmxhdE1hcENvbXBvbmVudHMobWF0Y2hlZCwgZnVuY3Rpb24gKGRlZiwgXywgbWF0Y2gsIGtleSkge1xuICAgICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uIGFuZCBkb2Vzbid0IGhhdmUgY2lkIGF0dGFjaGVkLFxuICAgICAgLy8gYXNzdW1lIGl0J3MgYW4gYXN5bmMgY29tcG9uZW50IHJlc29sdmUgZnVuY3Rpb24uXG4gICAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIFZ1ZSdzIGRlZmF1bHQgYXN5bmMgcmVzb2x2aW5nIG1lY2hhbmlzbSBiZWNhdXNlXG4gICAgICAvLyB3ZSB3YW50IHRvIGhhbHQgdGhlIG5hdmlnYXRpb24gdW50aWwgdGhlIGluY29taW5nIGNvbXBvbmVudCBoYXMgYmVlblxuICAgICAgLy8gcmVzb2x2ZWQuXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWYuY2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzQXN5bmMgPSB0cnVlO1xuICAgICAgICBwZW5kaW5nKys7XG5cbiAgICAgICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXNvbHZlZERlZikge1xuICAgICAgICAgIGlmIChpc0VTTW9kdWxlKHJlc29sdmVkRGVmKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWREZWYgPSByZXNvbHZlZERlZi5kZWZhdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzYXZlIHJlc29sdmVkIG9uIGFzeW5jIGZhY3RvcnkgaW4gY2FzZSBpdCdzIHVzZWQgZWxzZXdoZXJlXG4gICAgICAgICAgZGVmLnJlc29sdmVkID0gdHlwZW9mIHJlc29sdmVkRGVmID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHJlc29sdmVkRGVmXG4gICAgICAgICAgICA6IF9WdWUuZXh0ZW5kKHJlc29sdmVkRGVmKTtcbiAgICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZjtcbiAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgaWYgKHBlbmRpbmcgPD0gMCkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHZhciBtc2cgPSBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudCBcIiArIGtleSArIFwiOiBcIiArIHJlYXNvbjtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIG1zZyk7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBpc0Vycm9yKHJlYXNvbilcbiAgICAgICAgICAgICAgPyByZWFzb25cbiAgICAgICAgICAgICAgOiBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIG5leHQoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBkZWYocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbmV3IHN5bnRheCBpbiBWdWUgMi4zXG4gICAgICAgICAgICB2YXIgY29tcCA9IHJlcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcCAmJiB0eXBlb2YgY29tcC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbXAudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFoYXNBc3luYykgeyBuZXh0KCk7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0TWFwQ29tcG9uZW50cyAoXG4gIG1hdGNoZWQsXG4gIGZuXG4pIHtcbiAgcmV0dXJuIGZsYXR0ZW4obWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4oXG4gICAgICBtLmNvbXBvbmVudHNba2V5XSxcbiAgICAgIG0uaW5zdGFuY2VzW2tleV0sXG4gICAgICBtLCBrZXlcbiAgICApOyB9KVxuICB9KSlcbn1cblxuZnVuY3Rpb24gZmxhdHRlbiAoYXJyKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5mdW5jdGlvbiBpc0VTTW9kdWxlIChvYmopIHtcbiAgcmV0dXJuIG9iai5fX2VzTW9kdWxlIHx8IChoYXNTeW1ib2wgJiYgb2JqW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxufVxuXG4vLyBpbiBXZWJwYWNrIDIsIHJlcXVpcmUuZW5zdXJlIG5vdyBhbHNvIHJldHVybnMgYSBQcm9taXNlXG4vLyBzbyB0aGUgcmVzb2x2ZS9yZWplY3QgZnVuY3Rpb25zIG1heSBnZXQgY2FsbGVkIGFuIGV4dHJhIHRpbWVcbi8vIGlmIHRoZSB1c2VyIHVzZXMgYW4gYXJyb3cgZnVuY3Rpb24gc2hvcnRoYW5kIHRoYXQgaGFwcGVucyB0b1xuLy8gcmV0dXJuIHRoYXQgUHJvbWlzZS5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBpZiAoY2FsbGVkKSB7IHJldHVybiB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIEhpc3RvcnkgPSBmdW5jdGlvbiBIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIHRoaXMuYmFzZSA9IG5vcm1hbGl6ZUJhc2UoYmFzZSk7XG4gIC8vIHN0YXJ0IHdpdGggYSByb3V0ZSBvYmplY3QgdGhhdCBzdGFuZHMgZm9yIFwibm93aGVyZVwiXG4gIHRoaXMuY3VycmVudCA9IFNUQVJUO1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gIHRoaXMucmVhZHlDYnMgPSBbXTtcbiAgdGhpcy5yZWFkeUVycm9yQ2JzID0gW107XG4gIHRoaXMuZXJyb3JDYnMgPSBbXTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbiAoY2IpIHtcbiAgdGhpcy5jYiA9IGNiO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgY2IoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlYWR5Q2JzLnB1c2goY2IpO1xuICAgIGlmIChlcnJvckNiKSB7XG4gICAgICB0aGlzLnJlYWR5RXJyb3JDYnMucHVzaChlcnJvckNiKTtcbiAgICB9XG4gIH1cbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yIChlcnJvckNiKSB7XG4gIHRoaXMuZXJyb3JDYnMucHVzaChlcnJvckNiKTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25UbyAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcm91dGUgPSB0aGlzLnJvdXRlci5tYXRjaChsb2NhdGlvbiwgdGhpcy5jdXJyZW50KTtcbiAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB0aGlzJDEuZW5zdXJlVVJMKCk7XG5cbiAgICAvLyBmaXJlIHJlYWR5IGNicyBvbmNlXG4gICAgaWYgKCF0aGlzJDEucmVhZHkpIHtcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzJDEucmVhZHlDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2Iocm91dGUpOyB9KTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAob25BYm9ydCkge1xuICAgICAgb25BYm9ydChlcnIpO1xuICAgIH1cbiAgICBpZiAoZXJyICYmICF0aGlzJDEucmVhZHkpIHtcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzJDEucmVhZHlFcnJvckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihlcnIpOyB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChpc0Vycm9yKGVycikpIHtcbiAgICAgIGlmICh0aGlzJDEuZXJyb3JDYnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMkMS5lcnJvckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihlcnIpOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oZmFsc2UsICd1bmNhdWdodCBlcnJvciBkdXJpbmcgcm91dGUgbmF2aWdhdGlvbjonKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbkFib3J0ICYmIG9uQWJvcnQoZXJyKTtcbiAgfTtcbiAgaWYgKFxuICAgIGlzU2FtZVJvdXRlKHJvdXRlLCBjdXJyZW50KSAmJlxuICAgIC8vIGluIHRoZSBjYXNlIHRoZSByb3V0ZSBtYXAgaGFzIGJlZW4gZHluYW1pY2FsbHkgYXBwZW5kZWQgdG9cbiAgICByb3V0ZS5tYXRjaGVkLmxlbmd0aCA9PT0gY3VycmVudC5tYXRjaGVkLmxlbmd0aFxuICApIHtcbiAgICB0aGlzLmVuc3VyZVVSTCgpO1xuICAgIHJldHVybiBhYm9ydCgpXG4gIH1cblxuICB2YXIgcmVmID0gcmVzb2x2ZVF1ZXVlKHRoaXMuY3VycmVudC5tYXRjaGVkLCByb3V0ZS5tYXRjaGVkKTtcbiAgICB2YXIgdXBkYXRlZCA9IHJlZi51cGRhdGVkO1xuICAgIHZhciBkZWFjdGl2YXRlZCA9IHJlZi5kZWFjdGl2YXRlZDtcbiAgICB2YXIgYWN0aXZhdGVkID0gcmVmLmFjdGl2YXRlZDtcblxuICB2YXIgcXVldWUgPSBbXS5jb25jYXQoXG4gICAgLy8gaW4tY29tcG9uZW50IGxlYXZlIGd1YXJkc1xuICAgIGV4dHJhY3RMZWF2ZUd1YXJkcyhkZWFjdGl2YXRlZCksXG4gICAgLy8gZ2xvYmFsIGJlZm9yZSBob29rc1xuICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxuICAgIC8vIGluLWNvbXBvbmVudCB1cGRhdGUgaG9va3NcbiAgICBleHRyYWN0VXBkYXRlSG9va3ModXBkYXRlZCksXG4gICAgLy8gaW4tY29uZmlnIGVudGVyIGd1YXJkc1xuICAgIGFjdGl2YXRlZC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uYmVmb3JlRW50ZXI7IH0pLFxuICAgIC8vIGFzeW5jIGNvbXBvbmVudHNcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnRzKGFjdGl2YXRlZClcbiAgKTtcblxuICB0aGlzLnBlbmRpbmcgPSByb3V0ZTtcbiAgdmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gKGhvb2ssIG5leHQpIHtcbiAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICByZXR1cm4gYWJvcnQoKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaG9vayhyb3V0ZSwgY3VycmVudCwgZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIGlmICh0byA9PT0gZmFsc2UgfHwgaXNFcnJvcih0bykpIHtcbiAgICAgICAgICAvLyBuZXh0KGZhbHNlKSAtPiBhYm9ydCBuYXZpZ2F0aW9uLCBlbnN1cmUgY3VycmVudCBVUkxcbiAgICAgICAgICB0aGlzJDEuZW5zdXJlVVJMKHRydWUpO1xuICAgICAgICAgIGFib3J0KHRvKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgKHR5cGVvZiB0byA9PT0gJ29iamVjdCcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHRvLnBhdGggPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdG8ubmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICApKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBuZXh0KCcvJykgb3IgbmV4dCh7IHBhdGg6ICcvJyB9KSAtPiByZWRpcmVjdFxuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gJ29iamVjdCcgJiYgdG8ucmVwbGFjZSkge1xuICAgICAgICAgICAgdGhpcyQxLnJlcGxhY2UodG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzJDEucHVzaCh0byk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbmZpcm0gdHJhbnNpdGlvbiBhbmQgcGFzcyBvbiB0aGUgdmFsdWVcbiAgICAgICAgICBuZXh0KHRvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYWJvcnQoZSk7XG4gICAgfVxuICB9O1xuXG4gIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3N0RW50ZXJDYnMgPSBbXTtcbiAgICB2YXIgaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jdXJyZW50ID09PSByb3V0ZTsgfTtcbiAgICAvLyB3YWl0IHVudGlsIGFzeW5jIGNvbXBvbmVudHMgYXJlIHJlc29sdmVkIGJlZm9yZVxuICAgIC8vIGV4dHJhY3RpbmcgaW4tY29tcG9uZW50IGVudGVyIGd1YXJkc1xuICAgIHZhciBlbnRlckd1YXJkcyA9IGV4dHJhY3RFbnRlckd1YXJkcyhhY3RpdmF0ZWQsIHBvc3RFbnRlckNicywgaXNWYWxpZCk7XG4gICAgdmFyIHF1ZXVlID0gZW50ZXJHdWFyZHMuY29uY2F0KHRoaXMkMS5yb3V0ZXIucmVzb2x2ZUhvb2tzKTtcbiAgICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0KClcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgaWYgKHRoaXMkMS5yb3V0ZXIuYXBwKSB7XG4gICAgICAgIHRoaXMkMS5yb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcG9zdEVudGVyQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS51cGRhdGVSb3V0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVJvdXRlIChyb3V0ZSkge1xuICB2YXIgcHJldiA9IHRoaXMuY3VycmVudDtcbiAgdGhpcy5jdXJyZW50ID0gcm91dGU7XG4gIHRoaXMuY2IgJiYgdGhpcy5jYihyb3V0ZSk7XG4gIHRoaXMucm91dGVyLmFmdGVySG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgIGhvb2sgJiYgaG9vayhyb3V0ZSwgcHJldik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplQmFzZSAoYmFzZSkge1xuICBpZiAoIWJhc2UpIHtcbiAgICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcbiAgICAgIHZhciBiYXNlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICBiYXNlID0gKGJhc2VFbCAmJiBiYXNlRWwuZ2V0QXR0cmlidXRlKCdocmVmJykpIHx8ICcvJztcbiAgICAgIC8vIHN0cmlwIGZ1bGwgVVJMIG9yaWdpblxuICAgICAgYmFzZSA9IGJhc2UucmVwbGFjZSgvXmh0dHBzPzpcXC9cXC9bXlxcL10rLywgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJy8nO1xuICAgIH1cbiAgfVxuICAvLyBtYWtlIHN1cmUgdGhlcmUncyB0aGUgc3RhcnRpbmcgc2xhc2hcbiAgaWYgKGJhc2UuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBiYXNlID0gJy8nICsgYmFzZTtcbiAgfVxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgcmV0dXJuIGJhc2UucmVwbGFjZSgvXFwvJC8sICcnKVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUXVldWUgKFxuICBjdXJyZW50LFxuICBuZXh0XG4pIHtcbiAgdmFyIGk7XG4gIHZhciBtYXggPSBNYXRoLm1heChjdXJyZW50Lmxlbmd0aCwgbmV4dC5sZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBpZiAoY3VycmVudFtpXSAhPT0gbmV4dFtpXSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGVkOiBuZXh0LnNsaWNlKDAsIGkpLFxuICAgIGFjdGl2YXRlZDogbmV4dC5zbGljZShpKSxcbiAgICBkZWFjdGl2YXRlZDogY3VycmVudC5zbGljZShpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZHMgKFxuICByZWNvcmRzLFxuICBuYW1lLFxuICBiaW5kLFxuICByZXZlcnNlXG4pIHtcbiAgdmFyIGd1YXJkcyA9IGZsYXRNYXBDb21wb25lbnRzKHJlY29yZHMsIGZ1bmN0aW9uIChkZWYsIGluc3RhbmNlLCBtYXRjaCwga2V5KSB7XG4gICAgdmFyIGd1YXJkID0gZXh0cmFjdEd1YXJkKGRlZiwgbmFtZSk7XG4gICAgaWYgKGd1YXJkKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShndWFyZClcbiAgICAgICAgPyBndWFyZC5tYXAoZnVuY3Rpb24gKGd1YXJkKSB7IHJldHVybiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSk7IH0pXG4gICAgICAgIDogYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZsYXR0ZW4ocmV2ZXJzZSA/IGd1YXJkcy5yZXZlcnNlKCkgOiBndWFyZHMpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZCAoXG4gIGRlZixcbiAga2V5XG4pIHtcbiAgaWYgKHR5cGVvZiBkZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBleHRlbmQgbm93IHNvIHRoYXQgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZC5cbiAgICBkZWYgPSBfVnVlLmV4dGVuZChkZWYpO1xuICB9XG4gIHJldHVybiBkZWYub3B0aW9uc1trZXldXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RMZWF2ZUd1YXJkcyAoZGVhY3RpdmF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoZGVhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUxlYXZlJywgYmluZEd1YXJkLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VXBkYXRlSG9va3MgKHVwZGF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHModXBkYXRlZCwgJ2JlZm9yZVJvdXRlVXBkYXRlJywgYmluZEd1YXJkKVxufVxuXG5mdW5jdGlvbiBiaW5kR3VhcmQgKGd1YXJkLCBpbnN0YW5jZSkge1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRSb3V0ZUd1YXJkICgpIHtcbiAgICAgIHJldHVybiBndWFyZC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RW50ZXJHdWFyZHMgKFxuICBhY3RpdmF0ZWQsXG4gIGNicyxcbiAgaXNWYWxpZFxuKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlRW50ZXInLCBmdW5jdGlvbiAoZ3VhcmQsIF8sIG1hdGNoLCBrZXkpIHtcbiAgICByZXR1cm4gYmluZEVudGVyR3VhcmQoZ3VhcmQsIG1hdGNoLCBrZXksIGNicywgaXNWYWxpZClcbiAgfSlcbn1cblxuZnVuY3Rpb24gYmluZEVudGVyR3VhcmQgKFxuICBndWFyZCxcbiAgbWF0Y2gsXG4gIGtleSxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJvdXRlRW50ZXJHdWFyZCAodG8sIGZyb20sIG5leHQpIHtcbiAgICByZXR1cm4gZ3VhcmQodG8sIGZyb20sIGZ1bmN0aW9uIChjYikge1xuICAgICAgbmV4dChjYik7XG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNicy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAjNzUwXG4gICAgICAgICAgLy8gaWYgYSByb3V0ZXItdmlldyBpcyB3cmFwcGVkIHdpdGggYW4gb3V0LWluIHRyYW5zaXRpb24sXG4gICAgICAgICAgLy8gdGhlIGluc3RhbmNlIG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgYXQgdGhpcyB0aW1lLlxuICAgICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0byBwb2xsIGZvciByZWdpc3RyYXRpb24gdW50aWwgY3VycmVudCByb3V0ZVxuICAgICAgICAgIC8vIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgICAgICBwb2xsKGNiLCBtYXRjaC5pbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gcG9sbCAoXG4gIGNiLCAvLyBzb21laG93IGZsb3cgY2Fubm90IGluZmVyIHRoaXMgaXMgYSBmdW5jdGlvblxuICBpbnN0YW5jZXMsXG4gIGtleSxcbiAgaXNWYWxpZFxuKSB7XG4gIGlmIChpbnN0YW5jZXNba2V5XSkge1xuICAgIGNiKGluc3RhbmNlc1trZXldKTtcbiAgfSBlbHNlIGlmIChpc1ZhbGlkKCkpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHBvbGwoY2IsIGluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICB9LCAxNik7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIEhUTUw1SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBIVE1MNUhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG5cbiAgICB2YXIgZXhwZWN0U2Nyb2xsID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG5cbiAgICBpZiAoZXhwZWN0U2Nyb2xsKSB7XG4gICAgICBzZXR1cFNjcm9sbCgpO1xuICAgIH1cblxuICAgIHZhciBpbml0TG9jYXRpb24gPSBnZXRMb2NhdGlvbih0aGlzLmJhc2UpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMkMS5jdXJyZW50O1xuXG4gICAgICAvLyBBdm9pZGluZyBmaXJzdCBgcG9wc3RhdGVgIGV2ZW50IGRpc3BhdGNoZWQgaW4gc29tZSBicm93c2VycyBidXQgZmlyc3RcbiAgICAgIC8vIGhpc3Rvcnkgcm91dGUgbm90IHVwZGF0ZWQgc2luY2UgYXN5bmMgZ3VhcmQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldExvY2F0aW9uKHRoaXMkMS5iYXNlKTtcbiAgICAgIGlmICh0aGlzJDEuY3VycmVudCA9PT0gU1RBUlQgJiYgbG9jYXRpb24gPT09IGluaXRMb2NhdGlvbikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgICAgICBoYW5kbGVTY3JvbGwocm91dGVyLCByb3V0ZSwgY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSFRNTDVIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MNUhpc3Rvcnk7XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZVN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIGlmIChnZXRMb2NhdGlvbih0aGlzLmJhc2UpICE9PSB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gY2xlYW5QYXRoKHRoaXMuYmFzZSArIHRoaXMuY3VycmVudC5mdWxsUGF0aCk7XG4gICAgICBwdXNoID8gcHVzaFN0YXRlKGN1cnJlbnQpIDogcmVwbGFjZVN0YXRlKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldExvY2F0aW9uKHRoaXMuYmFzZSlcbiAgfTtcblxuICByZXR1cm4gSFRNTDVIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uIChiYXNlKSB7XG4gIHZhciBwYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICBpZiAoYmFzZSAmJiBwYXRoLmluZGV4T2YoYmFzZSkgPT09IDApIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2hcbn1cblxuLyogICovXG5cblxudmFyIEhhc2hIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhhc2hIaXN0b3J5IChyb3V0ZXIsIGJhc2UsIGZhbGxiYWNrKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgLy8gY2hlY2sgaGlzdG9yeSBmYWxsYmFjayBkZWVwbGlua2luZ1xuICAgIGlmIChmYWxsYmFjayAmJiBjaGVja0ZhbGxiYWNrKHRoaXMuYmFzZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbnN1cmVTbGFzaCgpO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSGFzaEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoSGlzdG9yeTtcblxuICAvLyB0aGlzIGlzIGRlbGF5ZWQgdW50aWwgdGhlIGFwcCBtb3VudHNcbiAgLy8gdG8gYXZvaWQgdGhlIGhhc2hjaGFuZ2UgbGlzdGVuZXIgYmVpbmcgZmlyZWQgdG9vIGVhcmx5XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByb3V0ZXIgPSB0aGlzLnJvdXRlcjtcbiAgICB2YXIgZXhwZWN0U2Nyb2xsID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gICAgdmFyIHN1cHBvcnRzU2Nyb2xsID0gc3VwcG9ydHNQdXNoU3RhdGUgJiYgZXhwZWN0U2Nyb2xsO1xuXG4gICAgaWYgKHN1cHBvcnRzU2Nyb2xsKSB7XG4gICAgICBzZXR1cFNjcm9sbCgpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKHN1cHBvcnRzUHVzaFN0YXRlID8gJ3BvcHN0YXRlJyA6ICdoYXNoY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcbiAgICAgIGlmICghZW5zdXJlU2xhc2goKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8oZ2V0SGFzaCgpLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzU2Nyb2xsKSB7XG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBjdXJyZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1cHBvcnRzUHVzaFN0YXRlKSB7XG4gICAgICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaEhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoO1xuICAgIGlmIChnZXRIYXNoKCkgIT09IGN1cnJlbnQpIHtcbiAgICAgIHB1c2ggPyBwdXNoSGFzaChjdXJyZW50KSA6IHJlcGxhY2VIYXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SGFzaCgpXG4gIH07XG5cbiAgcmV0dXJuIEhhc2hIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGNoZWNrRmFsbGJhY2sgKGJhc2UpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oYmFzZSk7XG4gIGlmICghL15cXC8jLy50ZXN0KGxvY2F0aW9uKSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFxuICAgICAgY2xlYW5QYXRoKGJhc2UgKyAnLyMnICsgbG9jYXRpb24pXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoICgpIHtcbiAgdmFyIHBhdGggPSBnZXRIYXNoKCk7XG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXBsYWNlSGFzaCgnLycgKyBwYXRoKTtcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdldEhhc2ggKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gJycgOiBocmVmLnNsaWNlKGluZGV4ICsgMSlcbn1cblxuZnVuY3Rpb24gZ2V0VXJsIChwYXRoKSB7XG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHZhciBiYXNlID0gaSA+PSAwID8gaHJlZi5zbGljZSgwLCBpKSA6IGhyZWY7XG4gIHJldHVybiAoYmFzZSArIFwiI1wiICsgcGF0aClcbn1cblxuZnVuY3Rpb24gcHVzaEhhc2ggKHBhdGgpIHtcbiAgaWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG4gICAgcHVzaFN0YXRlKGdldFVybChwYXRoKSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VIYXNoIChwYXRoKSB7XG4gIGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuICAgIHJlcGxhY2VTdGF0ZShnZXRVcmwocGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGdldFVybChwYXRoKSk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIEFic3RyYWN0SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBBYnN0cmFjdEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBBYnN0cmFjdEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFic3RyYWN0SGlzdG9yeTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCArIDEpLmNvbmNhdChyb3V0ZSk7XG4gICAgICB0aGlzJDEuaW5kZXgrKztcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXgpLmNvbmNhdChyb3V0ZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHRhcmdldEluZGV4ID0gdGhpcy5pbmRleCArIG47XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByb3V0ZSA9IHRoaXMuc3RhY2tbdGFyZ2V0SW5kZXhdO1xuICAgIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5pbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGN1cnJlbnQgPyBjdXJyZW50LmZ1bGxQYXRoIDogJy8nXG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKCkge1xuICAgIC8vIG5vb3BcbiAgfTtcblxuICByZXR1cm4gQWJzdHJhY3RIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbi8qICAqL1xuXG52YXIgVnVlUm91dGVyID0gZnVuY3Rpb24gVnVlUm91dGVyIChvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIHRoaXMuYXBwID0gbnVsbDtcbiAgdGhpcy5hcHBzID0gW107XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuYmVmb3JlSG9va3MgPSBbXTtcbiAgdGhpcy5yZXNvbHZlSG9va3MgPSBbXTtcbiAgdGhpcy5hZnRlckhvb2tzID0gW107XG4gIHRoaXMubWF0Y2hlciA9IGNyZWF0ZU1hdGNoZXIob3B0aW9ucy5yb3V0ZXMgfHwgW10sIHRoaXMpO1xuXG4gIHZhciBtb2RlID0gb3B0aW9ucy5tb2RlIHx8ICdoYXNoJztcbiAgdGhpcy5mYWxsYmFjayA9IG1vZGUgPT09ICdoaXN0b3J5JyAmJiAhc3VwcG9ydHNQdXNoU3RhdGUgJiYgb3B0aW9ucy5mYWxsYmFjayAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgbW9kZSA9ICdoYXNoJztcbiAgfVxuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIG1vZGUgPSAnYWJzdHJhY3QnO1xuICB9XG4gIHRoaXMubW9kZSA9IG1vZGU7XG5cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSAnaGlzdG9yeSc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSFRNTDVIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhhc2hIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSwgdGhpcy5mYWxsYmFjayk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Fic3RyYWN0JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBBYnN0cmFjdEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgKFwiaW52YWxpZCBtb2RlOiBcIiArIG1vZGUpKTtcbiAgICAgIH1cbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY3VycmVudFJvdXRlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgcmVkaXJlY3RlZEZyb21cbikge1xuICByZXR1cm4gdGhpcy5tYXRjaGVyLm1hdGNoKHJhdywgY3VycmVudCwgcmVkaXJlY3RlZEZyb20pXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuY3VycmVudFJvdXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkuY3VycmVudFxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoYXBwIC8qIFZ1ZSBjb21wb25lbnQgaW5zdGFuY2UgKi8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydChcbiAgICBpbnN0YWxsLmluc3RhbGxlZCxcbiAgICBcIm5vdCBpbnN0YWxsZWQuIE1ha2Ugc3VyZSB0byBjYWxsIGBWdWUudXNlKFZ1ZVJvdXRlcilgIFwiICtcbiAgICBcImJlZm9yZSBjcmVhdGluZyByb290IGluc3RhbmNlLlwiXG4gICk7XG5cbiAgdGhpcy5hcHBzLnB1c2goYXBwKTtcblxuICAvLyBtYWluIGFwcCBhbHJlYWR5IGluaXRpYWxpemVkLlxuICBpZiAodGhpcy5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuYXBwID0gYXBwO1xuXG4gIHZhciBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXG4gIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSFRNTDVIaXN0b3J5KSB7XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH0gZWxzZSBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhhc2hIaXN0b3J5KSB7XG4gICAgdmFyIHNldHVwSGFzaExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaGlzdG9yeS5zZXR1cExpc3RlbmVycygpO1xuICAgIH07XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oXG4gICAgICBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXIsXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lclxuICAgICk7XG4gIH1cblxuICBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAocm91dGUpIHtcbiAgICB0aGlzJDEuYXBwcy5mb3JFYWNoKGZ1bmN0aW9uIChhcHApIHtcbiAgICAgIGFwcC5fcm91dGUgPSByb3V0ZTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiBiZWZvcmVFYWNoIChmbikge1xuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMuYmVmb3JlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVSZXNvbHZlID0gZnVuY3Rpb24gYmVmb3JlUmVzb2x2ZSAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLnJlc29sdmVIb29rcywgZm4pXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uIGFmdGVyRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmFmdGVySG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IsIGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uUmVhZHkoY2IsIGVycm9yQ2IpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvciAoZXJyb3JDYikge1xuICB0aGlzLmhpc3Rvcnkub25FcnJvcihlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5wdXNoKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICB0aGlzLmhpc3RvcnkuZ28obik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiBiYWNrICgpIHtcbiAgdGhpcy5nbygtMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiBmb3J3YXJkICgpIHtcbiAgdGhpcy5nbygxKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ2V0TWF0Y2hlZENvbXBvbmVudHMgPSBmdW5jdGlvbiBnZXRNYXRjaGVkQ29tcG9uZW50cyAodG8pIHtcbiAgdmFyIHJvdXRlID0gdG9cbiAgICA/IHRvLm1hdGNoZWRcbiAgICAgID8gdG9cbiAgICAgIDogdGhpcy5yZXNvbHZlKHRvKS5yb3V0ZVxuICAgIDogdGhpcy5jdXJyZW50Um91dGU7XG4gIGlmICghcm91dGUpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCByb3V0ZS5tYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gbS5jb21wb25lbnRzW2tleV1cbiAgICB9KVxuICB9KSlcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKFxuICB0byxcbiAgY3VycmVudCxcbiAgYXBwZW5kXG4pIHtcbiAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24oXG4gICAgdG8sXG4gICAgY3VycmVudCB8fCB0aGlzLmhpc3RvcnkuY3VycmVudCxcbiAgICBhcHBlbmQsXG4gICAgdGhpc1xuICApO1xuICB2YXIgcm91dGUgPSB0aGlzLm1hdGNoKGxvY2F0aW9uLCBjdXJyZW50KTtcbiAgdmFyIGZ1bGxQYXRoID0gcm91dGUucmVkaXJlY3RlZEZyb20gfHwgcm91dGUuZnVsbFBhdGg7XG4gIHZhciBiYXNlID0gdGhpcy5oaXN0b3J5LmJhc2U7XG4gIHZhciBocmVmID0gY3JlYXRlSHJlZihiYXNlLCBmdWxsUGF0aCwgdGhpcy5tb2RlKTtcbiAgcmV0dXJuIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcm91dGU6IHJvdXRlLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBub3JtYWxpemVkVG86IGxvY2F0aW9uLFxuICAgIHJlc29sdmVkOiByb3V0ZVxuICB9XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFkZFJvdXRlcyA9IGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gIHRoaXMubWF0Y2hlci5hZGRSb3V0ZXMocm91dGVzKTtcbiAgaWYgKHRoaXMuaGlzdG9yeS5jdXJyZW50ICE9PSBTVEFSVCkge1xuICAgIHRoaXMuaGlzdG9yeS50cmFuc2l0aW9uVG8odGhpcy5oaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZ1ZVJvdXRlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiByZWdpc3Rlckhvb2sgKGxpc3QsIGZuKSB7XG4gIGxpc3QucHVzaChmbik7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBsaXN0LmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHsgbGlzdC5zcGxpY2UoaSwgMSk7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVIcmVmIChiYXNlLCBmdWxsUGF0aCwgbW9kZSkge1xuICB2YXIgcGF0aCA9IG1vZGUgPT09ICdoYXNoJyA/ICcjJyArIGZ1bGxQYXRoIDogZnVsbFBhdGg7XG4gIHJldHVybiBiYXNlID8gY2xlYW5QYXRoKGJhc2UgKyAnLycgKyBwYXRoKSA6IHBhdGhcbn1cblxuVnVlUm91dGVyLmluc3RhbGwgPSBpbnN0YWxsO1xuVnVlUm91dGVyLnZlcnNpb24gPSAnMy4wLjEnO1xuXG5pZiAoaW5Ccm93c2VyICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoVnVlUm91dGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWdWVSb3V0ZXI7XG4iLCIvKiFcbiAqIFZ1ZS5qcyB2Mi41LjE3XG4gKiAoYykgMjAxNC0yMDE4IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSBlLmcuIFtvYmplY3QgT2JqZWN0XVxuICovXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQuLi4gZS5nLlxuICogUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHkgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmUgc2luY2UgbmF0aXZlIGJpbmQgaXNcbiAqIG5vdyBtb3JlIHBlcmZvcm1hbnQgaW4gbW9zdCBicm93c2VycywgYnV0IHJlbW92aW5nIGl0IHdvdWxkIGJlIGJyZWFraW5nIGZvclxuICogY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpbiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3JcbiAqIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgPyBuYXRpdmVCaW5kXG4gIDogcG9seWZpbGxCaW5kO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKVxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cblxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJ1xuXTtcblxuLyogICovXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSlcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm0gfHwge307XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxudmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gKi9cbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgaWYgKCFnZXR0ZXIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGJvb2xlYW4gY2FzdGluZ1xuICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgfVxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIC8vIHNraXAgdmFsaWRhdGlvbiBmb3Igd2VleCByZWN5Y2xlLWxpc3QgY2hpbGQgY29tcG9uZW50IHByb3BzXG4gICAgIShmYWxzZSAmJiBpc09iamVjdCh2YWx1ZSkgJiYgKCdAYmluZGluZycgaW4gdmFsdWUpKVxuICApIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xuICAgICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSkgK1xuICAgICAgXCIsIGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAodm0pIHtcbiAgICB2YXIgY3VyID0gdm07XG4gICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHsgcmV0dXJuIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gbG9nRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE1lc3NhZ2VDaGFubmVsICovXG5cbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIGJvdGggbWljcm90YXNrcyBhbmQgKG1hY3JvKSB0YXNrcy5cbi8vIEluIDwgMi40IHdlIHVzZWQgbWljcm90YXNrcyBldmVyeXdoZXJlLCBidXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zIHdoZXJlXG4vLyBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCkgb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lXG4vLyBldmVudCAoIzY1NjYpLiBIb3dldmVyLCB1c2luZyAobWFjcm8pIHRhc2tzIGV2ZXJ5d2hlcmUgYWxzbyBoYXMgc3VidGxlIHByb2JsZW1zXG4vLyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnQgKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBIZXJlIHdlIHVzZSBtaWNyb3Rhc2sgYnkgZGVmYXVsdCwgYnV0IGV4cG9zZSBhIHdheSB0byBmb3JjZSAobWFjcm8pIHRhc2sgd2hlblxuLy8gbmVlZGVkIChlLmcuIGluIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIGJ5IHYtb24pLlxudmFyIG1pY3JvVGltZXJGdW5jO1xudmFyIG1hY3JvVGltZXJGdW5jO1xudmFyIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuXG4vLyBEZXRlcm1pbmUgKG1hY3JvKSB0YXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLy8gVGVjaG5pY2FsbHkgc2V0SW1tZWRpYXRlIHNob3VsZCBiZSB0aGUgaWRlYWwgY2hvaWNlLCBidXQgaXQncyBvbmx5IGF2YWlsYWJsZVxuLy8gaW4gSUUuIFRoZSBvbmx5IHBvbHlmaWxsIHRoYXQgY29uc2lzdGVudGx5IHF1ZXVlcyB0aGUgY2FsbGJhY2sgYWZ0ZXIgYWxsIERPTVxuLy8gZXZlbnRzIHRyaWdnZXJlZCBpbiB0aGUgc2FtZSBsb29wIGlzIGJ5IHVzaW5nIE1lc3NhZ2VDaGFubmVsLlxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTWVzc2FnZUNoYW5uZWwpIHx8XG4gIC8vIFBoYW50b21KU1xuICBNZXNzYWdlQ2hhbm5lbC50b1N0cmluZygpID09PSAnW29iamVjdCBNZXNzYWdlQ2hhbm5lbENvbnN0cnVjdG9yXSdcbikpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoQ2FsbGJhY2tzO1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwb3J0LnBvc3RNZXNzYWdlKDEpO1xuICB9O1xufSBlbHNlIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbi8vIERldGVybWluZSBtaWNyb3Rhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIG1pY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gZmFsbGJhY2sgdG8gbWFjcm9cbiAgbWljcm9UaW1lckZ1bmMgPSBtYWNyb1RpbWVyRnVuYztcbn1cblxuLyoqXG4gKiBXcmFwIGEgZnVuY3Rpb24gc28gdGhhdCBpZiBhbnkgY29kZSBpbnNpZGUgdHJpZ2dlcnMgc3RhdGUgY2hhbmdlLFxuICogdGhlIGNoYW5nZXMgYXJlIHF1ZXVlZCB1c2luZyBhIChtYWNybykgdGFzayBpbnN0ZWFkIG9mIGEgbWljcm90YXNrLlxuICovXG5mdW5jdGlvbiB3aXRoTWFjcm9UYXNrIChmbikge1xuICByZXR1cm4gZm4uX3dpdGhUYXNrIHx8IChmbi5fd2l0aFRhc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdXNlTWFjcm9UYXNrID0gdHJ1ZTtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgaWYgKHVzZU1hY3JvVGFzaykge1xuICAgICAgbWFjcm9UaW1lckZ1bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWljcm9UaW1lckZ1bmMoKTtcbiAgICB9XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbG9uZWRbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBkZWYsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgZGVmID0gY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICBkZWYgPSBkZWYuZGF0YS5ob29rIHx8IChkZWYuZGF0YS5ob29rID0ge30pO1xuICB9XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3RJbmRleCwgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKTtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgKGNbMF0pLnRleHQpO1xuICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY29udGV4dFxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LmNvbnRleHRzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlKSB7XG4gIGlmIChvbmNlKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb2ZmKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoIWZuKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGZuKSB7XG4gICAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICB2YXIgY2I7XG4gICAgICB2YXIgaSQxID0gY2JzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpJDEtLSkge1xuICAgICAgICBjYiA9IGNic1tpJDFdO1xuICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICAgIGNicy5zcGxpY2UoaSQxLCAxKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG5cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICAgIC8vIG5vIG5lZWQgZm9yIHRoZSByZWYgbm9kZXMgYWZ0ZXIgaW5pdGlhbCBwYXRjaFxuICAgICAgLy8gdGhpcyBwcmV2ZW50cyBrZWVwaW5nIGEgZGV0YWNoZWQgRE9NIHRyZWUgaW4gbWVtb3J5ICgjNTg1MSlcbiAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIG51bGwsIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zLFxuICBpc1JlbmRlcldhdGNoZXJcbikge1xuICB0aGlzLnZtID0gdm07XG4gIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gIH1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQxOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiB1c2VyRGVmO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluamVjdCwga2V5KS5lbnVtZXJhYmxlXG4gICAgICB9KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgaGFzT3duKHNvdXJjZS5fcHJvdmlkZWQsIHByb3ZpZGVLZXkpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3ROb2Rlcy5fcmVuZGVyZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIG5vZGVzID0gc2xvdE5vZGVzIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBkYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pOyB9O1xuICB9XG59XG5cbmluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHRWbSxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cblxuICB2YXIgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChcbiAgICBkYXRhLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRleHRWbSxcbiAgICBDdG9yXG4gICk7XG5cbiAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcblxuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucylcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHZhciB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW2ldID0gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZXNbaV0sIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQgKHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMpIHtcbiAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcbiAgLy8gKGUuZy4gaXQgd2FzIGZyb20gYSBjYWNoZWQgbm9ybWFsIHNsb3QpIHRoZSBmbkNvbnRleHQgY2F1c2VzIG5hbWVkIHNsb3RzXG4gIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxuICB2YXIgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgY2xvbmUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cblxuXG5cbi8vIFJlZ2lzdGVyIHRoZSBjb21wb25lbnQgaG9vayB0byB3ZWV4IG5hdGl2ZSByZW5kZXIgZW5naW5lLlxuLy8gVGhlIGhvb2sgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgbmF0aXZlLCBub3QgamF2YXNjcmlwdC5cblxuXG4vLyBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG5cbi8qICAqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XG5cbi8vIGxpc3RlbmluZyBvbiBuYXRpdmUgY2FsbGJhY2tcblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgLy8gV2VleCBzcGVjaWZpYzogaW52b2tlIHJlY3ljbGUtbGlzdCBvcHRpbWl6ZWQgQHJlbmRlciBmdW5jdGlvbiBmb3JcbiAgLy8gZXh0cmFjdGluZyBjZWxsLXNsb3QgdGVtcGxhdGUuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICBob29rc1trZXldID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVmICM1MzE4XG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICB9XG4gIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICAvLyByZXNldCBfcmVuZGVyZWQgZmxhZyBvbiBzbG90cyBmb3IgZHVwbGljYXRlIHNsb3QgY2hlY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgdm0uJHNsb3RzW2tleV0uX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQkMyA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG5cbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XG4gIHZhciBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cztcbiAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXG4gIGNhY2hlLFxuICBrZXksXG4gIGtleXMsXG4gIGN1cnJlbnRcbikge1xuICB2YXIgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGUsIGtleSwgdGhpcyQxLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICB2YXIgZXhjbHVkZSA9IHJlZi5leGNsdWRlO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmJDEgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn1cblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi41LjE3JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cblxuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgKFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgKSB8fCAoXG4gICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xuICAgICAgICB9KVxuICAgICAgKSAmJlxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgIClcbiAgfVxuXG4gIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxtIChcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbSxcbiAgICBuZXN0ZWQsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleFxuICApIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgIC8vIG5vdyBpdCdzIHVzZWQgYXMgYSBuZXcgbm9kZSwgb3ZlcndyaXRpbmcgaXRzIGVsbSB3b3VsZCBjYXVzZVxuICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgIC8vIGFzc29jaWF0ZWQgRE9NIGVsZW1lbnQgZm9yIGl0LlxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgIHZub2RlLmVsbSA9IGVsbTtcblxuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gYXNzZXJ0IG5vZGUgbWF0Y2hcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgIHZhciBpbnNlcnQgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xuICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGluc2VydC5mbnMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoZWwudGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxuICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgID8gJ3RydWUnXG4gICAgICAgIDoga2V5O1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmICFlbC5fX2llcGhcbiAgICApIHtcbiAgICAgIHZhciBibG9ja2VyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIH07XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuXG5cblxuXG5cblxuXG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuXG5cblxuXG5cblxuXG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuXG4vKiAgKi9cblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBoYW5kbGVyID0gd2l0aE1hY3JvVGFzayhoYW5kbGVyKTtcbiAgaWYgKG9uY2UkJDEpIHsgaGFuZGxlciA9IGNyZWF0ZU9uY2VIYW5kbGVyKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKTsgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIuX3dpdGhUYXNrIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLmxhenkpIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIGxhenkgc2hvdWxkIG9ubHkgYmUgdXBkYXRlZCB3aGVuIG5vdCBpbiBmb2N1c1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn1cblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl1cblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufVxuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93OiBzaG93XG59XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn1cblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgaXNDaHJvbWVcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbm1vZHVsZS5leHBvcnRzID0gVnVlO1xuIiwiKGZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dChyZXF1aXJlKFwibGVhZmxldFwiKSxyZXF1aXJlKFwibGVhZmxldC5tYXJrZXJjbHVzdGVyXCIpLHJlcXVpcmUoXCJ2dWUyLWxlYWZsZXRcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wibGVhZmxldFwiLFwibGVhZmxldC5tYXJrZXJjbHVzdGVyXCIsXCJ2dWUyLWxlYWZsZXRcIl0sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5WdWUyTGVhZmxldE1hcmtlcmNsdXN0ZXI9dChyZXF1aXJlKFwibGVhZmxldFwiKSxyZXF1aXJlKFwibGVhZmxldC5tYXJrZXJjbHVzdGVyXCIpLHJlcXVpcmUoXCJ2dWUyLWxlYWZsZXRcIikpOmUuVnVlMkxlYWZsZXRNYXJrZXJjbHVzdGVyPXQoZS5sZWFmbGV0LGVbXCJsZWFmbGV0Lm1hcmtlcmNsdXN0ZXJcIl0sZVtcInZ1ZTItbGVhZmxldFwiXSl9KSh0aGlzLGZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXtpZihyW25dKXJldHVybiByW25dLmV4cG9ydHM7dmFyIG89cltuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsdCksby5sPSEwLG8uZXhwb3J0c312YXIgcj17fTtyZXR1cm4gdC5tPWUsdC5jPXIsdC5pPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LmQ9ZnVuY3Rpb24oZSxyLG4pe3QubyhlLHIpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6bn0pfSx0Lm49ZnVuY3Rpb24oZSl7dmFyIHI9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIHQuZChyLFwiYVwiLHIpLHJ9LHQubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sdC5wPVwiL1wiLHQodC5zPTcpfShbZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMikocigxKSxyKDMpLG51bGwsbnVsbCk7ZS5leHBvcnRzPW4uZXhwb3J0c30sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPXIoNCksbz1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19KG4pO3IoNSk7dmFyIHU9cig2KSxhPXtvcHRpb25zOnt0eXBlOk9iamVjdCxkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJue319fX07dC5kZWZhdWx0PXtwcm9wczphLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57cmVhZHk6ITF9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dGhpcy5tYXBPYmplY3Q9by5kZWZhdWx0Lm1hcmtlckNsdXN0ZXJHcm91cCh0aGlzLm9wdGlvbnMpLG8uZGVmYXVsdC5Eb21FdmVudC5vbih0aGlzLm1hcE9iamVjdCx0aGlzLiRsaXN0ZW5lcnMpLCgwLHUucHJvcHNCaW5kZXIpKHRoaXMsdGhpcy5tYXBPYmplY3QsYSksdGhpcy5yZWFkeT0hMCx0aGlzLnBhcmVudENvbnRhaW5lcj0oMCx1LmZpbmRSZWFsUGFyZW50KSh0aGlzLiRwYXJlbnQpLHRoaXMucGFyZW50Q29udGFpbmVyLmFkZExheWVyKHRoaXMpfSxiZWZvcmVEZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5wYXJlbnRDb250YWluZXIucmVtb3ZlTGF5ZXIodGhpcyl9LG1ldGhvZHM6e2FkZExheWVyOmZ1bmN0aW9uKGUsdCl7dHx8dGhpcy5tYXBPYmplY3QuYWRkTGF5ZXIoZS5tYXBPYmplY3QpfSxyZW1vdmVMYXllcjpmdW5jdGlvbihlLHQpe3R8fHRoaXMubWFwT2JqZWN0LnJlbW92ZUxheWVyKGUubWFwT2JqZWN0KX19fX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIG8sdT1lPWV8fHt9LGE9dHlwZW9mIGUuZGVmYXVsdDtcIm9iamVjdFwiIT09YSYmXCJmdW5jdGlvblwiIT09YXx8KG89ZSx1PWUuZGVmYXVsdCk7dmFyIGk9XCJmdW5jdGlvblwiPT10eXBlb2YgdT91Lm9wdGlvbnM6dTtpZih0JiYoaS5yZW5kZXI9dC5yZW5kZXIsaS5zdGF0aWNSZW5kZXJGbnM9dC5zdGF0aWNSZW5kZXJGbnMpLHImJihpLl9zY29wZUlkPXIpLG4pe3ZhciBmPWkuY29tcHV0ZWR8fChpLmNvbXB1dGVkPXt9KTtPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PW5bZV07ZltlXT1mdW5jdGlvbigpe3JldHVybiB0fX0pfXJldHVybntlc01vZHVsZTpvLGV4cG9ydHM6dSxvcHRpb25zOml9fX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1lLiRjcmVhdGVFbGVtZW50O3JldHVybihlLl9zZWxmLl9jfHx0KShcImRpdlwiLHtzdGF0aWNTdHlsZTp7ZGlzcGxheTpcIm5vbmVcIn19LFtlLnJlYWR5P2UuX3QoXCJkZWZhdWx0XCIpOmUuX2UoKV0sMil9LHN0YXRpY1JlbmRlckZuczpbXX19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXJlcXVpcmUoXCJsZWFmbGV0XCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwibGVhZmxldC5tYXJrZXJjbHVzdGVyXCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidnVlMi1sZWFmbGV0XCIpfSxmdW5jdGlvbihlLHQscil7ZS5leHBvcnRzPXIoMCl9XSl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZ1ZTJMZWFmbGV0TWFya2VyY2x1c3Rlci5qcy5tYXAiLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKHJlcXVpcmUoXCJsZWFmbGV0XCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImxlYWZsZXRcIl0sZSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5WdWUyTGVhZmxldD1lKHJlcXVpcmUoXCJsZWFmbGV0XCIpKTp0LlZ1ZTJMZWFmbGV0PWUodC5MKX0od2luZG93LGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgZT17fTtmdW5jdGlvbiBuKGkpe2lmKGVbaV0pcmV0dXJuIGVbaV0uZXhwb3J0czt2YXIgcj1lW2ldPXtpOmksbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtpXS5jYWxsKHIuZXhwb3J0cyxyLHIuZXhwb3J0cyxuKSxyLmw9ITAsci5leHBvcnRzfXJldHVybiBuLm09dCxuLmM9ZSxuLmQ9ZnVuY3Rpb24odCxlLGkpe24ubyh0LGUpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHtlbnVtZXJhYmxlOiEwLGdldDppfSl9LG4ucj1mdW5jdGlvbih0KXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxuLnQ9ZnVuY3Rpb24odCxlKXtpZigxJmUmJih0PW4odCkpLDgmZSlyZXR1cm4gdDtpZig0JmUmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGk9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIoaSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGksXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pLDImZSYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpZm9yKHZhciByIGluIHQpbi5kKGkscixmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0uYmluZChudWxsLHIpKTtyZXR1cm4gaX0sbi5uPWZ1bmN0aW9uKHQpe3ZhciBlPXQmJnQuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiB0LmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIHR9O3JldHVybiBuLmQoZSxcImFcIixlKSxlfSxuLm89ZnVuY3Rpb24odCxlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSl9LG4ucD1cIlwiLG4obi5zPTUzKX0oW2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuLnIoZSk7dmFyIGk9big1MSkscj1uLm4oaSk7ZS5kZWZhdWx0PWZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgbz1yKCkobikscz1mdW5jdGlvbigpe3ZhciBpPW9bYV0scj1cInNldFwiK2Z1bmN0aW9uKHQpe3JldHVybiB0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSl9KGkpLHM9bltpXS50eXBlPT09T2JqZWN0fHxuW2ldLnR5cGU9PT1BcnJheXx8QXJyYXkuaXNBcnJheShuW2ldLnR5cGUpO25baV0uY3VzdG9tP3QuJHdhdGNoKGksZnVuY3Rpb24oZSxuKXt0W3JdKGUsbil9LHtkZWVwOnN9KTpcInNldE9wdGlvbnNcIj09PXI/dC4kd2F0Y2goaSxmdW5jdGlvbih0LG4pe0wuc2V0T3B0aW9ucyhlLHQpfSx7ZGVlcDpzfSk6dC4kd2F0Y2goaSxmdW5jdGlvbih0LG4pe2Vbcl0odCl9LHtkZWVwOnN9KX0sYT0wO2E8by5sZW5ndGg7YSsrKXMoKX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKHQsZSxuLGkscixvLHMsYSl7dmFyIHU9dHlwZW9mKHQ9dHx8e30pLmRlZmF1bHQ7XCJvYmplY3RcIiE9PXUmJlwiZnVuY3Rpb25cIiE9PXV8fCh0PXQuZGVmYXVsdCk7dmFyIGMsbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Qub3B0aW9uczp0O2lmKGUmJihsLnJlbmRlcj1lLGwuc3RhdGljUmVuZGVyRm5zPW4sbC5fY29tcGlsZWQ9ITApLGkmJihsLmZ1bmN0aW9uYWw9ITApLG8mJihsLl9zY29wZUlkPW8pLHM/KGM9ZnVuY3Rpb24odCl7KHQ9dHx8dGhpcy4kdm5vZGUmJnRoaXMuJHZub2RlLnNzckNvbnRleHR8fHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC4kdm5vZGUmJnRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KXx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX198fCh0PV9fVlVFX1NTUl9DT05URVhUX18pLHImJnIuY2FsbCh0aGlzLHQpLHQmJnQuX3JlZ2lzdGVyZWRDb21wb25lbnRzJiZ0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQocyl9LGwuX3NzclJlZ2lzdGVyPWMpOnImJihjPWE/ZnVuY3Rpb24oKXtyLmNhbGwodGhpcyx0aGlzLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3QpfTpyKSxjKWlmKGwuZnVuY3Rpb25hbCl7bC5faW5qZWN0U3R5bGVzPWM7dmFyIHA9bC5yZW5kZXI7bC5yZW5kZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gYy5jYWxsKGUpLHAodCxlKX19ZWxzZXt2YXIgZj1sLmJlZm9yZUNyZWF0ZTtsLmJlZm9yZUNyZWF0ZT1mP1tdLmNvbmNhdChmLGMpOltjXX1yZXR1cm57ZXhwb3J0czp0LG9wdGlvbnM6bH19bi5kKGUsXCJhXCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bi5kKGUsXCJhXCIsZnVuY3Rpb24oKXtyZXR1cm4gc30pO3ZhciBpPW4oNTIpLHI9bi5uKGkpLG89ZnVuY3Rpb24odCl7dmFyIGU9e307Zm9yKHZhciBuIGluIHQpe3ZhciBpPXRbbl07bnVsbCE9PWkmJnZvaWQgMCE9PWkmJihlW25dPWkpfXJldHVybiBlfSxzPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5vcHRpb25zJiZlLm9wdGlvbnMuY29uc3RydWN0b3I9PT1PYmplY3Q/ZS5vcHRpb25zOnt9O3Q9dCYmdC5jb25zdHJ1Y3Rvcj09PU9iamVjdD90Ont9O3ZhciBpPW8obik7dD1vKHQpO3ZhciBzPWUuJG9wdGlvbnMucHJvcHM7Zm9yKHZhciBhIGluIHQpe3ZhciB1PXNbYV0/c1thXS5kZWZhdWx0OnIoKShcInVuaXF1ZVwiKTtpW2FdJiZ1IT09dFthXT8oY29uc29sZS53YXJuKGErXCIgcHJvcHMgaXMgb3ZlcnJpZGluZyB0aGUgdmFsdWUgcGFzc2VkIGluIHRoZSBvcHRpb25zIHByb3BzXCIpLGlbYV09dFthXSk6aVthXXx8KGlbYV09dFthXSl9cmV0dXJuIGl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpLGUuZGVmYXVsdD1mdW5jdGlvbih0KXtmb3IodmFyIGU9ITE7IWU7KXZvaWQgMD09PXQubWFwT2JqZWN0P3Q9dC4kcGFyZW50OmU9ITA7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5fX2VzTW9kdWxlPSEwO3ZhciBpPWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX0obig3NykpO2UuZGVmYXVsdD1pLmRlZmF1bHR8fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBuPWFyZ3VtZW50c1tlXTtmb3IodmFyIGkgaW4gbilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixpKSYmKHRbaV09bltpXSl9cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5hPXtwcm9wczp7b3B0aW9uczp7dHlwZTpPYmplY3QsZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybnt9fX19fX0sZnVuY3Rpb24oZSxuKXtlLmV4cG9ydHM9dH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuYT17cHJvcHM6e3BhbmU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJvdmVybGF5UGFuZVwifSxhdHRyaWJ1dGlvbjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfSxuYW1lOnt0eXBlOlN0cmluZyxjdXN0b206ITAsZGVmYXVsdDp2b2lkIDB9LGxheWVyVHlwZTp7dHlwZTpTdHJpbmcsY3VzdG9tOiEwLGRlZmF1bHQ6dm9pZCAwfSx2aXNpYmxlOnt0eXBlOkJvb2xlYW4sY3VzdG9tOiEwLGRlZmF1bHQ6ITB9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dGhpcy5sYXllck9wdGlvbnM9e2F0dHJpYnV0aW9uOnRoaXMuYXR0cmlidXRpb24scGFuZTp0aGlzLnBhbmV9fSxiZWZvcmVEZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5wYXJlbnRDb250YWluZXIucmVtb3ZlTGF5ZXIodGhpcyl9LG1ldGhvZHM6e3NldEF0dHJpYnV0aW9uOmZ1bmN0aW9uKHQsZSl7dGhpcy4kcGFyZW50Lm1hcE9iamVjdC5hdHRyaWJ1dGlvbkNvbnRyb2wucmVtb3ZlQXR0cmlidXRpb24oZSkuYWRkQXR0cmlidXRpb24odCl9LHNldE5hbWU6ZnVuY3Rpb24odCxlKXt0IT09ZSYmKHRoaXMucGFyZW50Q29udGFpbmVyLnJlbW92ZUxheWVyKHRoaXMpLHRoaXMudmlzaWJsZSYmdGhpcy5wYXJlbnRDb250YWluZXIuYWRkTGF5ZXIodGhpcykpfSxzZXRMYXllclR5cGU6ZnVuY3Rpb24odCxlKXt0IT09ZSYmKHRoaXMucGFyZW50Q29udGFpbmVyLnJlbW92ZUxheWVyKHRoaXMpLHRoaXMudmlzaWJsZSYmdGhpcy5wYXJlbnRDb250YWluZXIuYWRkTGF5ZXIodGhpcykpfSxzZXRWaXNpYmxlOmZ1bmN0aW9uKHQsZSl7dCE9PWUmJnRoaXMubWFwT2JqZWN0JiYodD90aGlzLnBhcmVudENvbnRhaW5lci5hZGRMYXllcih0aGlzKTp0aGlzLnBhcmVudENvbnRhaW5lci5yZW1vdmVMYXllcih0aGlzKSl9fX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmE9e3Byb3BzOntwb3NpdGlvbjp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcInRvcHJpZ2h0XCJ9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dGhpcy5jb250cm9sT3B0aW9ucz17cG9zaXRpb246dGhpcy5wb3NpdGlvbn19LGJlZm9yZURlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLm1hcE9iamVjdCYmdGhpcy5tYXBPYmplY3QucmVtb3ZlKCl9fX0sZnVuY3Rpb24odCxlKXt2YXIgbj10LmV4cG9ydHM9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93Lk1hdGg9PU1hdGg/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmLk1hdGg9PU1hdGg/c2VsZjpGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XCJudW1iZXJcIj09dHlwZW9mIF9fZyYmKF9fZz1uKX0sZnVuY3Rpb24odCxlKXt2YXIgbj10LmV4cG9ydHM9e3ZlcnNpb246XCIyLjUuM1wifTtcIm51bWJlclwiPT10eXBlb2YgX19lJiYoX19lPW4pfSxmdW5jdGlvbih0LGUsbil7dmFyIGk9bigyMCkscj1uKDQ2KSxvPW4oMzQpLHM9T2JqZWN0LmRlZmluZVByb3BlcnR5O2UuZj1uKDEyKT9PYmplY3QuZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24odCxlLG4pe2lmKGkodCksZT1vKGUsITApLGkobikscil0cnl7cmV0dXJuIHModCxlLG4pfWNhdGNoKHQpe31pZihcImdldFwiaW4gbnx8XCJzZXRcImluIG4pdGhyb3cgVHlwZUVycm9yKFwiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhXCIpO3JldHVyblwidmFsdWVcImluIG4mJih0W2VdPW4udmFsdWUpLHR9fSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPSFuKDEzKShmdW5jdGlvbigpe3JldHVybiA3IT1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJhXCIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmF9KX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiEhdCgpfWNhdGNoKHQpe3JldHVybiEwfX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1uKDcpO2UuYT17bWl4aW5zOltpLmFdLG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLmxheWVyR3JvdXBPcHRpb25zPXRoaXMubGF5ZXJPcHRpb25zfSxtZXRob2RzOnthZGRMYXllcjpmdW5jdGlvbih0LGUpe2V8fHRoaXMubWFwT2JqZWN0LmFkZExheWVyKHQubWFwT2JqZWN0KSx0aGlzLnBhcmVudENvbnRhaW5lci5hZGRMYXllcih0LCEwKX0scmVtb3ZlTGF5ZXI6ZnVuY3Rpb24odCxlKXtlfHx0aGlzLm1hcE9iamVjdC5yZW1vdmVMYXllcih0Lm1hcE9iamVjdCksdGhpcy5wYXJlbnRDb250YWluZXIucmVtb3ZlTGF5ZXIodCwhMCl9fX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDQxKSxyPW4oMzEpO3QuZXhwb3J0cz1PYmplY3Qua2V5c3x8ZnVuY3Rpb24odCl7cmV0dXJuIGkodCxyKX19LGZ1bmN0aW9uKHQsZSl7dmFyIG49e30uaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4uY2FsbCh0LGUpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4oNDIpLHI9big0MCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpKHIodCkpfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQ/bnVsbCE9PXQ6XCJmdW5jdGlvblwiPT10eXBlb2YgdH19LGZ1bmN0aW9uKHQsZSl7dmFyIG49MCxpPU1hdGgucmFuZG9tKCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVyblwiU3ltYm9sKFwiLmNvbmNhdCh2b2lkIDA9PT10P1wiXCI6dCxcIilfXCIsKCsrbitpKS50b1N0cmluZygzNikpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4oMTgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZighaSh0KSl0aHJvdyBUeXBlRXJyb3IodCtcIiBpcyBub3QgYW4gb2JqZWN0IVwiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSl7ZS5mPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9big0KSxyPW4ubihpKSxvPW4oMjMpO2UuYT17bWl4aW5zOltvLmFdLHByb3BzOntyYWRpdXM6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6bnVsbH19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLmNpcmNsZU9wdGlvbnM9cigpKHt9LHRoaXMucGF0aE9wdGlvbnMse3JhZGl1czp0aGlzLnJhZGl1c30pfX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1uKDQpLHI9bi5uKGkpLG89big3KSxzPW4oMjQpO2UuYT17bWl4aW5zOltvLmEscy5hXSxwcm9wczp7bFN0eWxlOnt0eXBlOk9iamVjdCxjdXN0b206ITAsZGVmYXVsdDpudWxsfSxzdHJva2U6e3R5cGU6Qm9vbGVhbixjdXN0b206ITAsZGVmYXVsdDohMH0sY29sb3I6e3R5cGU6U3RyaW5nLGN1c3RvbTohMCxkZWZhdWx0OlwiIzMzODhmZlwifSx3ZWlnaHQ6e3R5cGU6TnVtYmVyLGN1c3RvbTohMCxkZWZhdWx0OjN9LG9wYWNpdHk6e3R5cGU6TnVtYmVyLGN1c3RvbTohMCxkZWZhdWx0OjF9LGxpbmVDYXA6e3R5cGU6U3RyaW5nLGN1c3RvbTohMCxkZWZhdWx0Olwicm91bmRcIn0sbGluZUpvaW46e3R5cGU6U3RyaW5nLGN1c3RvbTohMCxkZWZhdWx0Olwicm91bmRcIn0sZGFzaEFycmF5Ont0eXBlOlN0cmluZyxjdXN0b206ITAsZGVmYXVsdDpudWxsfSxkYXNoT2Zmc2V0Ont0eXBlOlN0cmluZyxjdXN0b206ITAsZGVmYXVsdDpudWxsfSxmaWxsOnt0eXBlOkJvb2xlYW4sY3VzdG9tOiEwLGRlZmF1bHQ6ITB9LGZpbGxDb2xvcjp7dHlwZTpTdHJpbmcsY3VzdG9tOiEwLGRlZmF1bHQ6XCIjMzM4OGZmXCJ9LGZpbGxPcGFjaXR5Ont0eXBlOk51bWJlcixjdXN0b206ITAsZGVmYXVsdDouMn0sZmlsbFJ1bGU6e3R5cGU6U3RyaW5nLGN1c3RvbTohMCxkZWZhdWx0OlwiZXZlbm9kZFwifSxjbGFzc05hbWU6e3R5cGU6U3RyaW5nLGN1c3RvbTohMCxkZWZhdWx0Om51bGx9fSxtb3VudGVkOmZ1bmN0aW9uKCl7aWYodGhpcy5wYXRoT3B0aW9ucz1yKCkoe30sdGhpcy5sYXllck9wdGlvbnMsdGhpcy5pbnRlcmFjdGl2ZUxheWVyT3B0aW9ucyx7c3Ryb2tlOnRoaXMuc3Ryb2tlLGNvbG9yOnRoaXMuY29sb3Isd2VpZ2h0OnRoaXMud2VpZ2h0LG9wYWNpdHk6dGhpcy5vcGFjaXR5LGxpbmVDYXA6dGhpcy5saW5lQ2FwLGxpbmVKb2luOnRoaXMubGluZUpvaW4sZGFzaEFycmF5OnRoaXMuZGFzaEFycmF5LGRhc2hPZmZzZXQ6dGhpcy5kYXNoT2Zmc2V0LGZpbGw6dGhpcy5maWxsLGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvcixmaWxsT3BhY2l0eTp0aGlzLmZpbGxPcGFjaXR5LGZpbGxSdWxlOnRoaXMuZmlsbFJ1bGUsY2xhc3NOYW1lOnRoaXMuY2xhc3NOYW1lfSksdGhpcy5sU3R5bGUpZm9yKHZhciB0IGluIGNvbnNvbGUud2FybihcImxTdHlsZSBpcyBkZXByZWNhdGVkIGFuZCBpcyBnb2luZyB0byBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cIiksdGhpcy5sU3R5bGUpdGhpcy5wYXRoT3B0aW9uc1t0XT10aGlzLmxTdHlsZVt0XX0sYmVmb3JlRGVzdHJveTpmdW5jdGlvbigpe3RoaXMucGFyZW50Q29udGFpbmVyP3RoaXMucGFyZW50Q29udGFpbmVyLnJlbW92ZUxheWVyKHRoaXMpOmNvbnNvbGUuZXJyb3IoXCJNaXNzaW5nIHBhcmVudCBjb250YWluZXJcIil9LG1ldGhvZHM6e3NldExTdHlsZTpmdW5jdGlvbih0KXt0aGlzLm1hcE9iamVjdC5zZXRTdHlsZSh0KX0sc2V0U3Ryb2tlOmZ1bmN0aW9uKHQsZSl7dCE9PWUmJnRoaXMubWFwT2JqZWN0LnNldFN0eWxlKHtzdHJva2U6dH0pfSxzZXRDb2xvcjpmdW5jdGlvbih0LGUpe3QhPT1lJiZ2b2lkIDAhPT10JiZudWxsIT09dCYmdGhpcy5tYXBPYmplY3Quc2V0U3R5bGUoe2NvbG9yOnR9KX0sc2V0V2VpZ2h0OmZ1bmN0aW9uKHQsZSl7dCE9PWUmJnQmJnRoaXMubWFwT2JqZWN0LnNldFN0eWxlKHt3ZWlnaHQ6dH0pfSxzZXRPcGFjaXR5OmZ1bmN0aW9uKHQsZSl7dCE9PWUmJnZvaWQgMCE9PXQmJm51bGwhPT10JiZ0aGlzLm1hcE9iamVjdC5zZXRTdHlsZSh7b3BhY2l0eTp0fSl9LHNldExpbmVDYXA6ZnVuY3Rpb24odCxlKXt0IT09ZSYmdCYmdGhpcy5tYXBPYmplY3Quc2V0U3R5bGUoe2xpbmVDYXA6dH0pfSxzZXRMaW5lSm9pbjpmdW5jdGlvbih0LGUpe3QhPT1lJiZ0JiZ0aGlzLm1hcE9iamVjdC5zZXRTdHlsZSh7bGluZUpvaW46dH0pfSxzZXREYXNoQXJyYXk6ZnVuY3Rpb24odCxlKXt0IT09ZSYmdCYmdGhpcy5tYXBPYmplY3Quc2V0U3R5bGUoe2Rhc2hBcnJheTp0fSl9LHNldERhc2hPZmZzZXQ6ZnVuY3Rpb24odCxlKXt0IT09ZSYmdCYmdGhpcy5tYXBPYmplY3Quc2V0U3R5bGUoe2Rhc2hPZmZzZXQ6dH0pfSxzZXRGaWxsOmZ1bmN0aW9uKHQsZSl7dCE9PWUmJnRoaXMubWFwT2JqZWN0LnNldFN0eWxlKHtmaWxsOnR9KX0sc2V0RmlsbENvbG9yOmZ1bmN0aW9uKHQsZSl7dCE9PWUmJnQmJnRoaXMubWFwT2JqZWN0LnNldFN0eWxlKHtmaWxsQ29sb3I6dH0pfSxzZXRGaWxsT3BhY2l0eTpmdW5jdGlvbih0LGUpe3QhPT1lJiZ0JiZ0aGlzLm1hcE9iamVjdC5zZXRTdHlsZSh7ZmlsbE9wYWNpdHk6dH0pfSxzZXRGaWxsUnVsZTpmdW5jdGlvbih0LGUpe3QhPT1lJiZ0JiZ0aGlzLm1hcE9iamVjdC5zZXRTdHlsZSh7ZmlsbFJ1bGU6dH0pfSxzZXRDbGFzc05hbWU6ZnVuY3Rpb24odCxlKXt0IT09ZSYmdCYmdGhpcy5tYXBPYmplY3Quc2V0U3R5bGUoe2NsYXNzTmFtZTp0fSl9fX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmE9e3Byb3BzOntpbnRlcmFjdGl2ZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITB9LGJ1YmJsaW5nTW91c2VFdmVudHM6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiEwfX0sbW91bnRlZDpmdW5jdGlvbigpe3RoaXMuaW50ZXJhY3RpdmVMYXllck9wdGlvbnM9e2ludGVyYWN0aXZlOnRoaXMuaW50ZXJhY3RpdmUsYnViYmxpbmdNb3VzZUV2ZW50czp0aGlzLmJ1YmJsaW5nTW91c2VFdmVudHN9fX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmE9ZnVuY3Rpb24odCxlKXt2YXIgbj12b2lkIDA7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgscj1BcnJheShpKSxvPTA7bzxpO28rKylyW29dPWFyZ3VtZW50c1tvXTt2YXIgcz10aGlzO2NsZWFyVGltZW91dChuKSxuPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShzLHIpfSxlKX19fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9bigyNyk7ZS5hPXttaXhpbnM6W2kuYV0sbW91bnRlZDpmdW5jdGlvbigpe3RoaXMucG9seWdvbk9wdGlvbnM9dGhpcy5wb2x5TGluZU9wdGlvbnN9LG1ldGhvZHM6e2dldEdlb0pTT05EYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwT2JqZWN0LnRvR2VvSlNPTigpfX19fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9big0KSxyPW4ubihpKSxvPW4oMjMpO2UuYT17bWl4aW5zOltvLmFdLHByb3BzOntzbW9vdGhGYWN0b3I6e3R5cGU6TnVtYmVyLGN1c3RvbTohMCxkZWZhdWx0OjF9LG5vQ2xpcDp7dHlwZTpCb29sZWFuLGN1c3RvbTohMCxkZWZhdWx0OiExfX0sZGF0YTpmdW5jdGlvbigpe3JldHVybntyZWFkeTohMX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLnBvbHlMaW5lT3B0aW9ucz1yKCkoe30sdGhpcy5wYXRoT3B0aW9ucyx7c21vb3RoRmFjdG9yOnRoaXMuc21vb3RoRmFjdG9yLG5vQ2xpcDp0aGlzLm5vQ2xpcH0pfSxtZXRob2RzOntzZXRTbW9vdGhGYWN0b3I6ZnVuY3Rpb24odCxlKXt0IT09ZSYmdCYmdGhpcy5tYXBPYmplY3Quc2V0U3R5bGUoe3Ntb290aEZhY3Rvcjp0fSl9LHNldE5vQ2xpcDpmdW5jdGlvbih0LGUpe3QhPT1lJiZ0JiZ0aGlzLm1hcE9iamVjdC5zZXRTdHlsZSh7bm9DbGlwOnR9KX0sYWRkTGF0TG5nOmZ1bmN0aW9uKHQpe3RoaXMubWFwT2JqZWN0LmFkZExhdExuZyh0KX19fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuYT17cHJvcHM6e2NvbnRlbnQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6bnVsbCxjdXN0b206ITB9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dGhpcy5wb3BwZXJPcHRpb25zPXt9fSxtZXRob2RzOntzZXRDb250ZW50OmZ1bmN0aW9uKHQpe3RoaXMubWFwT2JqZWN0JiZudWxsIT09dCYmdm9pZCAwIT09dCYmdGhpcy5tYXBPYmplY3Quc2V0Q29udGVudCh0KX19LHJlbmRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy4kc2xvdHMuZGVmYXVsdD90KFwiZGl2XCIsdGhpcy4kc2xvdHMuZGVmYXVsdCk6bnVsbH19fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9big0KSxyPW4ubihpKSxvPXttaXhpbnM6W24oNykuYV0scHJvcHM6e3BhbmU6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJ0aWxlUGFuZVwifSxvcGFjaXR5Ont0eXBlOk51bWJlcixjdXN0b206ITEsZGVmYXVsdDoxfSx6SW5kZXg6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6MX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLmdyaWRMYXllck9wdGlvbnM9cigpKHt9LHRoaXMubGF5ZXJPcHRpb25zLHtwYW5lOnRoaXMucGFuZSxvcGFjaXR5OnRoaXMub3BhY2l0eSx6SW5kZXg6dGhpcy56SW5kZXh9KX19O2UuYT17bWl4aW5zOltvXSxwcm9wczp7dG1zOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZGV0ZWN0UmV0aW5hOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLnRpbGVMYXllck9wdGlvbnM9cigpKHt9LHRoaXMuZ3JpZExheWVyT3B0aW9ucyx7dG1zOnRoaXMudG1zLGRldGVjdFJldGluYTp0aGlzLmRldGVjdFJldGluYX0pfSxyZW5kZXI6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH19fSxmdW5jdGlvbih0LGUsbil7dmFyIGk9big5KSxyPWlbXCJfX2NvcmUtanNfc2hhcmVkX19cIl18fChpW1wiX19jb3JlLWpzX3NoYXJlZF9fXCJdPXt9KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHJbdF18fChyW3RdPXt9KX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPVwiY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mXCIuc3BsaXQoXCIsXCIpfSxmdW5jdGlvbih0LGUsbil7dmFyIGk9big5KSxyPW4oMTApLG89big2MCkscz1uKDMzKSxhPWZ1bmN0aW9uKHQsZSxuKXt2YXIgdSxjLGwscD10JmEuRixmPXQmYS5HLGg9dCZhLlMsZD10JmEuUCxtPXQmYS5CLHk9dCZhLlcsYj1mP3I6cltlXXx8KHJbZV09e30pLE89Yi5wcm90b3R5cGUsdj1mP2k6aD9pW2VdOihpW2VdfHx7fSkucHJvdG90eXBlO2Zvcih1IGluIGYmJihuPWUpLG4pKGM9IXAmJnYmJnZvaWQgMCE9PXZbdV0pJiZ1IGluIGJ8fChsPWM/dlt1XTpuW3VdLGJbdV09ZiYmXCJmdW5jdGlvblwiIT10eXBlb2Ygdlt1XT9uW3VdOm0mJmM/byhsLGkpOnkmJnZbdV09PWw/ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oZSxuLGkpe2lmKHRoaXMgaW5zdGFuY2VvZiB0KXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBuZXcgdDtjYXNlIDE6cmV0dXJuIG5ldyB0KGUpO2Nhc2UgMjpyZXR1cm4gbmV3IHQoZSxuKX1yZXR1cm4gbmV3IHQoZSxuLGkpfXJldHVybiB0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07cmV0dXJuIGUucHJvdG90eXBlPXQucHJvdG90eXBlLGV9KGwpOmQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGw/byhGdW5jdGlvbi5jYWxsLGwpOmwsZCYmKChiLnZpcnR1YWx8fChiLnZpcnR1YWw9e30pKVt1XT1sLHQmYS5SJiZPJiYhT1t1XSYmcyhPLHUsbCkpKX07YS5GPTEsYS5HPTIsYS5TPTQsYS5QPTgsYS5CPTE2LGEuVz0zMixhLlU9NjQsYS5SPTEyOCx0LmV4cG9ydHM9YX0sZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4oMTEpLHI9bigzNSk7dC5leHBvcnRzPW4oMTIpP2Z1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaS5mKHQsZSxyKDEsbikpfTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRbZV09bix0fX0sZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4oMTgpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2lmKCFpKHQpKXJldHVybiB0O3ZhciBuLHI7aWYoZSYmXCJmdW5jdGlvblwiPT10eXBlb2Yobj10LnRvU3RyaW5nKSYmIWkocj1uLmNhbGwodCkpKXJldHVybiByO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mKG49dC52YWx1ZU9mKSYmIWkocj1uLmNhbGwodCkpKXJldHVybiByO2lmKCFlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZihuPXQudG9TdHJpbmcpJiYhaShyPW4uY2FsbCh0KSkpcmV0dXJuIHI7dGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6ZX19fSxmdW5jdGlvbih0LGUsbil7dmFyIGk9bigzMCkoXCJ3a3NcIikscj1uKDE5KSxvPW4oOSkuU3ltYm9sLHM9XCJmdW5jdGlvblwiPT10eXBlb2YgbzsodC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpW3RdfHwoaVt0XT1zJiZvW3RdfHwocz9vOnIpKFwiU3ltYm9sLlwiK3QpKX0pLnN0b3JlPWl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDkpLHI9bigxMCksbz1uKDQ5KSxzPW4oNDgpLGE9bigxMSkuZjt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9ci5TeW1ib2x8fChyLlN5bWJvbD1vP3t9OmkuU3ltYm9sfHx7fSk7XCJfXCI9PXQuY2hhckF0KDApfHx0IGluIGV8fGEoZSx0LHt2YWx1ZTpzLmYodCl9KX19LGZ1bmN0aW9uKHQsZSl7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHN9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDQwKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdChpKHQpKX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09dCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIrdCk7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUsbil7dmFyIGk9bigxNikscj1uKDE3KSxvPW4oNTYpKCExKSxzPW4oNDUpKFwiSUVfUFJPVE9cIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG4sYT1yKHQpLHU9MCxjPVtdO2ZvcihuIGluIGEpbiE9cyYmaShhLG4pJiZjLnB1c2gobik7Zm9yKDtlLmxlbmd0aD51OylpKGEsbj1lW3UrK10pJiYofm8oYyxuKXx8Yy5wdXNoKG4pKTtyZXR1cm4gY319LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDQzKTt0LmV4cG9ydHM9T2JqZWN0KFwielwiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKT9PYmplY3Q6ZnVuY3Rpb24odCl7cmV0dXJuXCJTdHJpbmdcIj09aSh0KT90LnNwbGl0KFwiXCIpOk9iamVjdCh0KX19LGZ1bmN0aW9uKHQsZSl7dmFyIG49e30udG9TdHJpbmc7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBuLmNhbGwodCkuc2xpY2UoOCwtMSl9fSxmdW5jdGlvbih0LGUpe3ZhciBuPU1hdGguY2VpbCxpPU1hdGguZmxvb3I7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpc05hTih0PSt0KT8wOih0PjA/aTpuKSh0KX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDMwKShcImtleXNcIikscj1uKDE5KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGlbdF18fChpW3RdPXIodCkpfX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz0hbigxMikmJiFuKDEzKShmdW5jdGlvbigpe3JldHVybiA3IT1PYmplY3QuZGVmaW5lUHJvcGVydHkobig0NykoXCJkaXZcIiksXCJhXCIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmF9KX0sZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4oMTgpLHI9big5KS5kb2N1bWVudCxvPWkocikmJmkoci5jcmVhdGVFbGVtZW50KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG8/ci5jcmVhdGVFbGVtZW50KHQpOnt9fX0sZnVuY3Rpb24odCxlLG4pe2UuZj1uKDM2KX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ITB9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDQxKSxyPW4oMzEpLmNvbmNhdChcImxlbmd0aFwiLFwicHJvdG90eXBlXCIpO2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc3x8ZnVuY3Rpb24odCl7cmV0dXJuIGkodCxyKX19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e2RlZmF1bHQ6big1NCksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e2RlZmF1bHQ6big2MiksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHQsZSxuKXtlLkw9big2KSxlLmZpbmRSZWFsUGFyZW50PW4oMykuZGVmYXVsdCxlLnByb3BzQmluZGVyPW4oMCkuZGVmYXVsdCxlLkxDaXJjbGU9big5NikuZGVmYXVsdCxlLkxDaXJjbGVNYXJrZXI9big5NCkuZGVmYXVsdCxlLkxDb250cm9sPW4oOTMpLmRlZmF1bHQsZS5MQ29udHJvbEF0dHJpYnV0aW9uPW4oMTAxKS5kZWZhdWx0LGUuTENvbnRyb2xMYXllcnM9bigxMDMpLmRlZmF1bHQsZS5MQ29udHJvbFNjYWxlPW4oMTA1KS5kZWZhdWx0LGUuTENvbnRyb2xab29tPW4oMTA0KS5kZWZhdWx0LGUuTEZlYXR1cmVHcm91cD1uKDg3KS5kZWZhdWx0LGUuTEdlb0pzb249bigxMDApLmRlZmF1bHQsZS5MSWNvbj1uKDkwKS5kZWZhdWx0LGUuTEljb25EZWZhdWx0PW4oMTAyKS5kZWZhdWx0LGUuTEltYWdlT3ZlcmxheT1uKDg1KS5kZWZhdWx0LGUuTExheWVyR3JvdXA9big4NCkuZGVmYXVsdCxlLkxNYXA9big5NSkuZGVmYXVsdCxlLkxNYXJrZXI9big5OCkuZGVmYXVsdCxlLkxQb2x5Z29uPW4oOTIpLmRlZmF1bHQsZS5MUG9seWxpbmU9big5MSkuZGVmYXVsdCxlLkxQb3B1cD1uKDk5KS5kZWZhdWx0LGUuTFJlY3RhbmdsZT1uKDg5KS5kZWZhdWx0LGUuTFRpbGVMYXllcj1uKDg4KS5kZWZhdWx0LGUuTFRvb2x0aXA9big5NykuZGVmYXVsdCxlLkxXTVNUaWxlTGF5ZXI9big4NikuZGVmYXVsdH0sZnVuY3Rpb24odCxlLG4pe24oNTUpLHQuZXhwb3J0cz1uKDEwKS5PYmplY3Qua2V5c30sZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4oMzkpLHI9bigxNSk7big1OSkoXCJrZXlzXCIsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIHIoaSh0KSl9fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDE3KSxyPW4oNTcpLG89big1OCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLG4scyl7dmFyIGEsdT1pKGUpLGM9cih1Lmxlbmd0aCksbD1vKHMsYyk7aWYodCYmbiE9bil7Zm9yKDtjPmw7KWlmKChhPXVbbCsrXSkhPWEpcmV0dXJuITB9ZWxzZSBmb3IoO2M+bDtsKyspaWYoKHR8fGwgaW4gdSkmJnVbbF09PT1uKXJldHVybiB0fHxsfHwwO3JldHVybiF0JiYtMX19fSxmdW5jdGlvbih0LGUsbil7dmFyIGk9big0NCkscj1NYXRoLm1pbjt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MD9yKGkodCksOTAwNzE5OTI1NDc0MDk5MSk6MH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDQ0KSxyPU1hdGgubWF4LG89TWF0aC5taW47dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQ9aSh0KSk8MD9yKHQrZSwwKTpvKHQsZSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIGk9bigzMikscj1uKDEwKSxvPW4oMTMpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBuPShyLk9iamVjdHx8e30pW3RdfHxPYmplY3RbdF0scz17fTtzW3RdPWUobiksaShpLlMraS5GKm8oZnVuY3Rpb24oKXtuKDEpfSksXCJPYmplY3RcIixzKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDYxKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe2lmKGkodCksdm9pZCAwPT09ZSlyZXR1cm4gdDtzd2l0Y2gobil7Y2FzZSAxOnJldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gdC5jYWxsKGUsbil9O2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24obixpKXtyZXR1cm4gdC5jYWxsKGUsbixpKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLGkscil7cmV0dXJuIHQuY2FsbChlLG4saSxyKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoZSxhcmd1bWVudHMpfX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgVHlwZUVycm9yKHQrXCIgaXMgbm90IGEgZnVuY3Rpb24hXCIpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLG4pe24oNjMpLG4oNzQpLG4oNzUpLG4oNzYpLHQuZXhwb3J0cz1uKDEwKS5TeW1ib2x9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1uKDkpLHI9bigxNiksbz1uKDEyKSxzPW4oMzIpLGE9big2NCksdT1uKDY1KS5LRVksYz1uKDEzKSxsPW4oMzApLHA9big2NiksZj1uKDE5KSxoPW4oMzYpLGQ9big0OCksbT1uKDM3KSx5PW4oNjcpLGI9big2OCksTz1uKDIwKSx2PW4oMTgpLGo9bigxNyksZz1uKDM0KSxMPW4oMzUpLFM9big2OSksQz1uKDcyKSx4PW4oNzMpLF89bigxMSksJD1uKDE1KSx3PXguZixBPV8uZixFPUMuZixUPWkuU3ltYm9sLEk9aS5KU09OLEI9SSYmSS5zdHJpbmdpZnksTj1oKFwiX2hpZGRlblwiKSxQPWgoXCJ0b1ByaW1pdGl2ZVwiKSxNPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLEQ9bChcInN5bWJvbC1yZWdpc3RyeVwiKSxSPWwoXCJzeW1ib2xzXCIpLFU9bChcIm9wLXN5bWJvbHNcIiksej1PYmplY3QucHJvdG90eXBlLEY9XCJmdW5jdGlvblwiPT10eXBlb2YgVCxrPWkuUU9iamVjdCxXPSFrfHwhay5wcm90b3R5cGV8fCFrLnByb3RvdHlwZS5maW5kQ2hpbGQsRz1vJiZjKGZ1bmN0aW9uKCl7cmV0dXJuIDchPVMoQSh7fSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEEodGhpcyxcImFcIix7dmFsdWU6N30pLmF9fSkpLmF9KT9mdW5jdGlvbih0LGUsbil7dmFyIGk9dyh6LGUpO2kmJmRlbGV0ZSB6W2VdLEEodCxlLG4pLGkmJnQhPT16JiZBKHosZSxpKX06QSxKPWZ1bmN0aW9uKHQpe3ZhciBlPVJbdF09UyhULnByb3RvdHlwZSk7cmV0dXJuIGUuX2s9dCxlfSxaPUYmJlwic3ltYm9sXCI9PXR5cGVvZiBULml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVyblwic3ltYm9sXCI9PXR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFR9LEg9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0PT09eiYmSChVLGUsbiksTyh0KSxlPWcoZSwhMCksTyhuKSxyKFIsZSk/KG4uZW51bWVyYWJsZT8ocih0LE4pJiZ0W05dW2VdJiYodFtOXVtlXT0hMSksbj1TKG4se2VudW1lcmFibGU6TCgwLCExKX0pKToocih0LE4pfHxBKHQsTixMKDEse30pKSx0W05dW2VdPSEwKSxHKHQsZSxuKSk6QSh0LGUsbil9LFY9ZnVuY3Rpb24odCxlKXtPKHQpO2Zvcih2YXIgbixpPXkoZT1qKGUpKSxyPTAsbz1pLmxlbmd0aDtvPnI7KUgodCxuPWlbcisrXSxlW25dKTtyZXR1cm4gdH0scT1mdW5jdGlvbih0KXt2YXIgZT1NLmNhbGwodGhpcyx0PWcodCwhMCkpO3JldHVybiEodGhpcz09PXomJnIoUix0KSYmIXIoVSx0KSkmJighKGV8fCFyKHRoaXMsdCl8fCFyKFIsdCl8fHIodGhpcyxOKSYmdGhpc1tOXVt0XSl8fGUpfSxLPWZ1bmN0aW9uKHQsZSl7aWYodD1qKHQpLGU9ZyhlLCEwKSx0IT09enx8IXIoUixlKXx8cihVLGUpKXt2YXIgbj13KHQsZSk7cmV0dXJuIW58fCFyKFIsZSl8fHIodCxOKSYmdFtOXVtlXXx8KG4uZW51bWVyYWJsZT0hMCksbn19LFg9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49RShqKHQpKSxpPVtdLG89MDtuLmxlbmd0aD5vOylyKFIsZT1uW28rK10pfHxlPT1OfHxlPT11fHxpLnB1c2goZSk7cmV0dXJuIGl9LFk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49dD09PXosaT1FKG4/VTpqKHQpKSxvPVtdLHM9MDtpLmxlbmd0aD5zOykhcihSLGU9aVtzKytdKXx8biYmIXIoeixlKXx8by5wdXNoKFJbZV0pO3JldHVybiBvfTtGfHwoYSgoVD1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBUKXRocm93IFR5cGVFcnJvcihcIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciFcIik7dmFyIHQ9Zihhcmd1bWVudHMubGVuZ3RoPjA/YXJndW1lbnRzWzBdOnZvaWQgMCksZT1mdW5jdGlvbihuKXt0aGlzPT09eiYmZS5jYWxsKFUsbikscih0aGlzLE4pJiZyKHRoaXNbTl0sdCkmJih0aGlzW05dW3RdPSExKSxHKHRoaXMsdCxMKDEsbikpfTtyZXR1cm4gbyYmVyYmRyh6LHQse2NvbmZpZ3VyYWJsZTohMCxzZXQ6ZX0pLEoodCl9KS5wcm90b3R5cGUsXCJ0b1N0cmluZ1wiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2t9KSx4LmY9SyxfLmY9SCxuKDUwKS5mPUMuZj1YLG4oMjEpLmY9cSxuKDM4KS5mPVksbyYmIW4oNDkpJiZhKHosXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLHEsITApLGQuZj1mdW5jdGlvbih0KXtyZXR1cm4gSihoKHQpKX0pLHMocy5HK3MuVytzLkYqIUYse1N5bWJvbDpUfSk7Zm9yKHZhciBRPVwiaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXNcIi5zcGxpdChcIixcIiksdHQ9MDtRLmxlbmd0aD50dDspaChRW3R0KytdKTtmb3IodmFyIGV0PSQoaC5zdG9yZSksbnQ9MDtldC5sZW5ndGg+bnQ7KW0oZXRbbnQrK10pO3Mocy5TK3MuRiohRixcIlN5bWJvbFwiLHtmb3I6ZnVuY3Rpb24odCl7cmV0dXJuIHIoRCx0Kz1cIlwiKT9EW3RdOkRbdF09VCh0KX0sa2V5Rm9yOmZ1bmN0aW9uKHQpe2lmKCFaKHQpKXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBhIHN5bWJvbCFcIik7Zm9yKHZhciBlIGluIEQpaWYoRFtlXT09PXQpcmV0dXJuIGV9LHVzZVNldHRlcjpmdW5jdGlvbigpe1c9ITB9LHVzZVNpbXBsZTpmdW5jdGlvbigpe1c9ITF9fSkscyhzLlMrcy5GKiFGLFwiT2JqZWN0XCIse2NyZWF0ZTpmdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lP1ModCk6VihTKHQpLGUpfSxkZWZpbmVQcm9wZXJ0eTpILGRlZmluZVByb3BlcnRpZXM6VixnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6SyxnZXRPd25Qcm9wZXJ0eU5hbWVzOlgsZ2V0T3duUHJvcGVydHlTeW1ib2xzOll9KSxJJiZzKHMuUytzLkYqKCFGfHxjKGZ1bmN0aW9uKCl7dmFyIHQ9VCgpO3JldHVyblwiW251bGxdXCIhPUIoW3RdKXx8XCJ7fVwiIT1CKHthOnR9KXx8XCJ7fVwiIT1CKE9iamVjdCh0KSl9KSksXCJKU09OXCIse3N0cmluZ2lmeTpmdW5jdGlvbih0KXtmb3IodmFyIGUsbixpPVt0XSxyPTE7YXJndW1lbnRzLmxlbmd0aD5yOylpLnB1c2goYXJndW1lbnRzW3IrK10pO2lmKG49ZT1pWzFdLCh2KGUpfHx2b2lkIDAhPT10KSYmIVoodCkpcmV0dXJuIGIoZSl8fChlPWZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgbiYmKGU9bi5jYWxsKHRoaXMsdCxlKSksIVooZSkpcmV0dXJuIGV9KSxpWzFdPWUsQi5hcHBseShJLGkpfX0pLFQucHJvdG90eXBlW1BdfHxuKDMzKShULnByb3RvdHlwZSxQLFQucHJvdG90eXBlLnZhbHVlT2YpLHAoVCxcIlN5bWJvbFwiKSxwKE1hdGgsXCJNYXRoXCIsITApLHAoaS5KU09OLFwiSlNPTlwiLCEwKX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz1uKDMzKX0sZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4oMTkpKFwibWV0YVwiKSxyPW4oMTgpLG89bigxNikscz1uKDExKS5mLGE9MCx1PU9iamVjdC5pc0V4dGVuc2libGV8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LGM9IW4oMTMpKGZ1bmN0aW9uKCl7cmV0dXJuIHUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSl9KSxsPWZ1bmN0aW9uKHQpe3ModCxpLHt2YWx1ZTp7aTpcIk9cIisgKythLHc6e319fSl9LHA9dC5leHBvcnRzPXtLRVk6aSxORUVEOiExLGZhc3RLZXk6ZnVuY3Rpb24odCxlKXtpZighcih0KSlyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgdD90OihcInN0cmluZ1wiPT10eXBlb2YgdD9cIlNcIjpcIlBcIikrdDtpZighbyh0LGkpKXtpZighdSh0KSlyZXR1cm5cIkZcIjtpZighZSlyZXR1cm5cIkVcIjtsKHQpfXJldHVybiB0W2ldLml9LGdldFdlYWs6ZnVuY3Rpb24odCxlKXtpZighbyh0LGkpKXtpZighdSh0KSlyZXR1cm4hMDtpZighZSlyZXR1cm4hMTtsKHQpfXJldHVybiB0W2ldLnd9LG9uRnJlZXplOmZ1bmN0aW9uKHQpe3JldHVybiBjJiZwLk5FRUQmJnUodCkmJiFvKHQsaSkmJmwodCksdH19fSxmdW5jdGlvbih0LGUsbil7dmFyIGk9bigxMSkuZixyPW4oMTYpLG89bigzNikoXCJ0b1N0cmluZ1RhZ1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3QmJiFyKHQ9bj90OnQucHJvdG90eXBlLG8pJiZpKHQsbyx7Y29uZmlndXJhYmxlOiEwLHZhbHVlOmV9KX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDE1KSxyPW4oMzgpLG89bigyMSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPWkodCksbj1yLmY7aWYobilmb3IodmFyIHMsYT1uKHQpLHU9by5mLGM9MDthLmxlbmd0aD5jOyl1LmNhbGwodCxzPWFbYysrXSkmJmUucHVzaChzKTtyZXR1cm4gZX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDQzKTt0LmV4cG9ydHM9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24odCl7cmV0dXJuXCJBcnJheVwiPT1pKHQpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4oMjApLHI9big3MCksbz1uKDMxKSxzPW4oNDUpKFwiSUVfUFJPVE9cIiksYT1mdW5jdGlvbigpe30sdT1mdW5jdGlvbigpe3ZhciB0LGU9big0NykoXCJpZnJhbWVcIiksaT1vLmxlbmd0aDtmb3IoZS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLG4oNzEpLmFwcGVuZENoaWxkKGUpLGUuc3JjPVwiamF2YXNjcmlwdDpcIiwodD1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQpLm9wZW4oKSx0LndyaXRlKFwiPHNjcmlwdD5kb2N1bWVudC5GPU9iamVjdDxcXC9zY3JpcHQ+XCIpLHQuY2xvc2UoKSx1PXQuRjtpLS07KWRlbGV0ZSB1LnByb3RvdHlwZVtvW2ldXTtyZXR1cm4gdSgpfTt0LmV4cG9ydHM9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24odCxlKXt2YXIgbjtyZXR1cm4gbnVsbCE9PXQ/KGEucHJvdG90eXBlPWkodCksbj1uZXcgYSxhLnByb3RvdHlwZT1udWxsLG5bc109dCk6bj11KCksdm9pZCAwPT09ZT9uOnIobixlKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDExKSxyPW4oMjApLG89bigxNSk7dC5leHBvcnRzPW4oMTIpP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzOmZ1bmN0aW9uKHQsZSl7cih0KTtmb3IodmFyIG4scz1vKGUpLGE9cy5sZW5ndGgsdT0wO2E+dTspaS5mKHQsbj1zW3UrK10sZVtuXSk7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUsbil7dmFyIGk9big5KS5kb2N1bWVudDt0LmV4cG9ydHM9aSYmaS5kb2N1bWVudEVsZW1lbnR9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDE3KSxyPW4oNTApLmYsbz17fS50b1N0cmluZyxzPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM/T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KTpbXTt0LmV4cG9ydHMuZj1mdW5jdGlvbih0KXtyZXR1cm4gcyYmXCJbb2JqZWN0IFdpbmRvd11cIj09by5jYWxsKHQpP2Z1bmN0aW9uKHQpe3RyeXtyZXR1cm4gcih0KX1jYXRjaCh0KXtyZXR1cm4gcy5zbGljZSgpfX0odCk6cihpKHQpKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uKDIxKSxyPW4oMzUpLG89bigxNykscz1uKDM0KSxhPW4oMTYpLHU9big0NiksYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2UuZj1uKDEyKT9jOmZ1bmN0aW9uKHQsZSl7aWYodD1vKHQpLGU9cyhlLCEwKSx1KXRyeXtyZXR1cm4gYyh0LGUpfWNhdGNoKHQpe31pZihhKHQsZSkpcmV0dXJuIHIoIWkuZi5jYWxsKHQsZSksdFtlXSl9fSxmdW5jdGlvbih0LGUpe30sZnVuY3Rpb24odCxlLG4pe24oMzcpKFwiYXN5bmNJdGVyYXRvclwiKX0sZnVuY3Rpb24odCxlLG4pe24oMzcpKFwib2JzZXJ2YWJsZVwiKX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz17ZGVmYXVsdDpuKDc4KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odCxlLG4pe24oNzkpLHQuZXhwb3J0cz1uKDEwKS5PYmplY3QuYXNzaWdufSxmdW5jdGlvbih0LGUsbil7dmFyIGk9bigzMik7aShpLlMraS5GLFwiT2JqZWN0XCIse2Fzc2lnbjpuKDgwKX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9bigxNSkscj1uKDM4KSxvPW4oMjEpLHM9bigzOSksYT1uKDQyKSx1PU9iamVjdC5hc3NpZ247dC5leHBvcnRzPSF1fHxuKDEzKShmdW5jdGlvbigpe3ZhciB0PXt9LGU9e30sbj1TeW1ib2woKSxpPVwiYWJjZGVmZ2hpamtsbW5vcHFyc3RcIjtyZXR1cm4gdFtuXT03LGkuc3BsaXQoXCJcIikuZm9yRWFjaChmdW5jdGlvbih0KXtlW3RdPXR9KSw3IT11KHt9LHQpW25dfHxPYmplY3Qua2V5cyh1KHt9LGUpKS5qb2luKFwiXCIpIT1pfSk/ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49cyh0KSx1PWFyZ3VtZW50cy5sZW5ndGgsYz0xLGw9ci5mLHA9by5mO3U+YzspZm9yKHZhciBmLGg9YShhcmd1bWVudHNbYysrXSksZD1sP2koaCkuY29uY2F0KGwoaCkpOmkoaCksbT1kLmxlbmd0aCx5PTA7bT55OylwLmNhbGwoaCxmPWRbeSsrXSkmJihuW2ZdPWhbZl0pO3JldHVybiBufTp1fSxmdW5jdGlvbih0LGUsbil7dmFyIGk9big4Mik7XCJzdHJpbmdcIj09dHlwZW9mIGkmJihpPVtbdC5pLGksXCJcIl1dKSxpLmxvY2FscyYmKHQuZXhwb3J0cz1pLmxvY2Fscyk7KDAsbigxMDYpLmRlZmF1bHQpKFwiNTE2ZjFlZjZcIixpLCEwLHt9KX0sZnVuY3Rpb24odCxlLG4peyh0LmV4cG9ydHM9big4MykoITEpKS5wdXNoKFt0LmksXCIudnVlMmxlYWZsZXQtbWFwe2hlaWdodDoxMDAlO3dpZHRoOjEwMCV9XCIsXCJcIl0pfSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1bXTtyZXR1cm4gZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbihlKXt2YXIgbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRbMV18fFwiXCIsaT10WzNdO2lmKCFpKXJldHVybiBuO2lmKGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGJ0b2Epe3ZhciByPWZ1bmN0aW9uKHQpe3JldHVyblwiLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiK2J0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHQpKSkpK1wiICovXCJ9KGkpLG89aS5zb3VyY2VzLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cIi8qIyBzb3VyY2VVUkw9XCIraS5zb3VyY2VSb290K3QrXCIgKi9cIn0pO3JldHVybltuXS5jb25jYXQobykuY29uY2F0KFtyXSkuam9pbihcIlxcblwiKX1yZXR1cm5bbl0uam9pbihcIlxcblwiKX0oZSx0KTtyZXR1cm4gZVsyXT9cIkBtZWRpYSBcIitlWzJdK1wie1wiK24rXCJ9XCI6bn0pLmpvaW4oXCJcIil9LGUuaT1mdW5jdGlvbih0LG4pe1wic3RyaW5nXCI9PXR5cGVvZiB0JiYodD1bW251bGwsdCxcIlwiXV0pO2Zvcih2YXIgaT17fSxyPTA7cjx0aGlzLmxlbmd0aDtyKyspe3ZhciBvPXRoaXNbcl1bMF07XCJudW1iZXJcIj09dHlwZW9mIG8mJihpW29dPSEwKX1mb3Iocj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgcz10W3JdO1wibnVtYmVyXCI9PXR5cGVvZiBzWzBdJiZpW3NbMF1dfHwobiYmIXNbMl0/c1syXT1uOm4mJihzWzJdPVwiKFwiK3NbMl0rXCIpIGFuZCAoXCIrbitcIilcIiksZS5wdXNoKHMpKX19LGV9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpO3ZhciBpPW4oMCkscj1uKDMpLG89e25hbWU6XCJMTGF5ZXJHcm91cFwiLG1peGluczpbbigxNCkuYV0sZGF0YTpmdW5jdGlvbigpe3JldHVybntyZWFkeTohMX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLm1hcE9iamVjdD1MLmxheWVyR3JvdXAoKSxPYmplY3QoaS5kZWZhdWx0KSh0aGlzLHRoaXMubWFwT2JqZWN0LHRoaXMuJG9wdGlvbnMucHJvcHMpLEwuRG9tRXZlbnQub24odGhpcy5tYXBPYmplY3QsdGhpcy4kbGlzdGVuZXJzKSx0aGlzLnJlYWR5PSEwLHRoaXMucGFyZW50Q29udGFpbmVyPU9iamVjdChyLmRlZmF1bHQpKHRoaXMuJHBhcmVudCksdGhpcy52aXNpYmxlJiZ0aGlzLnBhcmVudENvbnRhaW5lci5hZGRMYXllcih0aGlzKX19LHM9bigxKSxhPU9iamVjdChzLmEpKG8sZnVuY3Rpb24oKXt2YXIgdD10aGlzLiRjcmVhdGVFbGVtZW50O3JldHVybih0aGlzLl9zZWxmLl9jfHx0KShcImRpdlwiLHtzdGF0aWNTdHlsZTp7ZGlzcGxheTpcIm5vbmVcIn19LFt0aGlzLnJlYWR5P3RoaXMuX3QoXCJkZWZhdWx0XCIpOnRoaXMuX2UoKV0sMil9LFtdLCExLG51bGwsbnVsbCxudWxsKTtlLmRlZmF1bHQ9YS5leHBvcnRzfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpO3ZhciBpPW4oMCkscj1uKDMpLG89bigyKSxzPW4oNCksYT1uLm4ocyksdT1uKDcpLGM9bigyNCksbD17bmFtZTpcIkxJbWFnZU92ZXJsYXlcIixtaXhpbnM6W3ttaXhpbnM6W3UuYSxjLmFdLHByb3BzOnt1cmw6e3R5cGU6U3RyaW5nLGN1c3RvbTohMH0sYm91bmRzOntjdXN0b206ITB9LG9wYWNpdHk6e3R5cGU6TnVtYmVyLGN1c3RvbTohMCxkZWZhdWx0OjF9LGFsdDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifSxpbnRlcmFjdGl2ZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGNyb3NzT3JpZ2luOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZXJyb3JPdmVybGF5VXJsOnt0eXBlOlN0cmluZyxjdXN0b206ITAsZGVmYXVsdDpcIlwifSx6SW5kZXg6e3R5cGU6TnVtYmVyLGN1c3RvbTohMCxkZWZhdWx0OjF9LGNsYXNzTmFtZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlwifX0sbW91bnRlZDpmdW5jdGlvbigpe3RoaXMuaW1hZ2VPdmVybGF5T3B0aW9ucz1hKCkoe30sdGhpcy5sYXllck9wdGlvbnMsdGhpcy5pbnRlcmFjdGl2ZUxheWVyT3B0aW9ucyx7b3BhY2l0eTp0aGlzLm9wYWNpdHksYWx0OnRoaXMuYWx0LGludGVyYWN0aXZlOnRoaXMuaW50ZXJhY3RpdmUsY3Jvc3NPcmlnaW46dGhpcy5jcm9zc09yaWdpbixlcnJvck92ZXJsYXlVcmw6dGhpcy5lcnJvck92ZXJsYXlVcmwsekluZGV4OnRoaXMuekluZGV4LGNsYXNzTmFtZTp0aGlzLmNsYXNzTmFtZX0pfSxtZXRob2RzOntzZXRPcGFjaXR5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm1hcE9iamVjdC5zZXRPcGFjaXR5KHQpfSxzZXRVcmw6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubWFwT2JqZWN0LnNldFVybCh0KX0sc2V0Qm91bmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm1hcE9iamVjdC5zZXRCb3VuZHModCl9LGdldEJvdW5kczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcE9iamVjdC5nZXRCb3VuZHMoKX0sZ2V0RWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcE9iamVjdC5nZXRFbGVtZW50KCl9LGJyaW5nVG9Gcm9udDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcE9iamVjdC5icmluZ1RvRnJvbnQoKX0sYnJpbmdUb0JhY2s6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBPYmplY3QuYnJpbmdUb0JhY2soKX19LHJlbmRlcjpmdW5jdGlvbigpe3JldHVybiBudWxsfX1dLG1vdW50ZWQ6ZnVuY3Rpb24oKXt2YXIgdD1PYmplY3Qoby5hKSh0aGlzLmltYWdlT3ZlcmxheU9wdGlvbnMsdGhpcyk7dGhpcy5tYXBPYmplY3Q9TC5pbWFnZU92ZXJsYXkodGhpcy51cmwsdGhpcy5ib3VuZHMsdCksTC5Eb21FdmVudC5vbih0aGlzLm1hcE9iamVjdCx0aGlzLiRsaXN0ZW5lcnMpLE9iamVjdChpLmRlZmF1bHQpKHRoaXMsdGhpcy5tYXBPYmplY3QsdGhpcy4kb3B0aW9ucy5wcm9wcyksdGhpcy5wYXJlbnRDb250YWluZXI9T2JqZWN0KHIuZGVmYXVsdCkodGhpcy4kcGFyZW50KSx0aGlzLnBhcmVudENvbnRhaW5lci5hZGRMYXllcih0aGlzLCF0aGlzLnZpc2libGUpfX0scD1uKDEpLGY9T2JqZWN0KHAuYSkobCx2b2lkIDAsdm9pZCAwLCExLG51bGwsbnVsbCxudWxsKTtlLmRlZmF1bHQ9Zi5leHBvcnRzfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpO3ZhciBpPW4oMCkscj1uKDMpLG89bigyKSxzPW4oNCksYT1uLm4ocyksdT17bmFtZTpcIkxXTVNUaWxlTGF5ZXJcIixtaXhpbnM6W3ttaXhpbnM6W24oMjkpLmFdLHByb3BzOntsYXllcnM6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJcIn0sc3R5bGVzOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiXCJ9LGZvcm1hdDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcImltYWdlL2pwZWdcIn0sdHJhbnNwYXJlbnQ6e3R5cGU6Qm9vbGVhbixjdXN0b206ITF9LHZlcnNpb246e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCIxLjEuMVwifSxjcnM6e2RlZmF1bHQ6bnVsbH0sdXBwZXJDYXNlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLnRpbGVMYXllcldNU09wdGlvbnM9YSgpKHt9LHRoaXMudGlsZUxheWVyT3B0aW9ucyx7bGF5ZXJzOnRoaXMubGF5ZXJzLHN0eWxlczp0aGlzLnN0eWxlcyxmb3JtYXQ6dGhpcy5mb3JtYXQsdHJhbnNwYXJlbnQ6dGhpcy50cmFuc3BhcmVudCx2ZXJzaW9uOnRoaXMudmVyc2lvbixjcnM6dGhpcy5jcnMsdXBwZXJDYXNlOnRoaXMudXBwZXJDYXNlfSl9fSxuKDUpLmFdLHByb3BzOntiYXNlVXJsOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dmFyIHQ9T2JqZWN0KG8uYSkodGhpcy50aWxlTGF5ZXJXTVNPcHRpb25zLHRoaXMpO3RoaXMubWFwT2JqZWN0PUwudGlsZUxheWVyLndtcyh0aGlzLmJhc2VVcmwsdCksTC5Eb21FdmVudC5vbih0aGlzLm1hcE9iamVjdCx0aGlzLiRsaXN0ZW5lcnMpLE9iamVjdChpLmRlZmF1bHQpKHRoaXMsdGhpcy5tYXBPYmplY3QsdGhpcy4kb3B0aW9ucy5wcm9wcyksdGhpcy5wYXJlbnRDb250YWluZXI9T2JqZWN0KHIuZGVmYXVsdCkodGhpcy4kcGFyZW50KSx0aGlzLnBhcmVudENvbnRhaW5lci5hZGRMYXllcih0aGlzLCF0aGlzLnZpc2libGUpfX0sYz1uKDEpLGw9T2JqZWN0KGMuYSkodSx2b2lkIDAsdm9pZCAwLCExLG51bGwsbnVsbCxudWxsKTtlLmRlZmF1bHQ9bC5leHBvcnRzfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpO3ZhciBpPW4oMCkscj1uKDMpLG89e25hbWU6XCJMRmVhdHVyZUdyb3VwXCIsbWl4aW5zOltuKDE0KS5hXSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3JlYWR5OiExfX0sbW91bnRlZDpmdW5jdGlvbigpe3RoaXMubWFwT2JqZWN0PUwuZmVhdHVyZUdyb3VwKCksT2JqZWN0KGkuZGVmYXVsdCkodGhpcyx0aGlzLm1hcE9iamVjdCx0aGlzLiRvcHRpb25zLnByb3BzKSxMLkRvbUV2ZW50Lm9uKHRoaXMubWFwT2JqZWN0LHRoaXMuJGxpc3RlbmVycyksdGhpcy5yZWFkeT0hMCx0aGlzLnBhcmVudENvbnRhaW5lcj1PYmplY3Qoci5kZWZhdWx0KSh0aGlzLiRwYXJlbnQsITApLHRoaXMudmlzaWJsZSYmdGhpcy5wYXJlbnRDb250YWluZXIuYWRkTGF5ZXIodGhpcyl9fSxzPW4oMSksYT1PYmplY3Qocy5hKShvLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kY3JlYXRlRWxlbWVudDtyZXR1cm4odGhpcy5fc2VsZi5fY3x8dCkoXCJkaXZcIix7c3RhdGljU3R5bGU6e2Rpc3BsYXk6XCJub25lXCJ9fSxbdGhpcy5yZWFkeT90aGlzLl90KFwiZGVmYXVsdFwiKTp0aGlzLl9lKCldLDIpfSxbXSwhMSxudWxsLG51bGwsbnVsbCk7ZS5kZWZhdWx0PWEuZXhwb3J0c30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24ucihlKTt2YXIgaT1uKDYpLHI9bi5uKGkpLG89bigwKSxzPW4oMyksYT1uKDIpLHU9bigyOSksYz1uKDUpLGw9e25hbWU6XCJMVGlsZUxheWVyXCIsbWl4aW5zOlt1LmEsYy5hXSxwcm9wczp7dXJsOnt0eXBlOlN0cmluZyxkZWZhdWx0Om51bGx9LHRpbGVMYXllckNsYXNzOnt0eXBlOkZ1bmN0aW9uLGRlZmF1bHQ6ci5hLnRpbGVMYXllcn19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt2YXIgdD1PYmplY3QoYS5hKSh0aGlzLnRpbGVMYXllck9wdGlvbnMsdGhpcyk7dGhpcy5tYXBPYmplY3Q9dGhpcy50aWxlTGF5ZXJDbGFzcyh0aGlzLnVybCx0KSxyLmEuRG9tRXZlbnQub24odGhpcy5tYXBPYmplY3QsdGhpcy4kbGlzdGVuZXJzKSxPYmplY3Qoby5kZWZhdWx0KSh0aGlzLHRoaXMubWFwT2JqZWN0LHRoaXMuJG9wdGlvbnMucHJvcHMpLHRoaXMucGFyZW50Q29udGFpbmVyPU9iamVjdChzLmRlZmF1bHQpKHRoaXMuJHBhcmVudCksdGhpcy5wYXJlbnRDb250YWluZXIuYWRkTGF5ZXIodGhpcywhdGhpcy52aXNpYmxlKX19LHA9bigxKSxmPU9iamVjdChwLmEpKGwsZnVuY3Rpb24oKXt2YXIgdD10aGlzLiRjcmVhdGVFbGVtZW50O3JldHVybih0aGlzLl9zZWxmLl9jfHx0KShcImRpdlwiKX0sW10sITEsbnVsbCxudWxsLG51bGwpO2UuZGVmYXVsdD1mLmV4cG9ydHN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuLnIoZSk7dmFyIGk9bigwKSxyPW4oMyksbz1uKDIpLHM9e25hbWU6XCJMUmVjdGFuZ2xlXCIsbWl4aW5zOltuKDI2KS5hXSxwcm9wczp7Ym91bmRzOnt0eXBlOkFycmF5LGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm5bXX19fSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3JlYWR5OiExfX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PU9iamVjdChvLmEpKHRoaXMucG9seWdvbk9wdGlvbnMsdGhpcyk7dGhpcy5tYXBPYmplY3Q9TC5yZWN0YW5nbGUodGhpcy5ib3VuZHMsdCksTC5Eb21FdmVudC5vbih0aGlzLm1hcE9iamVjdCx0aGlzLiRsaXN0ZW5lcnMpLE9iamVjdChpLmRlZmF1bHQpKHRoaXMsdGhpcy5tYXBPYmplY3QsdGhpcy4kb3B0aW9ucy5wcm9wcyksdGhpcy5yZWFkeT0hMCx0aGlzLnBhcmVudENvbnRhaW5lcj1PYmplY3Qoci5kZWZhdWx0KSh0aGlzLiRwYXJlbnQpLHRoaXMucGFyZW50Q29udGFpbmVyLmFkZExheWVyKHRoaXMsIXRoaXMudmlzaWJsZSl9fSxhPW4oMSksdT1PYmplY3QoYS5hKShzLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kY3JlYXRlRWxlbWVudDtyZXR1cm4odGhpcy5fc2VsZi5fY3x8dCkoXCJkaXZcIix7c3RhdGljU3R5bGU6e2Rpc3BsYXk6XCJub25lXCJ9fSxbdGhpcy5yZWFkeT90aGlzLl90KFwiZGVmYXVsdFwiKTp0aGlzLl9lKCldLDIpfSxbXSwhMSxudWxsLG51bGwsbnVsbCk7ZS5kZWZhdWx0PXUuZXhwb3J0c30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24ucihlKTt2YXIgaT1uKDApLHI9bigzKSxvPW4oMikscz17bmFtZTpcIkxJY29uXCIscHJvcHM6e2ljb25Vcmw6e3R5cGU6U3RyaW5nLGN1c3RvbTohMCxkZWZhdWx0Om51bGx9LGljb25SZXRpbmFVcmw6e3R5cGU6U3RyaW5nLGN1c3RvbTohMCxkZWZhdWx0Om51bGx9LGljb25TaXplOnt0eXBlOltPYmplY3QsQXJyYXldLGN1c3RvbTohMCxkZWZhdWx0Om51bGx9LGljb25BbmNob3I6e3R5cGU6W09iamVjdCxBcnJheV0sY3VzdG9tOiEwLGRlZmF1bHQ6bnVsbH0scG9wdXBBbmNob3I6e3R5cGU6W09iamVjdCxBcnJheV0sY3VzdG9tOiEwLGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm5bMCwwXX19LHRvb2x0aXBBbmNob3I6e3R5cGU6W09iamVjdCxBcnJheV0sY3VzdG9tOiEwLGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm5bMCwwXX19LHNoYWRvd1VybDp7dHlwZTpTdHJpbmcsY3VzdG9tOiEwLGRlZmF1bHQ6bnVsbH0sc2hhZG93UmV0aW5hVXJsOnt0eXBlOlN0cmluZyxjdXN0b206ITAsZGVmYXVsdDpudWxsfSxzaGFkb3dTaXplOnt0eXBlOltPYmplY3QsQXJyYXldLGN1c3RvbTohMCxkZWZhdWx0Om51bGx9LHNoYWRvd0FuY2hvcjp7dHlwZTpbT2JqZWN0LEFycmF5XSxjdXN0b206ITAsZGVmYXVsdDpudWxsfSxiZ1Bvczp7dHlwZTpbT2JqZWN0LEFycmF5XSxjdXN0b206ITAsZGVmYXVsdDpmdW5jdGlvbigpe3JldHVyblswLDBdfX0sY2xhc3NOYW1lOnt0eXBlOlN0cmluZyxjdXN0b206ITAsZGVmYXVsdDpcIlwifSxvcHRpb25zOnt0eXBlOk9iamVjdCxjdXN0b206ITAsZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybnt9fX19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57cGFyZW50Q29udGFpbmVyOm51bGwsb2JzZXJ2ZXI6bnVsbCxyZWNyZWF0aW9uTmVlZGVkOiExLHN3YXBIdG1sTmVlZGVkOiExfX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5wYXJlbnRDb250YWluZXI9T2JqZWN0KHIuZGVmYXVsdCkodGhpcy4kcGFyZW50KSxPYmplY3QoaS5kZWZhdWx0KSh0aGlzLG51bGwsdGhpcy4kb3B0aW9ucy5wcm9wcyksdGhpcy5vYnNlcnZlcj1uZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpe3Quc2NoZWR1bGVIdG1sU3dhcCgpfSksdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMuJGVsLHthdHRyaWJ1dGVzOiEwLGNoaWxkTGlzdDohMCxjaGFyYWN0ZXJEYXRhOiEwLHN1YnRyZWU6ITB9KSx0aGlzLnNjaGVkdWxlQ3JlYXRlSWNvbigpfSxiZWZvcmVEZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5wYXJlbnRDb250YWluZXIubWFwT2JqZWN0JiZ0aGlzLnBhcmVudENvbnRhaW5lci5tYXBPYmplY3Quc2V0SWNvbih0aGlzLnBhcmVudENvbnRhaW5lci4kcHJvcHMuaWNvbiksdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCl9LG1ldGhvZHM6e3NjaGVkdWxlQ3JlYXRlSWNvbjpmdW5jdGlvbigpe3RoaXMucmVjcmVhdGlvbk5lZWRlZD0hMCx0aGlzLiRuZXh0VGljayh0aGlzLmNyZWF0ZUljb24pfSxzY2hlZHVsZUh0bWxTd2FwOmZ1bmN0aW9uKCl7dGhpcy5odG1sU3dhcE5lZWRlZD0hMCx0aGlzLiRuZXh0VGljayh0aGlzLmNyZWF0ZUljb24pfSxjcmVhdGVJY29uOmZ1bmN0aW9uKCl7aWYodGhpcy5odG1sU3dhcE5lZWRlZCYmIXRoaXMucmVjcmVhdGlvbk5lZWRlZCYmdGhpcy5pY29uT2JqZWN0JiZ0aGlzLnBhcmVudENvbnRhaW5lci5tYXBPYmplY3QuZ2V0RWxlbWVudCgpKXJldHVybiB0aGlzLnBhcmVudENvbnRhaW5lci5tYXBPYmplY3QuZ2V0RWxlbWVudCgpLmlubmVySFRNTD10aGlzLiRlbC5pbm5lckhUTUwsdm9pZCh0aGlzLmh0bWxTd2FwTmVlZGVkPSExKTtpZih0aGlzLnJlY3JlYXRpb25OZWVkZWQpe3RoaXMuaWNvbk9iamVjdCYmTC5Eb21FdmVudC5vZmYodGhpcy5pY29uT2JqZWN0LHRoaXMuJGxpc3RlbmVycyk7dmFyIHQ9T2JqZWN0KG8uYSkoe2ljb25Vcmw6dGhpcy5pY29uVXJsLGljb25SZXRpbmFVcmw6dGhpcy5pY29uUmV0aW5hVXJsLGljb25TaXplOnRoaXMuaWNvblNpemUsaWNvbkFuY2hvcjp0aGlzLmljb25BbmNob3IscG9wdXBBbmNob3I6dGhpcy5wb3B1cEFuY2hvcix0b29sdGlwQW5jaG9yOnRoaXMudG9vbHRpcEFuY2hvcixzaGFkb3dVcmw6dGhpcy5zaGFkb3dVcmwsc2hhZG93UmV0aW5hVXJsOnRoaXMuc2hhZG93UmV0aW5hVXJsLHNoYWRvd1NpemU6dGhpcy5zaGFkb3dTaXplLHNoYWRvd0FuY2hvcjp0aGlzLnNoYWRvd0FuY2hvcixiZ1Bvczp0aGlzLmJnUG9zLGNsYXNzTmFtZTp0aGlzLmNsYXNzTmFtZSxodG1sOnRoaXMuJGVsLmlubmVySFRNTHx8dGhpcy5odG1sfSx0aGlzKTt0Lmh0bWw/dGhpcy5pY29uT2JqZWN0PUwuZGl2SWNvbih0KTp0aGlzLmljb25PYmplY3Q9TC5pY29uKHQpLEwuRG9tRXZlbnQub24odGhpcy5pY29uT2JqZWN0LHRoaXMuJGxpc3RlbmVycyksdGhpcy5wYXJlbnRDb250YWluZXIubWFwT2JqZWN0LnNldEljb24odGhpcy5pY29uT2JqZWN0KSx0aGlzLnJlY3JlYXRpb25OZWVkZWQ9ITEsdGhpcy5odG1sU3dhcE5lZWRlZD0hMX19LHNldEljb25Vcmw6ZnVuY3Rpb24oKXt0aGlzLnNjaGVkdWxlQ3JlYXRlSWNvbigpfSxzZXRJY29uUmV0aW5hVXJsOmZ1bmN0aW9uKCl7dGhpcy5zY2hlZHVsZUNyZWF0ZUljb24oKX0sc2V0SWNvblNpemU6ZnVuY3Rpb24oKXt0aGlzLnNjaGVkdWxlQ3JlYXRlSWNvbigpfSxzZXRJY29uQW5jaG9yOmZ1bmN0aW9uKCl7dGhpcy5zY2hlZHVsZUNyZWF0ZUljb24oKX0sc2V0UG9wdXBBbmNob3I6ZnVuY3Rpb24oKXt0aGlzLnNjaGVkdWxlQ3JlYXRlSWNvbigpfSxzZXRUb29sdGlwQW5jaG9yOmZ1bmN0aW9uKCl7dGhpcy5zY2hlZHVsZUNyZWF0ZUljb24oKX0sc2V0U2hhZG93VXJsOmZ1bmN0aW9uKCl7dGhpcy5zY2hlZHVsZUNyZWF0ZUljb24oKX0sc2V0U2hhZG93UmV0aW5hVXJsOmZ1bmN0aW9uKCl7dGhpcy5zY2hlZHVsZUNyZWF0ZUljb24oKX0sc2V0U2hhZG93QW5jaG9yOmZ1bmN0aW9uKCl7dGhpcy5zY2hlZHVsZUNyZWF0ZUljb24oKX0sc2V0QmdQb3M6ZnVuY3Rpb24oKXt0aGlzLnNjaGVkdWxlQ3JlYXRlSWNvbigpfSxzZXRDbGFzc05hbWU6ZnVuY3Rpb24oKXt0aGlzLnNjaGVkdWxlQ3JlYXRlSWNvbigpfSxzZXRIdG1sOmZ1bmN0aW9uKCl7dGhpcy5zY2hlZHVsZUNyZWF0ZUljb24oKX19LHJlbmRlcjpmdW5jdGlvbigpe3JldHVybiBudWxsfX0sYT1uKDEpLHU9T2JqZWN0KGEuYSkocyxmdW5jdGlvbigpe3ZhciB0PXRoaXMuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHRoaXMuX3NlbGYuX2N8fHQpKFwiZGl2XCIsW3RoaXMuX3QoXCJkZWZhdWx0XCIpXSwyKX0sW10sITEsbnVsbCxudWxsLG51bGwpO2UuZGVmYXVsdD11LmV4cG9ydHN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuLnIoZSk7dmFyIGk9bigwKSxyPW4oMyksbz1uKDIpLHM9e25hbWU6XCJMUG9seWxpbmVcIixtaXhpbnM6W24oMjcpLmFdLHByb3BzOntsYXRMbmdzOnt0eXBlOkFycmF5LGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm5bXX19fSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3JlYWR5OiExfX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PU9iamVjdChvLmEpKHRoaXMucG9seUxpbmVPcHRpb25zLHRoaXMpO3RoaXMubWFwT2JqZWN0PUwucG9seWxpbmUodGhpcy5sYXRMbmdzLHQpLEwuRG9tRXZlbnQub24odGhpcy5tYXBPYmplY3QsdGhpcy4kbGlzdGVuZXJzKSxPYmplY3QoaS5kZWZhdWx0KSh0aGlzLHRoaXMubWFwT2JqZWN0LHRoaXMuJG9wdGlvbnMucHJvcHMpLHRoaXMucmVhZHk9ITAsdGhpcy5wYXJlbnRDb250YWluZXI9T2JqZWN0KHIuZGVmYXVsdCkodGhpcy4kcGFyZW50KSx0aGlzLnBhcmVudENvbnRhaW5lci5hZGRMYXllcih0aGlzLCF0aGlzLnZpc2libGUpfX0sYT1uKDEpLHU9T2JqZWN0KGEuYSkocyxmdW5jdGlvbigpe3ZhciB0PXRoaXMuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHRoaXMuX3NlbGYuX2N8fHQpKFwiZGl2XCIse3N0YXRpY1N0eWxlOntkaXNwbGF5Olwibm9uZVwifX0sW3RoaXMucmVhZHk/dGhpcy5fdChcImRlZmF1bHRcIik6dGhpcy5fZSgpXSwyKX0sW10sITEsbnVsbCxudWxsLG51bGwpO2UuZGVmYXVsdD11LmV4cG9ydHN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuLnIoZSk7dmFyIGk9bigwKSxyPW4oMyksbz1uKDIpLHM9e25hbWU6XCJMUG9seWdvblwiLG1peGluczpbbigyNikuYV0scHJvcHM6e2xhdExuZ3M6e3R5cGU6QXJyYXksZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybltdfX19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57cmVhZHk6ITF9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dmFyIHQ9T2JqZWN0KG8uYSkodGhpcy5wb2x5Z29uT3B0aW9ucyx0aGlzKTt0aGlzLm1hcE9iamVjdD1MLnBvbHlnb24odGhpcy5sYXRMbmdzLHQpLEwuRG9tRXZlbnQub24odGhpcy5tYXBPYmplY3QsdGhpcy4kbGlzdGVuZXJzKSxPYmplY3QoaS5kZWZhdWx0KSh0aGlzLHRoaXMubWFwT2JqZWN0LHRoaXMuJG9wdGlvbnMucHJvcHMpLHRoaXMucmVhZHk9ITAsdGhpcy5wYXJlbnRDb250YWluZXI9T2JqZWN0KHIuZGVmYXVsdCkodGhpcy4kcGFyZW50KSx0aGlzLnBhcmVudENvbnRhaW5lci5hZGRMYXllcih0aGlzLCF0aGlzLnZpc2libGUpfX0sYT1uKDEpLHU9T2JqZWN0KGEuYSkocyxmdW5jdGlvbigpe3ZhciB0PXRoaXMuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHRoaXMuX3NlbGYuX2N8fHQpKFwiZGl2XCIse3N0YXRpY1N0eWxlOntkaXNwbGF5Olwibm9uZVwifX0sW3RoaXMucmVhZHk/dGhpcy5fdChcImRlZmF1bHRcIik6dGhpcy5fZSgpXSwyKX0sW10sITEsbnVsbCxudWxsLG51bGwpO2UuZGVmYXVsdD11LmV4cG9ydHN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuLnIoZSk7dmFyIGk9bigwKSxyPW4oMyksbz1uKDIpLHM9big4KSxhPW4oNSksdT17bmFtZTpcIkxDb250cm9sXCIsbWl4aW5zOltzLmEsYS5hXSxtb3VudGVkOmZ1bmN0aW9uKCl7dmFyIHQ9TC5Db250cm9sLmV4dGVuZCh7ZWxlbWVudDp2b2lkIDAsb25BZGQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbGVtZW50fSxzZXRFbGVtZW50OmZ1bmN0aW9uKHQpe3RoaXMuZWxlbWVudD10fX0pLGU9T2JqZWN0KG8uYSkodGhpcy5jb250cm9sT3B0aW9ucyx0aGlzKTt0aGlzLm1hcE9iamVjdD1uZXcgdChlKSxPYmplY3QoaS5kZWZhdWx0KSh0aGlzLHRoaXMubWFwT2JqZWN0LHRoaXMuJG9wdGlvbnMucHJvcHMpLHRoaXMucGFyZW50Q29udGFpbmVyPU9iamVjdChyLmRlZmF1bHQpKHRoaXMuJHBhcmVudCksdGhpcy5tYXBPYmplY3Quc2V0RWxlbWVudCh0aGlzLiRlbCksdGhpcy5tYXBPYmplY3QuYWRkVG8odGhpcy5wYXJlbnRDb250YWluZXIubWFwT2JqZWN0KX19LGM9bigxKSxsPU9iamVjdChjLmEpKHUsZnVuY3Rpb24oKXt2YXIgdD10aGlzLiRjcmVhdGVFbGVtZW50O3JldHVybih0aGlzLl9zZWxmLl9jfHx0KShcImRpdlwiLFt0aGlzLl90KFwiZGVmYXVsdFwiKV0sMil9LFtdLCExLG51bGwsbnVsbCxudWxsKTtlLmRlZmF1bHQ9bC5leHBvcnRzfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpO3ZhciBpPW4oMCkscj1uKDMpLG89bigyKSxzPXtuYW1lOlwiTENpcmNsZU1hcmtlclwiLG1peGluczpbbigyMikuYV0scHJvcHM6e2xhdExuZzp7dHlwZTpbT2JqZWN0LEFycmF5XSxkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuW119fX0sZGF0YTpmdW5jdGlvbigpe3JldHVybntyZWFkeTohMX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt2YXIgdD1PYmplY3Qoby5hKSh0aGlzLmNpcmNsZU9wdGlvbnMsdGhpcyk7dGhpcy5tYXBPYmplY3Q9TC5jaXJjbGVNYXJrZXIodGhpcy5sYXRMbmcsdCksTC5Eb21FdmVudC5vbih0aGlzLm1hcE9iamVjdCx0aGlzLiRsaXN0ZW5lcnMpLE9iamVjdChpLmRlZmF1bHQpKHRoaXMsdGhpcy5tYXBPYmplY3QsdGhpcy4kb3B0aW9ucy5wcm9wcyksdGhpcy5yZWFkeT0hMCx0aGlzLnBhcmVudENvbnRhaW5lcj1PYmplY3Qoci5kZWZhdWx0KSh0aGlzLiRwYXJlbnQpLHRoaXMucGFyZW50Q29udGFpbmVyLmFkZExheWVyKHRoaXMsIXRoaXMudmlzaWJsZSl9fSxhPW4oMSksdT1PYmplY3QoYS5hKShzLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kY3JlYXRlRWxlbWVudDtyZXR1cm4odGhpcy5fc2VsZi5fY3x8dCkoXCJkaXZcIix7c3RhdGljU3R5bGU6e2Rpc3BsYXk6XCJub25lXCJ9fSxbdGhpcy5yZWFkeT90aGlzLl90KFwiZGVmYXVsdFwiKTp0aGlzLl9lKCldLDIpfSxbXSwhMSxudWxsLG51bGwsbnVsbCk7ZS5kZWZhdWx0PXUuZXhwb3J0c30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24ucihlKTt2YXIgaT1uKDQpLHI9bi5uKGkpLG89big2KSxzPW4ubihvKSxhPW4oMCksdT1uKDI1KSxjPW4oMiksbD17bmFtZTpcIkxNYXBcIixtaXhpbnM6W24oNSkuYV0scHJvcHM6e2NlbnRlcjp7dHlwZTpbT2JqZWN0LEFycmF5XSxjdXN0b206ITAsZGVmYXVsdDpmdW5jdGlvbigpe3JldHVyblswLDBdfX0sYm91bmRzOnt0eXBlOltBcnJheSxPYmplY3RdLGN1c3RvbTohMCxkZWZhdWx0Om51bGx9LG1heEJvdW5kczp7dHlwZTpbQXJyYXksT2JqZWN0XSxkZWZhdWx0Om51bGx9LHpvb206e3R5cGU6TnVtYmVyLGN1c3RvbTohMCxkZWZhdWx0OjB9LG1pblpvb206e3R5cGU6TnVtYmVyLGRlZmF1bHQ6bnVsbH0sbWF4Wm9vbTp7dHlwZTpOdW1iZXIsZGVmYXVsdDpudWxsfSxwYWRkaW5nQm90dG9tUmlnaHQ6e3R5cGU6QXJyYXksY3VzdG9tOiEwLGRlZmF1bHQ6bnVsbH0scGFkZGluZ1RvcExlZnQ6e3R5cGU6QXJyYXksY3VzdG9tOiEwLGRlZmF1bHQ6bnVsbH0scGFkZGluZzp7dHlwZTpBcnJheSxjdXN0b206ITAsZGVmYXVsdDpudWxsfSx3b3JsZENvcHlKdW1wOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sY3JzOnt0eXBlOk9iamVjdCxjdXN0b206ITAsZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiBzLmEuQ1JTLkVQU0czODU3fX0sbWF4Qm91bmRzVmlzY29zaXR5Ont0eXBlOk51bWJlcixkZWZhdWx0Om51bGx9fSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3JlYWR5OiExLGxhc3RTZXRDZW50ZXI6bnVsbCxsYXN0U2V0Qm91bmRzOm51bGwsbGFzdFNldFpvb206bnVsbCxsYXllckNvbnRyb2w6dm9pZCAwLGxheWVyc1RvQWRkOltdfX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PU9iamVjdChjLmEpKHttaW5ab29tOnRoaXMubWluWm9vbSxtYXhab29tOnRoaXMubWF4Wm9vbSxtYXhCb3VuZHM6dGhpcy5tYXhCb3VuZHMsbWF4Qm91bmRzVmlzY29zaXR5OnRoaXMubWF4Qm91bmRzVmlzY29zaXR5LHdvcmxkQ29weUp1bXA6dGhpcy53b3JsZENvcHlKdW1wLGNyczp0aGlzLmNycyxjZW50ZXI6dGhpcy5jZW50ZXIsem9vbTp0aGlzLnpvb219LHRoaXMpO3RoaXMubWFwT2JqZWN0PXMuYS5tYXAodGhpcy4kZWwsdCksdGhpcy5zZXRCb3VuZHModGhpcy5ib3VuZHMpLHRoaXMubWFwT2JqZWN0Lm9uKFwibW92ZWVuZFwiLE9iamVjdCh1LmEpKHRoaXMubW92ZUVuZEhhbmRsZXIsMTAwKSkscy5hLkRvbUV2ZW50Lm9uKHRoaXMubWFwT2JqZWN0LHRoaXMuJGxpc3RlbmVycyksT2JqZWN0KGEuZGVmYXVsdCkodGhpcyx0aGlzLm1hcE9iamVjdCx0aGlzLiRvcHRpb25zLnByb3BzKSx0aGlzLnJlYWR5PSEwLHRoaXMuJGVtaXQoXCJsZWFmbGV0OmxvYWRcIil9LG1ldGhvZHM6e3JlZ2lzdGVyTGF5ZXJDb250cm9sOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0aGlzLmxheWVyQ29udHJvbD10LHRoaXMubWFwT2JqZWN0LmFkZENvbnRyb2wodC5tYXBPYmplY3QpLHRoaXMubGF5ZXJzVG9BZGQpdGhpcy5sYXllckNvbnRyb2wuYWRkTGF5ZXIoZSk7dGhpcy5sYXllcnNUb0FkZD1bXX0sYWRkTGF5ZXI6ZnVuY3Rpb24odCxlKXt2b2lkIDAhPT10LmxheWVyVHlwZSYmKHZvaWQgMD09PXRoaXMubGF5ZXJDb250cm9sP3RoaXMubGF5ZXJzVG9BZGQucHVzaCh0KTp0aGlzLmxheWVyQ29udHJvbC5hZGRMYXllcih0KSksZXx8dGhpcy5tYXBPYmplY3QuYWRkTGF5ZXIodC5tYXBPYmplY3QpfSxyZW1vdmVMYXllcjpmdW5jdGlvbih0LGUpe3ZvaWQgMCE9PXQubGF5ZXJUeXBlJiYodm9pZCAwPT09dGhpcy5sYXllckNvbnRyb2w/dGhpcy5sYXllcnNUb0FkZD10aGlzLmxheWVyc1RvQWRkLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lIT09dC5uYW1lfSk6dGhpcy5sYXllckNvbnRyb2wucmVtb3ZlTGF5ZXIodCkpLGV8fHRoaXMubWFwT2JqZWN0LnJlbW92ZUxheWVyKHQubWFwT2JqZWN0KX0sc2V0Wm9vbTpmdW5jdGlvbih0LGUpe3RoaXMubWFwT2JqZWN0LnNldFpvb20odCl9LHNldENlbnRlcjpmdW5jdGlvbih0LGUpe2lmKG51bGwhPXQpe3ZhciBuPTAsaT0wO0FycmF5LmlzQXJyYXkodCk/KG49dFswXSxpPXRbMV0pOihuPXQubGF0LGk9dC5sbmcpO3ZhciBvPW51bGw9PXRoaXMubGFzdFNldENlbnRlcj90aGlzLm1hcE9iamVjdC5nZXRDZW50ZXIoKTp0aGlzLmxhc3RTZXRDZW50ZXI7KG89cigpKHt9LG8pKS5sYXQ9PT1uJiZvLmxuZz09PWl8fChvLmxhdD10LmxhdCxvLmxuZz10LmxuZyx0aGlzLmxhc3RTZXRDZW50ZXI9byx0aGlzLm1hcE9iamVjdC5wYW5Ubyh0KSl9fSxzZXRCb3VuZHM6ZnVuY3Rpb24odCxlKXtpZih0KXtpZih0IGluc3RhbmNlb2Ygcy5hLkxhdExuZ0JvdW5kcyl7aWYoIXQuaXNWYWxpZCgpKXJldHVybn1lbHNlIGlmKCFBcnJheS5pc0FycmF5KHQpKXJldHVybjt2YXIgbj1udWxsPT10aGlzLmxhc3RTZXRCb3VuZHM/dGhpcy5tYXBPYmplY3QuZ2V0Qm91bmRzKCk6dGhpcy5sYXN0U2V0Qm91bmRzLGk9MCxyPTAsbz0wLGE9MDtBcnJheS5pc0FycmF5KG4pPyhBcnJheS5pc0FycmF5KG5bMF0pPyhpPW5bMF1bMF0scj1uWzBdWzFdKTooaT1uWzBdLmxhdCxyPW5bMF0ubG5nKSxBcnJheS5pc0FycmF5KG5bMV0pPyhvPW5bMV1bMF0sYT1uWzFdWzFdKToobz1uWzFdLmxhdCxhPW5bMV0ubG5nKSk6KGk9bi5fc291dGhXZXN0LmxhdCxyPW4uX3NvdXRoV2VzdC5sbmcsbz1uLl9ub3J0aEVhc3QubGF0LGE9bi5fbm9ydGhFYXN0LmxuZyk7dmFyIHUsYyxsLHA7aWYoQXJyYXkuaXNBcnJheSh0KSYmKHQ9cy5hLmxhdExuZ0JvdW5kcyh0KSksdT10Ll9zb3V0aFdlc3QubGF0LGM9dC5fc291dGhXZXN0LmxuZyxsPXQuX25vcnRoRWFzdC5sYXQscD10Ll9ub3J0aEVhc3QubG5nLHUhPT1pfHxjIT09cnx8bCE9PW98fHAhPT1hKXt2YXIgZj17fTt0aGlzLnBhZGRpbmc/Zi5wYWRkaW5nPXRoaXMucGFkZGluZzoodGhpcy5wYWRkaW5nQm90dG9tUmlnaHQmJihmLnBhZGRpbmdCb3R0b21SaWdodD10aGlzLnBhZGRpbmdCb3R0b21SaWdodCksdGhpcy5wYWRkaW5nVG9wTGVmdCYmKGYucGFkZGluZ1RvcExlZnQ9dGhpcy5wYWRkaW5nVG9wTGVmdCkpLHRoaXMubGFzdFNldEJvdW5kcz1uLEFycmF5LmlzQXJyYXkobik/KEFycmF5LmlzQXJyYXkoblswXSk/KG5bMF1bMF09aSxuWzBdWzFdPXIpOihuWzBdLmxhdD1pLG5bMF0ubG5nPXIpLEFycmF5LmlzQXJyYXkoblsxXSk/KG5bMV1bMF09byxuWzFdWzFdPWEpOihuWzFdLmxhdD1vLG5bMV0ubG5nPWEpKToobi5fc291dGhXZXN0LmxhdD1pLG4uX3NvdXRoV2VzdC5sbmc9cixuLl9ub3J0aEVhc3QubGF0PW8sbi5fbm9ydGhFYXN0LmxuZz1hKSx0aGlzLm1hcE9iamVjdC5maXRCb3VuZHModCxmKX19fSxzZXRQYWRkaW5nQm90dG9tUmlnaHQ6ZnVuY3Rpb24odCxlKXt0aGlzLnBhZGRpbmdCb3R0b21SaWdodD10fSxzZXRQYWRkaW5nVG9wTGVmdDpmdW5jdGlvbih0LGUpe3RoaXMucGFkZGluZ1RvcExlZnQ9dH0sc2V0UGFkZGluZzpmdW5jdGlvbih0LGUpe3RoaXMucGFkZGluZz10fSxzZXRDcnM6ZnVuY3Rpb24odCxlKXtjb25zb2xlLmxvZyhcIkNoYW5naW5nIENSUyBpcyBub3QgeWV0IHN1cHBvcnRlZCBieSBMZWFmbGV0XCIpfSxmaXRCb3VuZHM6ZnVuY3Rpb24odCl7dGhpcy5tYXBPYmplY3QuZml0Qm91bmRzKHQpfSxtb3ZlRW5kSGFuZGxlcjpmdW5jdGlvbigpe3RoaXMuJGVtaXQoXCJ1cGRhdGU6em9vbVwiLHRoaXMubWFwT2JqZWN0LmdldFpvb20oKSk7dmFyIHQ9dGhpcy5tYXBPYmplY3QuZ2V0Q2VudGVyKCk7dGhpcy4kZW1pdChcInVwZGF0ZTpjZW50ZXJcIix0KTt2YXIgZT10aGlzLm1hcE9iamVjdC5nZXRCb3VuZHMoKTt0aGlzLiRlbWl0KFwidXBkYXRlOmJvdW5kc1wiLGUpfX19LHA9bigxKTt2YXIgZj1mdW5jdGlvbih0KXtuKDgxKX0saD1PYmplY3QocC5hKShsLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kY3JlYXRlRWxlbWVudDtyZXR1cm4odGhpcy5fc2VsZi5fY3x8dCkoXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJ2dWUybGVhZmxldC1tYXBcIn0sW3RoaXMucmVhZHk/dGhpcy5fdChcImRlZmF1bHRcIik6dGhpcy5fZSgpXSwyKX0sW10sITEsZixudWxsLG51bGwpO2UuZGVmYXVsdD1oLmV4cG9ydHN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuLnIoZSk7dmFyIGk9bigwKSxyPW4oMyksbz1uKDIpLHM9e25hbWU6XCJMQ2lyY2xlXCIsbWl4aW5zOltuKDIyKS5hXSxwcm9wczp7bGF0TG5nOnt0eXBlOltPYmplY3QsQXJyYXldLGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm5bXX19fSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3JlYWR5OiExfX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PU9iamVjdChvLmEpKHRoaXMuY2lyY2xlT3B0aW9ucyx0aGlzKTt0aGlzLm1hcE9iamVjdD1MLmNpcmNsZSh0aGlzLmxhdExuZyx0KSxMLkRvbUV2ZW50Lm9uKHRoaXMubWFwT2JqZWN0LHRoaXMuJGxpc3RlbmVycyksT2JqZWN0KGkuZGVmYXVsdCkodGhpcyx0aGlzLm1hcE9iamVjdCx0aGlzLiRvcHRpb25zLnByb3BzKSx0aGlzLnJlYWR5PSEwLHRoaXMucGFyZW50Q29udGFpbmVyPU9iamVjdChyLmRlZmF1bHQpKHRoaXMuJHBhcmVudCksdGhpcy5wYXJlbnRDb250YWluZXIuYWRkTGF5ZXIodGhpcywhdGhpcy52aXNpYmxlKX0sbWV0aG9kczp7fX0sYT1uKDEpLHU9T2JqZWN0KGEuYSkocyxmdW5jdGlvbigpe3ZhciB0PXRoaXMuJGNyZWF0ZUVsZW1lbnQ7cmV0dXJuKHRoaXMuX3NlbGYuX2N8fHQpKFwiZGl2XCIse3N0YXRpY1N0eWxlOntkaXNwbGF5Olwibm9uZVwifX0sW3RoaXMucmVhZHk/dGhpcy5fdChcImRlZmF1bHRcIik6dGhpcy5fZSgpXSwyKX0sW10sITEsbnVsbCxudWxsLG51bGwpO2UuZGVmYXVsdD11LmV4cG9ydHN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuLnIoZSk7dmFyIGk9bigwKSxyPW4oMyksbz1uKDIpLHM9bigyOCksYT1uKDUpLHU9e25hbWU6XCJMVG9vbHRpcFwiLG1peGluczpbcy5hLGEuYV0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PU9iamVjdChvLmEpKHRoaXMucG9wcGVyT3B0aW9ucyx0aGlzKTt0aGlzLm1hcE9iamVjdD1MLnRvb2x0aXAodCksTC5Eb21FdmVudC5vbih0aGlzLm1hcE9iamVjdCx0aGlzLiRsaXN0ZW5lcnMpLE9iamVjdChpLmRlZmF1bHQpKHRoaXMsdGhpcy5tYXBPYmplY3QsdGhpcy4kb3B0aW9ucy5wcm9wcyksdGhpcy5tYXBPYmplY3Quc2V0Q29udGVudCh0aGlzLmNvbnRlbnR8fHRoaXMuJGVsKSx0aGlzLnBhcmVudENvbnRhaW5lcj1PYmplY3Qoci5kZWZhdWx0KSh0aGlzLiRwYXJlbnQpLHRoaXMucGFyZW50Q29udGFpbmVyLm1hcE9iamVjdC5iaW5kVG9vbHRpcCh0aGlzLm1hcE9iamVjdCl9LGJlZm9yZURlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLnBhcmVudENvbnRhaW5lci5tYXBPYmplY3QmJnRoaXMucGFyZW50Q29udGFpbmVyLm1hcE9iamVjdC5nZXRUb29sdGlwKCkmJnRoaXMucGFyZW50Q29udGFpbmVyLm1hcE9iamVjdC51bmJpbmRUb29sdGlwKCl9fSxjPW4oMSksbD1PYmplY3QoYy5hKSh1LHZvaWQgMCx2b2lkIDAsITEsbnVsbCxudWxsLG51bGwpO2UuZGVmYXVsdD1sLmV4cG9ydHN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuLnIoZSk7dmFyIGk9big0KSxyPW4ubihpKSxvPW4oMCkscz1uKDMpLGE9bigyNSksdT1uKDIpLGM9big3KSxsPW4oNSkscD17bmFtZTpcIkxNYXJrZXJcIixtaXhpbnM6W2MuYSxsLmFdLHByb3BzOntwYW5lOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwibWFya2VyUGFuZVwifSxkcmFnZ2FibGU6e3R5cGU6Qm9vbGVhbixjdXN0b206ITAsZGVmYXVsdDohMX0sbGF0TG5nOnt0eXBlOltPYmplY3QsQXJyYXldLGN1c3RvbTohMCxkZWZhdWx0Om51bGx9LGljb246e3R5cGU6W09iamVjdF0sY3VzdG9tOiExLGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEwuSWNvbi5EZWZhdWx0fX0sekluZGV4T2Zmc2V0Ont0eXBlOk51bWJlcixjdXN0b206ITEsZGVmYXVsdDpudWxsfX0sZGF0YTpmdW5jdGlvbigpe3JldHVybntyZWFkeTohMX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt2YXIgdD1PYmplY3QodS5hKShyKCkoe30sdGhpcy5sYXllck9wdGlvbnMse2ljb246dGhpcy5pY29uLHpJbmRleE9mZnNldDp0aGlzLnpJbmRleE9mZnNldCxkcmFnZ2FibGU6dGhpcy5kcmFnZ2FibGV9KSx0aGlzKTt0aGlzLm1hcE9iamVjdD1MLm1hcmtlcih0aGlzLmxhdExuZyx0KSxMLkRvbUV2ZW50Lm9uKHRoaXMubWFwT2JqZWN0LHRoaXMuJGxpc3RlbmVycyksdGhpcy5tYXBPYmplY3Qub24oXCJtb3ZlXCIsT2JqZWN0KGEuYSkodGhpcy5sYXRMbmdTeW5jLDEwMCkpLE9iamVjdChvLmRlZmF1bHQpKHRoaXMsdGhpcy5tYXBPYmplY3QsdGhpcy4kb3B0aW9ucy5wcm9wcyksdGhpcy5wYXJlbnRDb250YWluZXI9T2JqZWN0KHMuZGVmYXVsdCkodGhpcy4kcGFyZW50KSx0aGlzLnBhcmVudENvbnRhaW5lci5hZGRMYXllcih0aGlzLCF0aGlzLnZpc2libGUpLHRoaXMucmVhZHk9ITB9LG1ldGhvZHM6e3NldERyYWdnYWJsZTpmdW5jdGlvbih0LGUpe3RoaXMubWFwT2JqZWN0LmRyYWdnaW5nJiYodD90aGlzLm1hcE9iamVjdC5kcmFnZ2luZy5lbmFibGUoKTp0aGlzLm1hcE9iamVjdC5kcmFnZ2luZy5kaXNhYmxlKCkpfSxzZXRMYXRMbmc6ZnVuY3Rpb24odCl7aWYobnVsbCE9dCYmdGhpcy5tYXBPYmplY3Qpe3ZhciBlPXRoaXMubWFwT2JqZWN0LmdldExhdExuZygpLG49e2xhdDp0WzBdfHx0LmxhdCxsbmc6dFsxXXx8dC5sbmd9O24ubGF0PT09ZS5sYXQmJm4ubG5nPT09ZS5sbmd8fHRoaXMubWFwT2JqZWN0LnNldExhdExuZyhuKX19LGxhdExuZ1N5bmM6ZnVuY3Rpb24odCl7dGhpcy4kZW1pdChcInVwZGF0ZTpsYXRMbmdcIix0LmxhdGxuZyl9fSxyZW5kZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVhZHkmJnRoaXMuJHNsb3RzLmRlZmF1bHQ/dChcImRpdlwiLHtzdHlsZTp7ZGlzcGxheTpcIm5vbmVcIn19LHRoaXMuJHNsb3RzLmRlZmF1bHQpOm51bGx9fSxmPW4oMSksaD1PYmplY3QoZi5hKShwLHZvaWQgMCx2b2lkIDAsITEsbnVsbCxudWxsLG51bGwpO2UuZGVmYXVsdD1oLmV4cG9ydHN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuLnIoZSk7dmFyIGk9bigwKSxyPW4oMyksbz1uKDIpLHM9bigyOCksYT1uKDUpLHU9e25hbWU6XCJMUG9wdXBcIixtaXhpbnM6W3MuYSxhLmFdLHByb3BzOntsYXRMbmc6e3R5cGU6W09iamVjdCxBcnJheV0sZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybltdfX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt2YXIgdD1PYmplY3Qoby5hKSh0aGlzLnBvcHBlck9wdGlvbnMsdGhpcyk7dGhpcy5tYXBPYmplY3Q9TC5wb3B1cCh0KSx2b2lkIDAhPT10aGlzLmxhdExuZyYmdGhpcy5tYXBPYmplY3Quc2V0TGF0TG5nKHRoaXMubGF0TG5nKSxMLkRvbUV2ZW50Lm9uKHRoaXMubWFwT2JqZWN0LHRoaXMuJGxpc3RlbmVycyksT2JqZWN0KGkuZGVmYXVsdCkodGhpcyx0aGlzLm1hcE9iamVjdCx0aGlzLiRvcHRpb25zLnByb3BzKSx0aGlzLm1hcE9iamVjdC5zZXRDb250ZW50KHRoaXMuY29udGVudHx8dGhpcy4kZWwpLHRoaXMucGFyZW50Q29udGFpbmVyPU9iamVjdChyLmRlZmF1bHQpKHRoaXMuJHBhcmVudCksdGhpcy5wYXJlbnRDb250YWluZXIubWFwT2JqZWN0LmJpbmRQb3B1cCh0aGlzLm1hcE9iamVjdCl9LGJlZm9yZURlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLnBhcmVudENvbnRhaW5lci5tYXBPYmplY3QmJnRoaXMucGFyZW50Q29udGFpbmVyLm1hcE9iamVjdC5nZXRQb3B1cCgpJiZ0aGlzLnBhcmVudENvbnRhaW5lci5tYXBPYmplY3QudW5iaW5kUG9wdXAoKX19LGM9bigxKSxsPU9iamVjdChjLmEpKHUsdm9pZCAwLHZvaWQgMCwhMSxudWxsLG51bGwsbnVsbCk7ZS5kZWZhdWx0PWwuZXhwb3J0c30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24ucihlKTt2YXIgaT1uKDQpLHI9bi5uKGkpLG89bigwKSxzPW4oMyksYT1uKDIpLHU9big2KSxjPW4ubih1KSxsPXtuYW1lOlwiTEdlb0pzb25cIixtaXhpbnM6W24oMTQpLmFdLHByb3BzOntnZW9qc29uOnt0eXBlOltPYmplY3QsQXJyYXldLGN1c3RvbTohMCxkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJue319fSxvcHRpb25zOnt0eXBlOk9iamVjdCxjdXN0b206ITAsZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybnt9fX0sb3B0aW9uc1N0eWxlOnt0eXBlOltPYmplY3QsRnVuY3Rpb25dLGN1c3RvbTohMCxkZWZhdWx0Om51bGx9fSxjb21wdXRlZDp7bWVyZ2VkT3B0aW9uczpmdW5jdGlvbigpe3JldHVybiBPYmplY3QoYS5hKShyKCkoe30sdGhpcy5sYXllckdyb3VwT3B0aW9ucyx7c3R5bGU6dGhpcy5vcHRpb25zU3R5bGV9KSx0aGlzKX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLm1hcE9iamVjdD1jLmEuZ2VvSlNPTih0aGlzLmdlb2pzb24sdGhpcy5tZXJnZWRPcHRpb25zKSxjLmEuRG9tRXZlbnQub24odGhpcy5tYXBPYmplY3QsdGhpcy4kbGlzdGVuZXJzKSxPYmplY3Qoby5kZWZhdWx0KSh0aGlzLHRoaXMubWFwT2JqZWN0LHRoaXMuJG9wdGlvbnMucHJvcHMpLHRoaXMucGFyZW50Q29udGFpbmVyPU9iamVjdChzLmRlZmF1bHQpKHRoaXMuJHBhcmVudCwhMCksdGhpcy5wYXJlbnRDb250YWluZXIuYWRkTGF5ZXIodGhpcywhdGhpcy52aXNpYmxlKX0sYmVmb3JlRGVzdHJveTpmdW5jdGlvbigpe3RoaXMucGFyZW50Q29udGFpbmVyLm1hcE9iamVjdC5yZW1vdmVMYXllcih0aGlzLm1hcE9iamVjdCl9LG1ldGhvZHM6e3NldEdlb2pzb246ZnVuY3Rpb24odCl7dGhpcy5tYXBPYmplY3QuY2xlYXJMYXllcnMoKSx0aGlzLm1hcE9iamVjdC5hZGREYXRhKHQpfSxnZXRHZW9KU09ORGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcE9iamVjdC50b0dlb0pTT04oKX0sZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwT2JqZWN0LmdldEJvdW5kcygpfSxzZXRPcHRpb25zOmZ1bmN0aW9uKHQsZSl7dGhpcy5tYXBPYmplY3QuY2xlYXJMYXllcnMoKSxjLmEuc2V0T3B0aW9ucyh0aGlzLm1hcE9iamVjdCx0aGlzLm1lcmdlZE9wdGlvbnMpLHRoaXMubWFwT2JqZWN0LmFkZERhdGEodGhpcy5nZW9qc29uKX0sc2V0T3B0aW9uc1N0eWxlOmZ1bmN0aW9uKHQsZSl7dGhpcy5tYXBPYmplY3Quc2V0U3R5bGUodCl9fSxyZW5kZXI6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH19LHA9bigxKSxmPU9iamVjdChwLmEpKGwsdm9pZCAwLHZvaWQgMCwhMSxudWxsLG51bGwsbnVsbCk7ZS5kZWZhdWx0PWYuZXhwb3J0c30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24ucihlKTt2YXIgaT1uKDQpLHI9bi5uKGkpLG89bigwKSxzPW4oMiksYT1uKDgpLHU9big1KSxjPXtuYW1lOlwiTENvbnRyb2xBdHRyaWJ1dGlvblwiLG1peGluczpbYS5hLHUuYV0scHJvcHM6e3ByZWZpeDp7dHlwZTpTdHJpbmcsZGVmYXVsdDpudWxsfX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PU9iamVjdChzLmEpKHIoKSh7fSx0aGlzLmNvbnRyb2xPcHRpb25zLHtwcmVmaXg6dGhpcy5wcmVmaXh9KSx0aGlzKTt0aGlzLm1hcE9iamVjdD1MLmNvbnRyb2wuYXR0cmlidXRpb24odCksT2JqZWN0KG8uZGVmYXVsdCkodGhpcyx0aGlzLm1hcE9iamVjdCx0aGlzLiRvcHRpb25zLnByb3BzKSx0aGlzLm1hcE9iamVjdC5hZGRUbyh0aGlzLiRwYXJlbnQubWFwT2JqZWN0KX0scmVuZGVyOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9fSxsPW4oMSkscD1PYmplY3QobC5hKShjLHZvaWQgMCx2b2lkIDAsITEsbnVsbCxudWxsLG51bGwpO2UuZGVmYXVsdD1wLmV4cG9ydHN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtuLnIoZSk7dmFyIGk9bigwKSxyPXtuYW1lOlwiTEljb25EZWZhdWx0XCIscHJvcHM6e2ltYWdlUGF0aDp7dHlwZTpTdHJpbmcsY3VzdG9tOiEwLGRlZmF1bHQ6XCJcIn19LG1vdW50ZWQ6ZnVuY3Rpb24oKXtMLkljb24uRGVmYXVsdC5pbWFnZVBhdGg9dGhpcy5pbWFnZVBhdGgsT2JqZWN0KGkuZGVmYXVsdCkodGhpcyx0aGlzLm1hcE9iamVjdCx0aGlzLiRvcHRpb25zLnByb3BzKX0sbWV0aG9kczp7c2V0SW1hZ2VQYXRoOmZ1bmN0aW9uKHQsZSl7TC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoPXR9fSxyZW5kZXI6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH19LG89bigxKSxzPU9iamVjdChvLmEpKHIsdm9pZCAwLHZvaWQgMCwhMSxudWxsLG51bGwsbnVsbCk7ZS5kZWZhdWx0PXMuZXhwb3J0c30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24ucihlKTt2YXIgaT1uKDQpLHI9bi5uKGkpLG89bigwKSxzPW4oMiksYT1uKDgpLHU9big1KSxjPXtuYW1lOlwiTENvbnRyb2xMYXllcnNcIixtaXhpbnM6W2EuYSx1LmFdLHByb3BzOntjb2xsYXBzZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiEwfSxhdXRvWkluZGV4Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMH0saGlkZVNpbmdsZUJhc2U6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxzb3J0TGF5ZXJzOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sc29ydEZ1bmN0aW9uOnt0eXBlOkZ1bmN0aW9uLGRlZmF1bHQ6dm9pZCAwfX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PU9iamVjdChzLmEpKHIoKSh7fSx0aGlzLmNvbnRyb2xPcHRpb25zLHtjb2xsYXBzZWQ6dGhpcy5jb2xsYXBzZWQsYXV0b1pJbmRleDp0aGlzLmF1dG9aSW5kZXgsaGlkZVNpbmdsZUJhc2U6dGhpcy5oaWRlU2luZ2xlQmFzZSxzb3J0TGF5ZXJzOnRoaXMuc29ydExheWVycyxzb3J0RnVuY3Rpb246dGhpcy5zb3J0RnVuY3Rpb259KSx0aGlzKTt0aGlzLm1hcE9iamVjdD1MLmNvbnRyb2wubGF5ZXJzKG51bGwsbnVsbCx0KSxPYmplY3Qoby5kZWZhdWx0KSh0aGlzLHRoaXMubWFwT2JqZWN0LHRoaXMuJG9wdGlvbnMucHJvcHMpLHRoaXMuJHBhcmVudC5yZWdpc3RlckxheWVyQ29udHJvbCh0aGlzKX0sbWV0aG9kczp7YWRkTGF5ZXI6ZnVuY3Rpb24odCl7XCJiYXNlXCI9PT10LmxheWVyVHlwZT90aGlzLm1hcE9iamVjdC5hZGRCYXNlTGF5ZXIodC5tYXBPYmplY3QsdC5uYW1lKTpcIm92ZXJsYXlcIj09PXQubGF5ZXJUeXBlJiZ0aGlzLm1hcE9iamVjdC5hZGRPdmVybGF5KHQubWFwT2JqZWN0LHQubmFtZSl9LHJlbW92ZUxheWVyOmZ1bmN0aW9uKHQpe3RoaXMubWFwT2JqZWN0LnJlbW92ZUxheWVyKHQubWFwT2JqZWN0KX19LHJlbmRlcjpmdW5jdGlvbigpe3JldHVybiBudWxsfX0sbD1uKDEpLHA9T2JqZWN0KGwuYSkoYyx2b2lkIDAsdm9pZCAwLCExLG51bGwsbnVsbCxudWxsKTtlLmRlZmF1bHQ9cC5leHBvcnRzfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpO3ZhciBpPW4oNCkscj1uLm4oaSksbz1uKDApLHM9bigyKSxhPW4oOCksdT1uKDUpLGM9e25hbWU6XCJMQ29udHJvbFpvb21cIixtaXhpbnM6W2EuYSx1LmFdLHByb3BzOnt6b29tSW5UZXh0Ont0eXBlOlN0cmluZyxkZWZhdWx0OlwiK1wifSx6b29tSW5UaXRsZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlpvb20gaW5cIn0sem9vbU91dFRleHQ6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCItXCJ9LHpvb21PdXRUaXRsZTp7dHlwZTpTdHJpbmcsZGVmYXVsdDpcIlpvb20gb3V0XCJ9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dmFyIHQ9T2JqZWN0KHMuYSkocigpKHt9LHRoaXMuY29udHJvbE9wdGlvbnMse3pvb21JblRleHQ6dGhpcy56b29tSW5UZXh0LHpvb21JblRpdGxlOnRoaXMuem9vbUluVGl0bGUsem9vbU91dFRleHQ6dGhpcy56b29tT3V0VGV4dCx6b29tT3V0VGl0bGU6dGhpcy56b29tT3V0VGl0bGV9KSx0aGlzKTt0aGlzLm1hcE9iamVjdD1MLmNvbnRyb2wuem9vbSh0KSxPYmplY3Qoby5kZWZhdWx0KSh0aGlzLHRoaXMubWFwT2JqZWN0LHRoaXMuJG9wdGlvbnMucHJvcHMpLHRoaXMubWFwT2JqZWN0LmFkZFRvKHRoaXMuJHBhcmVudC5tYXBPYmplY3QpfSxyZW5kZXI6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH19LGw9bigxKSxwPU9iamVjdChsLmEpKGMsdm9pZCAwLHZvaWQgMCwhMSxudWxsLG51bGwsbnVsbCk7ZS5kZWZhdWx0PXAuZXhwb3J0c30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24ucihlKTt2YXIgaT1uKDQpLHI9bi5uKGkpLG89bigwKSxzPW4oMiksYT1uKDgpLHU9big1KSxjPXtuYW1lOlwiTENvbnRyb2xTY2FsZVwiLG1peGluczpbYS5hLHUuYV0scHJvcHM6e21heFdpZHRoOnt0eXBlOk51bWJlcixkZWZhdWx0OjEwMH0sbWV0cmljOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMH0saW1wZXJpYWw6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiEwfSx1cGRhdGVXaGVuSWRsZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dmFyIHQ9T2JqZWN0KHMuYSkocigpKHt9LHRoaXMuY29udHJvbE9wdGlvbnMse21heFdpZHRoOnRoaXMubWF4V2lkdGgsbWV0cmljOnRoaXMubWV0cmljLGltcGVyaWFsOnRoaXMuaW1wZXJpYWwsdXBkYXRlV2hlbklkbGU6dGhpcy51cGRhdGVXaGVuSWRsZX0pLHRoaXMpO3RoaXMubWFwT2JqZWN0PUwuY29udHJvbC5zY2FsZSh0KSxPYmplY3Qoby5kZWZhdWx0KSh0aGlzLHRoaXMubWFwT2JqZWN0LHRoaXMuJG9wdGlvbnMucHJvcHMpLHRoaXMubWFwT2JqZWN0LmFkZFRvKHRoaXMuJHBhcmVudC5tYXBPYmplY3QpfSxyZW5kZXI6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH19LGw9bigxKSxwPU9iamVjdChsLmEpKGMsdm9pZCAwLHZvaWQgMCwhMSxudWxsLG51bGwsbnVsbCk7ZS5kZWZhdWx0PXAuZXhwb3J0c30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkodCxlKXtmb3IodmFyIG49W10saT17fSxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBvPWVbcl0scz1vWzBdLGE9e2lkOnQrXCI6XCIrcixjc3M6b1sxXSxtZWRpYTpvWzJdLHNvdXJjZU1hcDpvWzNdfTtpW3NdP2lbc10ucGFydHMucHVzaChhKTpuLnB1c2goaVtzXT17aWQ6cyxwYXJ0czpbYV19KX1yZXR1cm4gbn1uLnIoZSksbi5kKGUsXCJkZWZhdWx0XCIsZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3ZhciByPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudDtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgREVCVUcmJkRFQlVHJiYhcil0aHJvdyBuZXcgRXJyb3IoXCJ2dWUtc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuIFVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCIpO3ZhciBvPXt9LHM9ciYmKGRvY3VtZW50LmhlYWR8fGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSksYT1udWxsLHU9MCxjPSExLGw9ZnVuY3Rpb24oKXt9LHA9bnVsbCxmPVwiZGF0YS12dWUtc3NyLWlkXCIsaD1cInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiYvbXNpZSBbNi05XVxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO2Z1bmN0aW9uIGQodCxlLG4scil7Yz1uLHA9cnx8e307dmFyIHM9aSh0LGUpO3JldHVybiBtKHMpLGZ1bmN0aW9uKGUpe2Zvcih2YXIgbj1bXSxyPTA7cjxzLmxlbmd0aDtyKyspe3ZhciBhPXNbcl07KHU9b1thLmlkXSkucmVmcy0tLG4ucHVzaCh1KX1lP20ocz1pKHQsZSkpOnM9W107Zm9yKHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIHU7aWYoMD09PSh1PW5bcl0pLnJlZnMpe2Zvcih2YXIgYz0wO2M8dS5wYXJ0cy5sZW5ndGg7YysrKXUucGFydHNbY10oKTtkZWxldGUgb1t1LmlkXX19fX1mdW5jdGlvbiBtKHQpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj10W2VdLGk9b1tuLmlkXTtpZihpKXtpLnJlZnMrKztmb3IodmFyIHI9MDtyPGkucGFydHMubGVuZ3RoO3IrKylpLnBhcnRzW3JdKG4ucGFydHNbcl0pO2Zvcig7cjxuLnBhcnRzLmxlbmd0aDtyKyspaS5wYXJ0cy5wdXNoKGIobi5wYXJ0c1tyXSkpO2kucGFydHMubGVuZ3RoPm4ucGFydHMubGVuZ3RoJiYoaS5wYXJ0cy5sZW5ndGg9bi5wYXJ0cy5sZW5ndGgpfWVsc2V7dmFyIHM9W107Zm9yKHI9MDtyPG4ucGFydHMubGVuZ3RoO3IrKylzLnB1c2goYihuLnBhcnRzW3JdKSk7b1tuLmlkXT17aWQ6bi5pZCxyZWZzOjEscGFydHM6c319fX1mdW5jdGlvbiB5KCl7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO3JldHVybiB0LnR5cGU9XCJ0ZXh0L2Nzc1wiLHMuYXBwZW5kQ2hpbGQodCksdH1mdW5jdGlvbiBiKHQpe3ZhciBlLG4saT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic3R5bGVbXCIrZisnfj1cIicrdC5pZCsnXCJdJyk7aWYoaSl7aWYoYylyZXR1cm4gbDtpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaSl9aWYoaCl7dmFyIHI9dSsrO2k9YXx8KGE9eSgpKSxlPXYuYmluZChudWxsLGksciwhMSksbj12LmJpbmQobnVsbCxpLHIsITApfWVsc2UgaT15KCksZT1mdW5jdGlvbih0LGUpe3ZhciBuPWUuY3NzLGk9ZS5tZWRpYSxyPWUuc291cmNlTWFwO2kmJnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIixpKTtwLnNzcklkJiZ0LnNldEF0dHJpYnV0ZShmLGUuaWQpO3ImJihuKz1cIlxcbi8qIyBzb3VyY2VVUkw9XCIrci5zb3VyY2VzWzBdK1wiICovXCIsbis9XCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiK2J0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHIpKSkpK1wiICovXCIpO2lmKHQuc3R5bGVTaGVldCl0LnN0eWxlU2hlZXQuY3NzVGV4dD1uO2Vsc2V7Zm9yKDt0LmZpcnN0Q2hpbGQ7KXQucmVtb3ZlQ2hpbGQodC5maXJzdENoaWxkKTt0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG4pKX19LmJpbmQobnVsbCxpKSxuPWZ1bmN0aW9uKCl7aS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGkpfTtyZXR1cm4gZSh0KSxmdW5jdGlvbihpKXtpZihpKXtpZihpLmNzcz09PXQuY3NzJiZpLm1lZGlhPT09dC5tZWRpYSYmaS5zb3VyY2VNYXA9PT10LnNvdXJjZU1hcClyZXR1cm47ZSh0PWkpfWVsc2UgbigpfX12YXIgTz1mdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiBmdW5jdGlvbihlLG4pe3JldHVybiB0W2VdPW4sdC5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKX19KCk7ZnVuY3Rpb24gdih0LGUsbixpKXt2YXIgcj1uP1wiXCI6aS5jc3M7aWYodC5zdHlsZVNoZWV0KXQuc3R5bGVTaGVldC5jc3NUZXh0PU8oZSxyKTtlbHNle3ZhciBvPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHIpLHM9dC5jaGlsZE5vZGVzO3NbZV0mJnQucmVtb3ZlQ2hpbGQoc1tlXSkscy5sZW5ndGg/dC5pbnNlcnRCZWZvcmUobyxzW2VdKTp0LmFwcGVuZENoaWxkKG8pfX19XSl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZ1ZTItbGVhZmxldC5taW4uanMubWFwIiwiZXhwb3J0cy5zeW5jID0gZnVuY3Rpb24gKHN0b3JlLCByb3V0ZXIsIG9wdGlvbnMpIHtcbiAgdmFyIG1vZHVsZU5hbWUgPSAob3B0aW9ucyB8fCB7fSkubW9kdWxlTmFtZSB8fCAncm91dGUnXG5cbiAgc3RvcmUucmVnaXN0ZXJNb2R1bGUobW9kdWxlTmFtZSwge1xuICAgIG5hbWVzcGFjZWQ6IHRydWUsXG4gICAgc3RhdGU6IGNsb25lUm91dGUocm91dGVyLmN1cnJlbnRSb3V0ZSksXG4gICAgbXV0YXRpb25zOiB7XG4gICAgICAnUk9VVEVfQ0hBTkdFRCc6IGZ1bmN0aW9uIFJPVVRFX0NIQU5HRUQgKHN0YXRlLCB0cmFuc2l0aW9uKSB7XG4gICAgICAgIHN0b3JlLnN0YXRlW21vZHVsZU5hbWVdID0gY2xvbmVSb3V0ZSh0cmFuc2l0aW9uLnRvLCB0cmFuc2l0aW9uLmZyb20pXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHZhciBpc1RpbWVUcmF2ZWxpbmcgPSBmYWxzZVxuICB2YXIgY3VycmVudFBhdGhcblxuICAvLyBzeW5jIHJvdXRlciBvbiBzdG9yZSBjaGFuZ2VcbiAgdmFyIHN0b3JlVW53YXRjaCA9IHN0b3JlLndhdGNoKFxuICAgIGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGVbbW9kdWxlTmFtZV07IH0sXG4gICAgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB2YXIgZnVsbFBhdGggPSByb3V0ZS5mdWxsUGF0aDtcbiAgICAgIGlmIChmdWxsUGF0aCA9PT0gY3VycmVudFBhdGgpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhdGggIT0gbnVsbCkge1xuICAgICAgICBpc1RpbWVUcmF2ZWxpbmcgPSB0cnVlXG4gICAgICAgIHJvdXRlci5wdXNoKHJvdXRlKVxuICAgICAgfVxuICAgICAgY3VycmVudFBhdGggPSBmdWxsUGF0aFxuICAgIH0sXG4gICAgeyBzeW5jOiB0cnVlIH1cbiAgKVxuXG4gIC8vIHN5bmMgc3RvcmUgb24gcm91dGVyIG5hdmlnYXRpb25cbiAgdmFyIGFmdGVyRWFjaFVuSG9vayA9IHJvdXRlci5hZnRlckVhY2goZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgaWYgKGlzVGltZVRyYXZlbGluZykge1xuICAgICAgaXNUaW1lVHJhdmVsaW5nID0gZmFsc2VcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjdXJyZW50UGF0aCA9IHRvLmZ1bGxQYXRoXG4gICAgc3RvcmUuY29tbWl0KG1vZHVsZU5hbWUgKyAnL1JPVVRFX0NIQU5HRUQnLCB7IHRvOiB0bywgZnJvbTogZnJvbSB9KVxuICB9KVxuXG4gIHJldHVybiBmdW5jdGlvbiB1bnN5bmMgKCkge1xuICAgIC8vIE9uIHVuc3luYywgcmVtb3ZlIHJvdXRlciBob29rXG4gICAgaWYgKGFmdGVyRWFjaFVuSG9vayAhPSBudWxsKSB7XG4gICAgICBhZnRlckVhY2hVbkhvb2soKVxuICAgIH1cblxuICAgIC8vIE9uIHVuc3luYywgcmVtb3ZlIHN0b3JlIHdhdGNoXG4gICAgaWYgKHN0b3JlVW53YXRjaCAhPSBudWxsKSB7XG4gICAgICBzdG9yZVVud2F0Y2goKVxuICAgIH1cblxuICAgIC8vIE9uIHVuc3luYywgdW5yZWdpc3RlciBNb2R1bGUgd2l0aCBzdG9yZVxuICAgIHN0b3JlLnVucmVnaXN0ZXJNb2R1bGUobW9kdWxlTmFtZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZVJvdXRlICh0bywgZnJvbSkge1xuICB2YXIgY2xvbmUgPSB7XG4gICAgbmFtZTogdG8ubmFtZSxcbiAgICBwYXRoOiB0by5wYXRoLFxuICAgIGhhc2g6IHRvLmhhc2gsXG4gICAgcXVlcnk6IHRvLnF1ZXJ5LFxuICAgIHBhcmFtczogdG8ucGFyYW1zLFxuICAgIGZ1bGxQYXRoOiB0by5mdWxsUGF0aCxcbiAgICBtZXRhOiB0by5tZXRhXG4gIH1cbiAgaWYgKGZyb20pIHtcbiAgICBjbG9uZS5mcm9tID0gY2xvbmVSb3V0ZShmcm9tKVxuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKGNsb25lKVxufVxuXG4iLCIvKipcbiAqIHZ1ZXggdjMuMC4xXG4gKiAoYykgMjAxNyBFdmFuIFlvdVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGFwcGx5TWl4aW4gPSBmdW5jdGlvbiAoVnVlKSB7XG4gIHZhciB2ZXJzaW9uID0gTnVtYmVyKFZ1ZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pO1xuXG4gIGlmICh2ZXJzaW9uID49IDIpIHtcbiAgICBWdWUubWl4aW4oeyBiZWZvcmVDcmVhdGU6IHZ1ZXhJbml0IH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG92ZXJyaWRlIGluaXQgYW5kIGluamVjdCB2dWV4IGluaXQgcHJvY2VkdXJlXG4gICAgLy8gZm9yIDEueCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICB2YXIgX2luaXQgPSBWdWUucHJvdG90eXBlLl9pbml0O1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgICAgIG9wdGlvbnMuaW5pdCA9IG9wdGlvbnMuaW5pdFxuICAgICAgICA/IFt2dWV4SW5pdF0uY29uY2F0KG9wdGlvbnMuaW5pdClcbiAgICAgICAgOiB2dWV4SW5pdDtcbiAgICAgIF9pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWdWV4IGluaXQgaG9vaywgaW5qZWN0ZWQgaW50byBlYWNoIGluc3RhbmNlcyBpbml0IGhvb2tzIGxpc3QuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHZ1ZXhJbml0ICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgLy8gc3RvcmUgaW5qZWN0aW9uXG4gICAgaWYgKG9wdGlvbnMuc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gdHlwZW9mIG9wdGlvbnMuc3RvcmUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBvcHRpb25zLnN0b3JlKClcbiAgICAgICAgOiBvcHRpb25zLnN0b3JlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQuJHN0b3JlKSB7XG4gICAgICB0aGlzLiRzdG9yZSA9IG9wdGlvbnMucGFyZW50LiRzdG9yZTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZXZ0b29sSG9vayA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG5mdW5jdGlvbiBkZXZ0b29sUGx1Z2luIChzdG9yZSkge1xuICBpZiAoIWRldnRvb2xIb29rKSB7IHJldHVybiB9XG5cbiAgc3RvcmUuX2RldnRvb2xIb29rID0gZGV2dG9vbEhvb2s7XG5cbiAgZGV2dG9vbEhvb2suZW1pdCgndnVleDppbml0Jywgc3RvcmUpO1xuXG4gIGRldnRvb2xIb29rLm9uKCd2dWV4OnRyYXZlbC10by1zdGF0ZScsIGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZSh0YXJnZXRTdGF0ZSk7XG4gIH0pO1xuXG4gIHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAobXV0YXRpb24sIHN0YXRlKSB7XG4gICAgZGV2dG9vbEhvb2suZW1pdCgndnVleDptdXRhdGlvbicsIG11dGF0aW9uLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgaXRlbSB0aGF0IHBhc3MgdGhlIHRlc3RcbiAqIGJ5IHNlY29uZCBhcmd1bWVudCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEByZXR1cm4geyp9XG4gKi9cbi8qKlxuICogRGVlcCBjb3B5IHRoZSBnaXZlbiBvYmplY3QgY29uc2lkZXJpbmcgY2lyY3VsYXIgc3RydWN0dXJlLlxuICogVGhpcyBmdW5jdGlvbiBjYWNoZXMgYWxsIG5lc3RlZCBvYmplY3RzIGFuZCBpdHMgY29waWVzLlxuICogSWYgaXQgZGV0ZWN0cyBjaXJjdWxhciBzdHJ1Y3R1cmUsIHVzZSBjYWNoZWQgY29weSB0byBhdm9pZCBpbmZpbml0ZSBsb29wLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGNhY2hlXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cblxuLyoqXG4gKiBmb3JFYWNoIGZvciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaFZhbHVlIChvYmosIGZuKSB7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihvYmpba2V5XSwga2V5KTsgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbXNnKSB7XG4gIGlmICghY29uZGl0aW9uKSB7IHRocm93IG5ldyBFcnJvcigoXCJbdnVleF0gXCIgKyBtc2cpKSB9XG59XG5cbnZhciBNb2R1bGUgPSBmdW5jdGlvbiBNb2R1bGUgKHJhd01vZHVsZSwgcnVudGltZSkge1xuICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICB0aGlzLl9jaGlsZHJlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3Jhd01vZHVsZSA9IHJhd01vZHVsZTtcbiAgdmFyIHJhd1N0YXRlID0gcmF3TW9kdWxlLnN0YXRlO1xuICB0aGlzLnN0YXRlID0gKHR5cGVvZiByYXdTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IHJhd1N0YXRlKCkgOiByYXdTdGF0ZSkgfHwge307XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7IG5hbWVzcGFjZWQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEubmFtZXNwYWNlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIXRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGtleSwgbW9kdWxlKSB7XG4gIHRoaXMuX2NoaWxkcmVuW2tleV0gPSBtb2R1bGU7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGtleSkge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5ba2V5XTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiBnZXRDaGlsZCAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAocmF3TW9kdWxlKSB7XG4gIHRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkID0gcmF3TW9kdWxlLm5hbWVzcGFjZWQ7XG4gIGlmIChyYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zID0gcmF3TW9kdWxlLmFjdGlvbnM7XG4gIH1cbiAgaWYgKHJhd01vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zID0gcmF3TW9kdWxlLm11dGF0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycyA9IHJhd01vZHVsZS5nZXR0ZXJzO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIGZvckVhY2hDaGlsZCAoZm4pIHtcbiAgZm9yRWFjaFZhbHVlKHRoaXMuX2NoaWxkcmVuLCBmbik7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hHZXR0ZXIgPSBmdW5jdGlvbiBmb3JFYWNoR2V0dGVyIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoQWN0aW9uID0gZnVuY3Rpb24gZm9yRWFjaEFjdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zLCBmbik7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaE11dGF0aW9uID0gZnVuY3Rpb24gZm9yRWFjaE11dGF0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zLCBmbik7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNb2R1bGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG52YXIgTW9kdWxlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIE1vZHVsZUNvbGxlY3Rpb24gKHJhd1Jvb3RNb2R1bGUpIHtcbiAgLy8gcmVnaXN0ZXIgcm9vdCBtb2R1bGUgKFZ1ZXguU3RvcmUgb3B0aW9ucylcbiAgdGhpcy5yZWdpc3RlcihbXSwgcmF3Um9vdE1vZHVsZSwgZmFsc2UpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobW9kdWxlLCBrZXkpIHtcbiAgICByZXR1cm4gbW9kdWxlLmdldENoaWxkKGtleSlcbiAgfSwgdGhpcy5yb290KVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24gZ2V0TmFtZXNwYWNlIChwYXRoKSB7XG4gIHZhciBtb2R1bGUgPSB0aGlzLnJvb3Q7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBrZXkpIHtcbiAgICBtb2R1bGUgPSBtb2R1bGUuZ2V0Q2hpbGQoa2V5KTtcbiAgICByZXR1cm4gbmFtZXNwYWNlICsgKG1vZHVsZS5uYW1lc3BhY2VkID8ga2V5ICsgJy8nIDogJycpXG4gIH0sICcnKVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlJDEgKHJhd1Jvb3RNb2R1bGUpIHtcbiAgdXBkYXRlKFtdLCB0aGlzLnJvb3QsIHJhd1Jvb3RNb2R1bGUpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlciAocGF0aCwgcmF3TW9kdWxlLCBydW50aW1lKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgaWYgKCBydW50aW1lID09PSB2b2lkIDAgKSBydW50aW1lID0gdHJ1ZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFJhd01vZHVsZShwYXRoLCByYXdNb2R1bGUpO1xuICB9XG5cbiAgdmFyIG5ld01vZHVsZSA9IG5ldyBNb2R1bGUocmF3TW9kdWxlLCBydW50aW1lKTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5yb290ID0gbmV3TW9kdWxlO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgcGFyZW50LmFkZENoaWxkKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgbmV3TW9kdWxlKTtcbiAgfVxuXG4gIC8vIHJlZ2lzdGVyIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdNb2R1bGUubW9kdWxlcywgZnVuY3Rpb24gKHJhd0NoaWxkTW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3RlcihwYXRoLmNvbmNhdChrZXkpLCByYXdDaGlsZE1vZHVsZSwgcnVudGltZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyIChwYXRoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmICghcGFyZW50LmdldENoaWxkKGtleSkucnVudGltZSkgeyByZXR1cm4gfVxuXG4gIHBhcmVudC5yZW1vdmVDaGlsZChrZXkpO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlIChwYXRoLCB0YXJnZXRNb2R1bGUsIG5ld01vZHVsZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFJhd01vZHVsZShwYXRoLCBuZXdNb2R1bGUpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHRhcmdldCBtb2R1bGVcbiAgdGFyZ2V0TW9kdWxlLnVwZGF0ZShuZXdNb2R1bGUpO1xuXG4gIC8vIHVwZGF0ZSBuZXN0ZWQgbW9kdWxlc1xuICBpZiAobmV3TW9kdWxlLm1vZHVsZXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmV3TW9kdWxlLm1vZHVsZXMpIHtcbiAgICAgIGlmICghdGFyZ2V0TW9kdWxlLmdldENoaWxkKGtleSkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIlt2dWV4XSB0cnlpbmcgdG8gYWRkIGEgbmV3IG1vZHVsZSAnXCIgKyBrZXkgKyBcIicgb24gaG90IHJlbG9hZGluZywgXCIgK1xuICAgICAgICAgICAgJ21hbnVhbCByZWxvYWQgaXMgbmVlZGVkJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUoXG4gICAgICAgIHBhdGguY29uY2F0KGtleSksXG4gICAgICAgIHRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpLFxuICAgICAgICBuZXdNb2R1bGUubW9kdWxlc1trZXldXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZnVuY3Rpb25Bc3NlcnQgPSB7XG4gIGFzc2VydDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7IH0sXG4gIGV4cGVjdGVkOiAnZnVuY3Rpb24nXG59O1xuXG52YXIgb2JqZWN0QXNzZXJ0ID0ge1xuICBhc3NlcnQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmhhbmRsZXIgPT09ICdmdW5jdGlvbicpOyB9LFxuICBleHBlY3RlZDogJ2Z1bmN0aW9uIG9yIG9iamVjdCB3aXRoIFwiaGFuZGxlclwiIGZ1bmN0aW9uJ1xufTtcblxudmFyIGFzc2VydFR5cGVzID0ge1xuICBnZXR0ZXJzOiBmdW5jdGlvbkFzc2VydCxcbiAgbXV0YXRpb25zOiBmdW5jdGlvbkFzc2VydCxcbiAgYWN0aW9uczogb2JqZWN0QXNzZXJ0XG59O1xuXG5mdW5jdGlvbiBhc3NlcnRSYXdNb2R1bGUgKHBhdGgsIHJhd01vZHVsZSkge1xuICBPYmplY3Qua2V5cyhhc3NlcnRUeXBlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFyYXdNb2R1bGVba2V5XSkgeyByZXR1cm4gfVxuXG4gICAgdmFyIGFzc2VydE9wdGlvbnMgPSBhc3NlcnRUeXBlc1trZXldO1xuXG4gICAgZm9yRWFjaFZhbHVlKHJhd01vZHVsZVtrZXldLCBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgYXNzZXJ0T3B0aW9ucy5hc3NlcnQodmFsdWUpLFxuICAgICAgICBtYWtlQXNzZXJ0aW9uTWVzc2FnZShwYXRoLCBrZXksIHR5cGUsIHZhbHVlLCBhc3NlcnRPcHRpb25zLmV4cGVjdGVkKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VBc3NlcnRpb25NZXNzYWdlIChwYXRoLCBrZXksIHR5cGUsIHZhbHVlLCBleHBlY3RlZCkge1xuICB2YXIgYnVmID0ga2V5ICsgXCIgc2hvdWxkIGJlIFwiICsgZXhwZWN0ZWQgKyBcIiBidXQgXFxcIlwiICsga2V5ICsgXCIuXCIgKyB0eXBlICsgXCJcXFwiXCI7XG4gIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICBidWYgKz0gXCIgaW4gbW9kdWxlIFxcXCJcIiArIChwYXRoLmpvaW4oJy4nKSkgKyBcIlxcXCJcIjtcbiAgfVxuICBidWYgKz0gXCIgaXMgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSArIFwiLlwiO1xuICByZXR1cm4gYnVmXG59XG5cbnZhciBWdWU7IC8vIGJpbmQgb24gaW5zdGFsbFxuXG52YXIgU3RvcmUgPSBmdW5jdGlvbiBTdG9yZSAob3B0aW9ucykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgLy8gQXV0byBpbnN0YWxsIGlmIGl0IGlzIG5vdCBkb25lIHlldCBhbmQgYHdpbmRvd2AgaGFzIGBWdWVgLlxuICAvLyBUbyBhbGxvdyB1c2VycyB0byBhdm9pZCBhdXRvLWluc3RhbGxhdGlvbiBpbiBzb21lIGNhc2VzLFxuICAvLyB0aGlzIGNvZGUgc2hvdWxkIGJlIHBsYWNlZCBoZXJlLiBTZWUgIzczMVxuICBpZiAoIVZ1ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgaW5zdGFsbCh3aW5kb3cuVnVlKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KFZ1ZSwgXCJtdXN0IGNhbGwgVnVlLnVzZShWdWV4KSBiZWZvcmUgY3JlYXRpbmcgYSBzdG9yZSBpbnN0YW5jZS5cIik7XG4gICAgYXNzZXJ0KHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJywgXCJ2dWV4IHJlcXVpcmVzIGEgUHJvbWlzZSBwb2x5ZmlsbCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuICAgIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgU3RvcmUsIFwiU3RvcmUgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yLlwiKTtcbiAgfVxuXG4gIHZhciBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zOyBpZiAoIHBsdWdpbnMgPT09IHZvaWQgMCApIHBsdWdpbnMgPSBbXTtcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0OyBpZiAoIHN0cmljdCA9PT0gdm9pZCAwICkgc3RyaWN0ID0gZmFsc2U7XG5cbiAgdmFyIHN0YXRlID0gb3B0aW9ucy5zdGF0ZTsgaWYgKCBzdGF0ZSA9PT0gdm9pZCAwICkgc3RhdGUgPSB7fTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0YXRlID0gc3RhdGUoKSB8fCB7fTtcbiAgfVxuXG4gIC8vIHN0b3JlIGludGVybmFsIHN0YXRlXG4gIHRoaXMuX2NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgdGhpcy5fYWN0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX2FjdGlvblN1YnNjcmliZXJzID0gW107XG4gIHRoaXMuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3dyYXBwZWRHZXR0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fbW9kdWxlcyA9IG5ldyBNb2R1bGVDb2xsZWN0aW9uKG9wdGlvbnMpO1xuICB0aGlzLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcbiAgdGhpcy5fd2F0Y2hlclZNID0gbmV3IFZ1ZSgpO1xuXG4gIC8vIGJpbmQgY29tbWl0IGFuZCBkaXNwYXRjaCB0byBzZWxmXG4gIHZhciBzdG9yZSA9IHRoaXM7XG4gIHZhciByZWYgPSB0aGlzO1xuICB2YXIgZGlzcGF0Y2ggPSByZWYuZGlzcGF0Y2g7XG4gIHZhciBjb21taXQgPSByZWYuY29tbWl0O1xuICB0aGlzLmRpc3BhdGNoID0gZnVuY3Rpb24gYm91bmREaXNwYXRjaCAodHlwZSwgcGF5bG9hZCkge1xuICAgIHJldHVybiBkaXNwYXRjaC5jYWxsKHN0b3JlLCB0eXBlLCBwYXlsb2FkKVxuICB9O1xuICB0aGlzLmNvbW1pdCA9IGZ1bmN0aW9uIGJvdW5kQ29tbWl0ICh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNvbW1pdC5jYWxsKHN0b3JlLCB0eXBlLCBwYXlsb2FkLCBvcHRpb25zKVxuICB9O1xuXG4gIC8vIHN0cmljdCBtb2RlXG4gIHRoaXMuc3RyaWN0ID0gc3RyaWN0O1xuXG4gIC8vIGluaXQgcm9vdCBtb2R1bGUuXG4gIC8vIHRoaXMgYWxzbyByZWN1cnNpdmVseSByZWdpc3RlcnMgYWxsIHN1Yi1tb2R1bGVzXG4gIC8vIGFuZCBjb2xsZWN0cyBhbGwgbW9kdWxlIGdldHRlcnMgaW5zaWRlIHRoaXMuX3dyYXBwZWRHZXR0ZXJzXG4gIGluc3RhbGxNb2R1bGUodGhpcywgc3RhdGUsIFtdLCB0aGlzLl9tb2R1bGVzLnJvb3QpO1xuXG4gIC8vIGluaXRpYWxpemUgdGhlIHN0b3JlIHZtLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHJlYWN0aXZpdHlcbiAgLy8gKGFsc28gcmVnaXN0ZXJzIF93cmFwcGVkR2V0dGVycyBhcyBjb21wdXRlZCBwcm9wZXJ0aWVzKVxuICByZXNldFN0b3JlVk0odGhpcywgc3RhdGUpO1xuXG4gIC8vIGFwcGx5IHBsdWdpbnNcbiAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHsgcmV0dXJuIHBsdWdpbih0aGlzJDEpOyB9KTtcblxuICBpZiAoVnVlLmNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xQbHVnaW4odGhpcyk7XG4gIH1cbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHN0YXRlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5zdGF0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl92bS5fZGF0YS4kJHN0YXRlXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc3RhdGUuc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoZmFsc2UsIFwiVXNlIHN0b3JlLnJlcGxhY2VTdGF0ZSgpIHRvIGV4cGxpY2l0IHJlcGxhY2Ugc3RvcmUgc3RhdGUuXCIpO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gY29tbWl0IChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGNvbW1pdFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG4gICAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcblxuICB2YXIgbXV0YXRpb24gPSB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fbXV0YXRpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIHVua25vd24gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIGVudHJ5LmZvckVhY2goZnVuY3Rpb24gY29tbWl0SXRlcmF0b3IgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIocGF5bG9hZCk7XG4gICAgfSk7XG4gIH0pO1xuICB0aGlzLl9zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1YihtdXRhdGlvbiwgdGhpcyQxLnN0YXRlKTsgfSk7XG5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBvcHRpb25zICYmIG9wdGlvbnMuc2lsZW50XG4gICkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW3Z1ZXhdIG11dGF0aW9uIHR5cGU6IFwiICsgdHlwZSArIFwiLiBTaWxlbnQgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIFwiICtcbiAgICAgICdVc2UgdGhlIGZpbHRlciBmdW5jdGlvbmFsaXR5IGluIHRoZSB2dWUtZGV2dG9vbHMnXG4gICAgKTtcbiAgfVxufTtcblxuU3RvcmUucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2ggKF90eXBlLCBfcGF5bG9hZCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIC8vIGNoZWNrIG9iamVjdC1zdHlsZSBkaXNwYXRjaFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcblxuICB2YXIgYWN0aW9uID0geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkIH07XG4gIHZhciBlbnRyeSA9IHRoaXMuX2FjdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5fYWN0aW9uU3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIoYWN0aW9uLCB0aGlzJDEuc3RhdGUpOyB9KTtcblxuICByZXR1cm4gZW50cnkubGVuZ3RoID4gMVxuICAgID8gUHJvbWlzZS5hbGwoZW50cnkubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKHBheWxvYWQpOyB9KSlcbiAgICA6IGVudHJ5WzBdKHBheWxvYWQpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlIChmbikge1xuICByZXR1cm4gZ2VuZXJpY1N1YnNjcmliZShmbiwgdGhpcy5fc3Vic2NyaWJlcnMpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuc3Vic2NyaWJlQWN0aW9uID0gZnVuY3Rpb24gc3Vic2NyaWJlQWN0aW9uIChmbikge1xuICByZXR1cm4gZ2VuZXJpY1N1YnNjcmliZShmbiwgdGhpcy5fYWN0aW9uU3Vic2NyaWJlcnMpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiB3YXRjaCAoZ2V0dGVyLCBjYiwgb3B0aW9ucykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBnZXR0ZXIgPT09ICdmdW5jdGlvbicsIFwic3RvcmUud2F0Y2ggb25seSBhY2NlcHRzIGEgZnVuY3Rpb24uXCIpO1xuICB9XG4gIHJldHVybiB0aGlzLl93YXRjaGVyVk0uJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldHRlcih0aGlzJDEuc3RhdGUsIHRoaXMkMS5nZXR0ZXJzKTsgfSwgY2IsIG9wdGlvbnMpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gcmVwbGFjZVN0YXRlIChzdGF0ZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS5fdm0uX2RhdGEuJCRzdGF0ZSA9IHN0YXRlO1xuICB9KTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlIChwYXRoLCByYXdNb2R1bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7IHBhdGggPSBbcGF0aF07IH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICAgIGFzc2VydChwYXRoLmxlbmd0aCA+IDAsICdjYW5ub3QgcmVnaXN0ZXIgdGhlIHJvb3QgbW9kdWxlIGJ5IHVzaW5nIHJlZ2lzdGVyTW9kdWxlLicpO1xuICB9XG5cbiAgdGhpcy5fbW9kdWxlcy5yZWdpc3RlcihwYXRoLCByYXdNb2R1bGUpO1xuICBpbnN0YWxsTW9kdWxlKHRoaXMsIHRoaXMuc3RhdGUsIHBhdGgsIHRoaXMuX21vZHVsZXMuZ2V0KHBhdGgpLCBvcHRpb25zLnByZXNlcnZlU3RhdGUpO1xuICAvLyByZXNldCBzdG9yZSB0byB1cGRhdGUgZ2V0dGVycy4uLlxuICByZXNldFN0b3JlVk0odGhpcywgdGhpcy5zdGF0ZSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUudW5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJNb2R1bGUgKHBhdGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7IHBhdGggPSBbcGF0aF07IH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgdGhpcy5fbW9kdWxlcy51bnJlZ2lzdGVyKHBhdGgpO1xuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50U3RhdGUgPSBnZXROZXN0ZWRTdGF0ZSh0aGlzJDEuc3RhdGUsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBWdWUuZGVsZXRlKHBhcmVudFN0YXRlLCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0pO1xuICB9KTtcbiAgcmVzZXRTdG9yZSh0aGlzKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5ob3RVcGRhdGUgPSBmdW5jdGlvbiBob3RVcGRhdGUgKG5ld09wdGlvbnMpIHtcbiAgdGhpcy5fbW9kdWxlcy51cGRhdGUobmV3T3B0aW9ucyk7XG4gIHJlc2V0U3RvcmUodGhpcywgdHJ1ZSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuX3dpdGhDb21taXQgPSBmdW5jdGlvbiBfd2l0aENvbW1pdCAoZm4pIHtcbiAgdmFyIGNvbW1pdHRpbmcgPSB0aGlzLl9jb21taXR0aW5nO1xuICB0aGlzLl9jb21taXR0aW5nID0gdHJ1ZTtcbiAgZm4oKTtcbiAgdGhpcy5fY29tbWl0dGluZyA9IGNvbW1pdHRpbmc7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggU3RvcmUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gZ2VuZXJpY1N1YnNjcmliZSAoZm4sIHN1YnMpIHtcbiAgaWYgKHN1YnMuaW5kZXhPZihmbikgPCAwKSB7XG4gICAgc3Vicy5wdXNoKGZuKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gc3Vicy5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBzdWJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZSAoc3RvcmUsIGhvdCkge1xuICBzdG9yZS5fYWN0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tdXRhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdG9yZS5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBzdGF0ZSA9IHN0b3JlLnN0YXRlO1xuICAvLyBpbml0IGFsbCBtb2R1bGVzXG4gIGluc3RhbGxNb2R1bGUoc3RvcmUsIHN0YXRlLCBbXSwgc3RvcmUuX21vZHVsZXMucm9vdCwgdHJ1ZSk7XG4gIC8vIHJlc2V0IHZtXG4gIHJlc2V0U3RvcmVWTShzdG9yZSwgc3RhdGUsIGhvdCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3RvcmVWTSAoc3RvcmUsIHN0YXRlLCBob3QpIHtcbiAgdmFyIG9sZFZtID0gc3RvcmUuX3ZtO1xuXG4gIC8vIGJpbmQgc3RvcmUgcHVibGljIGdldHRlcnNcbiAgc3RvcmUuZ2V0dGVycyA9IHt9O1xuICB2YXIgd3JhcHBlZEdldHRlcnMgPSBzdG9yZS5fd3JhcHBlZEdldHRlcnM7XG4gIHZhciBjb21wdXRlZCA9IHt9O1xuICBmb3JFYWNoVmFsdWUod3JhcHBlZEdldHRlcnMsIGZ1bmN0aW9uIChmbiwga2V5KSB7XG4gICAgLy8gdXNlIGNvbXB1dGVkIHRvIGxldmVyYWdlIGl0cyBsYXp5LWNhY2hpbmcgbWVjaGFuaXNtXG4gICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuKHN0b3JlKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUuZ2V0dGVycywga2V5LCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLl92bVtrZXldOyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSAvLyBmb3IgbG9jYWwgZ2V0dGVyc1xuICAgIH0pO1xuICB9KTtcblxuICAvLyB1c2UgYSBWdWUgaW5zdGFuY2UgdG8gc3RvcmUgdGhlIHN0YXRlIHRyZWVcbiAgLy8gc3VwcHJlc3Mgd2FybmluZ3MganVzdCBpbiBjYXNlIHRoZSB1c2VyIGhhcyBhZGRlZFxuICAvLyBzb21lIGZ1bmt5IGdsb2JhbCBtaXhpbnNcbiAgdmFyIHNpbGVudCA9IFZ1ZS5jb25maWcuc2lsZW50O1xuICBWdWUuY29uZmlnLnNpbGVudCA9IHRydWU7XG4gIHN0b3JlLl92bSA9IG5ldyBWdWUoe1xuICAgIGRhdGE6IHtcbiAgICAgICQkc3RhdGU6IHN0YXRlXG4gICAgfSxcbiAgICBjb21wdXRlZDogY29tcHV0ZWRcbiAgfSk7XG4gIFZ1ZS5jb25maWcuc2lsZW50ID0gc2lsZW50O1xuXG4gIC8vIGVuYWJsZSBzdHJpY3QgbW9kZSBmb3IgbmV3IHZtXG4gIGlmIChzdG9yZS5zdHJpY3QpIHtcbiAgICBlbmFibGVTdHJpY3RNb2RlKHN0b3JlKTtcbiAgfVxuXG4gIGlmIChvbGRWbSkge1xuICAgIGlmIChob3QpIHtcbiAgICAgIC8vIGRpc3BhdGNoIGNoYW5nZXMgaW4gYWxsIHN1YnNjcmliZWQgd2F0Y2hlcnNcbiAgICAgIC8vIHRvIGZvcmNlIGdldHRlciByZS1ldmFsdWF0aW9uIGZvciBob3QgcmVsb2FkaW5nLlxuICAgICAgc3RvcmUuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBvbGRWbS5fZGF0YS4kJHN0YXRlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBWdWUubmV4dFRpY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gb2xkVm0uJGRlc3Ryb3koKTsgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbE1vZHVsZSAoc3RvcmUsIHJvb3RTdGF0ZSwgcGF0aCwgbW9kdWxlLCBob3QpIHtcbiAgdmFyIGlzUm9vdCA9ICFwYXRoLmxlbmd0aDtcbiAgdmFyIG5hbWVzcGFjZSA9IHN0b3JlLl9tb2R1bGVzLmdldE5hbWVzcGFjZShwYXRoKTtcblxuICAvLyByZWdpc3RlciBpbiBuYW1lc3BhY2UgbWFwXG4gIGlmIChtb2R1bGUubmFtZXNwYWNlZCkge1xuICAgIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV0gPSBtb2R1bGU7XG4gIH1cblxuICAvLyBzZXQgc3RhdGVcbiAgaWYgKCFpc1Jvb3QgJiYgIWhvdCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHJvb3RTdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIHZhciBtb2R1bGVOYW1lID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHN0b3JlLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgIFZ1ZS5zZXQocGFyZW50U3RhdGUsIG1vZHVsZU5hbWUsIG1vZHVsZS5zdGF0ZSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbG9jYWwgPSBtb2R1bGUuY29udGV4dCA9IG1ha2VMb2NhbENvbnRleHQoc3RvcmUsIG5hbWVzcGFjZSwgcGF0aCk7XG5cbiAgbW9kdWxlLmZvckVhY2hNdXRhdGlvbihmdW5jdGlvbiAobXV0YXRpb24sIGtleSkge1xuICAgIHZhciBuYW1lc3BhY2VkVHlwZSA9IG5hbWVzcGFjZSArIGtleTtcbiAgICByZWdpc3Rlck11dGF0aW9uKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgbXV0YXRpb24sIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hBY3Rpb24oZnVuY3Rpb24gKGFjdGlvbiwga2V5KSB7XG4gICAgdmFyIHR5cGUgPSBhY3Rpb24ucm9vdCA/IGtleSA6IG5hbWVzcGFjZSArIGtleTtcbiAgICB2YXIgaGFuZGxlciA9IGFjdGlvbi5oYW5kbGVyIHx8IGFjdGlvbjtcbiAgICByZWdpc3RlckFjdGlvbihzdG9yZSwgdHlwZSwgaGFuZGxlciwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEdldHRlcihmdW5jdGlvbiAoZ2V0dGVyLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJHZXR0ZXIoc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBnZXR0ZXIsIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGtleSkge1xuICAgIGluc3RhbGxNb2R1bGUoc3RvcmUsIHJvb3RTdGF0ZSwgcGF0aC5jb25jYXQoa2V5KSwgY2hpbGQsIGhvdCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIG1ha2UgbG9jYWxpemVkIGRpc3BhdGNoLCBjb21taXQsIGdldHRlcnMgYW5kIHN0YXRlXG4gKiBpZiB0aGVyZSBpcyBubyBuYW1lc3BhY2UsIGp1c3QgdXNlIHJvb3Qgb25lc1xuICovXG5mdW5jdGlvbiBtYWtlTG9jYWxDb250ZXh0IChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKSB7XG4gIHZhciBub05hbWVzcGFjZSA9IG5hbWVzcGFjZSA9PT0gJyc7XG5cbiAgdmFyIGxvY2FsID0ge1xuICAgIGRpc3BhdGNoOiBub05hbWVzcGFjZSA/IHN0b3JlLmRpc3BhdGNoIDogZnVuY3Rpb24gKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICAgIHZhciBwYXlsb2FkID0gYXJncy5wYXlsb2FkO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnM7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3MudHlwZTtcblxuICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnJvb3QpIHtcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZSArIHR5cGU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdG9yZS5fYWN0aW9uc1t0eXBlXSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIHVua25vd24gbG9jYWwgYWN0aW9uIHR5cGU6IFwiICsgKGFyZ3MudHlwZSkgKyBcIiwgZ2xvYmFsIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCh0eXBlLCBwYXlsb2FkKVxuICAgIH0sXG5cbiAgICBjb21taXQ6IG5vTmFtZXNwYWNlID8gc3RvcmUuY29tbWl0IDogZnVuY3Rpb24gKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICAgIHZhciBwYXlsb2FkID0gYXJncy5wYXlsb2FkO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnM7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3MudHlwZTtcblxuICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnJvb3QpIHtcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZSArIHR5cGU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdG9yZS5fbXV0YXRpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBtdXRhdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9yZS5jb21taXQodHlwZSwgcGF5bG9hZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGdldHRlcnMgYW5kIHN0YXRlIG9iamVjdCBtdXN0IGJlIGdvdHRlbiBsYXppbHlcbiAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgY2hhbmdlZCBieSB2bSB1cGRhdGVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobG9jYWwsIHtcbiAgICBnZXR0ZXJzOiB7XG4gICAgICBnZXQ6IG5vTmFtZXNwYWNlXG4gICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyczsgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VMb2NhbEdldHRlcnMoc3RvcmUsIG5hbWVzcGFjZSk7IH1cbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldE5lc3RlZFN0YXRlKHN0b3JlLnN0YXRlLCBwYXRoKTsgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxvY2FsXG59XG5cbmZ1bmN0aW9uIG1ha2VMb2NhbEdldHRlcnMgKHN0b3JlLCBuYW1lc3BhY2UpIHtcbiAgdmFyIGdldHRlcnNQcm94eSA9IHt9O1xuXG4gIHZhciBzcGxpdFBvcyA9IG5hbWVzcGFjZS5sZW5ndGg7XG4gIE9iamVjdC5rZXlzKHN0b3JlLmdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvLyBza2lwIGlmIHRoZSB0YXJnZXQgZ2V0dGVyIGlzIG5vdCBtYXRjaCB0aGlzIG5hbWVzcGFjZVxuICAgIGlmICh0eXBlLnNsaWNlKDAsIHNwbGl0UG9zKSAhPT0gbmFtZXNwYWNlKSB7IHJldHVybiB9XG5cbiAgICAvLyBleHRyYWN0IGxvY2FsIGdldHRlciB0eXBlXG4gICAgdmFyIGxvY2FsVHlwZSA9IHR5cGUuc2xpY2Uoc3BsaXRQb3MpO1xuXG4gICAgLy8gQWRkIGEgcG9ydCB0byB0aGUgZ2V0dGVycyBwcm94eS5cbiAgICAvLyBEZWZpbmUgYXMgZ2V0dGVyIHByb3BlcnR5IGJlY2F1c2VcbiAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBldmFsdWF0ZSB0aGUgZ2V0dGVycyBpbiB0aGlzIHRpbWUuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldHRlcnNQcm94eSwgbG9jYWxUeXBlLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLmdldHRlcnNbdHlwZV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBnZXR0ZXJzUHJveHlcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gfHwgKHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZE11dGF0aW9uSGFuZGxlciAocGF5bG9hZCkge1xuICAgIGhhbmRsZXIuY2FsbChzdG9yZSwgbG9jYWwuc3RhdGUsIHBheWxvYWQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJBY3Rpb24gKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCkge1xuICB2YXIgZW50cnkgPSBzdG9yZS5fYWN0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX2FjdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZEFjdGlvbkhhbmRsZXIgKHBheWxvYWQsIGNiKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuY2FsbChzdG9yZSwge1xuICAgICAgZGlzcGF0Y2g6IGxvY2FsLmRpc3BhdGNoLFxuICAgICAgY29tbWl0OiBsb2NhbC5jb21taXQsXG4gICAgICBnZXR0ZXJzOiBsb2NhbC5nZXR0ZXJzLFxuICAgICAgc3RhdGU6IGxvY2FsLnN0YXRlLFxuICAgICAgcm9vdEdldHRlcnM6IHN0b3JlLmdldHRlcnMsXG4gICAgICByb290U3RhdGU6IHN0b3JlLnN0YXRlXG4gICAgfSwgcGF5bG9hZCwgY2IpO1xuICAgIGlmICghaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcyA9IFByb21pc2UucmVzb2x2ZShyZXMpO1xuICAgIH1cbiAgICBpZiAoc3RvcmUuX2RldnRvb2xIb29rKSB7XG4gICAgICByZXR1cm4gcmVzLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc3RvcmUuX2RldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6ZXJyb3InLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckdldHRlciAoc3RvcmUsIHR5cGUsIHJhd0dldHRlciwgbG9jYWwpIHtcbiAgaWYgKHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSBkdXBsaWNhdGUgZ2V0dGVyIGtleTogXCIgKyB0eXBlKSk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSA9IGZ1bmN0aW9uIHdyYXBwZWRHZXR0ZXIgKHN0b3JlKSB7XG4gICAgcmV0dXJuIHJhd0dldHRlcihcbiAgICAgIGxvY2FsLnN0YXRlLCAvLyBsb2NhbCBzdGF0ZVxuICAgICAgbG9jYWwuZ2V0dGVycywgLy8gbG9jYWwgZ2V0dGVyc1xuICAgICAgc3RvcmUuc3RhdGUsIC8vIHJvb3Qgc3RhdGVcbiAgICAgIHN0b3JlLmdldHRlcnMgLy8gcm9vdCBnZXR0ZXJzXG4gICAgKVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmFibGVTdHJpY3RNb2RlIChzdG9yZSkge1xuICBzdG9yZS5fdm0uJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEuJCRzdGF0ZSB9LCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChzdG9yZS5fY29tbWl0dGluZywgXCJEbyBub3QgbXV0YXRlIHZ1ZXggc3RvcmUgc3RhdGUgb3V0c2lkZSBtdXRhdGlvbiBoYW5kbGVycy5cIik7XG4gICAgfVxuICB9LCB7IGRlZXA6IHRydWUsIHN5bmM6IHRydWUgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE5lc3RlZFN0YXRlIChzdGF0ZSwgcGF0aCkge1xuICByZXR1cm4gcGF0aC5sZW5ndGhcbiAgICA/IHBhdGgucmVkdWNlKGZ1bmN0aW9uIChzdGF0ZSwga2V5KSB7IHJldHVybiBzdGF0ZVtrZXldOyB9LCBzdGF0ZSlcbiAgICA6IHN0YXRlXG59XG5cbmZ1bmN0aW9uIHVuaWZ5T2JqZWN0U3R5bGUgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgaWYgKGlzT2JqZWN0KHR5cGUpICYmIHR5cGUudHlwZSkge1xuICAgIG9wdGlvbnMgPSBwYXlsb2FkO1xuICAgIHBheWxvYWQgPSB0eXBlO1xuICAgIHR5cGUgPSB0eXBlLnR5cGU7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycsIChcIkV4cGVjdHMgc3RyaW5nIGFzIHRoZSB0eXBlLCBidXQgZm91bmQgXCIgKyAodHlwZW9mIHR5cGUpICsgXCIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQsIG9wdGlvbnM6IG9wdGlvbnMgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsIChfVnVlKSB7XG4gIGlmIChWdWUgJiYgX1Z1ZSA9PT0gVnVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgVnVlID0gX1Z1ZTtcbiAgYXBwbHlNaXhpbihWdWUpO1xufVxuXG52YXIgbWFwU3RhdGUgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgc3RhdGVzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKHN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZFN0YXRlICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHN0b3JlLnN0YXRlO1xuICAgICAgdmFyIGdldHRlcnMgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBTdGF0ZScsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBtb2R1bGUuY29udGV4dC5zdGF0ZTtcbiAgICAgICAgZ2V0dGVycyA9IG1vZHVsZS5jb250ZXh0LmdldHRlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5jYWxsKHRoaXMsIHN0YXRlLCBnZXR0ZXJzKVxuICAgICAgICA6IHN0YXRlW3ZhbF1cbiAgICB9O1xuICAgIC8vIG1hcmsgdnVleCBnZXR0ZXIgZm9yIGRldnRvb2xzXG4gICAgcmVzW2tleV0udnVleCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIG1hcE11dGF0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBtdXRhdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAobXV0YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkTXV0YXRpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIHZhciBjb21taXQgPSB0aGlzLiRzdG9yZS5jb21taXQ7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcE11dGF0aW9ucycsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29tbWl0ID0gbW9kdWxlLmNvbnRleHQuY29tbWl0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB2YWwuYXBwbHkodGhpcywgW2NvbW1pdF0uY29uY2F0KGFyZ3MpKVxuICAgICAgICA6IGNvbW1pdC5hcHBseSh0aGlzLiRzdG9yZSwgW3ZhbF0uY29uY2F0KGFyZ3MpKVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIG1hcEdldHRlcnMgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgZ2V0dGVycykge1xuICB2YXIgcmVzID0ge307XG4gIG5vcm1hbGl6ZU1hcChnZXR0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHZhbCA9IG5hbWVzcGFjZSArIHZhbDtcbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZEdldHRlciAoKSB7XG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEdldHRlcnMnLCBuYW1lc3BhY2UpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgISh2YWwgaW4gdGhpcy4kc3RvcmUuZ2V0dGVycykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBnZXR0ZXI6IFwiICsgdmFsKSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwQWN0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBhY3Rpb25zKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRBY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIHZhciBkaXNwYXRjaCA9IHRoaXMuJHN0b3JlLmRpc3BhdGNoO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBBY3Rpb25zJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCA9IG1vZHVsZS5jb250ZXh0LmRpc3BhdGNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB2YWwuYXBwbHkodGhpcywgW2Rpc3BhdGNoXS5jb25jYXQoYXJncykpXG4gICAgICAgIDogZGlzcGF0Y2guYXBwbHkodGhpcy4kc3RvcmUsIFt2YWxdLmNvbmNhdChhcmdzKSlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbnZhciBjcmVhdGVOYW1lc3BhY2VkSGVscGVycyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UpIHsgcmV0dXJuICh7XG4gIG1hcFN0YXRlOiBtYXBTdGF0ZS5iaW5kKG51bGwsIG5hbWVzcGFjZSksXG4gIG1hcEdldHRlcnM6IG1hcEdldHRlcnMuYmluZChudWxsLCBuYW1lc3BhY2UpLFxuICBtYXBNdXRhdGlvbnM6IG1hcE11dGF0aW9ucy5iaW5kKG51bGwsIG5hbWVzcGFjZSksXG4gIG1hcEFjdGlvbnM6IG1hcEFjdGlvbnMuYmluZChudWxsLCBuYW1lc3BhY2UpXG59KTsgfTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTWFwIChtYXApIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWFwKVxuICAgID8gbWFwLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoeyBrZXk6IGtleSwgdmFsOiBrZXkgfSk7IH0pXG4gICAgOiBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoeyBrZXk6IGtleSwgdmFsOiBtYXBba2V5XSB9KTsgfSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZXNwYWNlIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWFwKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICBtYXAgPSBuYW1lc3BhY2U7XG4gICAgICBuYW1lc3BhY2UgPSAnJztcbiAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZS5jaGFyQXQobmFtZXNwYWNlLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgIG5hbWVzcGFjZSArPSAnLyc7XG4gICAgfVxuICAgIHJldHVybiBmbihuYW1lc3BhY2UsIG1hcClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNb2R1bGVCeU5hbWVzcGFjZSAoc3RvcmUsIGhlbHBlciwgbmFtZXNwYWNlKSB7XG4gIHZhciBtb2R1bGUgPSBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcFtuYW1lc3BhY2VdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhbW9kdWxlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gbW9kdWxlIG5hbWVzcGFjZSBub3QgZm91bmQgaW4gXCIgKyBoZWxwZXIgKyBcIigpOiBcIiArIG5hbWVzcGFjZSkpO1xuICB9XG4gIHJldHVybiBtb2R1bGVcbn1cblxudmFyIGluZGV4ID0ge1xuICBTdG9yZTogU3RvcmUsXG4gIGluc3RhbGw6IGluc3RhbGwsXG4gIHZlcnNpb246ICczLjAuMScsXG4gIG1hcFN0YXRlOiBtYXBTdGF0ZSxcbiAgbWFwTXV0YXRpb25zOiBtYXBNdXRhdGlvbnMsXG4gIG1hcEdldHRlcnM6IG1hcEdldHRlcnMsXG4gIG1hcEFjdGlvbnM6IG1hcEFjdGlvbnMsXG4gIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzOiBjcmVhdGVOYW1lc3BhY2VkSGVscGVyc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbmRleDtcbiIsIjx0ZW1wbGF0ZT5cblxuICA8ZGl2IGNsYXNzPVwibmF2YmFyLWJyYW5kXCIgOnRpdGxlPVwiYnJhbmRcIj5cblxuICAgICAgPCEtLSA8YSBocmVmPVwiL1wiIGNsYXNzPVwibmF2YmFyLWl0ZW1cIj5cbiAgICAgICAgPGltZyBpZD1cIm5hdmJhci1sb2dvXCIgOnNyYz1cImxvZ29cIiA6YWx0PVwiJ0xvZ28gJysgYnJhbmRcIj5cbiAgICAgIDwvYT4gLS0+XG5cbiAgICAgIDxyb3V0ZXItbGluayBcdFxuICAgICAgICBpZD1cImxvZ29faG9tZVwiXG4gICAgICAgIGNsYXNzPVwibmF2YmFyLWl0ZW1cIiBcbiAgICAgICAgOnRvPVwibG9nb1RvXCI+XG4gICAgICAgIDxpbWcgXG4gICAgICAgICAgICBpZD1cIm5hdmJhci1sb2dvXCIgXG4gICAgICAgICAgICA6c3JjPVwidGhpcy5sb2dvLnVybFwiXG4gICAgICAgICAgICA6YWx0PVwiJ0xvZ28gJyArIGJyYW5kXCJcbiAgICAgICAgPjwvaW1nPlxuICAgICAgPC9yb3V0ZXItbGluaz5cblxuICAgICAgPCEtLSBjZiA6IGh0dHBzOi8vanNmaWRkbGUubmV0L3Rib256LzgwamtxMExzLyAtLT5cbiAgICAgICAgPCEtLSBjbGFzcz1cIm5hdmJhci1idXJnZXJcIiAgLS0+XG4gICAgICA8ZGl2IFxuICAgICAgICA6Y2xhc3M9XCJgbmF2YmFyLWJ1cmdlciAkeyBzaG93TmF2ID8gJ2lzLWFjdGl2ZScgOiAnJyB9YFwiXG4gICAgICAgIEBjbGljaz1cInRyaWdnZXJCdXJnZXIoKVwiIFxuICAgICAgICBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIiBcbiAgICAgICAgZGF0YS10YXJnZXQ9XCJuYXZiYXItbWFpblwiXG4gICAgICAgID5cbiAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgICAgICA8c3Bhbj48L3NwYW4+XG4gICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiBbXG4gICAgJ2xvZ28nLFxuICAgICdsb2dvVG8nLCBcbiAgICAnYnJhbmQnXG4gIF0sXG4gIGNvbXB1dGVkOiB7XG4gICAgc2hvd05hdigpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldE5hdmJhclZpc2liaWxpdHlcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHMgOiB7XG4gICAgdHJpZ2dlckJ1cmdlcigpe1xuICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KCdzd2l0Y2hOYXZiYXJNZW51JylcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IDpjbGFzcz1cImBjb3VudC1hbmQtdGFicyAkeyB2aWV3ID09IFZJRVdfTUFQID8gJ2lzLW1hcCcgOiAnaXMtbm90LW1hcCd9YFwiPlxuXG4gICAgPGRpdiA6Y2xhc3M9XCJbJ3Jlc3VsdC1jb3VudC1wYXJlbnQnLCBvcGVuID8gJ29wZW4nIDogdW5kZWZpbmVkXVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInJlc3VsdHMtY291bnRcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJuYlwiPlxuICAgICAgICAgIHt7IHBlbmRpbmcgPyAnPycgOiB0b3RhbCB9fVxuICAgICAgICA8L3NwYW4+IFxuICAgICAgICA8c3Bhbj5cbiAgICAgICAgICB7eyB0cmFuc2xhdGVCaXMoZW5kcG9pbnRDb25maWdGaWx0ZXJzLCAnaXRlbXNfZm91bmQnICl9fVxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxzbG90IG5hbWU9XCJwcm9qZWN0XCIvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImJ1dHRvbnMgaGFzLWFkZG9ucyBpcy1yaWdodFwiPlxuXG4gICAgICA8cm91dGVyLWxpbmsgXG4gICAgICAgIHYtaWY9XCJ0eXBlb2YgZW5kcG9pbnRDb25maWdMaXN0ICE9PSAndW5kZWZpbmVkJ1wiXG4gICAgICAgIDpkaXNhYmxlZD1cImVuZHBvaW50Q29uZmlnTGlzdC5pc19kaXNhYmxlZFwiIFxuICAgICAgICA6dG89XCJlbmRwb2ludENvbmZpZ1VybFRvTGlzdC51cmxzWzBdXCIgXG4gICAgICAgIDpjbGFzcz1cIlsnYnV0dG9uJywgdmlldyA9PT0gVklFV19MSVNUID8gJ2lzLXNlbGVjdGVkIGlzLXByaW1hcnknIDogdW5kZWZpbmVkXVwiIFxuICAgICAgICA+XG4gICAgICAgIDxpbWcgOnNyYz1cImAvc3RhdGljL2ljb25zLyR7dmlldyA9PT0gVklFV19MSVNUID8gJ2ljb25fbGlzdF9ibGFuYy5zdmcnOiAnaWNvbl9saXN0LnN2Zyd9YFwiPlxuICAgICAgICA8IS0tIDxzcGFuPmxpc3RlPC9zcGFuPiAtLT5cbiAgICAgICAgPHNwYW4+e3sgdHJhbnNsYXRlKGNvbmZpZ1RhYnMoJ3RhYl9saXN0JykpIH19PC9zcGFuPlxuICAgICAgPC9yb3V0ZXItbGluaz5cblxuICAgICAgPHJvdXRlci1saW5rXG4gICAgICAgIHYtaWY9XCJ0eXBlb2YgZW5kcG9pbnRDb25maWdNYXAgIT09ICd1bmRlZmluZWQnXCJcbiAgICAgICAgOmRpc2FibGVkPVwiZW5kcG9pbnRDb25maWdNYXAuaXNfZGlzYWJsZWRcIiBcbiAgICAgICAgOnRvPVwiZW5kcG9pbnRDb25maWdVcmxUb01hcC51cmxzWzBdXCIgXG4gICAgICAgIDpjbGFzcz1cIlsnYnV0dG9uJywgdmlldyA9PT0gVklFV19NQVAgPyAnaXMtc2VsZWN0ZWQgaXMtcHJpbWFyeScgOiB1bmRlZmluZWRdXCIgXG4gICAgICAgID5cbiAgICAgICAgPGltZyA6c3JjPVwiYC9zdGF0aWMvaWNvbnMvJHt2aWV3ID09PSBWSUVXX01BUCA/ICdpY29uX21hcF9ibGFuYy5zdmcnOiAnaWNvbl9tYXAuc3ZnJ31gXCI+XG4gICAgICAgIDwhLS0gPHNwYW4+Y2FydGU8L3NwYW4+IC0tPlxuICAgICAgICA8c3Bhbj57eyB0cmFuc2xhdGUoY29uZmlnVGFicygndGFiX21hcCcpKSB9fTwvc3Bhbj5cbiAgICAgIDwvcm91dGVyLWxpbms+XG5cbiAgICAgIDwhLS0gPHJvdXRlci1saW5rXG4gICAgICAgIHYtaWY9XCJ0eXBlb2YgZW5kcG9pbnRDb25maWdVcmxUb1N0YXQgIT09ICd1bmRlZmluZWQnXCJcbiAgICAgICAgOmRpc2FibGVkPVwiZW5kcG9pbnRDb25maWdTdGF0LmlzX2Rpc2FibGVkXCIgXG4gICAgICAgIDp0bz1cImVuZHBvaW50Q29uZmlnVXJsVG9TdGF0LnVybHNbMF1cIiBcbiAgICAgICAgOmNsYXNzPVwiWydidXR0b24nLCB2aWV3ID09PSBWSUVXX01BUCA/ICdpcy1zZWxlY3RlZCBpcy1wcmltYXJ5JyA6IHVuZGVmaW5lZF1cIiBcbiAgICAgICAgPlxuICAgICAgICA8aW1nIHNyYz1cIi9zdGF0aWMvaWNvbnMvaWNvbl9kYXRhdml6LnN2Z1wiPlxuICAgICAgICA8c3Bhbj57eyB0cmFuc2xhdGUoY29uZmlnVGFicygndGFiX3N0YXQnKSkgfX08L3NwYW4+XG4gICAgICA8L3JvdXRlci1saW5rPiAtLT5cblxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge21hcFN0YXRlfSBmcm9tICd2dWV4J1xuXG5pbXBvcnQge1ZJRVdfTElTVCwgVklFV19NQVAsIFZJRVdfU1RBVH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgbmFtZTogJ0NJU1NlYXJjaFJlc3VsdHNDb3VudEFuZFRhYnMnLFxuICAgIFxuICAgIHByb3BzOiBbXG4gICAgICAndmlldycsIFxuICAgICAgJ29wZW4nXG4gICAgXSxcblxuICAgIGRhdGEoKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFZJRVdfTUFQLCBcbiAgICAgICAgVklFV19MSVNULFxuICAgICAgICBWSUVXX1NUQVRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIC4uLm1hcFN0YXRlKHtcbiAgICAgICAgcGVuZGluZzogKHtzZWFyY2h9KSA9PiAhIXNlYXJjaC5hbnN3ZXIucGVuZGluZ0Fib3J0LFxuICAgICAgICB0b3RhbDogKHtzZWFyY2h9KSA9PiBzZWFyY2guYW5zd2VyLnJlc3VsdCAmJiBzZWFyY2guYW5zd2VyLnJlc3VsdC50b3RhbFxuICAgICAgfSksXG5cbiAgICAgIC8vIENPTkZJRyBFTkRQT0lOVFNcbiAgICAgIGVuZHBvaW50Q29uZmlnRmlsdGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0RW5kcG9pbnRDb25maWdGaWx0ZXJzXG4gICAgICB9LFxuICAgICAgZW5kcG9pbnRDb25maWdMaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRFbmRwb2ludENvbmZpZ0xpc3RcbiAgICAgIH0sXG4gICAgICBlbmRwb2ludENvbmZpZ01hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0RW5kcG9pbnRDb25maWdNYXBcbiAgICAgIH0sXG4gICAgICBlbmRwb2ludENvbmZpZ0RldGFpbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0RW5kcG9pbnRDb25maWdEZXRhaWxcbiAgICAgIH0sXG4gICAgICBlbmRwb2ludENvbmZpZ1N0YXQoKSB7XG4gICAgICAgIGxldCBlbmRwb2ludFN0YXQgPSAgdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRFbmRwb2ludENvbmZpZ1N0YXRcbiAgICAgICAgY29uc29sZS5sb2coXCJlbmRwb2ludFN0YXQgOiBcIiwgZW5kcG9pbnRTdGF0KVxuICAgICAgICByZXR1cm4gZW5kcG9pbnRTdGF0XG4gICAgICB9LFxuXG4gICAgICAvLyBDT05GSUcgUk9VVEVTXG4gICAgICBlbmRwb2ludENvbmZpZ1VybFRvTGlzdCgpIHtcbiAgICAgICAgbGV0IHJvdXRlQ29uZmlnID0gIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0Um91dGVDb25maWdMaXN0Rm9yRGF0YXNldFxuICAgICAgICByZXR1cm4gcm91dGVDb25maWdcbiAgICAgIH0sXG4gICAgICBlbmRwb2ludENvbmZpZ1VybFRvTWFwKCkge1xuICAgICAgICBsZXQgcm91dGVDb25maWcgPSAgdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRSb3V0ZUNvbmZpZ01hcEZvckRhdGFzZXRcbiAgICAgICAgcmV0dXJuIHJvdXRlQ29uZmlnXG4gICAgICB9LFxuICAgICAgLy8gZW5kcG9pbnRDb25maWdVcmxUb1N0YXQoKSB7XG4gICAgICAvLyAgIGxldCByb3V0ZUNvbmZpZyA9IHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0Um91dGVDb25maWdTdGF0Rm9yRGF0YXNldFxuICAgICAgLy8gICBjb25zb2xlLmxvZyhcInJvdXRlQ29uZmlnIDogXCIsIHJvdXRlQ29uZmlnKVxuICAgICAgLy8gICByZXR1cm4gcm91dGVDb25maWdcbiAgICAgIC8vIH1cbiAgICB9LFxuXG4gICAgbWV0aG9kcyA6IHtcbiAgICAgIGNvbmZpZ1RhYnModGFiRmllbGQpIHtcbiAgICAgICAgbGV0IHRhYnNDb25mID0gdGhpcy4kc3RvcmUuc3RhdGUuY29uZmlnLmdsb2JhbC5hcHBfc2NyZWVuX3RhYnNcbiAgICAgICAgcmV0dXJuIHRhYnNDb25mW3RhYkZpZWxkXVxuICAgICAgfSxcbiAgICAgIHRyYW5zbGF0ZSggdGV4dHNUb1RyYW5zbGF0ZSApIHtcbiAgICAgICAgbGV0IGxpc3RUZXh0cyA9IHRleHRzVG9UcmFuc2xhdGUubGlua190ZXh0XG4gICAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldFRyYW5zbGF0aW9uKHsgdGV4dHMgOiBsaXN0VGV4dHMgfSlcbiAgICAgIH0sXG4gICAgICB0cmFuc2xhdGVCaXMoIHRleHRzVG9UcmFuc2xhdGUsIGxpc3RGaWVsZCApIHtcbiAgICAgICAgbGV0IGxpc3RUZXh0cyA9IHRleHRzVG9UcmFuc2xhdGVbbGlzdEZpZWxkXVxuICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRUcmFuc2xhdGlvbih7IHRleHRzIDogbGlzdFRleHRzIH0pXG4gICAgICB9XG4gICAgfVxuXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuXG5AaW1wb3J0ICcuLi8uLi9zdHlsZXMvYXBpdml6LWNvbG9ycy5zY3NzJztcblxuLmNvdW50LWFuZC10YWJze1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuXG4gIG1hcmdpbi1ib3R0b206IDFlbTtcblxuICAucmVzdWx0LWNvdW50LXBhcmVudHtcbiAgICBwYWRkaW5nLXRvcDogMXJlbTtcbiAgICBwYWRkaW5nOiAwIDFlbTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgbGVmdDogLTFlbTsgLyogVE9ETyBTQVNTIDogc2FtZSBhYnNvbHV0ZSB2YWx1ZSBhcyBwYWRkaW5nIGFib3ZlKi9cbiAgICBtYXgtd2lkdGg6IDIwZW07XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblxuICAgICYub3BlbntcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICRhcGl2aXotZ3JleS1iYWNrZ3JvdW5kO1xuICAgICAgXG4gICAgICB0b3A6IC0xcmVtO1xuICAgICAgcGFkZGluZy10b3A6IDFyZW07XG4gICAgfVxuXG4gICAgLnJlc3VsdHMtY291bnR7XG4gICAgICBwYWRkaW5nOiAwLjVlbSAxZW07XG5cbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgICAgZm9udC1zaXplOiAxLjJlbTtcblxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAubmJ7XG4gICAgICAgICAgY29sb3I6ICRhcGl2aXotcHJpbWFyeTtcbiAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgIG1hcmdpbi1yaWdodDogMC41ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLmJ1dHRvbnN7XG4gICAgJiA+ICp7XG4gICAgICB3aWR0aDogN2VtO1xuICAgICAganVzdGlmeS1jb250ZW50OiBsZWZ0O1xuXG4gICAgICBpbWd7XG4gICAgICAgICAgbWF4LWhlaWdodDogMS41ZW07XG4gICAgICB9XG5cbiAgICAgIHNwYW57XG4gICAgICAgICAgbWFyZ2luLWxlZnQ6IDAuMmVtO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cbn1cblxuXG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgbWFwU3RhdGUsIG1hcEFjdGlvbnMgfSBmcm9tICd2dWV4J1xuaW1wb3J0IHsgTCwgTEljb24gfSBmcm9tICd2dWUyLWxlYWZsZXQnO1xuaW1wb3J0IHsgUHJ1bmVDbHVzdGVyLCBQcnVuZUNsdXN0ZXJGb3JMZWFmbGV0IH0gZnJvbSAnLi4vdXRpbHNQcnVuZUNsdXN0ZXIuanMnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJDdXN0b21NYXJrZXJzXCIsXG4gIHByb3BzOiBbXG4gICAgJ3JvdXRlQ29uZmlnJyxcbiAgICAnZW5kUG9pbnRDb25maWcnLFxuICAgICdpdGVtc0Zvck1hcCcsXG4gICAgJ21hcE9iamVjdCcsXG4gICAgJ2NoZWNrSWZTdHJpbmdGbG9hdCcsXG4gICAgJ2NvbnRlbnRGaWVsZHMnLFxuICAgICdoaWdobGlnaHRlZEl0ZW0nXG4gIF0sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbXNPbk1hcCA6IFtdLFxuICAgICAgcHJ1bmVDbHVzdGVyOiB1bmRlZmluZWQsXG5cbiAgICAgIGljb25TaXplTm9ybWFsIDogWzI5LCAyOV0sXG4gICAgICBpY29uU2l6ZUhpZ2hsaWdodGVkIDogWzQ5LCA0OV0sXG5cbiAgICAgIC8vIHRlc3RQcm9wIDogXCJ0aGlzIGlzIHRoZSB0ZXN0IHByb3BcIixcblxuICAgIH07XG4gIH0sXG4gIG1vdW50ZWQoKXtcbiAgICBjb25zb2xlLmxvZyhcIiAtIC0gQ3VzdG9tTWFya2VycyAvIG1vdW50ZWQuLi4gXCIpXG4gICAgdGhpcy5pdGVtc09uTWFwID0gdGhpcy5wcm9qZWN0c1xuICAgIHRoaXMucHJ1bmVDbHVzdGVyID0gbmV3IFBydW5lQ2x1c3RlckZvckxlYWZsZXQoKTtcblxuICAgIGNvbnN0IGljb25Ob3JtYWxTaXplID0gdGhpcy5pY29uU2l6ZU5vcm1hbFxuICAgIGNvbnN0IGljb25CaWdTaXplID0gdGhpcy5pY29uU2l6ZUhpZ2hsaWdodGVkXG5cbiAgICBjb25zdCBlbWl0RGF0YUZ1bmN0aW9uID0gdGhpcy5lbWl0SXRlbVxuICAgIGNvbnN0IEljb25TaXplID0gdGhpcy5nZXRJY29uU2l6ZVxuXG4gICAgY29uc3Qgc21hbGxJY29uID0gTC5pY29uKHtcbiAgICAgIGljb25Vcmw6ICcvc3RhdGljL2ljb25zL2ljb25fcGluX3BsZWluX3Zpb2xldC5zdmcnLFxuICAgICAgaWNvblNpemU6IGljb25Ob3JtYWxTaXplLFxuICAgIH0pXG5cbiAgICBjb25zdCBiaWdJY29uID0gTC5pY29uKHtcbiAgICAgIGljb25Vcmw6ICcvc3RhdGljL2ljb25zL2ljb25fcGluX3BsZWluX3Zpb2xldC5zdmcnLFxuICAgICAgaWNvblNpemU6IGljb25CaWdTaXplLFxuICAgIH0pXG5cbiAgICAvLyB3ZSBjb25maWd1cmUgdGhlIG9uQ2xpY2sgb3B0aW9uXG4gICAgdGhpcy5wcnVuZUNsdXN0ZXIuUHJlcGFyZUxlYWZsZXRNYXJrZXIgPSBmdW5jdGlvbihsZWFmbGV0TWFya2VyLCBkYXRhKSB7XG5cbiAgICAgIGxlYWZsZXRNYXJrZXIuc2V0SWNvbiggc21hbGxJY29uICk7XG5cbiAgICAgIGxlYWZsZXRNYXJrZXIub24oJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiUHJlcGFyZUxlYWZsZXRNYXJrZXIgLyBkYXRhIDogXCIsIGRhdGEpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlByZXBhcmVMZWFmbGV0TWFya2VyIC8gdGhpcyA6IFwiLCB0aGlzKTtcbiAgICAgICAgbGVhZmxldE1hcmtlci5zZXRJY29uKCBiaWdJY29uIClcbiAgICAgICAgZW1pdERhdGFGdW5jdGlvbihkYXRhKVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGNvbmZpZ3VyYXRpb24gZGUgbCdpY29uIGR1IENsdXN0ZXJcbiAgICB0aGlzLnBydW5lQ2x1c3Rlci5CdWlsZExlYWZsZXRDbHVzdGVySWNvbiA9IGZ1bmN0aW9uKGNsdXN0ZXIpIHtcbiAgICAgICAgIHZhciBlID0gbmV3IEwuSWNvbi5NYXJrZXJDbHVzdGVyKCk7XG4gICAgICAgICBlLnN0YXRzID0gY2x1c3Rlci5zdGF0cztcbiAgICAgICAgIGUucG9wdWxhdGlvbiA9IGNsdXN0ZXIucG9wdWxhdGlvbjtcbiAgICAgICAgIHJldHVybiBlO1xuICAgICB9O1xuICAgICB2YXIgY29sb3JzID0gWycjZmY0YjAwJywgJyNiYWM5MDAnLCAnI0VDMTgxMycsICcjNTVCQ0JFJywgJyNEMjIwNEMnLCAnI0ZGMDAwMCcsICcjYWRhNTlhJywgJyMzZTY0N2UnXSxcbiAgICAgcGkyID0gTWF0aC5QSSAqIDI7XG4gICAgIEwuSWNvbi5NYXJrZXJDbHVzdGVyID0gTC5JY29uLmV4dGVuZCh7XG4gICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgaWNvblVybDogJy9zdGF0aWMvaWNvbnMvaWNvbl9jbHVzdGVyX3llbGxvdy5zdmcnLFxuICAgICAgICAgICAgIGljb25TaXplOiBuZXcgTC5Qb2ludCg0NCwgNDQpLFxuICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BydW5lY2x1c3RlciBsZWFmbGV0LW1hcmtlcmNsdXN0ZXItaWNvbidcbiAgICAgICAgIH0sXG4gICAgICAgICBjcmVhdGVJY29uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgLy8gYmFzZWQgb24gTC5JY29uLkNhbnZhcyBmcm9tIHNocmFtb3YvbGVhZmxldC1wbHVnaW5zIChCU0QgbGljZW5jZSlcbiAgICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgIHRoaXMuX3NldEljb25TdHlsZXMoZSwgJ2ljb24nKTtcbiAgICAgICAgICAgICB2YXIgcyA9IHRoaXMub3B0aW9ucy5pY29uU2l6ZTtcbiAgICAgICAgICAgICBlLndpZHRoID0gcy54O1xuICAgICAgICAgICAgIGUuaGVpZ2h0ID0gcy55O1xuICAgICAgICAgICAgIHRoaXMuZHJhdyhlLmdldENvbnRleHQoJzJkJyksIHMueCwgcy55KTtcbiAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgIH0sXG4gICAgICAgICBjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgIH0sXG4gICAgICAgICBkcmF3OiBmdW5jdGlvbihjYW52YXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICB2YXIgbG9sID0gMDtcbiAgICAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc3RhdHNbaV0gLyB0aGlzLnBvcHVsYXRpb247XG4gICAgICAgICAgICAgICAgIGlmIChzaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgY2FudmFzLm1vdmVUbygyMiwgMjIpO1xuICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmZpbGxTdHlsZSA9IGNvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tID0gc3RhcnQgKyAwLjE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gc3RhcnQgKyBzaXplICogcGkyO1xuICAgICAgICAgICAgICAgICAgICAgaWYgKHRvIDwgZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5hcmMoMjIsMjIsMjIsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyBzaXplKnBpMjtcbiAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5saW5lVG8oMjIsMjIpO1xuICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBjYW52YXMuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgY2FudmFzLmZpbGxTdHlsZSA9ICcjYTE3NGFjJztcbiAgICAgICAgICAgICBjYW52YXMuYXJjKDIyLCAyMiwgMTgsIDAsIE1hdGguUEkqMik7XG4gICAgICAgICAgICAgY2FudmFzLmZpbGwoKTtcbiAgICAgICAgICAgICBjYW52YXMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgY2FudmFzLmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgY2FudmFzLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgIGNhbnZhcy50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICBjYW52YXMuZm9udCA9ICdib2xkIDEycHggc2Fucy1zZXJpZic7XG4gICAgICAgICAgICAgY2FudmFzLmZpbGxUZXh0KHRoaXMucG9wdWxhdGlvbiwgMjIsIDIyLCA0MCk7XG4gICAgICAgICB9XG4gICAgIH0pO1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHRoZSBlbmQgb2YgdGhlIENsdXN0ZXIgaWNvbiBjb25maWd1cmF0aW9uXG5cbiAgICAvLyBjb25zb2xlLmxvZygndGhpcy5tYXBPYmplY3QnLHRoaXMubWFwT2JqZWN0KTtcbiAgICBsZXQgbWFwID0gdGhpcy5tYXBPYmplY3QubWFwT2JqZWN0O1xuICAgIG1hcC5hZGRMYXllcih0aGlzLnBydW5lQ2x1c3Rlcik7XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICAuLi5tYXBTdGF0ZSh7XG4gICAgICBwcm9qZWN0cyh7c2VhcmNofSl7IHJldHVybiBzZWFyY2guYW5zd2VyLnJlc3VsdCAmJiBzZWFyY2guYW5zd2VyLnJlc3VsdC5wcm9qZWN0cyB9LFxuICAgIH0pXG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBwcm9qZWN0cyhvbGQpe1xuICAgICAgaWYgKHRoaXMucHJvamVjdHMgJiYgdGhpcy5wcm9qZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucmVEcmF3KClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczp7XG5cbiAgICBlbWl0SXRlbShpdGVtKXtcbiAgICAgIHRoaXMuJGVtaXQoJ2dldFNlbGVjdGVkSXRlbScsIGl0ZW0pXG4gICAgfSxcblxuICAgIGNoZWNrSWZJdGVtSGFzTGF0TG5nKGl0ZW0pe1xuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tJZlN0cmluZ0Zsb2F0KGl0ZW0ubGF0KSAmJiB0aGlzLmNoZWNrSWZTdHJpbmdGbG9hdChpdGVtLmxvbilcbiAgICB9LFxuXG4gICAgcmVEcmF3KCl7XG4gICAgICBjb25zb2xlLmxvZygnLS0tLS0tLS0tLS0tLSByZWRyYXcgLS0tLS0tLS0tLS0tLScpO1xuICAgICAgLy8gdmFyIHBydW5lQ2x1c3RlciA9IG5ldyBQcnVuZUNsdXN0ZXJGb3JMZWFmbGV0KCk7XG4gICAgICB2YXIgcHJ1bmVDbHVzdGVyID0gdGhpcy5wcnVuZUNsdXN0ZXJcblxuICAgICAgcHJ1bmVDbHVzdGVyLlJlbW92ZU1hcmtlcnMoKTtcblxuICAgICAgY29uc29sZS5sb2coJ3JlbW92ZWQgYWxsIHRoZSBtYXJrZXJzIC0gbnVtYmVyIG9mIG1hcmtlcnMgdG8gbWFwOiAnLHRoaXMuaXRlbXNGb3JNYXAoKS5sZW5ndGgpO1xuICAgICAgdGhpcy5pdGVtc0Zvck1hcCgpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgbGV0IG1hcmtlciA9IHRoaXMuY3JlYXRlTWFya2VyKGl0ZW0scHJ1bmVDbHVzdGVyKVxuICAgICAgICBwcnVuZUNsdXN0ZXIuUmVnaXN0ZXJNYXJrZXIobWFya2VyKTtcbiAgICAgIH0pXG5cbiAgICB9LFxuXG4gICAgLy8gY3JlYXRlSWNvbihkYXRhLCBjYXRlZ29yeSkge1xuICAgIC8vICAgICByZXR1cm4gTC5pY29uKHtcbiAgICAvLyAgICAgICAgIGljb25Vcmw6ICcvc3RhdGljL2ljb25zL2ljb25fcGluX3BsZWluX3Zpb2xldC5zdmcnLFxuICAgIC8vICAgICAgICAgaWNvblNpemU6IFszOCwgOTVdLFxuICAgIC8vICAgICAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXG4gICAgLy8gICAgICAgICAvLyBzaGFkb3dVcmw6ICdteS1pY29uLXNoYWRvdy5wbmcnLFxuICAgIC8vICAgICAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXG4gICAgLy8gICAgICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXG4gICAgLy8gICAgIH0pO1xuICAgIC8vIH0sXG5cbiAgICBjcmVhdGVNYXJrZXIob2JqLHBydW5lQ2x1c3Rlcil7XG4gICAgICBsZXQgcGFyc2VkT2JqID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKVxuICAgICAgbGV0IG1hcmtlciA9IG5ldyBQcnVuZUNsdXN0ZXIuTWFya2VyKHBhcnNlZE9iai5sYXQsIHBhcnNlZE9iai5sb24pO1xuICAgICAgLy8gbWFya2VyLmRhdGEuaWNvbiA9IHRoaXMuY3JlYXRlSWNvbjtcbiAgICAgIC8vIG1hcmtlci5kYXRhLklEID0gcGFyc2VkT2JqLnNkX2lkO1xuICAgICAgbWFya2VyLmRhdGEuSUQgPSB0aGlzLml0ZW1JZChvYmopO1xuICAgICAgbWFya2VyLmRhdGEubGF0ID0gcGFyc2VkT2JqLmxhdDtcbiAgICAgIG1hcmtlci5kYXRhLmxvbiA9IHBhcnNlZE9iai5sb247XG4gICAgICByZXR1cm4gbWFya2VyXG4gICAgfSxcblxuICAgIGdldEljb25TaXplKGl0ZW0pe1xuICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWRJdGVtKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1JRCA9IGl0ZW0uSURcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJnZXRJY29uU2l6ZSAvIGl0ZW1JRCA6IFwiICwgaXRlbUlEKVxuICAgICAgICBsZXQgaGlnaGxpZ2h0ZWRJdGVtSUQgPSB0aGlzLml0ZW1JZCh0aGlzLmhpZ2hsaWdodGVkSXRlbSwgJ2Jsb2NrX2lkJylcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJnZXRJY29uU2l6ZSAvIGhpZ2hsaWdodGVkSXRlbUlEIDogXCIgLCBoaWdobGlnaHRlZEl0ZW1JRClcbiAgICAgICAgLy8gcmV0dXJuIHRoaXMuaXRlbUlkKGl0ZW0sICdibG9ja19pZCcpID09PSB0aGlzLml0ZW1JZCh0aGlzLmhpZ2hsaWdodGVkSXRlbSwgJ2Jsb2NrX2lkJykgPyB0aGlzLmljb25TaXplSGlnaGxpZ2h0ZWQgOiB0aGlzLmljb25TaXplTm9ybWFsXG4gICAgICAgIC8vIHJldHVybiBpdGVtSUQgPT09IGhpZ2hsaWdodGVkSXRlbUlEID8gdGhpcy5pY29uU2l6ZUhpZ2hsaWdodGVkIDogdGhpcy5pY29uU2l6ZU5vcm1hbFxuICAgICAgICByZXR1cm4gaXRlbUlEID09PSBoaWdobGlnaHRlZEl0ZW1JRCA/IFs0OSw0OV0gOiBbMjksMjldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5pY29uU2l6ZU5vcm1hbFxuICAgICAgfVxuICAgIH0sXG4gICAgbWF0Y2hJdGVtV2l0aENvbmZpZyhpdGVtLCBmaWVsZEJsb2NrKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIm1hdGNoSXRlbVdpdGhDb25maWcgLyBpdGVtIDogXCIsIGl0ZW0pXG4gICAgICBjb25zdCBjb250ZW50RmllbGQgPSB0aGlzLmNvbnRlbnRGaWVsZHMuZmluZChmPT4gZi5wb3NpdGlvbiA9PSBmaWVsZEJsb2NrKVxuICAgICAgLy8gY29uc29sZS5sb2coXCJtYXRjaEl0ZW1XaXRoQ29uZmlnIC8gY29udGVudEZpZWxkIDogXCIsIGNvbnRlbnRGaWVsZClcbiAgICAgIGlmIChjb250ZW50RmllbGQpe1xuICAgICAgICBjb25zdCBmaWVsZCA9IGNvbnRlbnRGaWVsZC5maWVsZFxuICAgICAgICByZXR1cm4gaXRlbVtmaWVsZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0ZW1JZChpdGVtKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIml0ZW1JZCAvIGl0ZW0gOiBcIiwgaXRlbSlcbiAgICAgIHJldHVybiB0aGlzLm1hdGNoSXRlbVdpdGhDb25maWcoaXRlbSwgJ2Jsb2NrX2lkJylcbiAgICB9LFxuICAgIGdldEhpZ2hsaWdodGVkSXRlbUlkKCl7XG4gICAgICBpZiAoIHRoaXMuaGlnaGxpZ2h0ZWRJdGVtICkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtSWQoaGlnaGxpZ2h0ZWRJdGVtLCAnYmxvY2tfaWQnKSBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG5cbiAgfSxcblxuXG5cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwiY3NzXCI+XG48L3N0eWxlPlxuIiwiPHN0eWxlIHNjb3BlZD5cblxuICAuYmFubmVyLWhlaWdodC13aXRoLWZpbHRlcnMge1xuICAgIC8qIHBhZGRpbmctdG9wOiAxMjVweDsgKi9cbiAgICBtYXJnaW4tdG9wOiAxMDBweDtcbiAgICBtYXJnaW4tYm90dG9tOiAzMHB4O1xuICAgIG1heC1oZWlnaHQ6IDI1MHB4XG4gIH1cbiAgLmJhbm5lci1oZWlnaHQtd2l0aG91dC1maWx0ZXJzIHtcbiAgICBwYWRkaW5nLXRvcDogNjBweDtcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgIG1hcmdpbi1ib3R0b206IDMwcHg7XG4gICAgaGVpZ2h0OiAyNTBweFxuICB9XG5cbiAgLmJ1dHRvbnN7XG4gICAgbWFyZ2luLXJpZ2h0OiAzZW07XG4gIH1cblxuICAuYnV0dG9uc3tcbiAgICBtYXJnaW4tcmlnaHQ6IDNlbTtcbiAgfVxuXG4gIC5jbG9zZXtcbiAgICB6LWluZGV4OiAyO1xuICAgIHBvc2l0aW9uOmFic29sdXRlO1xuXG4gICAgLyogZmxvYXQ6IHJpZ2h0O1xuICAgIGRpc3BsYXk6IGZsZXg7ICAqL1xuICAgIC8qIGFsaWduLXNlbGY6IGZsZXgtZW5kOyAqL1xuICAgIC8qIGp1c3RpZnktY29udGVudDogZmxleC1lbmQgIWltcG9ydGFudDsgKi9cbiAgICAvKiBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kOyAqL1xufVxuXG48L3N0eWxlPlxuXG48dGVtcGxhdGU+XG5cbiAgPHNlY3Rpb24gXG4gICAgdi1zaG93PVwicmF3SHRtbCAhPT0gJycgJiYgYmFubmVyVmlzaWJsZVwiXG4gICAgOmNsYXNzPVwiYGlzLWhpZGRlbi10b3VjaCAkeyBoYXNGaWx0ZXJzID8gJ2Jhbm5lci1oZWlnaHQtd2l0aC1maWx0ZXJzJyA6ICdiYW5uZXItaGVpZ2h0LXdpdGhvdXQtZmlsdGVycycgfSBoYXMtdGV4dC1jZW50ZXIgc2tpcC1uYXZiYXJgXCJcbiAgICA+XG5cbiAgICA8IS0tIFJBVyBIVE1MIEZPUiBCQU5ORVIgLS0+XG4gICAgPCEtLSA8ZGl2XG4gICAgICA6Y2xhc3M9XCJgY29udGFpbmVyIGBcIlxuICAgICAgPiAtLT5cblxuICAgICAgPCEtLSBCVVRUT04gVE8gQ0xPU0UgUFJFVklFVyAtLT5cbiAgICAgIDxkaXYgY2xhc3M9XCJidXR0b25zIGlzLXJpZ2h0XCI+XG4gICAgICAgIDxidXR0b24gXG4gICAgICAgICAgY2xhc3M9XCJidXR0b24gY2xvc2UgaXMtcHJpbWFyeSBpcy1pbnZlcnRlZFwiIFxuICAgICAgICAgIEBjbGljaz1cImRpc2FibGVCYW5uZXJzXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsXCI+XG4gICAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS10aW1lc1wiPjwvaT5cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDwhLS0gQ09OVEVOVCBIVE1MIC0tPlxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgIDxzcGFuIHYtaHRtbD1cInJhd0h0bWxcIj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICA8IS0tIDwvZGl2PiAtLT5cblxuXG4gIDwvc2VjdGlvbj5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7bWFwU3RhdGV9IGZyb20gJ3Z1ZXgnXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczpbXG4gICAgICAndGVtcGxhdGVfdXJsJyxcbiAgICAgICdkeW5hbWljVGVtcGxhdGUnLFxuICAgICAgJ25hdmJhckNvbmZpZydcbiAgICBdLFxuICBkYXRhOiAoKSA9PiB7XG4gICAgcmV0dXJuICAge1xuICAgICAgcmF3SHRtbCA6ICcnLFxuICAgICAgdmlzaWJsZSA6IHRydWUsXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIC4uLm1hcFN0YXRlKHtcbiAgICAgIHVzZXI6ICd1c2VyJyxcbiAgICAgIGJhbm5lclZpc2libGUgOiAnYmFubmVyVmlzaWJsZSdcbiAgICB9KSxcbiAgICBoYXNGaWx0ZXJzKCl7XG4gICAgICByZXR1cm4gKHRoaXMuZHluYW1pY1RlbXBsYXRlID09PSAnRHluYW1pY1N0YXRpYycgKT8gZmFsc2UgOiB0cnVlXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCl7XG4gICAgXG4gICAgLy8gaGFjayB0byBzY3JvbGwgdG9wIGJlY2F1c2UgdnVlLXJvdXRlciBzY3JvbGxCZWhhdmlvciB0aGluZyBkb2Vzbid0IHNlZW0gdG8gd29yayBvbiBGaXJlZm94IG9uIExpbnV4IGF0IGxlYXN0XG4gIC8vIGhlcmUgd2UgZ28gZmV0Y2ggdGhlIHJhdyBIVE1MIGNvbnRlbnQgb2YgYSB3ZWJwYWdlXG4gIGxldCB0ZW1wbGF0ZV91cmwgPSAodGhpcy50ZW1wbGF0ZV91cmwpID8gdGhpcy50ZW1wbGF0ZV91cmwgOiAnaHR0cHM6Ly9jby1kZW1vcy5jb20vZXJyb3InXG4gIGxldCBoZWFkID0geyBcbiAgICBoZWFkZXJzOiB7XG4gICAgICAvLyAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLFxuICAgICAgJ2FjY2VwdCcgOiAndGV4dC9odG1sJyxcbiAgICB9XG4gIH1cbiAgYXhpb3MuZ2V0KHRlbXBsYXRlX3VybCwgaGVhZClcbiAgICAudGhlbiggKHJlc3BvbnNlKSA9PiB7IFxuICAgICAgLy8gY29uc29sZS5sb2cocmVzcG9uc2UpOyBcbiAgICAgIHRoaXMucmF3SHRtbCA9IChyZXNwb25zZSAmJiByZXNwb25zZS5kYXRhKSA/IHJlc3BvbnNlLmRhdGEgOiAnPGJyPjxicj50aGVyZSBpcyBhbiBFcnJvciA8YnI+PGJyPid9IFxuICAgIClcbiAgICAuY2F0Y2goIChlcnIpID0+IHt0aGlzLnJhd0h0bWwgPSAnPGJyPjxicj50aGVyZSBpcyBhbiA8c3Ryb25nPiBFcnJvciA8L3N0cm9uZz48YnI+PGJyPid9IClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGRpc2FibGVCYW5uZXJzKCkge1xuICAgICAgdGhpcy5yYXdIdG1sID0gJydcbiAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgnZGlzYWJsZUJhbm5lcnMnKVxuICAgIH0sXG4gICAgZ29CYWNrKGUpe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB0aGlzLiRyb3V0ZXIuYmFjaygpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cblxuICAgIDxtYWluIHYtaWY9XCJkaXNwbGF5YWJsZUl0ZW1cIj5cbiAgICAgIFxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuXG4gICAgICAgIDwhLS0gQkFDSyBUTyBSRVNVTFRTIC0tPlxuICAgICAgICA8YSBjbGFzcz1cImJhY2tcIiBAY2xpY2s9XCJnb0JhY2tcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLWFycm93LWxlZnRcIj48L2k+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAge3sgYmFja1RvUmVzdWx0cyB9fVxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9hPlxuXG5cbiAgICAgICAgPCEtLSBERUJVR0dJTkcgIC0tPlxuICAgICAgICA8IS0tIHt7IGRpc3BsYXlhYmxlSXRlbSB9fSAtLT5cblxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XG4gICAgICAgICAgXG4gICAgICAgICAgPCEtLSAvLy8vIENPTFVNTiBMRUZUIC8vLy8gLS0+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy01IGlzLW9mZnNldC0xXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZGVzY3JpcHRpb25cIj5cblxuICAgICAgICAgICAgICA8IS0tIEJMT0NLIFRJVExFIC0tPlxuICAgICAgICAgICAgICA8aDEgaWQ9XCJibG9jay10aXRsZVwiIGNsYXNzPVwidGl0bGUgaXMtM1wiPlxuICAgICAgICAgICAgICAgIDwhLS0ge3twcm9qZWN0Rm9ybWF0dGVkLnRpdGxlfX0gLS0+XG4gICAgICAgICAgICAgICAgIHt7IG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX3RpdGxlJyl9fVxuICAgICAgICAgICAgICA8L2gxPlxuXG4gICAgICAgICAgICAgIDwhLS0gQkxPQ0sgTUFJTiBUQUdTIC0tPlxuICAgICAgICAgICAgICA8ZGl2IGlkPVwiYmxvY2stbWFpbi10YWdzXCIgdi1pZj1cImlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX21haW5fdGFncycpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gXG4gICAgICAgICAgICAgICAgICB2LWlmPVwiZ2V0Q3VzdG9tQmxvY2tUaXRsZSgnYmxvY2tfbWFpbl90YWdzJylcIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGQgaGFzLXRleHQtcHJpbWFyeVwiIFxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge3sgZ2V0Q3VzdG9tQmxvY2tUaXRsZSgnYmxvY2tfbWFpbl90YWdzJykgfX1cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGJyPlxuICAgICAgICAgICAgICAgIDxzcGFuIFxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0YWdcIiBcbiAgICAgICAgICAgICAgICAgIHYtZm9yPVwiKHRhZywgaSkgaW4gbWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfbWFpbl90YWdzJylcIlxuICAgICAgICAgICAgICAgICAgOmtleT1cInRhZyArIGlcIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge3sgdGFnIH19XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxicj48YnI+XG4gICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgIDwhLS0gQkxPQ0sgQUREUkVTUyAtLT5cbiAgICAgICAgICAgICAgPHAgaWQ9XCJibG9jay1hZGRyZXNzXCIgdi1pZj1cImlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX2FkZHJlc3MnKVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cImltYWdlIGlzLTE2eDE2XCIgc3JjPVwiL3N0YXRpYy9pY29ucy9pY29uX3Bpbi5zdmdcIj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAge3sgbWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfYWRkcmVzcycpfX1cbiAgICAgICAgICAgICAgPC9wPlxuXG4gICAgICAgICAgICAgIDwhLS0gQkxPQ0sgUFJFIEFCU1RSQUNUIC0tPlxuICAgICAgICAgICAgICA8cCBpZD1cImJsb2NrLXByZS1hYnN0cmFjdFwiIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19wcmVfYWJzdHJhY3QnKVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIFxuICAgICAgICAgICAgICAgICAgdi1pZj1cImdldEN1c3RvbUJsb2NrVGl0bGUoJ2Jsb2NrX3ByZV9hYnN0cmFjdCcpXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaGFzLXRleHQtd2VpZ2h0LXNlbWlib2xkIGhhcy10ZXh0LXByaW1hcnlcIiBcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHt7IGdldEN1c3RvbUJsb2NrVGl0bGUoJ2Jsb2NrX3ByZV9hYnN0cmFjdCcpIH19XG4gICAgICAgICAgICAgICAgICA8YnI+PGJyPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICB7eyBtYXRjaFByb2plY3RXaXRoQ29uZmlnKCdibG9ja19wcmVfYWJzdHJhY3QnKX19XG4gICAgICAgICAgICAgIDwvcD5cblxuICAgICAgICAgICAgICA8IS0tIEJMT0NLIEFCU1RSQUNUIC0tPlxuICAgICAgICAgICAgICA8cCBpZD1cImJsb2NrLWFic3RyYWN0XCIgdi1pZj1cImlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX2Fic3RyYWN0JylcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBcbiAgICAgICAgICAgICAgICAgIHYtaWY9XCJnZXRDdXN0b21CbG9ja1RpdGxlKCdibG9ja19hYnN0cmFjdCcpXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaGFzLXRleHQtd2VpZ2h0LXNlbWlib2xkIGhhcy10ZXh0LXByaW1hcnlcIiBcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHt7IGdldEN1c3RvbUJsb2NrVGl0bGUoJ2Jsb2NrX2Fic3RyYWN0JykgfX1cbiAgICAgICAgICAgICAgICAgIDxicj48YnI+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIHt7IG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX2Fic3RyYWN0Jyl9fVxuICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICA8IS0tIEJMT0NLIFBBUlRORVJTIC0tPlxuICAgICAgICAgICAgICA8ZGl2IGlkPVwiYmxvY2stcGFydG5lcnNcIiB2LWlmPVwiaXNQb3NpdGlvbkZpbGxlZCgnYmxvY2tfcGFydG5lcnMnKVwiPlxuICAgICAgICAgICAgICAgIDxwPnt7IG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX3BhcnRuZXJzJyl9fTwvcD5cbiAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgPCEtLSBCTE9DSyBQT1NUIEFCU1RSQUNUIC0tPlxuICAgICAgICAgICAgICA8cCBpZD1cImJsb2NrLXBvc3QtYWJzdHJhY3QtMVwiIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19wb3N0X2Fic3RyYWN0XzEnKVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIFxuICAgICAgICAgICAgICAgICAgdi1pZj1cImdldEN1c3RvbUJsb2NrVGl0bGUoJ2Jsb2NrX3Bvc3RfYWJzdHJhY3RfMScpXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaGFzLXRleHQtd2VpZ2h0LXNlbWlib2xkIGhhcy10ZXh0LXByaW1hcnlcIiBcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHt7IGdldEN1c3RvbUJsb2NrVGl0bGUoJ2Jsb2NrX3Bvc3RfYWJzdHJhY3RfMScpIH19XG4gICAgICAgICAgICAgICAgICA8YnI+PGJyPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICB7eyBtYXRjaFByb2plY3RXaXRoQ29uZmlnKCdibG9ja19wb3N0X2Fic3RyYWN0XzEnKX19XG4gICAgICAgICAgICAgIDwvcD5cblxuICAgICAgICAgICAgICA8IS0tIEJMT0NLIFBPU1QgQUJTVFJBQ1QgLS0+XG4gICAgICAgICAgICAgIDxwIGlkPVwiYmxvY2stcG9zdC1hYnN0cmFjdC0yXCIgdi1pZj1cImlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX3Bvc3RfYWJzdHJhY3RfMicpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gXG4gICAgICAgICAgICAgICAgICB2LWlmPVwiZ2V0Q3VzdG9tQmxvY2tUaXRsZSgnYmxvY2tfcG9zdF9hYnN0cmFjdF8yJylcIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGQgaGFzLXRleHQtcHJpbWFyeVwiIFxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge3sgZ2V0Q3VzdG9tQmxvY2tUaXRsZSgnYmxvY2tfcG9zdF9hYnN0cmFjdF8yJykgfX1cbiAgICAgICAgICAgICAgICAgIDxicj48YnI+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIHt7IG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX3Bvc3RfYWJzdHJhY3RfMicpfX1cbiAgICAgICAgICAgICAgPC9wPlxuXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XG5cbiAgICAgICAgICAgICAgICA8IS0tIEJMT0NLIFdFQlNJVEUgLS0+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cImJsb2NrLW1haW4td2Vic2l0ZVwiIGNsYXNzPVwiY29sdW1uIGlzLTUgaXMtb2Zmc2V0LTEgbGlua1wiPlxuICAgICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgdi1pZj1cIm1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX3dlc2l0ZScpXCJcbiAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwibWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfd2VzaXRlJykgPT09IG5vRGF0YSA/ICdkaXNhYmxlZCBoYXMtdGV4dC1ncmV5JyA6ICcnIFwiXG4gICAgICAgICAgICAgICAgICAgIDpocmVmPVwibWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfd2VzaXRlJykgPT09IG5vRGF0YSA/ICcnIDogbWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfd2VzaXRlJykgXCJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7IHNlZVdlYnNpdGUgfX1cbiAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8IS0tIEJMT0NLIENPTlRBQ1QgLS0+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cImJsb2NrLW1haW4tY29udGFjdFwiIGNsYXNzPVwiY29sdW1uIGlzLTUgaXMtb2Zmc2V0LTEgbGlua1wiPlxuICAgICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgdi1pZj1cIm1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX2NvbnRhY3QnKVwiXG4gICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cIm1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX2NvbnRhY3QnKSA9PT0gbm9EYXRhID8gJ2Rpc2FibGVkIGhhcy10ZXh0LWdyZXknIDogJycgXCJcbiAgICAgICAgICAgICAgICAgICAgOmhyZWY9XCJtYXRjaFByb2plY3RXaXRoQ29uZmlnKCdibG9ja193ZXNpdGUnKSA9PT0gbm9EYXRhID8gJycgOidtYWlsdG86JyArIG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX2NvbnRhY3QnKSBcIlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgICAgICAgICAgICAgICAge3sgc2VlQ29udGFjdCB9fVxuICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDwhLS0gQkxPQ0sgU0VSVklDRVMgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWRkZWRcIiBpZD1cImJsb2NrLXNlcnZpY2VzXCIgdi1pZj1cImlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX3NlcnZpY2VzJylcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbnNcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLTEyXCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiAgXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGQgaGFzLXRleHQtcHJpbWFyeVwiPlxuICAgICAgICAgICAgICAgICAgICAgIHt7IHNlcnZpY2VzRGF0YSB9fSA6IDxicj48YnI+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgICAgICAge3sgbWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfc2VydmljZXMnKX19XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8IS0tIEJMT0NLIEJPVFRPTSAyIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFkZGVkXCIgaWQ9XCJibG9jay1MQjJcIiB2LWlmPVwiaXNQb3NpdGlvbkZpbGxlZCgnYmxvY2tfbGVmdF9ib3R0b21fMicpXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy0xMlwiPlxuICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gXG4gICAgICAgICAgICAgICAgICAgICAgdi1pZj1cImdldEN1c3RvbUJsb2NrVGl0bGUoJ2Jsb2NrX2xlZnRfYm90dG9tXzInKVwiXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGQgaGFzLXRleHQtcHJpbWFyeVwiIFxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7eyBnZXRDdXN0b21CbG9ja1RpdGxlKCdibG9ja19sZWZ0X2JvdHRvbV8yJykgfX1cbiAgICAgICAgICAgICAgICAgICAgICA8YnI+PGJyPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIHt7IG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX2xlZnRfYm90dG9tXzInKX19XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPC9kaXY+ICA8IS0tIGVuZCBjb2x1bW4gbGVmdCAtLT5cblxuXG5cbiAgICAgICAgICA8IS0tIC8vLy8gQ09MVU1OIFJJR0hUIC8vLy8gLS0+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy01XCI+XG5cbiAgICAgICAgICAgIDwhLS0gQkxPQ0sgTUFJTiBJTExVU1RSQVRJT04gLS0+XG4gICAgICAgICAgICA8YSBcbiAgICAgICAgICAgICAgaWQ9XCJibG9jay1pbGx1c3RyYXRpb25cIiBcbiAgICAgICAgICAgICAgOmhyZWY9XCJtYXRjaFByb2plY3RXaXRoQ29uZmlnKCdibG9ja193ZXNpdGUnKVwiIFxuICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICBjbGFzcz1cImlsbHVzdHJhdGlvblwiXG4gICAgICAgICAgICAgICAgOnNyYz1cIml0ZW1JbWFnZSgnY2FyZF9pbWdfbWFpbicpXCJcbiAgICAgICAgICAgICAgICA6YWx0PVwibWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfdGl0bGUnKVwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2E+XG5cbiAgICAgICAgICAgIDwhLS0gQkxPQ0sgRklMRSAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhZGRlZFwiIGlkPVwiYmxvY2stZmlsZVwiIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19maWxlXzEnKVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uc1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtMTJcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgICAgICAgICAgICA6aHJlZj1cIm1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX2ZpbGVfMScpXCJcbiAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS1kb3dubG9hZFwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICB7eyBkb3dubG9hZEZpbGUgfX1cbiAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8IS0tIEJMT0NLIFNPVVJDRSAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhZGRlZFwiIGlkPVwiYmxvY2stc3JjXCIgdi1pZj1cImlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX3NyYycpXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy0xMlwiPlxuICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGQgaGFzLXRleHQtcHJpbWFyeVwiPlxuICAgICAgICAgICAgICAgICAgICAgIHt7IHNvdXJjZURhdGEgfX0gOiBcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICB7eyBtYXRjaFByb2plY3RXaXRoQ29uZmlnKCdibG9ja19zcmMnKX19XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8IS0tIEJMT0NLIFNDQUxFIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFkZGVkXCIgaWQ9XCJibG9jay1zY2FsZVwiIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19zY2FsZScpIHx8IGlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX3NjYWxlX2FkZHJlc3MnKVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uc1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtMTJcIj5cblxuICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gXG4gICAgICAgICAgICAgICAgICAgICAgdi1pZj1cImdldEN1c3RvbUJsb2NrVGl0bGUoJ2Jsb2NrX3NjYWxlX3RhZ3MnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGQgaGFzLXRleHQtcHJpbWFyeVwiIFxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7eyBnZXRDdXN0b21CbG9ja1RpdGxlKCdibG9ja19zY2FsZV90YWdzJykgfX1cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInRhZ1wiIFxuICAgICAgICAgICAgICAgICAgICAgIHYtZm9yPVwiKHRhZywgaSkgaW4gbWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfc2NhbGVfdGFncycpXCJcbiAgICAgICAgICAgICAgICAgICAgICA6a2V5PVwidGFnICsgaVwiXG4gICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIHt7IHRhZyB9fVxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImJsb2NrLXNjYWxlLTJcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gXG4gICAgICAgICAgICAgICAgICAgICAgdi1pZj1cImdldEN1c3RvbUJsb2NrVGl0bGUoJ2Jsb2NrX3NjYWxlXzInKVwiXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGQgaGFzLXRleHQtcHJpbWFyeVwiIFxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7eyBnZXRDdXN0b21CbG9ja1RpdGxlKCdibG9ja19zY2FsZV8yJykgfX0gXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgICAgICAge3sgbWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfc2NhbGVfMicpfX1cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJibG9jay1zY2FsZS1hZGRyZXNzXCIgdi1pZj1cImlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX3NjYWxlX2FkZHJlc3MnKVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVwiaW1hZ2UgaXMtMTZ4MTZcIiBzcmM9XCIvc3RhdGljL2ljb25zL2ljb25fcGluLnN2Z1wiPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIHt7IG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX3NjYWxlX2FkZHJlc3MnKX19XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG5cbiAgICAgICAgICAgIDwhLS0gQkxPQ0sgUEVSSU9EIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFkZGVkXCIgaWQ9XCJibG9jay1wZXJpb2RcIiB2LWlmPVwiaXNQb3NpdGlvbkZpbGxlZCgnYmxvY2tfcGVyaW9kJylcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbnNcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLTEyXCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhhcy10ZXh0LXdlaWdodC1zZW1pYm9sZCBoYXMtdGV4dC1wcmltYXJ5XCI+XG4gICAgICAgICAgICAgICAgICAgICAge3sgcGVyaW9kRGF0YSB9fSA6IFxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIHt7IG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX3BlcmlvZCcpfX1cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDwhLS0gQkxPQ0sgQ09OVEFDVCAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhZGRlZCBibG9jay1jb2xvclwiIGlkPVwiYmxvY2stY29udGFjdFwiIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19jb250YWN0X25hbWUnKVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uc1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtMTJcIj5cblxuICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGRcIj5cbiAgICAgICAgICAgICAgICAgICAgICB7eyBzZWVDb250YWN0IH19IDogXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPGJyPlxuXG4gICAgICAgICAgICAgICAgICA8ZGl2IHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19jb250YWN0X25hbWUnKVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24gaXMtc21hbGxcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhciBmYS11c2VyXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19jb250YWN0X25hbWUnKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAge3sgbWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfY29udGFjdF9uYW1lJyl9fSBcbiAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgPHNwYW4gdi1pZj1cImlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX2NvbnRhY3Rfc3VybmFtZScpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7eyBtYXRjaFByb2plY3RXaXRoQ29uZmlnKCdibG9ja19jb250YWN0X3N1cm5hbWUnKX19XG4gICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19jb250YWN0X2Z1bGxuYW1lJylcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX2NvbnRhY3RfZnVsbG5hbWUnKX19XG4gICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19jb250YWN0X3RpdGxlJylcIj48YnI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7eyBtYXRjaFByb2plY3RXaXRoQ29uZmlnKCdibG9ja19jb250YWN0X3RpdGxlJyl9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPGJyPlxuICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8YnI+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgPGRpdiB2LWlmPVwiaXNQb3NpdGlvbkZpbGxlZCgnYmxvY2tfY29udGFjdF9lbWFpbCcpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbFwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLWF0XCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIHt7IG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX2NvbnRhY3RfZW1haWwnKX19IDxicj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgIDxkaXYgdi1pZj1cImlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX2NvbnRhY3RfdGVsJylcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYXMgZmEtcGhvbmVcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgICAgICAge3sgbWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfY29udGFjdF90ZWwnKX19IDxicj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPCEtLSBCTE9DSyBPUEVOIElORk9TIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFkZGVkXCIgaWQ9XCJibG9jay1pbmZvc1wiIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19vcGVuX2luZm9zJylcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbnNcIj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtMTJcIj5cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGQgaGFzLXRleHQtcHJpbWFyeVwiPlxuICAgICAgICAgICAgICAgICAgICAgIHt7IGluZm9zRGF0YSB9fSA6IDxicj48YnI+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiYmxvY2stdGVsXCIgdi1pZj1cImlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX3RlbCcpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbFwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLWFuZ2xlLXJpZ2h0XCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIHt7IGluZm9zVGVsIH19IDogXG4gICAgICAgICAgICAgICAgICAgICAge3sgbWF0Y2hQcm9qZWN0V2l0aENvbmZpZygnYmxvY2tfdGVsJyl9fSA8YnI+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiYmxvY2stb3Blbi1pbmZvc1wiIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19vcGVuX2luZm9zJylcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYXMgZmEtYW5nbGUtcmlnaHRcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgICAgICAge3sgaW5mb3NPcGVuIH19IDogPGJyPlxuICAgICAgICAgICAgICAgICAgICAgIHt7IG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX29wZW5faW5mb3MnKX19IDxicj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJibG9jay1pbmZvcy1wcmFjdFwiIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19pbmZvc19wcmFjdCcpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbFwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLWFuZ2xlLXJpZ2h0XCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIHt7IGluZm9zTW9yZSB9fSA6IFxuICAgICAgICAgICAgICAgICAgICAgIHt7IG1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX2luZm9zX3ByYWN0Jyl9fVxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDwhLS0gQkxPQ0sgUklHSFQgQk9UVE9NIDEgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWRkZWRcIiBpZD1cImJsb2NrLVJCMVwiIHYtaWY9XCJpc1Bvc2l0aW9uRmlsbGVkKCdibG9ja19yaWdodF9ib3R0b21fMScpXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy0xMlwiPlxuXG4gICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBcbiAgICAgICAgICAgICAgICAgICAgICB2LWlmPVwiZ2V0Q3VzdG9tQmxvY2tUaXRsZSgnYmxvY2tfcmlnaHRfYm90dG9tXzEnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGQgaGFzLXRleHQtcHJpbWFyeVwiIFxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7eyBnZXRDdXN0b21CbG9ja1RpdGxlKCdibG9ja19yaWdodF9ib3R0b21fMScpIH19XG4gICAgICAgICAgICAgICAgICAgICAgPGJyPjxicj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICB7eyBtYXRjaFByb2plY3RXaXRoQ29uZmlnKCdibG9ja19yaWdodF9ib3R0b21fMScpfX1cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgIDxkaXYgdi1pZj1cImlzUG9zaXRpb25GaWxsZWQoJ2Jsb2NrX3JpZ2h0X2JvdHRvbV8yJylcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJyPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBcbiAgICAgICAgICAgICAgICAgICAgICB2LWlmPVwiZ2V0Q3VzdG9tQmxvY2tUaXRsZSgnYmxvY2tfcmlnaHRfYm90dG9tXzInKVwiXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGQgaGFzLXRleHQtcHJpbWFyeVwiIFxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7eyBnZXRDdXN0b21CbG9ja1RpdGxlKCdibG9ja19yaWdodF9ib3R0b21fMicpIH19XG4gICAgICAgICAgICAgICAgICAgICAgPGJyPjxicj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICB7eyBtYXRjaFByb2plY3RXaXRoQ29uZmlnKCdibG9ja19yaWdodF9ib3R0b21fMicpfX1cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cblxuICAgICAgICAgIDwvZGl2PiA8IS0tIGVuZCBjb2x1bW4gcmlnaHQgLS0+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L21haW4+XG5cbiAgICA8Tm90Rm91bmRFcnJvciB2LWlmPVwiaXNFcnJvclwiLz5cblxuICAgIDxicj5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcHV0ZWQ6IHtcbiAgICAuLi5tYXBTdGF0ZSh7XG4gICAgICAgIHVzZXI6ICd1c2VyJ1xuICAgIH0pXG4gIH0sXG59XG48L3NjcmlwdD5cblxuXG48c2NyaXB0PlxuaW1wb3J0IHttYXBTdGF0ZX0gZnJvbSAndnVleCdcblxuaW1wb3J0IE5vdEZvdW5kRXJyb3IgZnJvbSAnLi9Ob3RGb3VuZEVycm9yLnZ1ZSc7XG5cbmltcG9ydCB7Z2V0SXRlbUJ5SWR9IGZyb20gJy4uL3V0aWxzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnRHluYW1pY0RldGFpbCcsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBOb3RGb3VuZEVycm9yLFxuICB9LFxuXG4gIHByb3BzOiBbXG4gICAgJ3JvdXRlQ29uZmlnJyxcbiAgICAnZW5kUG9pbnRDb25maWcnLFxuICAgIC8vICdsb2dvJyxcbiAgICAvLyAnYnJhbmQnXG4gIF0sXG5cbiAgZGF0YTogKCkgPT4ge1xuICAgIHJldHVybiAgIHtcbiAgICAgIGRpc3BsYXlhYmxlSXRlbSA6IG51bGwsXG4gICAgICBjb250ZW50RmllbGRzIDogbnVsbCxcbiAgICAgIGlzRXJyb3I6IGZhbHNlXG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZU1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJcXG4gLSAtIER5bmFtaWNEZXRhaWwgLyBiZWZvcmVNb3VudCAuLi4gXCIpXG4gICAgdGhpcy5jb250ZW50RmllbGRzID0gdGhpcy5yb3V0ZUNvbmZpZy5jb250ZW50c19maWVsZHNcblxuICB9LFxuXG4gIG1vdW50ZWQoKXtcbiAgICAvLyBoYWNrIHRvIHNjcm9sbCB0b3AgYmVjYXVzZSB2dWUtcm91dGVyIHNjcm9sbEJlaGF2aW9yIHRoaW5nIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIG9uIEZpcmVmb3ggb24gTGludXggYXQgbGVhc3RcbiAgICAvLyBjb25zb2xlLmxvZyhcIiAtIC0gRHluYW1pY0RldGFpbCAvIG1vdW50ZWQuLi4gXCIpXG4gICAgY29uc3QgaW50ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYod2luZG93LnBhZ2VZT2Zmc2V0IDwgNTApe1xuICAgICAgICBjbGVhckludGVydmFsKGludClcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxuICAgICAgfVxuICAgIH0sIDEwMCk7XG5cbiAgICBnZXRJdGVtQnlJZCh0aGlzLiRyb3V0ZS5xdWVyeS5pZCx0aGlzLiRzdG9yZS5zdGF0ZS5zZWFyY2guZW5kcG9pbnQpXG4gICAgLnRoZW4oaXRlbSA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIiAtIC0gRHluYW1pY0RldGFpbCAvIGl0ZW0gOiBcXG4gXCIsIGl0ZW0pXG4gICAgICAvLyB0aGlzLiRzdG9yZS5jb21taXQoJ3NldERpc3BsYXllZFByb2plY3QnLCB7aXRlbX0pXG4gICAgICB0aGlzLmRpc3BsYXlhYmxlSXRlbSA9IGl0ZW1cbiAgICB9KVxuICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHsgdGhpcy5pc0Vycm9yID0gdHJ1ZSA7IGNvbnNvbGUuZXJyb3IoJ2l0ZW0gcm91dGUgZXJyb3InLCBlcnIpIH0pXG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICAvLyAuLi5tYXBTdGF0ZSh7XG4gICAgLy8gICBwcm9qZWN0OiAnZGlzcGxheWVkUHJvamVjdCcsXG4gICAgLy8gfSksXG4gICAgLi4ubWFwU3RhdGUoe1xuICAgICAgICB1c2VyOiAndXNlcidcbiAgICB9KSxcblxuICAgIC8vIGRlZmF1bHQgdGV4dHNcbiAgICBiYWNrVG9SZXN1bHRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDonYmFja190b19yZXN1bHRzJ30pXG4gICAgfSxcblxuICAgIC8vIFBPU0lUSU9OUyBUTyBCRSBGSUxMRURcbiAgICBsaXN0T2ZQb3NpdGlvbnMoKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImxpc3RPZlBvc2l0aW9ucyAvICB0aGlzLmNvbnRlbnRGaWVsZHMubWFwKCBjID0+IGMucG9zaXRpb24gKSA6XCIsIHRoaXMuY29udGVudEZpZWxkcy5tYXAoIGMgPT4gYy5wb3NpdGlvbiApKVxuICAgICAgcmV0dXJuIHRoaXMuY29udGVudEZpZWxkcy5tYXAoIGMgPT4gYy5wb3NpdGlvbiApXG4gICAgfSxcblxuICAgIC8vIFRFWFQgVFJBTlNMQVRPUlMgLSBOTyBEQVRBIFxuICAgIG5vRGF0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmRlZmF1bHRUZXh0KHt0eHQ6J25vX2RhdGEnfSlcbiAgICB9LFxuICAgIG5vQWJzdHJhY3RUZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDonbm9fYWJzdHJhY3QnfSlcbiAgICB9LFxuICAgIG5vSW5mb3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kZWZhdWx0VGV4dCh7dHh0Oidub19pbmZvJ30pXG4gICAgfSxcbiAgICBub0FkZHJlc3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kZWZhdWx0VGV4dCh7dHh0Oidub19hZGRyZXNzJ30pXG4gICAgfSxcblxuICAgIC8vIFRFWFQgVFJBTlNMQVRPUlMgLSBGSUVMRCBUSVRMRVNcbiAgICBzZWVXZWJzaXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDonc2VlX3dlYnNpdGUnfSlcbiAgICB9LFxuICAgIHNlZUNvbnRhY3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kZWZhdWx0VGV4dCh7dHh0OidzZWVfY29udGFjdCd9KVxuICAgIH0sXG4gICAgc2hhcmVMaW5rKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDonc2hhcmVfbGluayd9KVxuICAgIH0sXG4gICAgc291cmNlRGF0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmRlZmF1bHRUZXh0KHt0eHQ6J3NvdXJjZSd9KVxuICAgIH0sXG4gICAgcGVyaW9kRGF0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmRlZmF1bHRUZXh0KHt0eHQ6J3BlcmlvZCd9KVxuICAgIH0sXG4gICAgaW5mb3NEYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDonaW5mb3MnfSlcbiAgICB9LFxuICAgIGluZm9zVGVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDondGVsJ30pXG4gICAgfSxcbiAgICBpbmZvc09wZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kZWZhdWx0VGV4dCh7dHh0OidvcGVuX2luZm9zJ30pXG4gICAgfSxcbiAgICBpbmZvc01vcmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kZWZhdWx0VGV4dCh7dHh0Oidtb3JlX2luZm9zJ30pXG4gICAgfSxcbiAgICBzZXJ2aWNlc0RhdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kZWZhdWx0VGV4dCh7dHh0OidzZXJ2aWNlcyd9KVxuICAgIH0sXG4gICAgZG93bmxvYWRGaWxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDonZG93bG9hZF9maWxlJ30pXG4gICAgfSxcbiAgICAvLyBwcm9qZWN0Rm9ybWF0dGVkKCl7XG4gICAgLy8gICBpZiAoIXRoaXMucHJvamVjdCkge1xuICAgIC8vICAgICByZXR1cm4ge1xuICAgIC8vICAgICAgIHRhZ3M6IFtdLFxuICAgIC8vICAgICAgIGltYWdlOiAnJyxcbiAgICAvLyAgICAgICBsb2dvX3VybDogJycsXG4gICAgLy8gICAgICAgdGl0bGU6ICcnLFxuICAgIC8vICAgICAgIGFkZHJlc3M6ICcnLFxuICAgIC8vICAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAvLyAgICAgICBwcm9qZWN0UGFydG5lcnM6ICcnLFxuICAgIC8vICAgICAgIHdlYnNpdGU6ICcnLFxuICAgIC8vICAgICAgIHBhZ2VBdFNvdXJjZXI6ICcnXG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH0gZWxzZSB7XG4gICAgLy8gICAgIC8vIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldFByb2plY3RDb25maWdVbmlmb3JtKHRoaXMucHJvamVjdClcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMucHJvamVjdFxuICAgIC8vICAgfVxuICAgIC8vIH0sXG5cblxuXG4gIH0sXG5cbiAgbWV0aG9kcyA6IHtcblxuICAgIGlzUG9zaXRpb25GaWxsZWQoZmllbGRCbG9jayl7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImlzUG9zaXRpb25GaWxsZWQgLyAgZmllbGRCbG9jayA6XCIsIGZpZWxkQmxvY2spXG4gICAgICByZXR1cm4gdGhpcy5saXN0T2ZQb3NpdGlvbnMuaW5kZXhPZihmaWVsZEJsb2NrKSAhPT0gLTFcbiAgICB9LFxuXG4gICAgaXRlbUltYWdlKGZpZWxkQmxvY2spe1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0SW1hZ2VVcmwoe2l0ZW06IHRoaXMuZGlzcGxheWFibGVJdGVtLCBwb3NpdGlvbjogZmllbGRCbG9ja30pXG4gICAgICAvLyByZXR1cm4gdGhpcy5pdGVtXG4gICAgfSxcbiAgICBtYXRjaFByb2plY3RXaXRoQ29uZmlnKGZpZWxkQmxvY2spIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRGaWVsZCA9IHRoaXMuY29udGVudEZpZWxkcy5maW5kKGY9PiBmLnBvc2l0aW9uID09IGZpZWxkQmxvY2spXG4gICAgICAvLyBjb25zb2xlLmxvZyhcImNvbnRlbnRGaWVsZCA6IFwiLCBjb250ZW50RmllbGQpXG4gICAgICBpZiAoY29udGVudEZpZWxkKXtcbiAgICAgICAgY29uc3QgZmllbGQgPSBjb250ZW50RmllbGQuZmllbGRcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmRpc3BsYXlhYmxlSXRlbVtmaWVsZF1cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJjb250ZW50IDogXCIsIGNvbnRlbnQpXG4gICAgICAgIGlmICggY29udGVudCAmJiBjb250ZW50ICE9PSBcIk5vbmVcIiAmJiBjb250ZW50ICE9PSBcIlwiICl7XG4gICAgICAgICAgaWYgKGNvbnRlbnRGaWVsZC5pc190YWdfbGlrZSkge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3BsaXQoY29udGVudEZpZWxkLnRhZ3Nfc2VwYXJhdG9yKS5maWx0ZXIoYyA9PiBjICE9IFwiXCIpXG4gICAgICAgICAgICByZXR1cm4gY29udGVudFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImNvbnRlbnQgaXMgTm9uZSB8IG51bGwgLi4uXCIpXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ0aGlzLm5vRGF0YSA6IFwiLCB0aGlzLm5vRGF0YSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub0RhdGFcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Q3VzdG9tQmxvY2tUaXRsZShmaWVsZEJsb2NrKXtcbiAgICAgIGxldCBjdXN0b21CbG9ja1RpdGxlID0gdW5kZWZpbmVkXG4gICAgICBjb25zdCBjb250ZW50RmllbGQgPSB0aGlzLmNvbnRlbnRGaWVsZHMuZmluZChmPT4gZi5wb3NpdGlvbiA9PSBmaWVsZEJsb2NrKVxuICAgICAgaWYgKGNvbnRlbnRGaWVsZCl7XG4gICAgICAgIGN1c3RvbUJsb2NrVGl0bGUgPSBjb250ZW50RmllbGQuY3VzdG9tX3RpdGxlXG4gICAgICB9XG4gICAgICByZXR1cm4gY3VzdG9tQmxvY2tUaXRsZVxuICAgIH0sXG5cbiAgICBwcm9qZWN0SWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaFByb2plY3RXaXRoQ29uZmlnKCdibG9ja19pZCcpXG4gICAgfSxcblxuICAgIC8vIHByb2plY3RBYnN0cmFjdCgpIHtcbiAgICAvLyAgIGxldCBmdWxsQWJzdHJhY3QgPSB0aGlzLm1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX2Fic3RyYWN0JylcbiAgICAvLyAgIGZ1bGxBYnN0cmFjdCA9ICggZnVsbEFic3RyYWN0ID09IG51bGwgKSA/IHRoaXMubm9BYnN0cmFjdFRleHQgOiBmdWxsQWJzdHJhY3RcbiAgICAvLyAgIGNvbnN0IHRhaWwgPSBmdWxsQWJzdHJhY3QubGVuZ3RoID4gTUFYX1NVTU1BUllfTEVOR1RIID8gJy4uLicgOiAnJztcbiAgICAvLyAgIHJldHVybiBmdWxsQWJzdHJhY3Quc2xpY2UoMCwgTUFYX1NVTU1BUllfTEVOR1RIKSArIHRhaWxcbiAgICAvLyB9LFxuICAgIC8vIHByb2plY3RJbmZvKGZpZWxkKSB7XG4gICAgLy8gICBsZXQgZnVsbEluZm8gPSB0aGlzLm1hdGNoUHJvamVjdFdpdGhDb25maWcoZmllbGQpXG4gICAgLy8gICBmdWxsSW5mbyA9ICggZnVsbEluZm8gPT0gbnVsbCApID8gdGhpcy5ub0luZm9zIDogZnVsbEluZm9cbiAgICAvLyAgIHJldHVybiBmdWxsSW5mb1xuICAgIC8vIH0sXG4gICAgLy8gcHJvamVjdEFkZHJlc3MoKSB7XG4gICAgLy8gICBsZXQgZnVsbEFkZHJlc3MgPSB0aGlzLm1hdGNoUHJvamVjdFdpdGhDb25maWcoJ2Jsb2NrX2FkZHJlc3MnKVxuICAgIC8vICAgLy8gY29uc29sZS5sb2coJ2Z1bGxBZGRyZXNzIDogJywgZnVsbEFkZHJlc3MpXG4gICAgLy8gICBsZXQgYWRkcmVzcyA9ICggZnVsbEFkZHJlc3MgfHwgZnVsbEFkZHJlc3MgIT09ICdOb25lJyApID8gIGZ1bGxBZGRyZXNzIDogdGhpcy5ub0FkZHJlc3NcbiAgICAvLyAgIHJldHVybiBhZGRyZXNzXG4gICAgLy8gfSxcblxuXG4gICAgZ29CYWNrKGUpe1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdGhpcy4kcm91dGVyLmJhY2soKVxuICAgIH1cbiAgfSxcblxufVxuPC9zY3JpcHQ+XG5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuICBAaW1wb3J0ICcuLi8uLi9zdHlsZXMvYXBpdml6LWNvbG9ycy5zY3NzJztcbiAgQGltcG9ydCAnLi4vLi4vc3R5bGVzL2FwaXZpei1taXNjLnNjc3MnO1xuXG4gIG1haW57XG4gICAgLy8gYmFja2dyb3VuZC1jb2xvcjogJGFwaXZpei1ibHVlLWRlZXA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJGFwaXZpei1ncmV5LWJhY2tncm91bmQ7XG4gICAgbWFyZ2luLXRvcDogJGFwaXZpei1uYXZiYXItaGVpZ2h0O1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBwYWRkaW5nLWJvdHRvbTogM2VtO1xuICAgIFxuICB9XG5cbiAgLmJsb2NrLWNvbG9yIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkYXBpdml6LXNlY29uZGFyeSAhaW1wb3J0YW50O1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgfVxuXG4gIC50YWd7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkYXBpdml6LXNlY29uZGFyeTtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIG1hcmdpbi1yaWdodDogMWVtO1xuICAgICAgbWFyZ2luLWJvdHRvbTogMC41ZW07XG4gIH1cblxuICBhLmRpc2FibGVkIHtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICBib3JkZXItYm90dG9tOiBub25lICFpbXBvcnRhbnQgO1xuICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgfVxuXG4gIGEuYmFja3tcbiAgICBwYWRkaW5nOiAxZW0gMDtcbiAgICBkaXNwbGF5OiBibG9jaztcblxuICAgIGNvbG9yOiAkYXBpdml6LXRleHQtY29sb3I7XG4gICAgLy8gY29sb3I6IHdoaXRlIDtcblxuICAgIGltZywgLmljb257XG4gICAgICBoZWlnaHQ6IDEuNWVtO1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAuM2VtKTtcbiAgICB9XG5cbiAgICBzcGFue1xuICAgICAgbWFyZ2luLWxlZnQ6IDFlbTtcbiAgICAgIC8vIGNvbG9yOiB3aGl0ZSA7XG4gICAgfVxuICB9XG5cbiAgLmNvbHVtbnN7XG4gICAgICBtYXJnaW4tdG9wOiAwO1xuICB9XG5cbiAgLmlsbHVzdHJhdGlvbntcbiAgICB3aWR0aDogMTAwJTtcbiAgICBtYXJnaW4tYm90dG9tOiAxZW07XG4gIH1cblxuICAuZGVzY3JpcHRpb24sIC5hZGRlZHtcbiAgICAvLyBiYWNrZ3JvdW5kLWNvbG9yOiAkYXBpdml6LWJsdWUtZGVlcDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICAvLyBjb2xvcjogd2hpdGU7XG4gICAgcGFkZGluZzogMWVtO1xuICAgIG1hcmdpbi1ib3R0b206IDFlbTtcbiAgfVxuXG4gIC5kZXNjcmlwdGlvbntcbiAgICBoMXtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuXG4gICAgcHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMWVtO1xuICAgIH1cblxuICAgIGF7XG4gICAgICAgIGNvbG9yOiAkYXBpdml6LXByaW1hcnk7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAkYXBpdml6LXByaW1hcnk7XG4gICAgfVxuICB9XG5cblxuICAuYWRkZWQge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogbGVmdDtcblxuICAgIC5saW5rLWF0LXNvdXJjZXIgaW1ne1xuICAgICAgICBtYXgtaGVpZ2h0OiAxLjFlbTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAuMmVtKTtcbiAgICB9XG5cbiAgICBpbWd7XG4gICAgICAgIGhlaWdodDphdXRvO1xuICAgIH1cblxuICAgIC5uby1sZWZ0LXBhZGRpbmcge1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDBlbTtcbiAgICB9XG4gICAgLmlzLXZlcnRpY2FsLWNlbnRlcmVkIHtcbiAgICAgICAgLy8gcGFkZGluZy1sZWZ0OiAxZW07XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgfVxuXG4gICAgLmxvZ28ge1xuICAgICAgICAvLyBtYXgtd2lkdGg6IDE3NXB4O1xuICAgICAgICBoZWlnaHQ6IGF1dG87XG4gICAgICAgIHdpZHRoOjEwMCU7XG4gICAgfVxuXG4gICAgYXtcbiAgICAgICAgY29sb3I6ICRhcGl2aXotcHJpbWFyeTtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuICB9XG5cbiAgLmNvbnRlbnR7XG4gICAgaDJ7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIH1cblxuICB9XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICA8RHluYW1pY1NlYXJjaFNjcmVlblNxdWVsZXRvbiBcbiAgICA6ZmlsdGVyc0NvbmZpZz1cImZpbHRlcnNDb25maWdcIlxuICAgIG1haW5DbGFzcz1cImxpc3RcIlxuICAgID5cbiAgICA8U2VhcmNoUmVzdWx0c0xpc3RcbiAgICAgIDpyb3V0ZUNvbmZpZz1cInJvdXRlQ29uZmlnXCJcbiAgICAgIDpwcm9qZWN0Q29udGVudHNGaWVsZHM9XCJyb3V0ZUNvbmZpZy5jb250ZW50c19maWVsZHNcIlxuICAgICAgLz5cbiAgICA8IS0tIDpsb2dvPVwibG9nb1wiIFxuICAgIDpicmFuZD1cImJyYW5kXCIgIC0tPlxuICA8L0R5bmFtaWNTZWFyY2hTY3JlZW5TcXVlbGV0b24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHttYXBTdGF0ZX0gZnJvbSAndnVleCdcblxuaW1wb3J0IER5bmFtaWNTZWFyY2hTY3JlZW5TcXVlbGV0b24gZnJvbSAnLi9EeW5hbWljU2VhcmNoU2NyZWVuU3F1ZWxldG9uLnZ1ZSdcbmltcG9ydCBTZWFyY2hSZXN1bHRzTGlzdCBmcm9tICcuL1NlYXJjaFJlc3VsdHNMaXN0LnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICBuYW1lOiAnRHluYW1pY0xpc3QnLFxuXG4gIHByb3BzOltcbiAgICAncm91dGVDb25maWcnLFxuICAgICdlbmRQb2ludENvbmZpZycsXG4gICAgJ2ZpbHRlcnNDb25maWcnXG4gICAgLy8gJ2xvZ28nLCBcbiAgICAvLyAnYnJhbmQnXG4gIF0sXG5cbiAgZGF0YTogKCkgPT4ge1xuICAgIHJldHVybiAgIHtcbiAgICAgIC8vIGxvY2FsRmlsdGVyc0NvbmZpZyA6IHVuZGVmaW5lZCxcbiAgICB9XG4gIH0sXG4gIC8vIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAvLyAgIGNvbnNvbGUubG9nKFwiXFxuIC0gLSBEeW5hbWljTGlzdCAvIGJlZm9yZUNyZWF0ZSAuLi4gXCIpXG4gIC8vIH0sXG4gIC8vIGNyZWF0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgLy8gICBjb25zb2xlLmxvZyhcIlxcbiAtIC0gRHluYW1pY0xpc3QgLyBjcmVhdGVkIC4uLiBcIilcbiAgLy8gfSxcbiAgLy8gYmVmb3JlTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgLy8gICBjb25zb2xlLmxvZyhcIlxcbiAtIC0gRHluYW1pY0xpc3QgLyBiZWZvcmVNb3VudCAuLi4gXCIpXG4gICAgLy8gbGV0IGRhdGFzZXRGaWx0ZXJzID0gdGhpcy4kc3RvcmUuZ2V0dGVycygnZ2V0Um91dGVDb25maWdGaWx0ZXJzRm9yRGF0YXNldCcpXG4gICAgLy8gY29uc29sZS5sb2coXCIgLSAtIER5bmFtaWNTY3JlZW4gLyBkYXRhc2V0RmlsdGVycyA6IFxcbiBcIiwgbG9jYWxGaWx0ZXJzQ29uZmlnKVxuICAgIC8vIHRoaXMubG9jYWxGaWx0ZXJzID0gZGF0YXNldEZpbHRlcnMuZmlsdGVyc19kZXNjcmlwdGlvblxuICAgIC8vIGNvbnNvbGUubG9nKFwiIC0gLSBEeW5hbWljU2NyZWVuIC8gdGhpcy5yb3V0ZUNvbmZpZyA6IFxcbiBcIiwgdGhpcy5yb3V0ZUNvbmZpZylcbiAgLy8gfSxcbiAgLy8gbW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAvLyAgIGNvbnNvbGUubG9nKFwiXFxuIC0gLSBEeW5hbWljTGlzdCAvIG1vdW50ZWQgLi4uIFwiKVxuICAvLyAgIGNvbnNvbGUubG9nKFwiLSAtIER5bmFtaWNMaXN0IC8gdGhpcy5yb3V0ZUNvbmZpZ1wiLCB0aGlzLnJvdXRlQ29uZmlnKVxuICAvLyB9LFxuXG4gIGNvbXBvbmVudHM6IHtcbiAgICBEeW5hbWljU2VhcmNoU2NyZWVuU3F1ZWxldG9uLCBcbiAgICBTZWFyY2hSZXN1bHRzTGlzdFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIC4uLm1hcFN0YXRlKHtcbiAgICAgIHVzZXI6ICd1c2VyJ1xuICAgIH0pLFxuXG4gIH0sXG59XG48L3NjcmlwdD5cbjxzdHlsZT5cbi5saXN0IC5maWx0ZXItZmVlZGJhY2t7XG4gIHBhZGRpbmctYm90dG9tOiAwO1xufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgPER5bmFtaWNTZWFyY2hTY3JlZW5TcXVlbGV0b24gXG4gICAgOmZpbHRlcnNDb25maWc9XCJmaWx0ZXJzQ29uZmlnXCJcbiAgICBtYWluQ2xhc3M9XCJsaXN0XCJcbiAgICA+XG4gICAgPFNlYXJjaFJlc3VsdHNNYXBcbiAgICAgIDpyb3V0ZUNvbmZpZz1cInJvdXRlQ29uZmlnXCJcbiAgICAgIDplbmRQb2ludENvbmZpZz1cImVuZFBvaW50Q29uZmlnXCJcbiAgICAvPlxuICA8L0R5bmFtaWNTZWFyY2hTY3JlZW5TcXVlbGV0b24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHttYXBTdGF0ZX0gZnJvbSAndnVleCdcblxuaW1wb3J0IER5bmFtaWNTZWFyY2hTY3JlZW5TcXVlbGV0b24gZnJvbSAnLi9EeW5hbWljU2VhcmNoU2NyZWVuU3F1ZWxldG9uLnZ1ZSdcbmltcG9ydCBTZWFyY2hSZXN1bHRzTWFwIGZyb20gJy4vU2VhcmNoUmVzdWx0c01hcC52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdEeW5hbWljTWFwJywgIFxuICBwcm9wczpbXG4gICAgJ3JvdXRlQ29uZmlnJyxcbiAgICAnZW5kUG9pbnRDb25maWcnLFxuICAgICdmaWx0ZXJzQ29uZmlnJyxcbiAgICAvLyAnbG9nbycsIFxuICAgIC8vICdicmFuZCdcbiAgXSxcbiAgY29tcG9uZW50czoge1xuICAgIER5bmFtaWNTZWFyY2hTY3JlZW5TcXVlbGV0b24sIFxuICAgIFNlYXJjaFJlc3VsdHNNYXBcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICAuLi5tYXBTdGF0ZSh7XG4gICAgICB1c2VyOiAndXNlcidcbiAgICB9KVxuICB9LFxufVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4gIC5saXN0IC5maWx0ZXItZmVlZGJhY2t7XG4gICAgcGFkZGluZy1ib3R0b206IDFlbTtcbiAgfVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8U2VhcmNoV2l0aEZpbHRlcnNcbiAgICAgIDpmaWx0ZXJzQ29uZmlnPVwiZmlsdGVyc0NvbmZpZ1wiXG4gICAgLz5cbiAgICA8bWFpbiA6Y2xhc3M9XCJtYWluQ2xhc3NcIj5cbiAgICAgIDxGaWx0ZXJzRmVlZGJhY2svPlxuICAgICAgPHNsb3QvPlxuICAgIDwvbWFpbj5cblxuICAgIDwhLS0gREVCVUdHSU5HIC0tPlxuICAgICAgPCEtLSBcbiAgICAgICAgPGJyPjxicj5cbiAgICAgIER5bmFtaWNTZWFyY2hTcXVlbGV0b24gLy8gZW5kcG9pbnRDb25maWcgOiA8YnI+PGNvZGU+e3sgdGhpcy5lbmRwb2ludENvbmZpZyB9fTwvY29kZT5cbiAgICAgIDxicj48YnI+XG4gICAgICBEeW5hbWljU2VhcmNoU3F1ZWxldG9uIC8vIGdldEVuZHBvaW50Q29uZmlnRmlsdGVycyA6IDxicj48Y29kZT57eyB0aGlzLmdldEVuZHBvaW50Q29uZmlnRmlsdGVycyB9fTwvY29kZT4gXG4gICAgLS0+IFxuXG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbi8vIGltcG9ydCBOYXZCYXIgZnJvbSAnLi9OYXZCYXIudnVlJztcbmltcG9ydCBTZWFyY2hXaXRoRmlsdGVycyBmcm9tICcuL1NlYXJjaFdpdGhGaWx0ZXJzLnZ1ZSc7XG5pbXBvcnQgRmlsdGVyc0ZlZWRiYWNrIGZyb20gJy4vRmlsdGVyc0ZlZWRiYWNrLnZ1ZSc7XG4vLyBpbXBvcnQgRm9vdGVyIGZyb20gJy4vRm9vdGVyLnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ0R5bmFtaWNTZWFyY2hTY3JlZW5TcXVlbGV0b24nLFxuICBjb21wb25lbnRzOiB7XG4gICAgLy8gTmF2QmFyLCBcbiAgICBTZWFyY2hXaXRoRmlsdGVycywgXG4gICAgRmlsdGVyc0ZlZWRiYWNrLCBcbiAgICAvLyBGb290ZXJcbiAgfSxcblx0cHJvcHM6IFtcbiAgICAvLyAnbG9nbycsIFxuICAgIC8vICdicmFuZCcsIFxuICAgICdmaWx0ZXJzQ29uZmlnJyxcbiAgICAnbWFpbkNsYXNzJ1xuICBdLFxuICBjb21wdXRlZCA6IHtcbiAgICAvLyBlbmRwb2ludENvbmZpZygpIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldEVuZHBvaW50Q29uZmlnXG4gICAgLy8gfSxcbiAgICAvLyBnZXRFbmRwb2ludENvbmZpZ0ZpbHRlcnMoKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRFbmRwb2ludENvbmZpZ0ZpbHRlcnNcbiAgICAvLyB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgJy4uLy4uL3N0eWxlcy9hcGl2aXotbWlzYy5zY3NzJztcblxubWFpbntcbiAgbWFyZ2luLXRvcDogJGFwaXZpei1uYXZiYXItaGVpZ2h0ICsgJGFwaXZpei1zZWFyY2gtYmFyLWhlaWdodDtcbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gIDwhLS0gPHNlY3Rpb24gY2xhc3M9XCJpcy1saWdodCBza2lwLW5hdmJhclwiPiAtLT5cblxuICAgIDwhLS0gREVCVUdHSU5HIC0tPlxuICAgIDwhLS0gPGRpdj5cbiAgICAgICAgLSByb3V0ZUNvbmZpZyA6IDxicj48Y29kZT57eyB0aGlzLnJvdXRlQ29uZmlnIH19PC9jb2RlPjxicj5cbiAgICAgICAgLSBhcHBDb25maWcgOiA8YnI+PGNvZGU+e3sgdGhpcy5hcHBDb25maWcgfX08L2NvZGU+PGJyPlxuICAgICAgICAtIG5hdmJhckNvbmZpZyA6IDxicj48Y29kZT57eyB0aGlzLm5hdmJhckNvbmZpZyB9fTwvY29kZT48YnI+XG4gICAgPC9kaXY+XG5cbiAgICA8aHI+IFxuICAgIHMtLT5cblxuXG4gICAgPCEtLSBNQUlOIFBBUlQgLS0+XG4gICAgPGRpdiBjbGFzcz1cInNraXAtbmF2YmFyXCI+XG5cbiAgICAgIDxzcGFuIHYtaHRtbD1cInJhd0h0bWxcIj48L3NwYW4+XG5cbiAgICA8L2Rpdj5cblxuXG5cblxuICA8IS0tIDwvc2VjdGlvbj4gLS0+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHttYXBTdGF0ZX0gZnJvbSAndnVleCdcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcydcbmltcG9ydCB7bG9hZFNjcmlwdCwgYWN0aXZhdGVDYXJvdXNlbH0gZnJvbSAnLi4vdXRpbHMnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ0R5bmFtaWNTdGF0aWMnLFxuICBwcm9wczpbXG4gICAgJ3JvdXRlQ29uZmlnJyxcbiAgICAnbmF2YmFyQ29uZmlnJ1xuICBdLFxuICBkYXRhOiAoKSA9PiB7XG4gICAgcmV0dXJuICAge1xuICAgICAgcmF3SHRtbCA6ICcnXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIC4uLm1hcFN0YXRlKHtcbiAgICAgIHVzZXI6ICd1c2VyJ1xuICAgIH0pXG4gIH0sXG5cbiAgd2F0Y2ggOiB7XG4gICAgcm91dGVDb25maWcob2xkKXtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuIC0gLSBEeW5hbWljU3RhdGljIC8gd2F0Y2ggLyByb3V0ZUNvbmZpZyAuLi4gXCIpXG4gICAgICB0aGlzLnJhd0h0bWwgPSAnJ1xuICAgICAgdGhpcy5nZXRSYXdIdG1sKClcbiAgICB9LFxuICAgIHJhd0h0bWwobmV3UmF3SHRtbCwgb2xkUmF3SHRtbCl7XG4gICAgICBpZiAob2xkUmF3SHRtbCA9PSAnJyAmJiBuZXdSYXdIdG1sICE9ICcnKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJyYXdIdG1sIGlzIG5vdCBibGFuayBhbnltb3JlXCIpXG4gICAgICAgIHRoaXMubG9hZEV4dFNjcmlwdCgpXG4gICAgICB9XG4gICAgICBlbHNle1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhvbGRSYXdIdG1sLCBuZXdSYXdIdG1sKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiZWZvcmVNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuIC0gLSBEeW5hbWljU3RhdGljIC8gYmVmb3JlTW91bnQgLi4uIFwiKVxuICB9LFxuXG4gIG1vdW50ZWQoKXtcbiAgICAvLyBjb25zb2xlLmxvZyhcIlxcbiAtIC0gRHluYW1pY1N0YXRpYyAvIG1vdW50ZWQgLi4uIFwiKVxuICAgIHRoaXMuZ2V0UmF3SHRtbCgpXG4gIH0sXG5cbiAgbWV0aG9kczoge1xuXG4gICAgZ2V0UmF3SHRtbCgpe1xuICAgICAgLy8gaGFjayB0byBzY3JvbGwgdG9wIGJlY2F1c2UgdnVlLXJvdXRlciBzY3JvbGxCZWhhdmlvciB0aGluZyBkb2Vzbid0IHNlZW0gdG8gd29yayBvbiBGaXJlZm94IG9uIExpbnV4IGF0IGxlYXN0XG4gICAgICBjb25zdCBpbnQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmKHdpbmRvdy5wYWdlWU9mZnNldCA8IDUwKXtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50KVxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTtcblxuICAgICAgLy8gaGVyZSB3ZSBnbyBmZXRjaCB0aGUgcmF3IEhUTUwgY29udGVudCBvZiBhIHdlYnBhZ2VcbiAgICAgIGxldCB0ZW1wbGF0ZV91cmwgPSAodGhpcy5yb3V0ZUNvbmZpZyAmJiB0aGlzLnJvdXRlQ29uZmlnLnRlbXBsYXRlX3VybCkgPyB0aGlzLnJvdXRlQ29uZmlnLnRlbXBsYXRlX3VybCA6ICdodHRwczovL2NvLWRlbW9zLmNvbS9lcnJvcidcbiAgICAgIGNvbnNvbGUubG9nKHRlbXBsYXRlX3VybCArIFwiIGlzIHRlbXBsYXRlXCIpXG4gICAgICBsZXQgaGVhZCA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAvLyAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbic6ICcqJywgLy8gVW5jb21tZW50ZWQsIHRvIHRyeVxuICAgICAgICAgICdhY2NlcHQnIDogJ3RleHQvaHRtbCcsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmF3SHRtbCA9ICcnXG4gICAgICBheGlvcy5nZXQodGVtcGxhdGVfdXJsLCBoZWFkKVxuICAgICAgICAudGhlbiggKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgdGhpcy5yYXdIdG1sID0gKHJlc3BvbnNlICYmIHJlc3BvbnNlLmRhdGEpID8gcmVzcG9uc2UuZGF0YSA6ICc8YnI+PGJyPnRoZXJlIGlzIGFuIEVycm9yIDxicj48YnI+J31cbiAgICAgICAgKVxuICAgICAgICAuY2F0Y2goIChlcnIpID0+IHt0aGlzLnJhd0h0bWwgPSAnPGJyPjxicj50aGVyZSBpcyBhbiA8c3Ryb25nPiBFcnJvciA8L3N0cm9uZz48YnI+PGJyPid9IClcblxuICAgIH0sXG5cbiAgICBsb2FkRXh0U2NyaXB0KCl7XG4gICAgICAvLyBJTVBPUlTCoEVYVCBTQ1JJUFRcbiAgICAgIC8vIENmOlxuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTczNDExMjIvbGluay1hbmQtZXhlY3V0ZS1leHRlcm5hbC1qYXZhc2NyaXB0LWZpbGUtaG9zdGVkLW9uLWdpdGh1YlxuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDUwNDcxMjYvaG93LXRvLWFkZC1leHRlcm5hbC1qcy1zY3JpcHRzLXRvLXZ1ZWpzLWNvbXBvbmVudHNcbiAgICAgIGlmICh0aGlzLnJvdXRlQ29uZmlnICYmIHRoaXMucm91dGVDb25maWcuaGFzX2V4dF9zY3JpcHQpIHtcblxuICAgICAgICBsZXQgZXh0X3NjcmlwdF91cmwgPSB0aGlzLnJvdXRlQ29uZmlnLmV4dF9zY3JpcHRfdXJsO1xuICAgICAgICBjb25zb2xlLmxvZyhleHRfc2NyaXB0X3VybCArIFwiIGlzIGV4dF9zY3JpcHRcIilcbiAgICAgICAgbGV0IGV4dFNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBleHRTY3JpcHQuc2V0QXR0cmlidXRlKCdzcmMnLCBleHRfc2NyaXB0X3VybCk7XG4gICAgICAgIGV4dFNjcmlwdC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCBcInRleHQvamF2YXNjcmlwdFwiKTtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChleHRTY3JpcHQpO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIEFDVElWQVRFwqBDQVJPVVNFTFNcbiAgICAgIGlmICh0aGlzLnJvdXRlQ29uZmlnICYmIHRoaXMucm91dGVDb25maWcuaGFzX2Nhcm91c2VsKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJsb2FkIGNhcm91c2VsIGZyb20gdXRpbHNcIik7XG4gICAgICAgIGxvYWRTY3JpcHQoXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2J1bG1hLWNhcm91c2VsQDQuMC40L2Rpc3QvanMvYnVsbWEtY2Fyb3VzZWwubWluLmpzXCIsIGFjdGl2YXRlQ2Fyb3VzZWwpO1xuICAgICAgICBcbiAgICAgICAgLy8gYWN0aXZhdGVDYXJvdXNlbCgpIFxuICAgICAgICAvLyBhY3RpdmF0ZUNhcm91c2VsKHNsaWRlc051bWJlcj0yLCBpc0luZmluaXRlPXRydWUsIGhhc1BhZ2luYXRpb249dHJ1ZSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ29CYWNrKGUpe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB0aGlzLiRyb3V0ZXIuYmFjaygpXG4gICAgfVxuXG4gIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxzcGFuIHYtaHRtbD1cInJhd0h0bWxcIj5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7bWFwU3RhdGV9IGZyb20gJ3Z1ZXgnXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczpbXG4gICAgICAvLyAncm91dGVDb25maWcnLFxuICAgICAgJ3RlbXBsYXRlVVJMJ1xuICAgIF0sXG4gIGRhdGE6ICgpID0+IHtcbiAgICByZXR1cm4gICB7XG4gICAgICByYXdIdG1sIDogJydcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgLi4ubWFwU3RhdGUoe1xuICAgICAgdXNlcjogJ3VzZXInXG4gICAgfSlcbiAgfSxcbiAgbW91bnRlZCgpe1xuICAgIC8vIGhlcmUgd2UgZ28gZmV0Y2ggdGhlIHJhdyBIVE1MIGNvbnRlbnQgb2YgYSB3ZWJwYWdlXG4gICAgbGV0IHRlbXBsYXRlX3VybCA9ICh0aGlzLnRlbXBsYXRlVVJMKSA/IHRoaXMudGVtcGxhdGVVUkwgOiAnaHR0cHM6Ly9jby1kZW1vcy5jb20vZXJyb3InXG4gICAgbGV0IGhlYWQgPSB7IFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAvLyAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLFxuICAgICAgICAnYWNjZXB0JyA6ICd0ZXh0L2h0bWwnLFxuICAgICAgfVxuICAgIH1cbiAgICBheGlvcy5nZXQodGVtcGxhdGVfdXJsLCBoZWFkKVxuICAgICAgLnRoZW4oIChyZXNwb25zZSkgPT4geyBcbiAgICAgICAgLy8gY29uc29sZS5sb2cocmVzcG9uc2UpOyBcbiAgICAgICAgdGhpcy5yYXdIdG1sID0gKHJlc3BvbnNlICYmIHJlc3BvbnNlLmRhdGEpID8gcmVzcG9uc2UuZGF0YSA6ICc8YnI+PGJyPnRoZXJlIGlzIGFuIEVycm9yIDxicj48YnI+J30gXG4gICAgICApXG4gICAgICAuY2F0Y2goIChlcnIpID0+IHt0aGlzLnJhd0h0bWwgPSAnPGJyPjxicj50aGVyZSBpcyBhbiA8c3Ryb25nPiBFcnJvciA8L3N0cm9uZz48YnI+PGJyPid9IClcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICBnb0JhY2soZSl7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIHRoaXMuJHJvdXRlci5iYWNrKClcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwic2tpcC1uYXZiYXJcIj5cblxuXG5cblxuXG4gICAgPCEtLSBNQUlOIElOVFJPIC0tPlxuICAgIDxkaXYgaWQ9XCJ0b3BcIj48L2Rpdj5cbiAgICA8c2VjdGlvbiBzdHlsZT1cInBhZGRpbmc6IDVlbSAwZW0gNWVtIDBlbVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgPGgxIGNsYXNzPVwidGl0bGUgaGFzLXRleHQtY2VudGVyZWRcIj5cbiAgICAgICAgICAgIEZhaXJlIHNvY2nDqXTDqSDDoCBsJ2hldXJlIGR1IG51bcOpcmlxdWUgOjxicj5cbiAgICAgICAgICAgIEZvcm1lciBldCBhY2NvbXBhZ25lciBjaGFjdW4gXG4gICAgICAgICAgPC9oMT5cbiAgICAgICAgICA8YnI+XG4gICAgICAgICAgPGgxIGNsYXNzPVwic3VidGl0bGUgaGFzLXRleHQtY2VudGVyZWRcIj5cbiAgICAgICAgICAgIFBsYXRlZm9ybWUgcmVzc291cmNlIHBvdXIgbGVzIGNvbGxlY3Rpdml0w6lzIHRlcnJpdG9yaWFsZXNcbiAgICAgICAgICA8L2gxPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvc2VjdGlvbj5cblxuXG4gICAgPCEtLSBCVUxNQSBDQVJEUyBPRiBFUVVBTCBTSVpFIC8gY2YgOiBodHRwczovL2pzZmlkZGxlLm5ldC9Ba3NoYXlhS1QvMXljNDVkb3MvIC0tPlxuXG4gICAgPCEtLSBERVBMT1kgLS0+XG4gICAgPGRpdiBpZD1cImRlcGxveVwiPjwvZGl2PlxuICAgIDxzZWN0aW9uIGNsYXNzPVwiaGFzLWJhY2tncm91bmQtaW5mb1wiIHN0eWxlPVwicGFkZGluZzogM2VtIDBlbSAzZW0gMGVtXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG5cbiAgICAgICAgPCEtLSBDT0xVTU5TIENBUkRTIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1ucyBpcy1jZW50ZXJlZCBpcy1tb2JpbGVcIj5cblxuICAgICAgICAgIDwhLS0gREVQTE9ZIC0tPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtdHdvLXRoaXJkc1wiPlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgY2xhc3M9XCJjYXJkXCJcbiAgICAgICAgICAgICAgc3R5bGU9XCJkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2hlaWdodDoxMDAlO3BhZGRpbmc6MmVtXCJcbiAgICAgICAgICAgID5cblxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1jb250ZW50XCIgc3R5bGU9XCJmbGV4OmF1dG87XCI+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWVkaWFcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZWRpYS1jb250ZW50IGhhcy10ZXh0LWNlbnRlcmVkXCI+XG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwidGl0bGUgaXMtNCBcIj5cbiAgICAgICAgICAgICAgICAgICAgICBDb21tZW50IGTDqXBsb3llciBsZSBQYXNzIE51bcOpcmlxdWUgc3VyIG1vbiB0ZXJyaXRvaXJlID9cbiAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8YnI+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgRW4gMjAxOSwgbCdFdGF0IG1vYmlsaXNlIDcsNSBtaWxsaW9ucyBkJ2V1cm9zIHBvdXIgbGUgZMOpcGxvaWVtZW50IGR1IFBhc3MgTnVtw6lyaXF1ZSBzdXIgbCdlbnNlbWJsZSBkdSB0ZXJyaXRvaXJlLiBVbiBhcHBlbCDDoCBwcm9qZXRzIMOgIGRlc3RpbmF0aW9uIGRlcyBjb2xsZWN0aXZpdMOpcyBlc3QgbGFuY8OpIGFmaW4gZGUgbGV1ciBwZXJtZXR0cmUgZCdvYnRlbmlyIHVuIGZpbmFuY2VtZW50IGRlIGwnRXRhdCBwb3VyIGFjaGV0ZXIgZGVzIFBhc3MgTnVtw6lyaXF1ZXMuXG4gICAgICAgICAgICAgICAgICA8YnI+PGJyPlxuICAgICAgICAgICAgICAgICAgQSBxdWVsIG1vbnRhbnQgZGUgY29maW5hbmNlbWVudCBzdWlzLWplIMOpbGlnaWJsZSA/XG4gICAgICAgICAgICAgICAgICA8YnI+PGJyPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudCBoYXMtdGV4dC1jZW50ZXJlZFwiPlxuXG4gICAgICAgICAgICAgICAgICA8YSBcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidXR0b24gaXMtcHJpbWFyeSBpcy1tZWRpdW1cIiBcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJwYWRkaW5nOjEuNWVtO1wiXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwczovL3NvY2lldGVudW1lcmlxdWUuZ291di5mci9wYXNzLW51bWVyaXF1ZS9cIlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgICA+XG5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgRW4gc2F2b2lyIHBsdXMgXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLW1lZGl1bSBcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS1leHRlcm5hbC1saW5rLWFsdFwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgICAgICAgICAgICA8L2E+XG5cblxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwvZGl2PiA8IS0tIGVuZCBjb2x1bW5zIC0tPlxuXG4gICAgICA8L2Rpdj5cbiAgICA8L3NlY3Rpb24+XG5cblxuICAgIDwhLS0gVE9PTEJPWCAtLT5cbiAgICA8ZGl2IGlkPVwidG9vbGJveFwiPjwvZGl2PlxuICAgIDxzZWN0aW9uIGNsYXNzPVwiaGFzLWJhY2tncm91bmQtcHJpbWFyeVwiIHN0eWxlPVwicGFkZGluZzogNGVtIDBlbSA0ZW0gMGVtXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG5cbiAgICAgICAgPCEtLSBJTlRSTyAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImhhcy10ZXh0LWNlbnRlcmVkXCIgPlxuICAgICAgICAgIDxoMiBjbGFzcz1cInRpdGxlIGhhcy10ZXh0LXdoaXRlIGlzLXNpemUtNCBoYXMtdGV4dC13ZWlnaHQtYm9sZFwiPlxuICAgICAgICAgICAgQm/DrnRlIMOgIG91dGlsc1xuICAgICAgICAgIDwvaDI+XG4gICAgICAgICAgPGgyIGNsYXNzPVwic3VidGl0bGUgaGFzLXRleHQtd2hpdGUgaXMtc2l6ZS01IGhhcy10ZXh0LXdlaWdodC1zZW1pLWJvbGRcIj5cbiAgICAgICAgICAgIFJldHJvdXZleiBpY2kgZGVzIHJlc3NvdXJjZXMgdXRpbGVzIHBvdXIgbGEgbWlzZSBlbiBwbGFjZSBkZSB2b3RyZSBwb2xpdGlxdWUgcHVibGlxdWVcbiAgICAgICAgICA8L2gyPlxuXG4gICAgICAgICAgPGJyPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8IS0tIFRJTEVTIENBUkRTIEEgLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zIGlzLW11bHRpbGluZSBpcy1uYXJyb3ctZGVza3RvcCBpcy04XCI+XG5cbiAgICAgICAgICA8IS0tIFRPT0xTIC0tPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtb25lLXF1YXJ0ZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkXCJcbiAgICAgICAgICAgICAgc3R5bGU9XCJkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2hlaWdodDoxMDAlXCJcbiAgICAgICAgICAgID5cblxuICAgICAgICAgICAgICA8YSBcbiAgICAgICAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9zb2NpZXRlbnVtZXJpcXVlLmdvdXYuZnIvdGVycml0b2lyZXMvXCJcbiAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICA+IFxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtaW1hZ2UgaGFzLXRleHQtY2VudGVyZWRcIiBzdHlsZT1cImZsZXg6YXV0bztcIj5cbiAgICAgICAgICAgICAgICAgIDxmaWd1cmUgY2xhc3M9XCJpbWFnZSBpcy1pbmxpbmUtYmxvY2tcIiBzdHlsZT1cInBhZGRpbmc6MzVweCAxMHB4IDEwcHggMTBweDtcIj5cbiAgICAgICAgICAgICAgICAgICAgPGltZyBcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIm1heC1oZWlnaHQ6MTUwcHg7IHdpZHRoOmF1dG87IGhlaWdodDoxNTBweFwiXG4gICAgICAgICAgICAgICAgICAgICAgc3JjPVwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NvLWRlbW9zL3hwLXNvbnVtL21hc3Rlci9pbGx1c3RyYXRpb25zL2ltYWdlcy9vdXRpbC5wbmdcIlxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDwvZmlndXJlPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1lZGlhXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZWRpYS1jb250ZW50IGhhcy10ZXh0LWNlbnRlcmVkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJ0aXRsZSBpcy01XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBCw6luw6lmaWNpZXIgZGVzIG91dGlscyBtaXMgw6AgZGlzcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgPC9hPlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDwhLS0gTU9CSUxJWkUgLS0+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy1vbmUtcXVhcnRlclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIlxuICAgICAgICAgICAgICBzdHlsZT1cImRpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47aGVpZ2h0OjEwMCVcIlxuICAgICAgICAgICAgPlxuXG4gICAgICAgICAgICAgIDxhIFxuICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwczovL3NvY2lldGVudW1lcmlxdWUuZ291di5mci9odWJzL1wiXG4gICAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgICAgPiBcblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWltYWdlIGhhcy10ZXh0LWNlbnRlcmVkXCIgc3R5bGU9XCJmbGV4OmF1dG87XCI+XG4gICAgICAgICAgICAgICAgICA8ZmlndXJlIGNsYXNzPVwiaW1hZ2UgaXMtaW5saW5lLWJsb2NrXCIgc3R5bGU9XCJwYWRkaW5nOjM1cHggMTBweCAxMHB4IDEwcHg7XCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbWcgXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJtYXgtaGVpZ2h0OjE1MHB4OyB3aWR0aDphdXRvOyBoZWlnaHQ6MTUwcHhcIlxuICAgICAgICAgICAgICAgICAgICAgIHNyYz1cImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9jby1kZW1vcy94cC1zb251bS9tYXN0ZXIvaWxsdXN0cmF0aW9ucy9pbWFnZXMvb3JpZW50YXRpb25zLnBuZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPC9maWd1cmU+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1jb250ZW50XCIgPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1lZGlhXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZWRpYS1jb250ZW50IGhhcy10ZXh0LWNlbnRlcmVkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJ0aXRsZSBpcy01XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBNb2JpbGlzZXIgbGVzIGludGVybG9jdXRldXJzIHN1ciBzb24gdGVycml0b2lyZVxuICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICA8L2E+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPCEtLSBTVFJBVEVHWSAtLT5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLW9uZS1xdWFydGVyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZFwiXG4gICAgICAgICAgICAgIHN0eWxlPVwiZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtoZWlnaHQ6MTAwJVwiXG4gICAgICAgICAgICA+XG5cbiAgICAgICAgICAgICAgPGEgXG4gICAgICAgICAgICAgICAgaHJlZj1cIi9zb251bS14cC9zdHJhdGVnaWVcIlxuICAgICAgICAgICAgICA+IFxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtaW1hZ2UgaGFzLXRleHQtY2VudGVyZWRcIiBzdHlsZT1cImZsZXg6YXV0bztcIj5cbiAgICAgICAgICAgICAgICAgIDxmaWd1cmUgY2xhc3M9XCJpbWFnZSBpcy1pbmxpbmUtYmxvY2tcIiBzdHlsZT1cInBhZGRpbmc6MzVweCAxMHB4IDEwcHggMTBweDtcIj5cbiAgICAgICAgICAgICAgICAgICAgPGltZyBcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIm1heC1oZWlnaHQ6MTUwcHg7IHdpZHRoOmF1dG87IGhlaWdodDoxNTBweFwiXG4gICAgICAgICAgICAgICAgICAgICAgc3JjPVwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NvLWRlbW9zL3hwLXNvbnVtL21hc3Rlci9pbGx1c3RyYXRpb25zL2ltYWdlcy9lbmpldXgucG5nXCJcbiAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8L2ZpZ3VyZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZWRpYVwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWVkaWEtY29udGVudCBoYXMtdGV4dC1jZW50ZXJlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwidGl0bGUgaXMtNVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgRWxhYm9yZXIgdW5lIHN0cmF0w6lnaWUgbG9jYWxlIGQnaW5jbHVzaW9uIG51bcOpcmlxdWVcbiAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgPC9hPlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDwhLS0gRElTQ09WRVIgLS0+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy1vbmUtcXVhcnRlclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIlxuICAgICAgICAgICAgICBzdHlsZT1cImRpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47aGVpZ2h0OjEwMCVcIlxuICAgICAgICAgICAgPlxuXG4gICAgICAgICAgICAgIDxhIFxuICAgICAgICAgICAgICAgIGhyZWY9XCIvc29udW0teHAvbGlzdGVcIlxuICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgID4gXG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1pbWFnZSBoYXMtdGV4dC1jZW50ZXJlZFwiIHN0eWxlPVwiZmxleDphdXRvO1wiPlxuICAgICAgICAgICAgICAgICAgPGZpZ3VyZSBjbGFzcz1cImltYWdlIGlzLWlubGluZS1ibG9ja1wiIHN0eWxlPVwicGFkZGluZzozNXB4IDEwcHggMTBweCAxMHB4O1wiPlxuICAgICAgICAgICAgICAgICAgICA8aW1nIFxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwibWF4LWhlaWdodDoxNTBweDsgd2lkdGg6YXV0bzsgaGVpZ2h0OjE1MHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICBzcmM9XCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vY28tZGVtb3MveHAtc29udW0vbWFzdGVyL2lsbHVzdHJhdGlvbnMvaW1hZ2VzL3Jlc3NvdXJjZS5wbmdcIlxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDwvZmlndXJlPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtY29udGVudFwiID5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZWRpYVwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWVkaWEtY29udGVudCBoYXMtdGV4dC1jZW50ZXJlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwidGl0bGUgaXMtNVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgRMOpY291dnJpciBsZXMgaW5pdGlhdGl2ZXMgZCdpbmNsdXNpb24gbnVtw6lyaXF1ZSBkYW5zIGxlcyB0ZXJyaXRvaXJlc1xuICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICA8L2E+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuXG5cbiAgICAgICAgPC9kaXY+IDwhLS0gZW5kIGNvbHVtbnMgLS0+XG5cblxuICAgICAgPC9kaXY+XG4gICAgPC9zZWN0aW9uPlxuXG5cbiAgICA8IS0tIENPTlRSSUJVVEUgLS0+XG4gICAgPGRpdiBpZD1cInRvb2xib3hcIj48L2Rpdj5cbiAgICA8c2VjdGlvbiBjbGFzcz1cImhhcy1iYWNrZ3JvdW5kLWluZm9cIiBzdHlsZT1cInBhZGRpbmc6IDRlbSAwZW0gNGVtIDBlbVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuXG4gICAgICAgIDwhLS0gSU5UUk8gLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJoYXMtdGV4dC1jZW50ZXJlZFwiID5cbiAgICAgICAgICA8aDIgY2xhc3M9XCJ0aXRsZSBoYXMtdGV4dC13aGl0ZSBpcy1zaXplLTQgaGFzLXRleHQtd2VpZ2h0LWJvbGRcIj5cbiAgICAgICAgICAgIENlIHNpdGUgZXN0IGNvbnRyaWJ1dGlmXG4gICAgICAgICAgPC9oMj5cblxuICAgICAgICAgIDxicj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPCEtLSBUSUxFUyBDQVJEUyBBIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1ucyBpcy1tdWx0aWxpbmUgaXMtY2VudGVyZWQgaXMtbmFycm93LWRlc2t0b3AgaXMtOFwiPlxuXG4gICAgICAgICAgPCEtLSBET0NVTUVOVEFUSU9OIC0tPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtdHdvLWZpZnRoc1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIlxuICAgICAgICAgICAgICBzdHlsZT1cImRpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47aGVpZ2h0OjEwMCVcIlxuICAgICAgICAgICAgPlxuXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWVkaWFcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZWRpYS1jb250ZW50XCI+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIlwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwiXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBWb3VzIGF2ZXogbWlzIGVuIHBsYWNlIHVuZSBpbml0aWF0aXZlIG91IHVuZSBwb2xpdGlxdWUgcHVibGlxdWUgaW5ub3ZhbnRlIGVuIG1hdGnDqHJlIGQndXNhZ2VzLCBkZSBzZXJ2aWNlcyBvdSBkJ2luY2x1c2lvbiBudW3DqXJpcXVlID8gRG9jdW1lbnRlei1sZXMgZW4gcmVtcGxpc3NhbnQgY2UgZm9ybXVsYWlyZSAhIFxuICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICA8YnI+XG4gICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIExlIGZvcm11bGFpcmUgZXN0IMOgIGNvbXBsw6l0ZXIgdmlhIGNlIGxpZW4gOiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICA8YnI+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJoYXMtdGV4dC1jZW50ZXJlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxhIFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vZnJhbWFmb3Jtcy5vcmcvZG9jdW1lbnRhdGlvbi1kaW5pdGlhdGl2ZXMtZXQtcG9saXRpcXVlcy1wdWJsaXF1ZXMtbnVtZXJpcXVlcy1pbm5vdmFudGVzLTE1NDA1NDczMzlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1tZWRpdW0gXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLWV4dGVybmFsLWxpbmstYWx0XCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgRm9ybXVsYWlyZSBkZSBkb2N1bWVudGF0aW9uIFxuICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8IS0tIENPTlRBQ1QgLS0+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy10d28tZmlmdGhzXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZFwiXG4gICAgICAgICAgICAgIHN0eWxlPVwiZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtoZWlnaHQ6MTAwJVwiXG4gICAgICAgICAgICA+XG5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtY29udGVudFwiID5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWVkaWFcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZWRpYS1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwiXCI+XG4gICAgICAgICAgICAgICAgICAgICAgVm91cyBzb3VoYWl0ZXogcGFydGFnZXIgdG91dCBhdXRyZSBvdXRpbCAob3V0aWwgZGUgZGlhZ25vc3RpYyBkZSBjb21ww6l0ZW5jZXMgbnVtw6lyaXF1ZXMpLCByZXNzb3VyY2UgKMOpdHVkZSBkZXMgcHJhdGlxdWVzIG51bcOpcmlxdWVzIHN1ciB2b3RyZSB0ZXJyaXRvaXJl4oCmKSBvdSBub3VzIGZhaXJlIHBhcnQgZOKAmXVuZSBzdWdnZXN0aW9uID8gXG4gICAgICAgICAgICAgICAgICAgICAgPGJyPjxicj5cbiAgICAgICAgICAgICAgICAgICAgICBWb3VzIHBvdXZleiBub3VzIMOpY3JpcmUgw6AgOiBcbiAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cImxpbmtcIiBocmVmPVwibWFpbHRvOnNvY2lldGUubnVtZXJpcXVlQGZpbmFuY2VzLmdvdXYuZnJcIj5cbiAgICAgICAgICAgICAgICAgICAgICBzb2NpZXRlLm51bWVyaXF1ZUBmaW5hbmNlcy5nb3V2LmZyLlxuICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8L2Rpdj4gPCEtLSBlbmQgY29sdW1ucyAtLT5cblxuXG4gICAgICA8L2Rpdj5cbiAgICA8L3NlY3Rpb24+XG5cblxuXG5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge21hcFN0YXRlfSBmcm9tICd2dWV4J1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6W1xuICAgICAgLy8gJ3JvdXRlQ29uZmlnJyxcbiAgICAgIC8vICd0ZW1wbGF0ZVVSTCdcbiAgICBdLFxuICBkYXRhOiAoKSA9PiB7XG4gICAgcmV0dXJuICAge1xuICAgICAgcmF3SHRtbCA6ICcnXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIC4uLm1hcFN0YXRlKHtcbiAgICAgIHVzZXI6ICd1c2VyJ1xuICAgIH0pXG4gIH0sXG4gIG1vdW50ZWQoKXtcbiAgICAvLyBoZXJlIHdlIGdvIGZldGNoIHRoZSByYXcgSFRNTCBjb250ZW50IG9mIGEgd2VicGFnZVxuICAgIC8vIGxldCB0ZW1wbGF0ZV91cmwgPSAodGhpcy50ZW1wbGF0ZVVSTCkgPyB0aGlzLnRlbXBsYXRlVVJMIDogJ2h0dHBzOi8vY28tZGVtb3MuY29tL2Vycm9yJ1xuICAgIC8vIGxldCBoZWFkID0geyBcbiAgICAvLyAgIGhlYWRlcnM6IHtcbiAgICAvLyAgICAgLy8gJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbic6ICcqJyxcbiAgICAvLyAgICAgJ2FjY2VwdCcgOiAndGV4dC9odG1sJyxcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgLy8gYXhpb3MuZ2V0KHRlbXBsYXRlX3VybCwgaGVhZClcbiAgICAvLyAgIC50aGVuKCAocmVzcG9uc2UpID0+IHsgXG4gICAgLy8gICAgIC8vIGNvbnNvbGUubG9nKHJlc3BvbnNlKTsgXG4gICAgLy8gICAgIHRoaXMucmF3SHRtbCA9IChyZXNwb25zZSAmJiByZXNwb25zZS5kYXRhKSA/IHJlc3BvbnNlLmRhdGEgOiAnPGJyPjxicj50aGVyZSBpcyBhbiBFcnJvciA8YnI+PGJyPid9IFxuICAgIC8vICAgKVxuICAgIC8vICAgLmNhdGNoKCAoZXJyKSA9PiB7dGhpcy5yYXdIdG1sID0gJzxicj48YnI+dGhlcmUgaXMgYW4gPHN0cm9uZz4gRXJyb3IgPC9zdHJvbmc+PGJyPjxicj4nfSApXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBnb0JhY2soZSl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0aGlzLiRyb3V0ZXIuYmFjaygpXG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8c2VjdGlvbiBjbGFzcz1cImZpbHRlci1mZWVkYmFja1wiIHYtaWY9XCJzZWxlY3RlZEZpbHRlcnMubGVuZ3RoID49IDFcIj5cbiAgICAgIFxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciBpbmxpbmUtZmlsdGVyc1wiPlxuXG4gICAgICAgIDxhIGNsYXNzPVwiYnV0dG9uIGlzLXNtYWxsXCIgQGNsaWNrPVwiY2xlYXJBbGxGaWx0ZXJzXCI+XG4gICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICBlZmZhY2VyIGxlcyBmaWx0cmVzXG4gICAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsXCI+XG4gICAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS10aW1lc1wiPjwvaT5cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvYT5cblxuICAgICAgICA8YSBcbiAgICAgICAgICB2LWZvcj1cIntmaWx0ZXIsIHZhbHVlfSBpbiBzZWxlY3RlZEZpbHRlcnNcIiA6a2V5PVwiZmlsdGVyK3ZhbHVlXCJcbiAgICAgICAgICBjbGFzcz1cImJ1dHRvbiBpcy1zbWFsbCBpcy1ncmV5XCIgXG4gICAgICAgICAgQGNsaWNrPVwiY2xlYXJGaWx0ZXIoe2ZpbHRlciwgdmFsdWV9KVwiXG4gICAgICAgICAgPlxuICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAge3tcbiAgICAgICAgICAgICAgZmlsdGVyRGVzY3JpcHRpb25zXG4gICAgICAgICAgICAgICAgLmZpbmQoZiA9PiBmLm5hbWUgPT09IGZpbHRlcilcbiAgICAgICAgICAgICAgICAuY2hvaWNlc1xuICAgICAgICAgICAgICAgIC5maW5kKGMgPT4gYy5uYW1lID09PSB2YWx1ZSlcbiAgICAgICAgICAgICAgICAuZnVsbG5hbWVcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsXCI+XG4gICAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS10aW1lc1wiPjwvaT5cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvYT5cblxuICAgICAgPC9kaXY+XG4gICAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7bWFwU3RhdGV9IGZyb20gJ3Z1ZXgnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAnRmlsdGVyc0ZlZWRiYWNrJyxcbiAgICBjb21wdXRlZDoge1xuICAgICAgLi4ubWFwU3RhdGUoe1xuICAgICAgICBmaWx0ZXJEZXNjcmlwdGlvbnM6ICdmaWx0ZXJEZXNjcmlwdGlvbnMnLFxuICAgICAgICBzZWxlY3RlZEZpbHRlcnM6ICh7c2VhcmNofSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHtzZWxlY3RlZEZpbHRlcnN9ID0gc2VhcmNoLnF1ZXN0aW9uXG4gICAgICAgICAgY29uc3QgZmlsdGVycyA9IFtdXG5cbiAgICAgICAgICBmb3IoY29uc3QgW2ZpbHRlciwgdmFsdWVzXSBvZiBzZWxlY3RlZEZpbHRlcnMpe1xuICAgICAgICAgICAgZm9yKGNvbnN0IHZhbHVlIG9mIHZhbHVlcyl7XG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKHtmaWx0ZXIsIHZhbHVlfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmlsdGVyc1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGNsZWFyQWxsRmlsdGVycygpe1xuICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCggJ2NsZWFyQWxsRmlsdGVycycgKVxuICAgICAgfSxcbiAgICAgIGNsZWFyRmlsdGVyKHtmaWx0ZXIsIHZhbHVlfSl7XG4gICAgICAgIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCAndG9nZ2xlRmlsdGVyJywge2ZpbHRlciwgdmFsdWV9IClcbiAgICAgIH0sXG5cblxuICAgICAgLy8gcmVpbml0RmlsdGVyc1RleHRzKCkge1xuICAgICAgLy8gICBsZXQgZmlsdGVyc0RmdFJlaW5pdCA9IHRoaXMuJHN0b3JlLnN0YXRlLmdsb2JhbC5hcHBfYmFzaWNfZGljdFxuICAgICAgLy8gICBjb25zb2xlLmxvZyhcImZpbHRlcnNEZnRSZWluaXQgOiBcIiwgZmlsdGVyc0RmdFJlaW5pdCApXG4gICAgICAvLyAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldFRyYW5zbGF0aW9uKHsgdGV4dHMgOiBmaWx0ZXJzRGZ0UmVpbml0IH0pXG4gICAgICAvLyB9LFxuICAgICAgLy8gdHJhbnNsYXRlKCB0ZXh0c1RvVHJhbnNsYXRlICkge1xuICAgICAgLy8gICBsZXQgbGlzdFRleHRzID0gdGV4dHNUb1RyYW5zbGF0ZVxuICAgICAgLy8gICBjb25zb2xlLmxvZyhcImxpc3RUZXh0cyA6IFwiLCBsaXN0VGV4dHMgKVxuICAgICAgLy8gICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRUcmFuc2xhdGlvbih7IHRleHRzIDogbGlzdFRleHRzIH0pXG4gICAgICAvLyB9LFxuICAgICAgLy8gdHJhbnNsYXRlQmlzKCB0ZXh0c1RvVHJhbnNsYXRlLCBsaXN0RmllbGQgKSB7XG4gICAgICAvLyAgIGxldCBsaXN0VGV4dHMgPSB0ZXh0c1RvVHJhbnNsYXRlW2xpc3RGaWVsZF1cbiAgICAgIC8vICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0VHJhbnNsYXRpb24oeyB0ZXh0cyA6IGxpc3RUZXh0cyB9KVxuICAgICAgLy8gfVxuICAgIH1cblxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG5cbi5maWx0ZXItZmVlZGJhY2t7XG4gIHdpZHRoOiAxMDAlO1xuICAvKiBiYWNrZ3JvdW5kLWNvbG9yOiAjRjZGNkY2OyAqL1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgLyogYm9yZGVyLXRvcDogMXB4IHNvbGlkOyAqL1xuICAvKiBib3JkZXItdG9wLWNvbG9yOiAjNDA1MjlkOyAqL1xuICAvKiB0b3AgOiAtMXB4OyAqL1xuICB6LWluZGV4OiAxMDtcbn1cblxuLmZpbHRlci1mZWVkYmFjayA+IC5pbmxpbmUtZmlsdGVyc3tcbiAgcGFkZGluZy10b3A6IDFlbTtcbiAgcGFkZGluZy1ib3R0b206IDFlbTtcbiAgZm9udC1zaXplOiAxMnB4O1xufVxuXG4uZmlsdGVyLWZlZWRiYWNrID4gLmlubGluZS1maWx0ZXJzIGEuYnV0dG9uIHtcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xuICBtYXJnaW4tcmlnaHQ6IDAuNWVtO1xuICBib3JkZXI6IDFweCBzb2xpZCAjNzY3Njc2O1xuICBwYWRkaW5nLXRvcDogMC4xZW0gO1xuICBwYWRkaW5nLWJvdHRvbTogMC4xZW0gO1xuICBoZWlnaHQ6IGluaGVyaXQ7XG59XG4vKiAuZmlsdGVyLWZlZWRiYWNrID4gLmlubGluZS1maWx0ZXJzIHNwYW57XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjNzY3Njc2O1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM3Njc2NzY7XG5cbiAgICBjb2xvcjogd2hpdGU7XG5cbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XG5cbiAgICBwYWRkaW5nOiAwLjFlbSAwIDAuMmVtIDFlbTtcbiAgICBmb250LXNpemU6IDAuOWVtO1xufVxuXG4uZmlsdGVyLWZlZWRiYWNrID4gLmlubGluZS1maWx0ZXJzIHNwYW4gYnV0dG9ue1xuICAgIGJvcmRlcjogMDtcbiAgICBwYWRkaW5nOiAwLjJlbSAxZW07XG4gICAgbWFyZ2luOiAwO1xuXG4gICAgZm9udC1zaXplOiAxLjJlbTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICBjb2xvcjogY3VycmVudENvbG9yO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIFxufSAqL1xuXG4uZmlsdGVyLWZlZWRiYWNrID4gLmlubGluZS1maWx0ZXJzIHNwYW4uYWxse1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG5cbiAgICBjb2xvcjogIzc2NzY3Njtcbn1cblxuPC9zdHlsZT4iLCI8dGVtcGxhdGU+XG4gIDxmb290ZXIgY2xhc3M9XCJmb290ZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uc1wiPlxuXG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy0zIGlzLW9mZnNldC0xXCJcbiAgICAgICAgICB2LWZvcj1cIihibG9ja19wb3MsIGluZGV4KSBpbiBbJ2Jsb2NrX2NlbnRlcl9sZWZ0JywgJ2Jsb2NrX2NlbnRlcl9yaWdodCcsJ2Jsb2NrX3JpZ2h0J11cIlxuICAgICAgICAgIDprZXk9XCJpbmRleFwiXG4gICAgICAgICAgPlxuXG4gICAgICAgICAgPGgzIGNsYXNzPVwiaGFzLXRleHQtbGVmdCBoYXMtdGV4dC1wcmltYXJ5XCI+IFxuICAgICAgICAgICAge3sgdHJhbnNsYXRlKGZvb3RlckxpbmtzKGJsb2NrX3BvcyksICd0aXRsZV9ibG9jaycpIH19XG4gICAgICAgICAgPC9oMz5cblxuICAgICAgICAgIDx0ZW1wbGF0ZSBcbiAgICAgICAgICAgIHYtaWY9XCJpc1Zpc2libGUoIGZvb3RlckxpbmtzKGJsb2NrX3BvcykgKVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgIDxsaSBcbiAgICAgICAgICAgICAgICB2LWZvcj1cIihsaW5rLCBpbmRleCkgaW4gZm9vdGVyTGlua3MoYmxvY2tfcG9zKVsnbGlua3MnXVwiXG4gICAgICAgICAgICAgICAgOmtleT1cImluZGV4XCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxhIDpocmVmPVwibGluay5saW5rX3RvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+IFxuICAgICAgICAgICAgICAgICAge3sgdHJhbnNsYXRlKGxpbmssICdsaW5rX3RleHQnKSB9fVxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgPC90ZW1wbGF0ZT5cblxuICAgICAgICAgIDwhLS0gQUREIFNPQ0lBTCBBVCBUSEUgRU5EIC0tPlxuICAgICAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwiYmxvY2tfcG9zID09PSAnYmxvY2tfcmlnaHQnIFwiPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8YnI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgICAgICA8dGVtcGxhdGUgIFxuICAgICAgICAgICAgICAgICAgdi1mb3I9XCIoaWNvbiwgaW5kZXgpIGluIGFwcFNvY2lhbHNcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8IS0tIHt7IGljb24gfX0gLS0+XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnV0dG9uIGlzLXByaW1hcnlcIiBcbiAgICAgICAgICAgICAgICAgIDprZXk9XCJpbmRleFwiXG4gICAgICAgICAgICAgICAgICA6aHJlZj1cImljb24udXJsXCIgXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpIFxuICAgICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cImljb24uaWNvbl9jbGFzc1wiXG4gICAgICAgICAgICAgICAgICAgID48L2k+XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8L3RlbXBsYXRlPlxuXG4gICAgICAgIDwvZGl2PlxuXG5cblxuXG5cbiAgICAgICAgPCEtLSA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLTRcIj5cblxuICAgICAgICAgIDxoMiBjbGFzcz1cImhhcy10ZXh0LXByaW1hcnlcIj4gXG4gICAgICAgICAgPC9oMj5cbiAgICAgICAgICBcbiAgICAgICAgICA8dWw+XG5cbiAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9jby1kZW1vcy9BcGlWaXpcIiB0YXJnZXQ9XCJfYmxhbmtcIj4gXG4gICAgICAgICAgICAgICAgQ29kZSBzb3VyY2UgXG4gICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgIDxhIGhyZWY9XCIvbG9naW5cIj5Mb2dpbjwvYT5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgIDxhIGhyZWY9XCIvYWRtaW5cIj5BZG1pbjwvYT5cbiAgICAgICAgICAgIDwvbGk+XG5cbiAgICAgICAgICA8L3VsPlxuXG4gICAgICAgIDwvZGl2PiAtLT5cblxuXG5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Zvb3Rlcj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4vLyBpbXBvcnQgTWFpbGNoaW1wU3Vic2NyaWJlIGZyb20gJy4vTWFpbGNoaW1wU3Vic2NyaWJlLnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIGNvbXBvbmVudHM6IHtcbiAgICAvLyBNYWlsY2hpbXBTdWJzY3JpYmVcbiAgfSxcblxuICBwcm9wcyA6IFtcbiAgICAnZm9vdGVyQ29uZmlnJyxcbiAgICAnYXBwU29jaWFscydcbiAgXSxcblxuICBjb21wdXRlZCA6IHtcbiAgICBmb290ZXJVSSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvb3RlckNvbmZpZy51aV9vcHRpb25zXG4gICAgfSxcbiAgfSxcblxuICBtZXRob2RzIDoge1xuXG4gICAgZm9vdGVyTGlua3MocG9zaXRpb24pIHtcbiAgICAgIGxldCBhbGxMaW5rcyA9IHRoaXMuZm9vdGVyQ29uZmlnLmxpbmtzX29wdGlvbnNcbiAgICAgIGxldCBibG9ja0xpbmtzID0gYWxsTGlua3NbcG9zaXRpb25dXG4gICAgICByZXR1cm4gYmxvY2tMaW5rc1xuICAgIH0sXG4gICAgZm9vdGVyQ29udGVudHMocG9zaXRpb24pIHtcbiAgICAgIGxldCBhbGxDb250ZW50cyA9IHRoaXMuZm9vdGVyQ29uZmlnLmNvbnRlbnRzX2ZpZWxkc1xuICAgICAgbGV0IGJsb2NrQ29udGVudHMgPSBhbGxDb250ZW50c1twb3NpdGlvbl1cbiAgICAgIHJldHVybiBibG9ja0NvbnRlbnRzXG4gICAgfSxcblxuICAgIGlzVmlzaWJsZShibG9jaykge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJibG9jayA6IFwiLCBibG9jaylcbiAgICAgIHJldHVybiBibG9jay5pc192aXNpYmxlXG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZSggdGV4dHNUb1RyYW5zbGF0ZSwgbGlzdEZpZWxkICkge1xuICAgICAgbGV0IGxpc3RUZXh0cyA9IHRleHRzVG9UcmFuc2xhdGVbbGlzdEZpZWxkXVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0VHJhbnNsYXRpb24oeyB0ZXh0cyA6IGxpc3RUZXh0cyB9KVxuICAgIH1cbiAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cblxuICAgIDxoNSBjbGFzcz1cInRpdGxlIGhhcy10ZXh0LWdyZXlcIlxuICAgICAgdi1pZj1cIiF1c2VyLmlzTG9nZ2VkaW5cIlxuICAgICAgPlxuICAgICAge3sgZ2V0VGV4dCgnbG9naW4nKSB9fVxuICAgIDwvaDU+XG5cbiAgICA8Zm9ybSBcbiAgICAgIHYtaWY9XCIhdXNlci5pc0xvZ2dlZGluXCJcbiAgICAgIHYtb246c3VibWl0LnByZXZlbnQ9XCJzZW5kTG9naW5Gb3JtXCIgXG4gICAgICBuYW1lPVwiZm9ybVwiIFxuICAgICAgPlxuICAgICAgPHNwYW4+e3sgdGhpcy5jdXN0b21mb3JtRXJyb3IgfX08L3NwYW4+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiPlxuICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImlucHV0XCIgXG4gICAgICAgICAgICB2LW1vZGVsPVwidXNlckVtYWlsXCJcbiAgICAgICAgICAgIHYtdmFsaWRhdGU9XCIncmVxdWlyZWR8ZW1haWwnXCIgXG4gICAgICAgICAgICBuYW1lPVwidXNlckVtYWlsXCIgXG4gICAgICAgICAgICA6cGxhY2Vob2xkZXI9XCJnZXRUZXh0KCdlbWFpbCcpXCJcbiAgICAgICAgICAgIHR5cGU9XCJlbWFpbFwiIFxuICAgICAgICAgICAgPlxuICAgICAgICAgIDxzcGFuPnt7IGVycm9ycy5maXJzdCgndXNlckVtYWlsJykgfX08L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLWVudmVsb3BlXCI+PC9pPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCI+XG4gICAgICAgICAgPGlucHV0IGNsYXNzPVwiaW5wdXRcIiBcbiAgICAgICAgICAgIHYtdmFsaWRhdGU9XCIncmVxdWlyZWQnXCIgXG4gICAgICAgICAgICB2LW1vZGVsPVwidXNlclBhc3N3b3JkXCJcbiAgICAgICAgICAgIG5hbWU9XCJ1c2VyUGFzc3dvcmRcIiBcbiAgICAgICAgICAgIDpwbGFjZWhvbGRlcj1cImdldFRleHQoJ3Bhc3N3b3JkJylcIlxuICAgICAgICAgICAgdHlwZT1cInBhc3N3b3JkXCIgXG4gICAgICAgICAgICA+XG4gICAgICAgICAgPHNwYW4+e3sgZXJyb3JzLmZpcnN0KCd1c2VyUGFzc3dvcmQnKSB9fTwvc3Bhbj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24gaXMtc21hbGwgaXMtbGVmdFwiPlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJmYXMgZmEta2V5XCI+PC9pPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgIDwhLS0gPGRpdiBjbGFzcz1cImNvbnRyb2wgaGFzLWljb25zLWxlZnRcIj4gLS0+XG4gICAgICAgICAgPGlucHV0IFxuICAgICAgICAgICAgY2xhc3M9XCJjaGVja2JveFwiIFxuICAgICAgICAgICAgbmFtZT1cInVzZXJSZW1lbWJlck1lXCIgXG4gICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIiBcbiAgICAgICAgICAgIHZhbHVlPVwiXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgPGxhYmVsIGZvcj1cImNoZWNrYm94XCI+XG4gICAgICAgICAgICA8IS0tIHJlbWVtYmVyIG1lIC0tPlxuICAgICAgICAgICAge3sgZ2V0VGV4dCgncmVtZW1iZXJfbWUnKSB9fVxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwhLS0gPC9kaXY+IC0tPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxicj5cblxuICAgICAgPGJ1dHRvbiBcbiAgICAgICAgY2xhc3M9XCJidXR0b24gaXMtYmxvY2sgaXMtcHJpbWFyeSBpcy1mdWxsd2lkdGhcIiBcbiAgICAgICAgdHlwZT1cInN1Ym1pdFwiIFxuICAgICAgICA+XG4gICAgICAgIDwhLS0gQGNsaWNrPVwic2VuZExvZ2luRm9ybVwiIC0tPlxuICAgICAgICB7eyBnZXRUZXh0KCdjb25uZWN0JykgfX1cbiAgICAgIDwvYnV0dG9uPlxuXG4gICAgPC9mb3JtPlxuXG5cbiAgICA8ZGl2XG4gICAgICB2LWlmPVwiaXNVc2VyQWRtaW4gfHwgaXNVc2VyU3RhZmZcIiBcbiAgICAgID5cbiAgICAgIDxyb3V0ZXItbGlua1xuICAgICAgICBjbGFzcz1cImJ1dHRvbiBpcy1ibG9jayBpcy1wcmltYXJ5IGlzLWZ1bGx3aWR0aFwiIFxuICAgICAgICA6dG89XCInL2JhY2tvZmZpY2UnXCJcbiAgICAgICAgPlxuICAgICAgICBiYWNrIG9mZmljZVxuICAgICAgPC9yb3V0ZXItbGluaz5cbiAgICAgIDxicj5cbiAgICA8L2Rpdj5cblxuICAgIDxidXR0b24gXG4gICAgICB2LWlmPVwidXNlci5pc0xvZ2dlZGluXCIgXG4gICAgICBjbGFzcz1cImJ1dHRvbiBpcy1ibG9jayBpcy1wcmltYXJ5IGlzLWZ1bGx3aWR0aFwiIFxuICAgICAgdHlwZT1cInN1Ym1pdFwiIFxuICAgICAgQGNsaWNrPVwic2VuZExvZ291dFwiXG4gICAgICA+XG4gICAgICB7eyBnZXRUZXh0KCdkaXNjb25uZWN0JykgfX1cbiAgICA8L2J1dHRvbj5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gJ3Z1ZXgnXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuLy8gaW1wb3J0IHsgYXBpQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2FwaS5qcyc7XG4vLyBpbXBvcnQgeyBnZXRDb25maWdOYW1lIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB1c2VyRW1haWw6ICcnLFxuICAgICAgdXNlclBhc3N3b3JkOiAnJyxcbiAgICAgIHVzZXJSZW1lbWJlck1lOiB0cnVlLFxuICAgICAgY3VzdG9tZm9ybUVycm9yOiAnJ1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICAuLi5tYXBTdGF0ZSh7XG4gICAgICB1c2VyIDogJ3VzZXInLFxuICAgICAgand0IDogJ2p3dCdcbiAgICB9KSxcbiAgICBpc1VzZXJBZG1pbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRDaGVja1VzZXJSb2xlKCdhZG1pbicpXG4gICAgfSxcbiAgICBpc1VzZXJTdGFmZiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRDaGVja1VzZXJSb2xlKCdzdGFmZicpXG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuXG4gICAgZ2V0VGV4dCh0ZXh0Q29kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDp0ZXh0Q29kZX0pXG4gICAgfSxcblxuICAgIHNlbmRMb2dpbkZvcm0oZSl7XG4gICAgICB0aGlzLmN1c3RvbWZvcm1FcnJvciA9ICcnXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcblxuICAgICAgY29uc3QgdXJsQXV0aFJvb3QgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldFJvb3RVcmxBdXRoXG4gICAgICAvLyBjb25zb2xlLmxvZyhcInVybEF1dGhSb290IDogXCIsIHVybEF1dGhSb290KVxuXG4gICAgICBjb25zdCB1cmxBdXRoTG9naW4gPSB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldEVuZHBvaW50Q29uZmlnQXV0aFNwZWNpZmljKCdsb2dpbicpXG4gICAgICBjb25zdCB1cmxBdXRoTG9naW5TdWZmaXggPSB1cmxBdXRoTG9naW4ucm9vdF91cmxcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwidXJsQXV0aExvZ2luU3VmZml4IDogXCIsIHVybEF1dGhMb2dpblN1ZmZpeClcblxuICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgIGVtYWlsIDogdGhpcy51c2VyRW1haWwsXG4gICAgICAgIHB3ZCA6IHRoaXMudXNlclBhc3N3b3JkXG4gICAgICB9XG5cbiAgICAgIGF4aW9zXG4gICAgICAgIC5wb3N0KCB1cmxBdXRoUm9vdCArIHVybEF1dGhMb2dpblN1ZmZpeCwgcGF5bG9hZCApXG4gICAgICAgIC5jYXRjaCggKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpXG4gICAgICAgICAgdGhpcy5jdXN0b21mb3JtRXJyb3IgPSAnTG9naW4gZmFpbGVkJ1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnc2F2ZUxvZ2luSW5mb3MnLHtBUElyZXNwb25zZTpyZXNwb25zZX0pIClcbiAgICAgIHRoaXMudXNlclBhc3N3b3JkID0gJydcbiAgICB9LFxuXG4gICAgc2VuZExvZ291dChlKXtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgdGhpcy51c2VyRW1haWwgPSAnJ1xuICAgICAgdGhpcy51c2VyUGFzc3dvcmQgPSAnJ1xuICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2xvZ291dCcpXG4gICAgICB0aGlzLiRyb3V0ZXIucHVzaCgnbG9nb3V0JylcbiAgICB9LFxuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXY+XG5cblxuICAgICAgPGg1IGNsYXNzPVwidGl0bGUgaGFzLXRleHQtZ3JleVwiPlxuICAgICAgICB7eyBnZXRUZXh0KCdyZWdpc3RlcicpIH19XG4gICAgICA8L2g1PlxuXG4gICAgICA8Zm9ybSBcbiAgICAgICAgdi1vbjpzdWJtaXQucHJldmVudD1cInNlbmRSZWdpc3RlckZvcm1cIiBcbiAgICAgICAgbmFtZT1cImZvcm1cIiBcbiAgICAgICAgdi1pZj1cIiF1c2VyLmlzTG9nZ2VkaW5cIlxuICAgICAgICA+XG5cbiAgICAgICAgPHNwYW4+e3sgdGhpcy5jdXN0b21mb3JtRXJyb3IgfX08L3NwYW4+XG5cbiAgICAgICAgPCEtLSBOQU1FIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cbiAgICAgIFx0XHQ8ZGl2IGNsYXNzPVwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiPlxuICAgICAgICAgICAgPGlucHV0IFxuICAgICAgICAgICAgICBjbGFzcz1cImlucHV0XCIgXG4gICAgICAgICAgICAgIHYtdmFsaWRhdGU9XCIncmVxdWlyZWQnXCIgXG4gICAgICAgICAgICAgIG5hbWU9XCJ1c2VyTmFtZVwiIFxuICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiIFxuICAgICAgICAgICAgICA6cGxhY2Vob2xkZXI9XCJnZXRUZXh0KCduYW1lJylcIiBcbiAgICAgICAgICAgICAgdi1tb2RlbD1cInVzZXJOYW1lXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4+e3sgZXJyb3JzLmZpcnN0KCd1c2VyTmFtZScpIH19PC9zcGFuPlxuICAgICAgXHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIj5cbiAgICAgIFx0XHRcdFx0PGkgY2xhc3M9XCJmYXMgZmEtdXNlclwiPjwvaT5cbiAgICAgIFx0XHRcdDwvc3Bhbj5cbiAgICAgIFx0XHQ8L2Rpdj5cbiAgICAgIFx0PC9kaXY+XG5cblxuICAgICAgICA8IS0tIFNVUk5BTUUgLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCI+XG4gICAgICAgICAgICA8aW5wdXQgXG4gICAgICAgICAgICAgIGNsYXNzPVwiaW5wdXRcIiBcbiAgICAgICAgICAgICAgdi12YWxpZGF0ZT1cIidyZXF1aXJlZCdcIiBuYW1lXG4gICAgICAgICAgICAgID1cInVzZXJTdXJuYW1lXCIgXG4gICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCIgXG4gICAgICAgICAgICAgIDpwbGFjZWhvbGRlcj1cImdldFRleHQoJ3N1cm5hbWUnKVwiIFxuICAgICAgICAgICAgICB2LW1vZGVsPVwidXNlclN1cm5hbWVcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICA8c3Bhbj57eyBlcnJvcnMuZmlyc3QoJ3VzZXJTdXJuYW1lJykgfX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24gaXMtc21hbGwgaXMtbGVmdFwiPlxuICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS11c2VyXCI+PC9pPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuXG4gICAgICAgIDwhLS0gRU1BSUwgLS0+XG4gICAgICBcdDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgXHRcdDxkaXYgY2xhc3M9XCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCI+XG4gICAgICAgICAgICA8aW5wdXQgXG4gICAgICAgICAgICAgIGNsYXNzPVwiaW5wdXRcIiBcbiAgICAgICAgICAgICAgdi12YWxpZGF0ZT1cIidyZXF1aXJlZHxlbWFpbCdcIiBcbiAgICAgICAgICAgICAgbmFtZT1cInVzZXJFbWFpbFwiIFxuICAgICAgICAgICAgICB0eXBlPVwiZW1haWxcIiBcbiAgICAgICAgICAgICAgOnBsYWNlaG9sZGVyPVwiZ2V0VGV4dCgnZW1haWwnKVwiXG4gICAgICAgICAgICAgIHYtbW9kZWw9XCJ1c2VyRW1haWxcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICA8c3Bhbj57eyBlcnJvcnMuZmlyc3QoJ3VzZXJFbWFpbCcpIH19PC9zcGFuPlxuICAgICAgXHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIj5cbiAgICAgIFx0XHRcdFx0PGkgY2xhc3M9XCJmYXMgZmEtZW52ZWxvcGVcIj48L2k+XG4gICAgICBcdFx0XHQ8L3NwYW4+XG4gICAgICBcdFx0PC9kaXY+XG4gICAgICBcdDwvZGl2PlxuXG4gICAgICAgIDwhLS0gUEFTU1dPUkQgLS0+XG4gICAgICBcdDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgXHRcdDxkaXYgY2xhc3M9XCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCI+XG4gICAgICAgICAgICA8aW5wdXQgXG4gICAgICAgICAgICAgIGNsYXNzPVwiaW5wdXRcIiBcbiAgICAgICAgICAgICAgdi12YWxpZGF0ZT1cIidyZXF1aXJlZCdcIiBcbiAgICAgICAgICAgICAgbmFtZT1cInVzZXJQYXNzd29yZFwiIFxuICAgICAgICAgICAgICB0eXBlPVwicGFzc3dvcmRcIiBcbiAgICAgICAgICAgICAgOnBsYWNlaG9sZGVyPVwiZ2V0VGV4dCgncGFzc3dvcmQnKVwiIFxuICAgICAgICAgICAgICByZWY9XCJ1c2VyUGFzc3dvcmRcIiBcbiAgICAgICAgICAgICAgdi1tb2RlbD1cInVzZXJQYXNzd29yZFwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuPnt7IGVycm9ycy5maXJzdCgndXNlclBhc3N3b3JkJykgfX08L3NwYW4+XG4gICAgICBcdFx0XHQ8c3BhbiBjbGFzcz1cImljb24gaXMtc21hbGwgaXMtbGVmdFwiPlxuICAgICAgXHRcdFx0XHQ8aSBjbGFzcz1cImZhcyBmYS1rZXlcIj48L2k+XG4gICAgICBcdFx0XHQ8L3NwYW4+XG4gICAgICBcdFx0PC9kaXY+XG4gICAgICBcdDwvZGl2PlxuXG4gICAgICAgIDwhLS0gQ09ORklSTSBQQVNTV09SRCAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2wgaGFzLWljb25zLWxlZnRcIj5cbiAgICAgICAgICAgIDxpbnB1dCBcbiAgICAgICAgICAgICAgY2xhc3M9XCJpbnB1dFwiIFxuICAgICAgICAgICAgICB2LXZhbGlkYXRlPVwiJ3JlcXVpcmVkfGNvbmZpcm1lZDp1c2VyUGFzc3dvcmQnXCIgXG4gICAgICAgICAgICAgIG5hbWU9XCJ1c2VyQ29uZmlybVBhc3N3b3JkXCIgXG4gICAgICAgICAgICAgIHR5cGU9XCJwYXNzd29yZFwiIFxuICAgICAgICAgICAgICBkYXRhLXZ2LWFzPVwidXNlclBhc3N3b3JkXCIgXG4gICAgICAgICAgICAgIDpwbGFjZWhvbGRlcj1cImdldFRleHQoJ3Bhc3N3b3JkX2JpcycpXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4+e3sgZXJyb3JzLmZpcnN0KCd1c2VyQ29uZmlybVBhc3N3b3JkJykgfX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24gaXMtc21hbGwgaXMtbGVmdFwiPlxuICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS1rZXlcIj48L2k+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG5cbiAgICAgICAgPCEtLSBDR1UgLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCI+XG4gICAgICAgICAgICA8aW5wdXQgXG4gICAgICAgICAgICAgIGNsYXNzPVwiY2hlY2tib3hcIiBcbiAgICAgICAgICAgICAgdi12YWxpZGF0ZT1cIidyZXF1aXJlZCdcIiBcbiAgICAgICAgICAgICAgbmFtZT1cInVzZXJBY2NlcHRDR1VcIiBcbiAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCIgXG4gICAgICAgICAgICAgIHYtbW9kZWw9XCJ1c2VyQWNjZXB0Q0dVXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuPnt7IGVycm9ycy5maXJzdCgndXNlckFjY2VwdENHVScpIH19PC9zcGFuPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cInVzZXJBY2NlcHRDR1VcIj5cblxuICAgICAgICAgICAgICA8YSBjbGFzcz1cIm1vZGFsLWJ1dHRvbiBoYXMtdGV4dC1wcmltYXJ5XCIgZGF0YS10YXJnZXQ9XCJtb2RhbF9sZWdhbFwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCI+XG4gICAgICAgICAgICAgICAgPCEtLSBDb25kaXRpb25zIEfDqW7DqXJhbGVzIGQnVXRpbGlzYXRpb24gLS0+XG4gICAgICAgICAgICAgICAge3sgZ2V0VGV4dCgnYWNjZXB0X2NndScpIH19XG4gICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG5cbiAgICAgICAgPGJyPlxuXG4gICAgICAgIDwhLS0gU1VCTUlUIC0tPlxuICAgICAgXHQ8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGlzLWJsb2NrIGlzLXByaW1hcnkgaXMtZnVsbHdpZHRoIFwiIFxuICAgICAgICAgIDpkaXNhYmxlZD1cIiFlbmFibGVCdG5cIiBcbiAgICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICA+XG4gICAgICBcdFx0PCEtLSBTJ2VucmVnaXN0cmVyIC0tPlxuICAgICAgICAgIHt7IGdldFRleHQoJ3JlZ2lzdGVyJykgfX1cbiAgICAgIFx0PC9idXR0b24+XG5cbiAgICAgICAgPCEtLSA8YnI+XG5cbiAgICAgICAgPHAgY2xhc3M9XCJoYXMtdGV4dC1ncmV5XCI+XG4gICAgICAgICAgPHJvdXRlci1saW5rIFxuICAgICAgICAgICAgOnRvPVwiJy9sb2dpbidcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAge3sgZ2V0VGV4dCgnY29ubmVjdCcpIH19XG4gICAgICAgICAgPC9yb3V0ZXItbGluaz5cbiAgICAgICAgPC9wPiAtLT5cblxuICAgICAgPC9mb3JtPlxuXG4gICAgICA8cCBcbiAgICAgICAgY2xhc3M9XCJidXR0b24gaXMtYmxvY2sgaXMtcHJpbWFyeSBpcy1mdWxsd2lkdGhcIiBcbiAgICAgICAgdHlwZT1cInN1Ym1pdFwiIFxuICAgICAgICB2LWlmPVwidXNlci5pc0xvZ2dlZGluXCJcbiAgICAgICAgPlxuICAgICAgICA8IS0tIGTDqWrDoCBjb25uZWN0w6kgLS0+XG4gICAgICAgIHt7IGdldFRleHQoJ2Nvbm5lY3RlZCcpIH19XG4gICAgICA8L3A+XG5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gJ3Z1ZXgnXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgYXBpQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2FwaS5qcyc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJOYW1lOiAnJyxcbiAgICAgIHVzZXJTdXJuYW1lOiAnJyxcbiAgICAgIHVzZXJFbWFpbDogJycsXG4gICAgICB1c2VyUGFzc3dvcmQ6ICcnLFxuICAgICAgdXNlckFjY2VwdENHVTogJycsXG4gICAgICBjdXN0b21mb3JtRXJyb3I6ICcnXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIC4uLm1hcFN0YXRlKHtcbiAgICAgIHVzZXI6ICd1c2VyJ1xuICAgIH0pLFxuICAgIGVuYWJsZUJ0bigpIHtcbiAgICAgIHJldHVybiAodGhpcy5lcnJvcnMuYWxsKCkubGVuZ3RoID09PSAwKSA/IHRydWUgOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuXG4gICAgZ2V0VGV4dCh0ZXh0Q29kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDp0ZXh0Q29kZX0pXG4gICAgfSxcblxuICAgIHNlbmRSZWdpc3RlckZvcm0oZSl7XG4gICAgICB0aGlzLmN1c3RvbWZvcm1FcnJvciA9ICcnXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcblxuICAgICAgdGhpcy4kdmFsaWRhdG9yLnZhbGlkYXRlKCkudGhlbihib28gPT4ge1xuICAgICAgICAvLyBpZiBzb21lIGZpZWxkcyBpbiB0aGUgZm9ybSBhcmVuJ3QgcHJvcGVybHkgZmlsbGVkXG4gICAgICAgIGlmICghYm9vKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbWZvcm1FcnJvciA9ICdSZWdpc3RlciBmYWlsZWQgLSAnICsgdGhpcy5lcnJvcnMuYWxsKCk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBpZiB0aGUgZm9ybSBsb29rcyBnb29kLCB3ZSBzZW5kIGl0IHRvIHRoZSBiYWNrZW5kXG4gICAgICAgICAgLy8gY29uc3QgdXJsUmVnaXN0ZXIgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldFJvb3RVcmxVc2VyXG4gICAgICAgICAgY29uc3QgdXJsQXV0aFJvb3QgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldFJvb3RVcmxBdXRoXG5cbiAgICAgICAgICBjb25zdCB1cmxBdXRoUmVnaXN0ZXIgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldEVuZHBvaW50Q29uZmlnQXV0aFNwZWNpZmljKCdyZWdpc3RlcicpXG4gICAgICAgICAgY29uc3QgdXJsQXV0aFJlZ2lzdGVyU3VmZml4ID0gdXJsQXV0aFJlZ2lzdGVyLnJvb3RfdXJsXG4gICAgICAgICAgY29uc29sZS5sb2coXCJ1cmxBdXRoUmVnaXN0ZXJTdWZmaXggOiBcIiwgdXJsQXV0aFJlZ2lzdGVyU3VmZml4KVxuXG4gICAgICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLnVzZXJOYW1lLFxuICAgICAgICAgICAgc3VybmFtZTogdGhpcy51c2VyU3VybmFtZSxcbiAgICAgICAgICAgIGVtYWlsOnRoaXMudXNlckVtYWlsLFxuICAgICAgICAgICAgcHdkOnRoaXMudXNlclBhc3N3b3JkLFxuICAgICAgICAgICAgbGFuZzogXCJlblwiLFxuICAgICAgICAgICAgYWdyZWVtZW50OiB0aGlzLnVzZXJBY2NlcHRDR1VcbiAgICAgICAgICB9XG4gICAgICAgICAgYXhpb3NcbiAgICAgICAgICAgIC5wb3N0KCB1cmxBdXRoUm9vdCArIHVybEF1dGhSZWdpc3RlclN1ZmZpeCwgcGF5bG9hZClcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIGNhc2Ugd2hlcmUgY29kZSBpcyAyMDAgPT4gc3VjY2Vzc1xuICAgICAgICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnc2F2ZUxvZ2luSW5mb3MnLHtBUElyZXNwb25zZTpyZXNwb25zZX0pXG4gICAgICAgICAgICAgIHRoaXMuJHJvdXRlci5wdXNoKCdsb2dpbicpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKCBlcnJvciA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBpbiBjYXNlIHdlIGNhdGNoIHNvbWV0aGluZywgbGV0J3MgZGlzcGxheSBpdCBmb3IgZWFzaWVyIGRlYnVnXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IG1zZyA9IChlcnJvci5yZXNwb25zZSAmJiBlcnJvci5yZXNwb25zZS5kYXRhICYmIGVycm9yLnJlc3BvbnNlLmRhdGEubXNnKSA/ICcgLSAnICsgZXJyb3IucmVzcG9uc2UuZGF0YS5tc2cgOiAnJ1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDQwMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXN0b21mb3JtRXJyb3IgPSAnUmVnaXN0ZXIgZmFpbGVkJyArIG1zZ1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvciB1bmtvd24nLGVycm9yLE9iamVjdC5rZXlzKGVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tZm9ybUVycm9yID0gJ1JlZ2lzdGVyIGZhaWxlZCAtIGNvbnRhY3QgdGhlIHdlYm1hc3RlcidcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3dlIGNhbm5vdCByZWFkIHRoZSBlcnJvciBtZXNzYWdlIGZyb20gdGhlIEFQSScsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21mb3JtRXJyb3IgPSAnUmVnaXN0ZXIgZmFpbGVkJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBlbmQsIGlmIHdlIG5lZWQgdG8gZG8gc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgdGhpcy51c2VyUGFzc3dvcmQgPSAnJ1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckNvbmZpcm1QYXNzd29yZCA9ICcnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPG5hdiBjbGFzcz1cIm5hdmJhciBpcy13aGl0ZSBpcy1maXhlZC10b3BcIiByb2xlPVwibmF2aWdhdGlvblwiIGFyaWEtbGFiZWw9XCJtYWluIG5hdmlnYXRpb25cIj5cblxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgICAgIFxuICAgICAgICA8QnJhbmQgXG4gICAgICAgICAgOmxvZ289XCJsb2dvXCIgXG4gICAgICAgICAgOmxvZ29Ubz1cInRoaXMubmF2YmFyQ29uZmlnLmxvZ29fdG9cIlxuICAgICAgICAgIDpicmFuZD1cImJyYW5kXCJcbiAgICAgICAgPjwvQnJhbmQ+XG5cbiAgICAgICAgPCEtLSBERUJVR0dJTkcgLS0+XG4gICAgICAgIDwhLS0gY3VycmVudFJvdXRlQ29uZmlnIDoge3sgY3VycmVudFJvdXRlQ29uZmlnLmZpZWxkIH19IC0tPlxuICAgICAgXG4gICAgICAgIDxOYXZCYXJDb250ZW50IFxuICAgICAgICAgIDpOYXZiYXJMaW5rcz1cInRoaXMubmF2YmFyQ29uZmlnLmxpbmtzX29wdGlvbnNcIlxuICAgICAgICAgIDp1c2VyPVwidXNlclwiXG4gICAgICAgICAgOmxvY2FsUm91dGVDb25maWc9XCJsb2NhbFJvdXRlQ29uZmlnXCJcbiAgICAgICAgPjwvTmF2QmFyQ29udGVudD5cblxuICAgICAgPC9kaXY+XG5cbiAgICA8L25hdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQnJhbmQgZnJvbSAnLi9CcmFuZC52dWUnO1xuaW1wb3J0IE5hdkJhckNvbnRlbnQgZnJvbSAnLi9OYXZCYXJDb250ZW50LnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIEJyYW5kLFxuICAgIE5hdkJhckNvbnRlbnRcbiAgfSxcbiAgcHJvcHM6IFtcbiAgICAnbmF2YmFyQ29uZmlnJyxcbiAgICAnYXBwTG9jYWxlcycsXG4gICAgJ2xvZ28nLCBcbiAgICAnYnJhbmQnLCBcbiAgICAnbG9jYWxSb3V0ZUNvbmZpZycsXG4gICAgXG4gICAgLy8gJ2N1cnJlbnREYXRhc2V0VVJJJyxcbiAgICAvLyAnY3VycmVudFJvdXRlQ29uZmlnJyxcblxuICAgICd1c2VyJ1xuICBdXG59XG48L3NjcmlwdD5cblxuPHN0eWxlPlxubmF2IHtcbiAgaGVpZ2h0OiA2MHB4O1xuICB6LWluZGV4OiAxMDtcbn1cbjwvc3R5bGU+IiwiPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuICBAaW1wb3J0ICcuLi8uLi9zdHlsZXMvYXBpdml6LWNvbG9ycy5zY3NzJztcbiAgLnJvdXRlci1saW5rLWFjdGl2ZXtcbiAgICAvLyB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICBjb2xvcjogJGFwaXZpei1wcmltYXJ5IDtcbiAgfVxuICAuaXMtdW5kZXJsaW5lZHtcbiAgICBib3JkZXItYm90dG9tOiBzb2xpZDtcbiAgICBib3JkZXItY29sb3I6ICRhcGl2aXotcHJpbWFyeTtcbiAgfVxuICAubmF2YmFyLWRyb3Bkb3duIHtcbiAgICB6LWluZGV4OiAxMDA7XG4gIH1cbiAgLm1lbnUtZGVsaW1pdGVye1xuICAgIG1hcmdpbjowZW0gMGVtIDEuNWVtIDBlbSA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJGFwaXZpei1wcmltYXJ5O1xuICB9XG4gIGhyLm1lbnUtZW5kZXJ7XG4gICAgbWFyZ2luOiAxLjVlbSAwZW0gMGVtIDBlbSA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJGFwaXZpei1wcmltYXJ5O1xuICB9XG4gIC8vIC5zcGFjZXJ7XG4gIC8vICAgcGFkZGluZzogMWVtIDBlbSAxLjVlbSAwZW07XG4gIC8vIH1cbiAgLmJ1dHRvbnN7XG4gICAgbWFyZ2luLWJvdHRvbTogMGVtO1xuICB9XG4gIC5idG4tbWVudXtcbiAgICBtYXJnaW4tbGVmdDogMWVtO1xuICAgIG1hcmdpbi1ib3R0b206IDBlbTtcbiAgfVxuICAuaXMtZmxleC10b3VjaHtcbiAgICBtYXJnaW4tdG9wOiAxZW07XG4gIH1cbjwvc3R5bGU+XG5cbjx0ZW1wbGF0ZT5cbiAgPGRpdiBcbiAgICBpZD1cIm5hdmJhci1tYWluXCIgXG4gICAgOmNsYXNzPVwiYG5hdmJhci1tZW51ICR7IHNob3dOYXYgPyAnaXMtYWN0aXZlJyA6ICcnIH1gXCJcbiAgICA+XG4gICAgPGRpdiBjbGFzcz1cIm5hdmJhci1lbmRcIj5cblxuXG4gICAgICA8IS0tIE5BVkJBUiBJVEVNUyAtLT5cbiAgICAgIDx0ZW1wbGF0ZVxuICAgICAgICB2LWZvcj1cIihsaW5rLCBpbmRleCkgaW4gdGhpcy5OYXZiYXJMaW5rcy5leHRyYV9idXR0b25zXCJcbiAgICAgICAgPlxuXG4gICAgICAgIDxyb3V0ZXItbGlua1xuICAgICAgICAgIHYtaWY9XCJsaW5rLmxpbmtfdHlwZSA9PSAnbGluaycgJiYgbGluay5pc192aXNpYmxlID09IHRydWVcIlxuICAgICAgICAgIDprZXk9XCJgJ2xpbmstJyArICR7aW5kZXh9YFwiXG4gICAgICAgICAgOmNsYXNzPVwiYG5hdmJhci1pdGVtICR7IGxpbmsuaGFzX2Ryb3Bkb3duID8gJ2hhcy1kcm9wZG93biBpcy1ob3ZlcmFibGUnIDogJycgfSAgYFwiXG4gICAgICAgICAgOnRvPVwibGluay5saW5rX3RvXCJcbiAgICAgICAgICA+XG5cbiAgICAgICAgICA8IS0tIE1BSU4gTElOSyAtLT5cbiAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgOmNsYXNzPVwiYCR7IGxpbmsuaGFzX2Ryb3Bkb3duID8gJ25hdmJhci1saW5rIGlzLWFycm93bGVzcycgOiAnJyB9ICR7IGlzSXRlbUFjdGl2ZShsaW5rKSA/ICdoYXMtdGV4dC1wcmltYXJ5JyA6ICcnIH1gXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIDpjbGFzcz1cImAkeyBpc0l0ZW1BY3RpdmUobGluaykgPyAnaXMtdW5kZXJsaW5lZCcgOiAnJyB9YFwiPlxuICAgICAgICAgICAgICB7eyB0cmFuc2xhdGUobGluaywgJ2xpbmtfdGV4dCcgKSB9fVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPCEtLSBEUk9QRE9XTlMgLS0+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgdi1pZj1cImxpbmsuaGFzX2Ryb3Bkb3duXCJcbiAgICAgICAgICAgIGNsYXNzPVwibmF2YmFyLWRyb3Bkb3duXCJcbiAgICAgICAgICAgID5cblxuICAgICAgICAgICAgPHRlbXBsYXRlIFxuICAgICAgICAgICAgICB2LWZvcj1cIihzdWJsaW5rLCBpKSBpbiBsaW5rLmRyb3Bkb3duc1wiXG4gICAgICAgICAgICAgID5cblxuICAgICAgICAgICAgICA8YSBcbiAgICAgICAgICAgICAgICB2LWlmPVwiIXN1YmxpbmsuaXNfZGl2aWRlciAmJiBzdWJsaW5rLmlzX2V4dGVybmFsX2xpbmtcIlxuICAgICAgICAgICAgICAgIDprZXk9XCJgJ3N1YmxpbmstZXh0LScgKyAke2l9YFwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJuYXZiYXItaXRlbVwiXG4gICAgICAgICAgICAgICAgOmhyZWY9XCJzdWJsaW5rLmxpbmtfdG9cIlxuICAgICAgICAgICAgICAgIEBjbGljaz1cImxvYWRFeHRlcm5hbFVSTChzdWJsaW5rLmxpbmtfdG8pXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3sgdHJhbnNsYXRlKHN1YmxpbmssICdsaW5rX3RleHQnICkgfX1cbiAgICAgICAgICAgICAgPC9hPlxuXG4gICAgICAgICAgICAgIDxyb3V0ZXItbGlua1xuICAgICAgICAgICAgICAgIHYtaWY9XCIhc3VibGluay5pc19kaXZpZGVyICYmICFzdWJsaW5rLmlzX2V4dGVybmFsX2xpbmtcIlxuICAgICAgICAgICAgICAgIDprZXk9XCJgJ3N1YmxpbmstaW50LScgKyAke2l9YFwiXG4gICAgICAgICAgICAgICAgOmNsYXNzPVwiYG5hdmJhci1pdGVtICR7IGlzQWN0aXZlTGluayhzdWJsaW5rLmxpbmtfdG8pID8gJ2hhcy10ZXh0LXdoaXRlIGhhcy1iYWNrZ3JvdW5kLXByaW1hcnknIDogJycgfWBcIlxuICAgICAgICAgICAgICAgIDp0bz1cInN1YmxpbmsubGlua190b1wiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHt7IHRyYW5zbGF0ZShzdWJsaW5rLCAnbGlua190ZXh0JyApIH19XG4gICAgICAgICAgICAgIDwvcm91dGVyLWxpbms+XG5cblxuICAgICAgICAgICAgICA8aHIgXG4gICAgICAgICAgICAgICAgdi1pZj1cInN1YmxpbmsuaXNfZGl2aWRlclwiXG4gICAgICAgICAgICAgICAgOmtleT1cImAnc3VibGluay1kaXYtJyArICR7aX1gXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cIm5hdmJhci1kaXZpZGVyXCJcbiAgICAgICAgICAgICAgPlxuXG4gICAgICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgICAgIFxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwvcm91dGVyLWxpbms+XG4gICAgICAgIFxuICAgICAgICA8aHIgXG4gICAgICAgICAgdi1pZj1cImxpbmsubGlua190eXBlID09ICdsaW5rJyAmJiBsaW5rLmlzX3Zpc2libGUgPT0gdHJ1ZVwiXG4gICAgICAgICAgOmtleT1cImluZGV4XCJcbiAgICAgICAgICBjbGFzcz1cImlzLWZsZXgtdG91Y2ggbWVudS1kZWxpbWl0ZXJcIlxuICAgICAgICA+XG4gICAgICBcbiAgICAgIDwvdGVtcGxhdGU+XG5cblxuICAgICAgPCEtLSBCVVRUT05TIExJTktTIC0tPlxuICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbnNcIj5cblxuICAgICAgICA8dGVtcGxhdGVcbiAgICAgICAgICB2LWZvcj1cIihsaW5rLCBpbmRleCkgaW4gdGhpcy5OYXZiYXJMaW5rcy5leHRyYV9idXR0b25zXCJcbiAgICAgICAgICA+XG5cbiAgICAgICAgICA8cm91dGVyLWxpbmtcbiAgICAgICAgICAgIHYtaWY9XCIhbGluay5oYXNfZHJvcGRvd24gJiYgIWxpbmsuaXNfZXh0ZXJuYWxfbGluayAmJiBsaW5rLmxpbmtfdHlwZSA9PSAnYnV0dG9uJyAmJiBsaW5rLmlzX3Zpc2libGUgPT0gdHJ1ZVwiXG4gICAgICAgICAgICA6Y2xhc3M9XCJgbmF2YmFyLWl0ZW0gYnV0dG9uIGlzLXByaW1hcnkgaXMtb3V0bGluZWQgaXMtc21hbGwgYnRuLW1lbnVgXCJcbiAgICAgICAgICAgIHYtYmluZDprZXk9XCJgJ2J0bmxpbmstZXh0LScgKyAke2luZGV4fWBcIlxuICAgICAgICAgICAgOnRvPVwibGluay5saW5rX3RvXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuPnt7IHRyYW5zbGF0ZSggbGluaywnbGlua190ZXh0JyApIH19PC9zcGFuPlxuICAgICAgICAgIDwvcm91dGVyLWxpbms+XG5cbiAgICAgICAgICA8YVxuICAgICAgICAgICAgdi1pZj1cIiFsaW5rLmhhc19kcm9wZG93biAmJiBsaW5rLmlzX2V4dGVybmFsX2xpbmsgJiYgbGluay5saW5rX3R5cGUgPT0gJ2J1dHRvbicgJiYgbGluay5pc192aXNpYmxlID09IHRydWVcIlxuICAgICAgICAgICAgOmNsYXNzPVwiYG5hdmJhci1pdGVtIGJ1dHRvbiBpcy1wcmltYXJ5IGlzLW91dGxpbmVkIGlzLXNtYWxsIGJ0bi1tZW51YFwiXG4gICAgICAgICAgICA6aHJlZj1cImxpbmsubGlua190b1wiXG4gICAgICAgICAgICB2LWJpbmQ6a2V5PVwiYCdzdWJsaW5rLWludC0nICsgJHtpfWBcIlxuICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuPnt7IHRyYW5zbGF0ZSggbGluaywnbGlua190ZXh0JyApIH19PC9zcGFuPlxuICAgICAgICAgIDwvYT5cblxuICAgICAgICAgIDxociBcbiAgICAgICAgICAgIHYtaWY9XCIhbGluay5oYXNfZHJvcGRvd24gJiYgbGluay5saW5rX3R5cGUgPT0gJ2J1dHRvbicgJiYgbGluay5pc192aXNpYmxlID09IHRydWVcIlxuICAgICAgICAgICAgdi1iaW5kOmtleT1cImAnc3VibGluay1kaXYtJyArICR7aX1gXCJcbiAgICAgICAgICAgIGNsYXNzPVwiaXMtZmxleC10b3VjaCBtZW51LWRlbGltaXRlclwiXG4gICAgICAgICAgPlxuXG4gICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgIDwvZGl2PlxuXG5cbiAgICAgIDwhLS0gVVNFUiBEUk9QRE9XTiAtLT5cbiAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbSBoYXMtZHJvcGRvd24gaXMtaG92ZXJhYmxlXCJcbiAgICAgICAgdi1pZj1cInVzZXIuaXNMb2dnZWRpblwiXG4gICAgICAgID5cblxuICAgICAgICA8YSBjbGFzcz1cIm5hdmJhci1saW5rIGlzLWFycm93bGVzc1wiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1sYXJnZVwiPlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJmYXIgZmEtdXNlci1jaXJjbGVcIj48L2k+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2E+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1kcm9wZG93biBpcy1yaWdodFwiPlxuXG4gICAgICAgICAgPHAgY2xhc3M9XCJuYXZiYXItaXRlbVwiPlxuICAgICAgICAgICAge3sgZ2V0VGV4dCgnaGVsbG8nKSB9fSB7eyB1c2VyLmluZm9zLm5hbWUgfX1cbiAgICAgICAgICA8L3A+XG5cbiAgICAgICAgICA8aHIgY2xhc3M9XCJuYXZiYXItZGl2aWRlclwiPlxuXG4gICAgICAgICAgPHJvdXRlci1saW5rIGNsYXNzPVwibmF2YmFyLWl0ZW1cIlxuICAgICAgICAgICAgdi1pZj1cImlzVXNlckFkbWluIHx8IGlzVXNlclN0YWZmXCJcbiAgICAgICAgICAgIDp0bz1cIicvYmFja29mZmljZSdcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAge3sgZ2V0VGV4dCgnYmFja29mZmljZScpIH19XG4gICAgICAgICAgPC9yb3V0ZXItbGluaz5cblxuICAgICAgICAgIDxyb3V0ZXItbGluayBjbGFzcz1cIm5hdmJhci1pdGVtXCJcbiAgICAgICAgICAgIDp0bz1cIicvcHJlZmVyZW5jZXMnXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIHt7IGdldFRleHQoJ3ByZWZfdXNlcicpIH19XG4gICAgICAgICAgPC9yb3V0ZXItbGluaz5cblxuICAgICAgICAgIDxociBjbGFzcz1cIm5hdmJhci1kaXZpZGVyXCI+XG5cbiAgICAgICAgICA8cm91dGVyLWxpbmsgY2xhc3M9XCJuYXZiYXItaXRlbVwiXG4gICAgICAgICAgICA6dG89XCInL2xvZ291dCdcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAge3sgZ2V0VGV4dCgnZGlzY29ubmVjdCcpIH19XG4gICAgICAgICAgPC9yb3V0ZXItbGluaz5cblxuICAgICAgICA8L2Rpdj5cblxuICAgICAgPC9kaXY+XG5cblxuICAgIDwvZGl2PlxuXG4gICAgPGhyIGNsYXNzPVwiaXMtZmxleC10b3VjaCBtZW51LWVuZGVyXCI+XG5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgbWFwU3RhdGUgfSBmcm9tICd2dWV4J1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzIDogW1xuICAgICdOYXZiYXJMaW5rcycsXG4gICAgJ2xvY2FsUm91dGVDb25maWcnXG4gICAgLy8gJ2N1cnJlbnREYXRhc2V0VVJJJ1xuICBdLFxuICBiZWZvcmVNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiLy8gTmF2YmFyTGlua3MgOiBcIiwgdGhpcy5OYXZiYXJMaW5rcylcbiAgICAvLyBjb25zb2xlLmxvZyhcIi8vIGN1cnJlbnREYXRhc2V0VVJJIDogXCIsIHRoaXMuY3VycmVudERhdGFzZXRVUkkpXG4gIH0sXG4gIGNvbXB1dGVkIDoge1xuICAgIC4uLm1hcFN0YXRlKHtcbiAgICAgIHVzZXI6ICd1c2VyJ1xuICAgIH0pLFxuICAgIHNob3dOYXYoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXROYXZiYXJWaXNpYmlsaXR5XG4gICAgfSxcbiAgICBpc1VzZXJBZG1pbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRDaGVja1VzZXJSb2xlKCdhZG1pbicpXG4gICAgfSxcbiAgICBpc1VzZXJTdGFmZiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRDaGVja1VzZXJSb2xlKCdzdGFmZicpXG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kcyA6IHtcblxuICAgIGdldFRleHQodGV4dENvZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmRlZmF1bHRUZXh0KHt0eHQ6dGV4dENvZGV9KVxuICAgIH0sXG5cbiAgICAvLyBpc0N1cnJlbnRSb3V0ZShsaW5rVG8pe1xuICAgIC8vICAgY29uc29sZS5sb2coXCJcXG4uLi4uLi4gbGlua1RvIDogXCIsIGxpbmtUbylcbiAgICAvLyAgIGxldCBwYXRoID0gdGhpcy4kcm91dGVyLmN1cnJlbnRSb3V0ZS5wYXRoXG4gICAgLy8gICBjb25zb2xlLmxvZyhcIi4uLi4uLiBwYXRoIDogXCIsIHBhdGgpXG4gICAgLy8gICByZXR1cm4gKCBwYXRoID09PSBsaW5rVG8gKSA/IHRydWUgOiBmYWxzZVxuICAgIC8vIH0sXG4gICAgbG9hZEV4dGVybmFsVVJMKGxpbmtfdG8pe1xuICAgICAgY29uc29sZS5sb2coXCJsb2FkRXh0ZXJuYWxVUkwgLyBsaW5rX3RvIDogXCIsIGxpbmtfdG8pXG4gICAgICB2YXIgd2luID0gd2luZG93Lm9wZW4obGlua190bywgJ19ibGFuaycpO1xuICAgICAgd2luLmZvY3VzKCk7XG4gICAgfSxcbiAgICBpc0FjdGl2ZUxpbmsobGlua190byl7XG4gICAgICBjb25zdCBjdXJyZW50Um91dGUgPSB0aGlzLiRyb3V0ZS5wYXRoXG4gICAgICAvLyBjb25zb2xlLmxvZyhcImlzQWN0aXZlTGluayAvIGN1cnJlbnRSb3V0ZSA6IFwiLCBjdXJyZW50Um91dGUpXG4gICAgICBjb25zdCByb3V0ZVVSTCA9IHRoaXMubG9jYWxSb3V0ZUNvbmZpZy51cmxzXG4gICAgICAvLyBjb25zb2xlLmxvZyhcImlzQWN0aXZlTGluayAvIHJvdXRlVVJMIDogXCIsIHJvdXRlVVJMKVxuICAgICAgcmV0dXJuIGxpbmtfdG8gPT09IGN1cnJlbnRSb3V0ZSB8fCByb3V0ZVVSTC5pbmRleE9mKGxpbmtfdG8pICE9IC0xXG4gICAgfSxcbiAgICBpc0l0ZW1BY3RpdmUobGluayl7XG4gICAgICBjb25zdCBjdXJyZW50Um91dGUgPSB0aGlzLiRyb3V0ZS5wYXRoXG4gICAgICBjb25zdCBpc0xpbmtUb1JvdXRlID0gdGhpcy5pc0FjdGl2ZUxpbmsobGluay5saW5rX3RvKVxuICAgICAgbGV0IGlzU3VibGlua1JvdXRlID0gZmFsc2VcbiAgICAgIGlmIChsaW5rLmhhc19kcm9wZG93bil7XG4gICAgICAgIGNvbnN0IGxpbmtEcm9wZG93bnMgPSBsaW5rLmRyb3Bkb3duc1xuICAgICAgICBjb25zdCBsaW5rRHJvcGRvd25zTGlzdCA9IGxpbmtEcm9wZG93bnMubWFwKGUgPT4gZS5saW5rX3RvKTtcbiAgICAgICAgaXNTdWJsaW5rUm91dGUgPSBsaW5rRHJvcGRvd25zTGlzdC5pbmRleE9mKGN1cnJlbnRSb3V0ZSkgIT0gLTFcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJpc0l0ZW1BY3RpdmUgLyBsaW5rRHJvcGRvd25zTGlzdCA6IFwiLCBsaW5rRHJvcGRvd25zTGlzdClcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0xpbmtUb1JvdXRlIHx8IGlzU3VibGlua1JvdXRlXG4gICAgfSxcbiAgICB0cmFuc2xhdGUoIHRleHRzVG9UcmFuc2xhdGUsIGxpc3RGaWVsZCApIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwidGV4dHNUb1RyYW5zbGF0ZSA6IFwiLCB0ZXh0c1RvVHJhbnNsYXRlIClcbiAgICAgIGxldCBsaXN0VGV4dHMgPSB0ZXh0c1RvVHJhbnNsYXRlLmxpbmtfdGV4dFxuICAgICAgLy8gY29uc29sZS5sb2coXCJsaXN0VGV4dHMgOiBcIiwgbGlzdFRleHRzIClcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldFRyYW5zbGF0aW9uKHsgdGV4dHMgOiBsaXN0VGV4dHMgfSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG4iLCJ2YXIgX192dWVfX29wdGlvbnNfXyA9ICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpXG5fX3Z1ZV9fb3B0aW9uc19fLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF92bS5fbSgwKX1cbl9fdnVlX19vcHRpb25zX18uc3RhdGljUmVuZGVyRm5zID0gW2Z1bmN0aW9uIHJlbmRlciAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdtYWluJyx7c3RhdGljQ2xhc3M6XCJlcnJvciBlcnJvci00MDRcIn0sW19jKCdpbWcnLHthdHRyczp7XCJzcmNcIjpcIi9zdGF0aWMvaWxsdXN0cmF0aW9ucy9lcnJldXJfNDA0LnBuZ1wifX0pLF92bS5fdihcIiBcIiksX2MoJ2RpdicsW19jKCdoMScse3N0YXRpY0NsYXNzOlwidGl0bGUgaXMtMSBpcy1wcmltYXJ5XCJ9LFtfdm0uX3YoXCJPb3BzLCBMYSBwYWdlIHF1ZSB2b3VzIGNoZXJjaGV6IG4nZXhpc3RlIHBhcyAhXCIpXSksX3ZtLl92KFwiIFwiKSxfYygnYScse3N0YXRpY0NsYXNzOlwiYnV0dG9uIGlzLXByaW1hcnkgaXMtb3V0bGluZWRcIixhdHRyczp7XCJocmVmXCI6XCIvXCJ9fSxbX3ZtLl92KFwiUmV2ZW5pciDDoCBsYSBwYWdlIHByaW5jaXBhbGVcIildKV0pXSl9XVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IFxuICAgIDpjbGFzcz1cImBjb2x1bW4gaXMtMTIgJHsgdmlldyA9PT0gJ1ZJRVdfTUFQJyA/ICdob3Zlci1lZmZlY3QnIDogJyd9YFwiPlxuICAgIDxkaXYgXG4gICAgICA6Y2xhc3M9XCJgY2FyZCBwcm9qLWNhcmQgJHsgdmlldyA9PT0gJ1ZJRVdfTElTVCcgPyAnaG92ZXItZWZmZWN0JyA6ICcnfWBcIlxuICAgICAgPlxuICAgICAgXG5cbiAgICAgIDwhLS0gQkxPQ0sgSU1BR0UgLS0+XG4gICAgICA8cm91dGVyLWxpbmsgXG4gICAgICAgIDp0bz1cImAvJHtkYXRhc2V0X3VyaX0vZGV0YWlsP2lkPSR7bWF0Y2hJdGVtV2l0aENvbmZpZygnYmxvY2tfaWQnKX1gXCIgXG4gICAgICAgIGNsYXNzPVwiY2FyZC1pbWFnZVwiXG4gICAgICAgID5cbiAgICAgICAgPGltZyBcbiAgICAgICAgICBjbGFzcz1cInByb2otY2FyZC1pbWdcIiBcbiAgICAgICAgICA6c3JjPVwiaXRlbUluZm9zLmltYWdlXCIgXG4gICAgICAgICAgOmFsdD1cIml0ZW1JbmZvcy50aXRsZVwiIFxuICAgICAgICA+XG4gICAgICA8L3JvdXRlci1saW5rPlxuXG4gICAgICA8IS0tIEJMT0NLIEFERFJFU1MgLS0+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1jb250ZW50XCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIiB2LWlmPVwicHJvamVjdENpdHkoKVwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuICAgICAgICAgICAgPGltZyBjbGFzcz1cImltYWdlIGlzLTE2eDE2XCIgc3JjPVwiL3N0YXRpYy9pY29ucy9pY29uX3Bpbi5zdmdcIj5cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdWJ0aXRsZSBpcy02IGlzLWNhcGl0YWxpemVkXCI+XG4gICAgICAgICAgICA8IS0tIHt7IG1hdGNoSXRlbVdpdGhDb25maWcoJ2Jsb2NrX2FkZHJlc3MnKX19IC0tPlxuICAgICAgICAgICAgPCEtLSB7eyBwcm9qZWN0QWRkcmVzcygpIH19IC0gIC0tPlxuICAgICAgICAgICAgPCEtLSB7eyBtYXRjaEl0ZW1XaXRoQ29uZmlnKCdibG9ja19jaXR5Jyl9fSAtLT5cbiAgICAgICAgICAgIHt7IHByb2plY3RDaXR5KCkgfX1cblxuICAgICAgICAgICAgPCEtLSB7eyBub0FkZHJlc3MoKSB9fSAtLT5cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwhLS0gQkxPQ0sgVElUTEUgLS0+XG4gICAgICAgIDxwIGNsYXNzPVwidGl0bGUgaXMtNSBoYXMtdGV4dC13ZWlnaHQtYm9sZCBoYXMtdGV4dC1ibGFjay10ZXJcIiB2LWlmPVwibWF0Y2hJdGVtV2l0aENvbmZpZygnYmxvY2tfaWQnKVwiPlxuICAgICAgICAgIDxyb3V0ZXItbGluayA6dG89XCJgLyR7ZGF0YXNldF91cml9L2RldGFpbD9pZD0keyBtYXRjaEl0ZW1XaXRoQ29uZmlnKCdibG9ja19pZCcpIH1gXCI+XG4gICAgICAgICAgICB7eyBtYXRjaEl0ZW1XaXRoQ29uZmlnKCdibG9ja190aXRsZScpfX1cbiAgICAgICAgICA8L3JvdXRlci1saW5rPlxuICAgICAgICA8L3A+XG5cbiAgICAgICAgPCEtLSBCTE9DSyBBQlNUUkFDVCAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIiB2LWlmPVwicHJvamVjdEFic3RyYWN0KClcIj5cbiAgICAgICAgICA8cCBjbGFzcz1cInN1YnRpdGxlIGlzLTZcIj5cbiAgICAgICAgICAgIHt7IHByb2plY3RBYnN0cmFjdCgpIH19XG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8IS0tIEJMT0NLIFNPVVJDRSAtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIiB2LWlmPVwibWF0Y2hJdGVtV2l0aENvbmZpZygnYmxvY2tfc3JjJylcIj5cbiAgICAgICAgICA8cCBjbGFzcz1cInN1YnRpdGxlIGlzLTYgaXMtaXRhbGljIGhhcy10ZXh0LWdyZXlcIj5cbiAgICAgICAgICAgIHt7IHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDonc291cmNlJ30pfX0gOiB7eyBtYXRjaEl0ZW1XaXRoQ29uZmlnKCdibG9ja19zcmMnKSB9fVxuICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPCEtLSBCTE9DSyBUQUdTIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiIHYtaWY9XCJBcnJheS5pc0FycmF5KCBpdGVtSW5mb3MudGFncyApICYmIGl0ZW1JbmZvcy50YWdzLmxlbmd0aCA+PTFcIj5cbiAgICAgICAgICA8c3BhbiB2LWZvcj1cInRhZyBpbiBpdGVtSW5mb3MudGFnc1wiIGNsYXNzPVwidGFnXCIgOmtleT1cInRhZ1wiPlxuICAgICAgICAgICAgICB7eyB0YWcgfX1cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gXCJ2dWV4XCI7XG5cbmNvbnN0IE1BWF9TVU1NQVJZX0xFTkdUSCA9IDEyMDtcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIG5hbWU6ICdQcm9qZWN0Q2FyZCcsXG5cbiAgY29tcG9uZW50czoge30sXG5cbiAgcHJvcHM6IFtcbiAgICAnaXRlbScsXG4gICAgJ2NvbnRlbnRGaWVsZHMnLFxuICAgICd2aWV3J1xuICAgIF0sXG4gIC8vIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAvLyAgIGNvbnNvbGUubG9nKFwiXFxuIC0gLSBQcm9qZWN0Q2FyZCAvIGJlZm9yZUNyZWF0ZSAuLi4gXCIpXG4gIC8vIH0sXG4gIC8vIGNyZWF0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgLy8gICBjb25zb2xlLmxvZyhcIlxcbiAtIC0gUHJvamVjdENhcmQgLyBjcmVhdGVkIC4uLiBcIilcbiAgLy8gfSxcbiAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIlxcbiAtIC0gUHJvamVjdENhcmQgLyBiZWZvcmVNb3VudCAuLi4gXCIpXG4gICAgLy8gY29uc29sZS5sb2coXCIgLSAtIFByb2plY3RDYXJkIC8gdGhpcy5jb250ZW50RmllbGRzIDogXFxuIFwiLCB0aGlzLmNvbnRlbnRGaWVsZHMpXG4gICAgLy8gY29uc29sZS5sb2coXCIgLSAtIFByb2plY3RDYXJkIC8gdGhpcy5pdGVtIDogXFxuIFwiLCB0aGlzLml0ZW0pXG4gICAgLy8gY29uc29sZS5sb2coXCIgLSAtIFByb2plY3RDYXJkIC8gdGhpcy4kc3RvcmUuc3RhdGUuY29uZmlnLmdsb2JhbC5hcHBfYmFzaWNfZGljdCA6IFxcbiBcIiwgdGhpcy4kc3RvcmUuc3RhdGUuY29uZmlnLmdsb2JhbC5hcHBfYmFzaWNfZGljdClcblxuICB9LFxuICAvLyBtb3VudGVkIDogZnVuY3Rpb24gKCkge1xuICAvLyAgIGNvbnNvbGUubG9nKFwiXFxuIC0gLSBQcm9qZWN0Q2FyZCAvIG1vdW50ZWQgLi4uIFwiKVxuICAvLyAgIGNvbnNvbGUubG9nKFwiLSAtIFByb2plY3RDYXJkIC8gdGhpcy5yb3V0ZUNvbmZpZ1wiLCB0aGlzLnJvdXRlQ29uZmlnKVxuICAvLyB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgLy8gc3VtbWFyeSgpe1xuICAgIC8vICAgY29uc3Qge2Rlc2NyaXB0aW9uID0gJyhwcm9qZXQgc2FucyByw6lzdW3DqSknfSA9IHRoaXMuaXRlbVxuICAgIC8vICAgY29uc3QgdGFpbCA9IGRlc2NyaXB0aW9uLmxlbmd0aCA+IE1BWF9TVU1NQVJZX0xFTkdUSCA/ICcuLi4nIDogJyc7XG4gICAgLy8gICByZXR1cm4gZGVzY3JpcHRpb24uc2xpY2UoMCwgTUFYX1NVTU1BUllfTEVOR1RIKSArIHRhaWxcbiAgICAvLyB9LFxuICAgIGRhdGFzZXRfdXJpKCl7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuc3RhdGUuc2VhcmNoLmRhdGFzZXRfdXJpXG4gICAgfSxcbiAgICBpdGVtSW5mb3MoKXtcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldFByb2plY3RDb25maWdVbmlmb3JtKHRoaXMuaXRlbSlcbiAgICAgIC8vIHJldHVybiB0aGlzLml0ZW1cbiAgICB9LFxuICAgIG5vRGF0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmRlZmF1bHRUZXh0KHt0eHQ6J25vX2RhdGEnfSlcbiAgICB9LFxuICAgIG5vQWJzdHJhY3RUZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDonbm9fYWJzdHJhY3QnfSlcbiAgICB9LFxuICAgIG5vSW5mb3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kZWZhdWx0VGV4dCh7dHh0Oidub19pbmZvJ30pXG4gICAgfSxcbiAgICBub0FkZHJlc3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kZWZhdWx0VGV4dCh7dHh0Oidub19hZGRyZXNzJ30pXG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kcyA6IHtcbiAgICBtYXRjaEl0ZW1XaXRoQ29uZmlnKGZpZWxkQmxvY2spIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwibWF0Y2hJdGVtV2l0aENvbmZpZyAvIGZpZWxkQmxvY2sgOiBcIiwgZmllbGRCbG9jayApXG4gICAgICBjb25zdCBjb250ZW50RmllbGQgPSB0aGlzLmNvbnRlbnRGaWVsZHMuZmluZChmPT4gZi5wb3NpdGlvbiA9PSBmaWVsZEJsb2NrKVxuICAgICAgaWYgKGNvbnRlbnRGaWVsZCkge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGNvbnRlbnRGaWVsZC5maWVsZFxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtW2ZpZWxkXVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0ZW1JbWFnZShmaWVsZEJsb2NrKXtcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldEltYWdlVXJsKHtpdGVtOiB0aGlzLml0ZW0sIHBvc2l0aW9uOiBmaWVsZEJsb2NrfSlcbiAgICAgIC8vIHJldHVybiB0aGlzLml0ZW1cbiAgICB9LFxuICAgIHByb2plY3RJZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGNoSXRlbVdpdGhDb25maWcoJ2Jsb2NrX2lkJylcbiAgICB9LFxuICAgIHByb2plY3RBYnN0cmFjdCgpIHtcbiAgICAgIGxldCBmdWxsQWJzdHJhY3QgPSB0aGlzLm1hdGNoSXRlbVdpdGhDb25maWcoJ2Jsb2NrX2Fic3RyYWN0JylcbiAgICAgIGZ1bGxBYnN0cmFjdCA9ICggZnVsbEFic3RyYWN0ID09IG51bGwgKSA/IHRoaXMubm9BYnN0cmFjdFRleHQgOiBmdWxsQWJzdHJhY3RcbiAgICAgIGNvbnN0IHRhaWwgPSBmdWxsQWJzdHJhY3QubGVuZ3RoID4gTUFYX1NVTU1BUllfTEVOR1RIID8gJy4uLicgOiAnJztcbiAgICAgIHJldHVybiBmdWxsQWJzdHJhY3Quc2xpY2UoMCwgTUFYX1NVTU1BUllfTEVOR1RIKSArIHRhaWxcbiAgICB9LFxuICAgIHByb2plY3RJbmZvKGZpZWxkKSB7XG4gICAgICBsZXQgZnVsbEluZm8gPSB0aGlzLm1hdGNoSXRlbVdpdGhDb25maWcoZmllbGQpXG4gICAgICBmdWxsSW5mbyA9ICggZnVsbEluZm8gPT0gbnVsbCApID8gdGhpcy5ub0luZm9zIDogZnVsbEluZm9cbiAgICAgIHJldHVybiBmdWxsSW5mb1xuICAgIH0sXG4gICAgcHJvamVjdEFkZHJlc3MoKSB7XG4gICAgICBsZXQgZnVsbEFkZHJlc3MgPSB0aGlzLm1hdGNoSXRlbVdpdGhDb25maWcoJ2Jsb2NrX2FkZHJlc3MnKVxuICAgICAgY29uc29sZS5sb2coJ2Z1bGxBZGRyZXNzIDogJywgZnVsbEFkZHJlc3MpXG4gICAgICBsZXQgYWRkcmVzcyA9ICggZnVsbEFkZHJlc3MgfHwgZnVsbEFkZHJlc3MgIT09ICdOb25lJyApID8gIGZ1bGxBZGRyZXNzIDogdGhpcy5ub0FkZHJlc3NcbiAgICAgIHJldHVybiBhZGRyZXNzXG4gICAgfSxcbiAgICBwcm9qZWN0Q2l0eSgpIHtcbiAgICAgIGxldCBjaXR5SXRlbSA9IHRoaXMubWF0Y2hJdGVtV2l0aENvbmZpZygnYmxvY2tfY2l0eScpXG4gICAgICAvLyBjb25zb2xlLmxvZygnY2l0eUl0ZW0gOiAnLCBjaXR5SXRlbSlcbiAgICAgIGxldCBjaXR5ID0gKCBjaXR5SXRlbSB8fCBjaXR5SXRlbSAhPT0gJ05vbmUnICkgPyAgY2l0eUl0ZW0gOiB0aGlzLm5vQWRkcmVzc1xuICAgICAgcmV0dXJuIGNpdHlcbiAgICB9LFxuICB9LFxuXG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbkBpbXBvcnQgJy4uLy4uL3N0eWxlcy9hcGl2aXotbWlzYy5zY3NzJztcblxuLmNhcmQtaW1hZ2Uge1xuICAgIG1pbi1oZWlnaHQ6IDEwMHB4O1xufVxuXG4uY2FyZC1pbWFnZSBpbWd7XG4gICAgd2lkdGg6IDEwMCU7XG59XG5cbi5wcm9qLWNhcmQge1xuXHRib3JkZXItcmFkaXVzOiAzcHggO1xuICBib3gtc2hhZG93IDogJGFwaXZpei1kaXNjcmV0ZS1zaGFkb3c7XG59XG4uaG92ZXItZWZmZWN0OmhvdmVyIHtcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSk7XG4gIGJveC1zaGFkb3c6IDAgMTRweCAyOHB4IHJnYmEoMCwwLDAsMC4yNSksIDAgMTBweCAxMHB4IHJnYmEoMCwwLDAsMC4yMilcbn1cblxuLnByb2otY2FyZC1pbWcge1xuXHRib3JkZXItcmFkaXVzIDogM3B4IDNweCAwcHggMHB4IDtcbn1cblxuLmNhcmQtY29udGVudCAudGFne1xuICAgIG1hcmdpbi1yaWdodDogMC41ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogMC41ZW07XG5cbiAgICBwYWRkaW5nOiAwLjJlbSAxZW07XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzY3Njc2O1xuICAgIGNvbG9yOiB3aGl0ZTtcblxuICAgIGZvbnQtc2l6ZTogMTJweDtcbn1cblxuLmNhcmQtY29udGVudCBpbWd7XG4gICAgbWF4LWhlaWdodDogMS4xZW07XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAuMWVtKTtcbn1cblxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gY2xhc3M9XCJzZWFyY2gtcmVzdWx0cy1saXN0XCI+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiIHYtaWY9XCJwZW5kaW5nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwicGVuZGluZ1wiPlJlY2hlcmNoZSBlbiBjb3Vycy4uLjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiIHYtaWY9XCIhcGVuZGluZ1wiPlxuICAgICAgPENJU1NlYXJjaFJlc3VsdHNDb3VudEFuZFRhYnMgXG4gICAgICAgIDp2aWV3PVwiVklFV19MSVNUXCJcbiAgICAgIC8+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCIgdi1pZj1cInRvdGFsID4gMFwiID5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy0zXCIgdi1mb3I9XCIoaXRlbXNDb2x1bW4sIGkpIGluIHByb2plY3RDb2x1bW5zXCIgOmtleT1cImlcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1ucyBpcy1tdWx0aWxpbmVcIj5cbiAgICAgICAgICAgIDxQcm9qZWN0Q2FyZCBcbiAgICAgICAgICAgICAgdi1mb3I9XCJpdGVtIGluIGl0ZW1zQ29sdW1uXCIgXG4gICAgICAgICAgICAgIDprZXk9XCJpdGVtLmlkXCIgXG4gICAgICAgICAgICAgIDppdGVtPVwiaXRlbVwiXG4gICAgICAgICAgICAgIDpjb250ZW50RmllbGRzPVwicHJvamVjdENvbnRlbnRzRmllbGRzXCJcbiAgICAgICAgICAgICAgOnZpZXc9XCJWSUVXX0xJU1RcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwibm8tcmVzdWx0IGVycm9yXCIgdi1pZj1cInRvdGFsID09PSAwXCI+XG4gICAgICAgIDxpbWcgc3JjPVwiL3N0YXRpYy9pbGx1c3RyYXRpb25zL2VycmV1cl9ub19yZXN1bHRzLnBuZ1wiPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxoMSBjbGFzcz1cInRpdGxlIGlzLTEgaXMtcHJpbWFyeVwiPkF1Y3VuIHByb2pldCB0cm91dsOpICE8L2gxPlxuICAgICAgICAgIDxwPlBvdXIgb2J0ZW5pciBwbHVzIGRlIHLDqXN1bHRhdHMsIG1vZGlmaWVyIHZvcyBjcml0w6hyZXMgZGUgcmVjaGVyY2hlPC9wPlxuICAgICAgICAgIDxidXR0b24gdi1pZj1cImhhc1NlbGVjdGVkRmlsdGVyc1wiIGhyZWY9XCIvXCIgY2xhc3M9XCJidXR0b24gaXMtcHJpbWFyeSBpcy1vdXRsaW5lZFwiIEBjbGljaz1cImNsZWFyQWxsRmlsdGVyc1wiPlxuICAgICAgICAgICAgU3VwcHJpbWVyIHRvdXMgbGVzIGZpbHRyZXNcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7bWFwU3RhdGV9IGZyb20gJ3Z1ZXgnXG5pbXBvcnQgUHJvamVjdENhcmQgZnJvbSAnLi9Qcm9qZWN0Q2FyZC52dWUnXG5cbmltcG9ydCBDSVNTZWFyY2hSZXN1bHRzQ291bnRBbmRUYWJzIGZyb20gJy4vQ0lTU2VhcmNoUmVzdWx0c0NvdW50QW5kVGFicy52dWUnXG5cbmltcG9ydCB7VklFV19MSVNUfSBmcm9tICcuLi9jb25zdGFudHMuanMnXG5cbmxldCBzY3JvbGxMaXN0ZW5lcjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnU2VhcmNoUmVzdWx0c0xpc3QnLFxuXG4gIGNvbXBvbmVudHM6IHtcbiAgICBQcm9qZWN0Q2FyZCxcbiAgICBDSVNTZWFyY2hSZXN1bHRzQ291bnRBbmRUYWJzXG4gIH0sXG5cbiAgcHJvcHM6IFtcbiAgICAncm91dGVDb25maWcnLFxuICAgICdwcm9qZWN0Q29udGVudHNGaWVsZHMnXG4gIF0sXG5cbiAgZGF0YSgpe1xuICAgIHJldHVybiB7XG4gICAgICBWSUVXX0xJU1QsXG4gICAgICBzaG93Q291bnQ6IHVuZGVmaW5lZCxcbiAgICB9XG4gIH0sXG5cbiAgLy8gYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gIC8vICAgY29uc29sZS5sb2coXCJcXG4gLSAtIFNlYXJjaFJlc3VsdHNMaXN0IC8gYmVmb3JlQ3JlYXRlIC4uLiBcIilcbiAgLy8gfSxcbiAgLy8gY3JlYXRlZDogZnVuY3Rpb24gKCkge1xuICAvLyAgIGNvbnNvbGUubG9nKFwiXFxuIC0gLSBTZWFyY2hSZXN1bHRzTGlzdCAvIGNyZWF0ZWQgLi4uIFwiKVxuICAvLyB9LFxuICAvLyBiZWZvcmVNb3VudDogZnVuY3Rpb24gKCkge1xuICAvLyAgIGNvbnNvbGUubG9nKFwiXFxuIC0gLSBTZWFyY2hSZXN1bHRzTGlzdCAvIGJlZm9yZU1vdW50IC4uLiBcIilcbiAgLy8gICAvLyBjb25zb2xlLmxvZyhcIiAtIC0gU2VhcmNoUmVzdWx0c0xpc3QgLyB0aGlzLnJvdXRlQ29uZmlnIDogXFxuIFwiLCB0aGlzLnJvdXRlQ29uZmlnKVxuICAvLyAgIGNvbnNvbGUubG9nKFwiIC0gLSBTZWFyY2hSZXN1bHRzTGlzdCAvIHRoaXMucHJvamVjdENvbnRlbnRzRmllbGRzIDogXFxuIFwiLCB0aGlzLnByb2plY3RDb250ZW50c0ZpZWxkcylcbiAgLy8gICBjb25zb2xlLmxvZyhcIiAtIC0gU2VhcmNoUmVzdWx0c0xpc3QgLyB0aGlzLiRzdG9yZS5zdGF0ZS5zZWFyY2ggOiBcXG4gXCIsIHRoaXMuJHN0b3JlLnN0YXRlLnNlYXJjaClcbiAgLy8gICAvLyB0aGlzLnByb2plY3RDb250ZW50c0ZpZWxkcyA9IHRoaXMucm91dGVDb25maWcuY29udGVudF9maWVsZHNcbiAgLy8gfSxcblxuICBtb3VudGVkKCl7XG4gICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ3NldFNlYXJjaENvbmZpZ0Rpc3BsYXknKTtcbiAgICB0aGlzLnNob3dDb3VudCA9IHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0U2VhcmNoQ29uZmlnRGVmYXVsdFNob3dDb3VudFxuXG4gICAgc2Nyb2xsTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBnZXRTZWFyY2hDb25maWdTY3JvbGxCZWZvcmVCb3R0b21UcmlnZ2VyID0gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRTZWFyY2hDb25maWdTY3JvbGxCZWZvcmVCb3R0b21UcmlnZ2VyXG4gICAgICBjb25zdCBnZXRTZWFyY2hDb25maWdNb3JlUHJvamVjdE9uU2Nyb2xsQ291bnQgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldFNlYXJjaENvbmZpZ01vcmVQcm9qZWN0T25TY3JvbGxDb3VudFxuXG4gICAgICBpZiAoZ2V0U2VhcmNoQ29uZmlnTW9yZVByb2plY3RPblNjcm9sbENvdW50ICYmIGdldFNlYXJjaENvbmZpZ1Njcm9sbEJlZm9yZUJvdHRvbVRyaWdnZXIgJiZcbiAgICAgICAgd2luZG93LmlubmVySGVpZ2h0ICsgd2luZG93LnNjcm9sbFkgPj0gKGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0IC0gZ2V0U2VhcmNoQ29uZmlnU2Nyb2xsQmVmb3JlQm90dG9tVHJpZ2dlcilcbiAgICAgICkge1xuICAgICAgICBpZih0aGlzLiRzdG9yZS5zdGF0ZS5zZWFyY2guYW5zd2VyLnJlc3VsdCAmJiB0aGlzLnNob3dDb3VudCA8IHRoaXMuJHN0b3JlLnN0YXRlLnNlYXJjaC5hbnN3ZXIucmVzdWx0LnByb2plY3RzLmxlbmd0aCl7XG4gICAgICAgICAgdGhpcy5zaG93Q291bnQgPSB0aGlzLnNob3dDb3VudCArIGdldFNlYXJjaENvbmZpZ01vcmVQcm9qZWN0T25TY3JvbGxDb3VudFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxMaXN0ZW5lciwge3Bhc3NpdmU6IHRydWV9KVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgcHJvamVjdHMocHJldiwgbmV4dCl7XG4gICAgICB0aGlzLnNob3dDb3VudCA9IHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0U2VhcmNoQ29uZmlnRGVmYXVsdFNob3dDb3VudDtcbiAgICB9XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBwcm9qZWN0Q29sdW1ucygpe1xuICAgICAgY29uc3Qge3Byb2plY3RzfSA9IHRoaXMuJHN0b3JlLnN0YXRlLnNlYXJjaC5hbnN3ZXIucmVzdWx0O1xuICAgICAgY29uc3QgZ2V0U2VhcmNoQ29uZmlnQ29sdW1uQ291bnQgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldFNlYXJjaENvbmZpZ0NvbHVtbkNvdW50XG5cbiAgICAgIGlmKHByb2plY3RzICYmIGdldFNlYXJjaENvbmZpZ0NvbHVtbkNvdW50KXtcbiAgICAgICAgY29uc3QgY29sdW1uc0RhdGEgPSBBcnJheShnZXRTZWFyY2hDb25maWdDb2x1bW5Db3VudCkuZmlsbCgpLm1hcCgoKSA9PiBbXSk7XG5cbiAgICAgICAgcHJvamVjdHMuc2xpY2UoMCwgdGhpcy5zaG93Q291bnQpLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbHVtbnNEYXRhW2klZ2V0U2VhcmNoQ29uZmlnQ29sdW1uQ291bnRdLnB1c2gocCk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIGNvbHVtbnNEYXRhXG4gICAgICB9XG4gICAgfSxcbiAgICAuLi5tYXBTdGF0ZSh7XG4gICAgICBwZW5kaW5nOiAoe3NlYXJjaH0pID0+ICEhc2VhcmNoLmFuc3dlci5wZW5kaW5nQWJvcnQsXG4gICAgICBwcm9qZWN0czogKHtzZWFyY2h9KSA9PiBzZWFyY2guYW5zd2VyLnJlc3VsdCAmJiBzZWFyY2guYW5zd2VyLnJlc3VsdC5wcm9qZWN0cyxcbiAgICAgIHRvdGFsOiAoe3NlYXJjaH0pID0+IHNlYXJjaC5hbnN3ZXIucmVzdWx0ICYmIHNlYXJjaC5hbnN3ZXIucmVzdWx0LnRvdGFsLFxuICAgICAgaGFzU2VsZWN0ZWRGaWx0ZXJzOiAoe3NlYXJjaH0pID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRGaWx0ZXJzID0gc2VhcmNoLnF1ZXN0aW9uICYmIHNlYXJjaC5xdWVzdGlvbi5zZWxlY3RlZEZpbHRlcnM7XG4gICAgICAgIGlmKCFzZWxlY3RlZEZpbHRlcnMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIFsuLi5zZWxlY3RlZEZpbHRlcnMudmFsdWVzKCldLnNvbWUoc2VsZWN0ZWRGaWx0ZXJWYWx1ZXMgPT4gc2VsZWN0ZWRGaWx0ZXJWYWx1ZXMuc2l6ZSA+PSAxKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGNsZWFyQWxsRmlsdGVycygpe1xuICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goICdjbGVhckFsbEZpbHRlcnMnIClcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGVzdHJveSgpe1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxMaXN0ZW5lcilcblxuICAgIHNjcm9sbExpc3RlbmVyID0gdW5kZWZpbmVkO1xuICB9XG5cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuICAvKiBUT0RPIFNBU1MgOiBtYWtlIGEgdmFyaWFibGUgb3V0IG9mIHRoaXMgYmFja2dyb3VuZC12YWx1ZS4gQWxzbyB1c2VkIGluIENJU1NlYXJjaFJlc3VsdHNDb3VudEFuZFRhYnMgKi9cbiAgLnNlYXJjaC1yZXN1bHRzLWxpc3R7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjZGNkY2O1xuICAgICAgd2lkdGg6IDEwMCU7XG5cbiAgICAgIHBhZGRpbmctYm90dG9tOiAxLjVyZW07XG4gICAgICBwYWRkaW5nLXRvcDogMXJlbTtcbiAgfVxuXG5cbiAgLnBlbmRpbmd7XG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICBwYWRkaW5nOiAyZW07XG4gIH1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtYXBcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY291bnQtYW5kLXRhYnMtY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG5cbiAgICAgICAgPENJU1NlYXJjaFJlc3VsdHNDb3VudEFuZFRhYnMgXG4gICAgICAgICAgOnZpZXc9XCJWSUVXX01BUFwiIFxuICAgICAgICAgIDpvcGVuPVwiISFzaG93Q2FyZFwiXG4gICAgICAgICAgPlxuICAgICAgICAgIFxuICAgICAgICAgIDwhLS0gSElHSExJR0hURUQgSVRFTSAgLS0+XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGNsYXNzPVwiaGlnaGxpZ2h0ZWQtcHJvamVjdFwiIFxuICAgICAgICAgICAgdi1pZj1cInNob3dDYXJkXCIgXG4gICAgICAgICAgICBzbG90PVwicHJvamVjdFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDwhLS0gQlVUVE9OIFRPIENMT1NFIFBSRVZJRVcgLS0+XG4gICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICB2LXNob3c9XCJpdGVtTG9hZGVkXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJidXR0b24gY2xvc2VcIiBcbiAgICAgICAgICAgICAgQGNsaWNrPVwic2hvd0NhcmQgPSBmYWxzZVwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPCEtLSBAY2xpY2s9XCJoaWdobGlnaHRJdGVtKHVuZGVmaW5lZClcIiAtLT5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsXCI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYXMgZmEtdGltZXNcIj48L2k+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8IS0tIFBST0pFQ1QgQ0FSRCAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkXCI+XG5cbiAgICAgICAgICAgICAgPCEtLSBMT0FERVIgLS0+XG4gICAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW5zIGlzLW1vYmlsZSBpcy12Y2VudGVyZWQgXCJcbiAgICAgICAgICAgICAgICB2LXNob3c9XCIhaXRlbUxvYWRlZFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cImNvbHVtbiBpcy0xMiBoYXMtdGV4dC1jZW50ZXJlZCBoYXMtdGV4dC1wcmltYXJ5XCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwibGRzLXJvbGxlclwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPGRpdj48L2Rpdj48ZGl2PjwvZGl2PjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPCEtLSA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLTEyIGhhcy10ZXh0LWNlbnRlcmVkIGhhcy10ZXh0LXByaW1hcnlcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBhcHAtbG9hZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLXNwaW5uZXIgZmEtcHVsc2UgZmEtM3hcIj48L2k+XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+IC0tPlxuXG5cbiAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgPCEtLSBJVEVNIERBVEEgLS0+XG4gICAgICAgICAgICAgIDxQcm9qZWN0Q2FyZCBcbiAgICAgICAgICAgICAgICB2LWlmPVwiaXRlbUxvYWRlZFwiXG4gICAgICAgICAgICAgICAgOml0ZW09XCJoaWdobGlnaHRlZEl0ZW1cIlxuICAgICAgICAgICAgICAgIDpjb250ZW50RmllbGRzPVwiY29udGVudEZpZWxkc1wiXG4gICAgICAgICAgICAgICAgOnZpZXc9XCJWSUVXX01BUFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8L1Byb2plY3RDYXJkPlxuXG5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPC9DSVNTZWFyY2hSZXN1bHRzQ291bnRBbmRUYWJzPlxuXG4gICAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbiAgPCEtLSBMT0FERVIgLS0+XG4gIDxkaXYgXG4gICAgdi1zaG93PVwiIXByb2plY3RzIHx8IGl0ZW1Mb2FkaW5nXCJcbiAgICBjbGFzcz1cImxkcy1yb2xsZXIgZmxvYXRpbmdcIlxuICAgID5cbiAgICA8ZGl2PjwvZGl2PjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PjxkaXY+PC9kaXY+XG4gICAgPCEtLSBjbGFzcz1cImxlYWZsZXQtY29udHJvbC1sb2FkZXIgbGRzLXJvbGxlclwiIC0tPlxuICA8L2Rpdj5cblxuICA8bC1tYXBcbiAgICA6em9vbT1cInpvb21cIlxuICAgIDpib3VuZHM9XCJib3VuZHNcIlxuICAgIDpwcmVmZXJDYW52YXM9XCJwcmVmZXJDYW52YXNcIlxuICAgIDptaW4tem9vbT1cIm1pblpvb21cIlxuICAgIDptYXgtem9vbT1cIm1heFpvb21cIlxuICAgIDpvcHRpb25zPVwieyB6b29tQ29udHJvbDogZmFsc2UgfVwiXG4gICAgOmNlbnRlcj1cImNlbnRlclwiXG4gICAgQHVwZGF0ZTpjZW50ZXI9XCJjZW50ZXJVcGRhdGVcIlxuICAgIEB1cGRhdGU6em9vbT1cInpvb21VcGRhdGVcIlxuICAgIHJlZj0nbWFwJ1xuICAgID5cblxuICAgIDxsLWNvbnRyb2wtem9vbSBwb3NpdGlvbj1cImJvdHRvbXJpZ2h0XCIvPlxuXG4gICAgPGwtdGlsZS1sYXllclxuICAgICAgOnVybD1cInVybFwiXG4gICAgICA6YXR0cmlidXRpb249XCJhdHRyaWJ1dGlvblwiLz5cblxuICAgICAgPCEtLSBNQVJLRVIgQ0xVU1RFUiAtLT5cbiAgICAgIDwhLS0gPHYtbWFya2VyLWNsdXN0ZXIgXG4gICAgICAgIHYtaWY9XCJwcm9qZWN0c1wiXG4gICAgICAgIDpvcHRpb25zPVwie3Nob3dDb3ZlcmFnZU9uSG92ZXI6IGZhbHNlLCBpY29uQ3JlYXRlRnVuY3Rpb246IGljb25DcmVhdGVGdW5jdGlvbn1cIlxuICAgICAgICA+XG4gICAgICAgIDxsLW1hcmtlciBcbiAgICAgICAgICB2LWZvcj1cIihpdGVtLCBpKSBpbiBpdGVtc0Zvck1hcCgpXCJcbiAgICAgICAgICA6a2V5PVwiaVwiXG4gICAgICAgICAgOmxhdC1sbmc9XCJ7bG5nOiBwYXJzZUZsb2F0KGl0ZW0ubG9uKSwgbGF0OiBwYXJzZUZsb2F0KGl0ZW0ubGF0KX1cIlxuICAgICAgICAgIEBjbGljaz1cInNob3dDYXJkPXRydWU7IGhpZ2hsaWdodEl0ZW0oaXRlbSlcIlxuICAgICAgICAgID5cbiAgICAgICAgICA8bC1pY29uXG4gICAgICAgICAgICB2LWlmPVwiY2hlY2tJZkl0ZW1IYXNMYXRMbmcoaXRlbSlcIlxuICAgICAgICAgICAgaWNvblVybD1cIi9zdGF0aWMvaWNvbnMvaWNvbl9waW5fcGxlaW5fdmlvbGV0LnN2Z1wiXG4gICAgICAgICAgICA6aWNvblNpemU9XCJnZXRJY29uU2l6ZShpdGVtLCBoaWdobGlnaHRlZEl0ZW0pXCJcbiAgICAgICAgICAvPlxuICAgICAgICAgICAgPCEtLSA6aWNvblNpemU9XCJpdGVtLnNkX2lkID09PSBoaWdobGlnaHRlZEl0ZW0uc2RfaWQgPyBbNDYsIDQ2XSA6IFsyOSwgMjldXCIgLS0+XG4gICAgICAgICAgICA8IS0tIDppY29uU2l6ZT1cIml0ZW1JZChpdGVtLCAnYmxvY2tfaWQnKSA9PT0gaXRlbUlkKGhpZ2hsaWdodGVkSXRlbSwgJ2Jsb2NrX2lkJykgPyBbNDYsIDQ2XSA6IFsyOSwgMjldXCIgLS0+XG4gICAgICAgIDwvbC1tYXJrZXI+XG4gICAgICA8L3YtbWFya2VyLWNsdXN0ZXI+IC0tPlxuXG4gICAgICA8Q3VzdG9tTWFya2Vyc1xuICAgICAgICA6cm91dGVDb25maWc9XCJyb3V0ZUNvbmZpZ1wiXG4gICAgICAgIDplbmRQb2ludENvbmZpZz1cImVuZFBvaW50Q29uZmlnXCJcbiAgICAgICAgOml0ZW1zRm9yTWFwPVwiaXRlbXNGb3JNYXBcIlxuICAgICAgICA6Y2hlY2tJZlN0cmluZ0Zsb2F0PVwiY2hlY2tJZlN0cmluZ0Zsb2F0XCJcbiAgICAgICAgOm1hcE9iamVjdD1cInRoaXMuJHJlZnMubWFwXCJcblxuICAgICAgICA6Y29udGVudEZpZWxkcz1cImNvbnRlbnRGaWVsZHNcIlxuICAgICAgICBAZ2V0U2VsZWN0ZWRJdGVtPVwiaGFuZGxlSWNvblNpZ25hbFwiXG4gICAgICAgIDpoaWdobGlnaHRlZEl0ZW09XCJoaWdobGlnaHRlZEl0ZW1cIlxuICAgICAgLz5cblxuICAgIDwvbC1tYXA+XG5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG5cblxuPHNjcmlwdD5cbmltcG9ydCB7IG1hcFN0YXRlLCBtYXBBY3Rpb25zIH0gZnJvbSAndnVleCdcblxuaW1wb3J0IHsgTCwgTE1hcCwgTENvbnRyb2xab29tLCBMVGlsZUxheWVyLCBMTWFya2VyLCBMSWNvbiB9IGZyb20gJ3Z1ZTItbGVhZmxldCc7XG5pbXBvcnQgVnVlMkxlYWZsZXRNYXJrZXJDbHVzdGVyIGZyb20gJ3Z1ZTItbGVhZmxldC1tYXJrZXJjbHVzdGVyJ1xuLy8gaW1wb3J0IHsgUHJ1bmVDbHVzdGVyLCBQcnVuZUNsdXN0ZXJGb3JMZWFmbGV0IH0gZnJvbSAnZXhwb3J0cy1sb2FkZXI/UHJ1bmVDbHVzdGVyLFBydW5lQ2x1c3RlckZvckxlYWZsZXQhcHJ1bmVjbHVzdGVyL2Rpc3QvUHJ1bmVDbHVzdGVyLmpzJ1xuLy8gaW1wb3J0IHsgUHJ1bmVDbHVzdGVyLCBQcnVuZUNsdXN0ZXJGb3JMZWFmbGV0IH0gZnJvbSAnUHJ1bmVDbHVzdGVyJ1xuXG5pbXBvcnQgUHJvamVjdENhcmQgZnJvbSAnLi9Qcm9qZWN0Q2FyZC52dWUnXG5pbXBvcnQgQ0lTU2VhcmNoUmVzdWx0c0NvdW50QW5kVGFicyBmcm9tICcuL0NJU1NlYXJjaFJlc3VsdHNDb3VudEFuZFRhYnMudnVlJ1xuaW1wb3J0IEN1c3RvbU1hcmtlcnMgZnJvbSAnLi9DdXN0b21NYXJrZXJzLnZ1ZSdcblxuaW1wb3J0IHtWSUVXX01BUH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJ1xuaW1wb3J0IHtnZXRJdGVtQnlJZH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5jb25zdCBGUkFOQ0VfQ0VOVEVSID0gWzQ2LjIyNzYsIDIuMjEzN107XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiBcIlNlYXJjaFJlc3VsdHNNYXBcIixcblxuICBjb21wb25lbnRzOiB7XG4gICAgTE1hcCxcbiAgICBMQ29udHJvbFpvb20sXG4gICAgTFRpbGVMYXllcixcbiAgICBMTWFya2VyLFxuICAgIExJY29uLFxuXG4gICAgQ3VzdG9tTWFya2VycyxcbiAgICAvLyAndi1tYXJrZXItY2x1c3Rlcic6IFZ1ZTJMZWFmbGV0TWFya2VyQ2x1c3RlcixcbiAgICAvLyBQcnVuZUNsdXN0ZXIsXG4gICAgLy8gUHJ1bmVDbHVzdGVyRm9yTGVhZmxldCxcblxuICAgIFByb2plY3RDYXJkLFxuICAgIENJU1NlYXJjaFJlc3VsdHNDb3VudEFuZFRhYnMsXG5cbiAgfSxcblxuICBwcm9wczogW1xuICAgICdyb3V0ZUNvbmZpZycsIFxuICAgICdlbmRQb2ludENvbmZpZydcbiAgXSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG5cbiAgICAgIC8vIExPQ0FMIERBVEFcbiAgICAgIFZJRVdfTUFQLFxuICAgICAgaWNvblNpemVOb3JtYWwgOiBbMjksIDI5XSxcbiAgICAgIGljb25TaXplSGlnaGxpZ2h0ZWQgOiBbNDksIDQ5XSxcblxuICAgICAgLy8gRklFTERTIE1BUFBFUlxuICAgICAgY29udGVudEZpZWxkcyA6IHVuZGVmaW5lZCxcblxuICAgICAgLy8gSVRFTVNcbiAgICAgIGhpZ2hsaWdodGVkSXRlbTogdW5kZWZpbmVkLFxuICAgICAgaXRlbUxvYWRlZDogZmFsc2UsXG4gICAgICBpdGVtTG9hZGluZzogZmFsc2UsXG4gICAgICBzaG93Q2FyZDpmYWxzZSxcbiAgICAgIGl0ZW1zT25NYXAgOiBbXG4gICAgICAgIC8vIHtzZF9pZCA6ICdBJywgbGF0IDogJzQ3LjQxMicsIGxvbiA6ICctMS4yMTgnIH0sXG4gICAgICAgIC8vIHtzZF9pZCA6ICdCJywgbGF0IDogJzQ3LjQyMzQnLCBsb24gOiAnLTEuMjQ4JyB9LFxuICAgICAgXSxcblxuICAgICAgLy8gTEVBRkxFVCBTRVRVUFxuICAgICAgcHJlZmVyQ2FudmFzOiB0cnVlLFxuICAgICAgem9vbTogNixcbiAgICAgIG1heFpvb206IDE5LFxuICAgICAgbWluWm9vbTogMixcbiAgICAgIGN1cnJlbnRab29tOiA2LFxuICAgICAgY2VudGVyOiBGUkFOQ0VfQ0VOVEVSLFxuICAgICAgY3VycmVudENlbnRlcjogRlJBTkNFX0NFTlRFUixcblxuICAgICAgLy8gdXJsOiAnaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLmRlL3RpbGVzL29zbWRlL3t6fS97eH0ve3l9LnBuZycsXG4gICAgICAvLyBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cDovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250aWJ1dG9ycycsXG4gICAgICBcbiAgICAgIHVybDogJ2h0dHBzOi8ve3N9LmJhc2VtYXBzLmNhcnRvY2RuLmNvbS9yYXN0ZXJ0aWxlcy92b3lhZ2VyL3t6fS97eH0ve3l9e3J9LnBuZycsXG4gICAgICBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzICZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly9jYXJ0by5jb20vYXR0cmlidXRpb25zXCI+Q0FSVE88L2E+JyxcbiAgICAgIHN1YmRvbWFpbnM6ICdhYmNkJyxcbiAgICAgIFxuICAgIH07XG4gIH0sXG5cbiAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIi0gLSAtIC0gLSBNQVAgVElNRSAhISEhIC0gLSAtIC0gLSAtXCIpXG4gICAgLy8gY29uc29sZS5sb2coXCJcXG4gLSAtIFNlYXJjaFJlc3VsdHNNYXAgLyBiZWZvcmVNb3VudCAuLi4gXCIpXG4gICAgLy8gY29uc29sZS5sb2coXCIgLSAtIFNlYXJjaFJlc3VsdHNNYXAgLyByb3V0ZUNvbmZpZyA6IFxcblwiLCB0aGlzLnJvdXRlQ29uZmlnKVxuICAgIC8vIGNvbnNvbGUubG9nKFwiIC0gLSBTZWFyY2hSZXN1bHRzTWFwIC8gZW5kUG9pbnRDb25maWcgOiBcXG5cIiwgdGhpcy5lbmRQb2ludENvbmZpZylcblxuICAgIC8vIGxldCBwcnVuZUNsdXN0ZXIgPSBuZXcgUHJ1bmVDbHVzdGVyRm9yTGVhZmxldCgpO1xuXG4gICAgLy8gc2V0IHVwIGZpZWxkcyBtYXBwZXJcbiAgICB0aGlzLmNvbnRlbnRGaWVsZHMgPSB0aGlzLnJvdXRlQ29uZmlnLmNvbnRlbnRzX2ZpZWxkc1xuICAgIC8vIGNvbnNvbGUubG9nKFwiIC0gLSBTZWFyY2hSZXN1bHRzTWFwIC8gY29udGVudEZpZWxkcyA6IFxcblwiLCB0aGlzLmNvbnRlbnRGaWVsZHMpXG5cbiAgICAvLyBjb25zb2xlLmxvZyhcInRlc3QgbWFya2VyIC8gTC5sYXRMbmcoNDcuNDEyLCAtMS4yMTgpXCIsIEwubGF0TG5nKDQ3LjQxMiwgLTEuMjE4KSlcbiAgICAvLyBzZXQgdXAgbGVhZmxldCBvcHRpb25zXG4gICAgY29uc3QgbWFwT3B0aW9ucyA9IHRoaXMuZW5kUG9pbnRDb25maWcubWFwX29wdGlvbnNcblxuICAgIHRoaXMuem9vbSA9IG1hcE9wdGlvbnMuem9vbVxuICAgIHRoaXMubWF4Wm9vbSA9IG1hcE9wdGlvbnMubWF4Wm9vbVxuICAgIHRoaXMubWluWm9vbSA9IG1hcE9wdGlvbnMubWluWm9vbVxuICAgIHRoaXMuY3VycmVudFpvb20gPSBtYXBPcHRpb25zLmN1cnJlbnRab29tXG4gICAgdGhpcy5jZW50ZXIgPSBtYXBPcHRpb25zLmNlbnRlclxuICAgIHRoaXMuY3VycmVudENlbnRlciA9IG1hcE9wdGlvbnMuY3VycmVudENlbnRlclxuICAgIHRoaXMudXJsID0gbWFwT3B0aW9ucy51cmxcbiAgICB0aGlzLmF0dHJpYnV0aW9uID0gbWFwT3B0aW9ucy5hdHRyaWJ1dGlvblxuICAgIHRoaXMuc3ViZG9tYWlucyA9IG1hcE9wdGlvbnMuc3ViZG9tYWluc1xuXG4gIH0sXG5cbiAgbW91bnRlZCgpe1xuXG4gICAgLy8gY29uc29sZS5sb2coXCIgLSAtIFNlYXJjaFJlc3VsdHNNYXAgLyBtb3VudGVkLi4uIFwiKVxuICAgIC8vIGlmKHRoaXMucHJvamVjdHMpe1xuICAgIC8vICAgY29uc3QgcHJvamVjdHNXaXRoTWlzc2luZ0FkZHJlc3MgPSB0aGlzLnByb2plY3RzLmZpbHRlcihwID0+ICFwLmxhdClcbiAgICAvLyAgIC8vIGlmKHByb2plY3RzV2l0aE1pc3NpbmdBZGRyZXNzLmxlbmd0aCA+PSAxKVxuICAgIC8vICAgLy8gICB0aGlzLmZpbmRQcm9qZWN0c0dlb2xvY3MocHJvamVjdHNXaXRoTWlzc2luZ0FkZHJlc3MpXG4gICAgLy8gICB9XG4gICAgdGhpcy5pdGVtc09uTWFwID0gdGhpcy5wcm9qZWN0c1xuXG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcblxuICAgIC4uLm1hcFN0YXRlKHtcbiAgICAgIHByb2plY3RzKHtzZWFyY2h9KXsgcmV0dXJuIHNlYXJjaC5hbnN3ZXIucmVzdWx0ICYmIHNlYXJjaC5hbnN3ZXIucmVzdWx0LnByb2plY3RzIH0sXG4gICAgICAvLyBpdGVtcyh7c2VhcmNofSl7IHJldHVybiBzZWFyY2guYW5zd2VyLnJlc3VsdE1hcCAmJiBzZWFyY2guYW5zd2VyLnJlc3VsdC5wcm9qZWN0cyB9LFxuICAgICAgLy8gZGlzcGxheWVkUHJvamVjdHMoKXtcbiAgICAgIC8vICAgcmV0dXJuIHRoaXMucHJvamVjdHMgJiYgdGhpcy5wcm9qZWN0cy5maWx0ZXIocCA9PiB0aGlzLmdlb2xvY0J5UHJvamVjdElkLmdldChwLmlkKSlcbiAgICAgIC8vIH0sXG4gICAgICAvLyBkaXNwbGF5ZWRQcm9qZWN0cygpe1xuICAgICAgLy8gICBjb25zb2xlLmxvZyhcImRpc3BsYXllZFByb2plY3RzIDogXCIsIHRoaXMucHJvamVjdHMpXG4gICAgICAvLyAgIGlmKHRoaXMucHJvamVjdHMpe1xuICAgICAgLy8gICAgIGxldCBpdGVtc1dpdGhMYXRMbmcgPSB0aGlzLnByb2plY3RzLmZpbHRlcihpID0+ICFpLmxhdCAmJiAhaS5sb24pXG4gICAgICAvLyAgICAgcmV0dXJuIGl0ZW1zV2l0aExhdExuZ1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9LFxuICAgICAgLy8gZ2VvbG9jQnlQcm9qZWN0SWQoe2dlb2xvY0J5UHJvamVjdElkfSl7cmV0dXJuIGdlb2xvY0J5UHJvamVjdElkfVxuICAgIH0pLFxuICAgIGJvdW5kcygpe1xuICAgICAgbGV0IGRpc3BsYXllZEl0ZW1zID0gdGhpcy5pdGVtc0Zvck1hcCgpXG4gICAgICByZXR1cm4gZGlzcGxheWVkSXRlbXMgJiYgbmV3IEwuTGF0TG5nQm91bmRzKGRpc3BsYXllZEl0ZW1zLm1hcChwID0+ICh7XG4gICAgICAgIGxuZzogcGFyc2VGbG9hdChwLmxvbiksIFxuICAgICAgICBsYXQ6IHBhcnNlRmxvYXQocC5sYXQpLFxuICAgICAgfSkpKTtcbiAgICB9LFxuICB9LFxuXG5cblxuXG4gIG1ldGhvZHM6IHtcblxuICAgIGhhbmRsZUljb25TaWduYWwoaXRlbURhdGEpe1xuICAgICAgLy8gY29uc29sZS5sb2coJ2hhbmRsZUljb25TaWduYWwgLyBpdGVtRGF0YSA6ICcsIGl0ZW1EYXRhKVxuICAgICAgdGhpcy5oaWdobGlnaHRJdGVtKGl0ZW1EYXRhKVxuICAgIH0sXG4gICAgaXRlbXNGb3JNYXAoKXtcbiAgICAgIGlmICh0aGlzLnByb2plY3RzKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdHMuZmlsdGVyKGl0ZW0gPT4gdGhpcy5jaGVja0lmSXRlbUhhc0xhdExuZyhpdGVtKSApXG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRJY29uU2l6ZShpdGVtLCBoaWdobGlnaHRlZEl0ZW0pe1xuICAgICAgaWYgKGhpZ2hsaWdodGVkSXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtSWQoaXRlbSwgJ2Jsb2NrX2lkJykgPT09IHRoaXMuaXRlbUlkKGhpZ2hsaWdodGVkSXRlbSwgJ2Jsb2NrX2lkJykgPyB0aGlzLmljb25TaXplSGlnaGxpZ2h0ZWQgOiB0aGlzLmljb25TaXplTm9ybWFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5pY29uU2l6ZU5vcm1hbFxuICAgICAgfVxuICAgIH0sXG4gICAgbWF0Y2hJdGVtV2l0aENvbmZpZyhpdGVtLCBmaWVsZEJsb2NrKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIm1hdGNoSXRlbVdpdGhDb25maWcgLyBpdGVtIDogXCIsIGl0ZW0pXG4gICAgICBjb25zdCBjb250ZW50RmllbGQgPSB0aGlzLmNvbnRlbnRGaWVsZHMuZmluZChmPT4gZi5wb3NpdGlvbiA9PSBmaWVsZEJsb2NrKVxuICAgICAgLy8gY29uc29sZS5sb2coXCJtYXRjaEl0ZW1XaXRoQ29uZmlnIC8gY29udGVudEZpZWxkIDogXCIsIGNvbnRlbnRGaWVsZClcbiAgICAgIGlmIChjb250ZW50RmllbGQpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBjb250ZW50RmllbGQuZmllbGRcbiAgICAgICAgcmV0dXJuIGl0ZW1bZmllbGRdXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0sXG4gICAgaXRlbUlkKGl0ZW0pIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiaXRlbUlkIC8gaXRlbSA6IFwiLCBpdGVtKVxuICAgICAgcmV0dXJuIHRoaXMubWF0Y2hJdGVtV2l0aENvbmZpZyhpdGVtLCAnYmxvY2tfaWQnKVxuICAgIH0sXG4gICAgZ2V0SGlnaGxpZ2h0ZWRJdGVtSWQoKXtcbiAgICAgIGlmICggdGhpcy5oaWdobGlnaHRlZEl0ZW0gKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaXRlbUlkIC8gdGhpcy5oaWdobGlnaHRlZEl0ZW0gOiBcIiwgdGhpcy5oaWdobGlnaHRlZEl0ZW0pXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1JZChoaWdobGlnaHRlZEl0ZW0sICdibG9ja19pZCcpIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuXG5cbiAgICBjaGVja0lmU3RyaW5nRmxvYXQodmFsdWUpe1xuICAgICAgbGV0IHZhbCA9IHBhcnNlRmxvYXQodmFsdWUpXG4gICAgICBpZighaXNOYU4odmFsKSl7XG4gICAgICAgIHJldHVybiB2YWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gZ2V0TGF0TG5nKGl0ZW0pe1xuICAgIC8vICAgcmV0dXJuIHsgbGF0IDogdGhpcy5jaGVja0lmU3RyaW5nRmxvYXQoaXRlbS5sYXQpICwgbG5nIDogY2hlY2tJZlN0cmluZ0Zsb2F0KGl0ZW0ubG9uKSB9XG4gICAgLy8gfSxcbiAgICAvLyBnZXRMYXRMbmdEZW5zZShpdGVtKXtcbiAgICAvLyAgIHJldHVybiB7IGxhdCA6IHRoaXMuY2hlY2tJZlN0cmluZ0Zsb2F0KGl0ZW0ubGF0bG5nWzBdKSAsIGxuZyA6IGNoZWNrSWZTdHJpbmdGbG9hdChpdGVtLmxhdGxuZ1sxXSkgfVxuICAgIC8vIH0sXG4gICAgY2hlY2tJZkl0ZW1IYXNMYXRMbmcoaXRlbSl7XG4gICAgICByZXR1cm4gdGhpcy5jaGVja0lmU3RyaW5nRmxvYXQoaXRlbS5sYXQpICYmIHRoaXMuY2hlY2tJZlN0cmluZ0Zsb2F0KGl0ZW0ubG9uKVxuICAgIH0sXG5cbiAgICB6b29tVXBkYXRlKHpvb20pIHtcbiAgICAgIHRoaXMuY3VycmVudFpvb20gPSB6b29tO1xuICAgIH0sXG4gICAgY2VudGVyVXBkYXRlKGNlbnRlcikge1xuICAgICAgdGhpcy5jdXJyZW50Q2VudGVyID0gY2VudGVyO1xuICAgIH0sXG5cblxuXG4gICAgaGlnaGxpZ2h0SXRlbShpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImhpZ2hsaWdodEl0ZW0gLyBpIDogXCIsIGkpXG4gICAgICAvLyBzaG93IGxvYWRlciBcbiAgICAgIHRoaXMuc2hvd0NhcmQgPSB0cnVlXG4gICAgICB0aGlzLml0ZW1Mb2FkZWQgPSBmYWxzZVxuICAgICAgLy8gdGhpcy5pdGVtTG9hZGluZyA9IHRydWVcbiAgICAgIHRoaXMuY2VudGVyID0gW2kubGF0LCBpLmxvbl1cbiAgICAgIC8vIHRoaXMuY2VudGVyID0gW2kubG9uLCBpLmxhdF1cbiAgICAgIC8vIGdldCBpdGVtIElEXG4gICAgICAvLyBjb25zdCBpdGVtX2lkID0gdGhpcy5pdGVtSWQoaSlcbiAgICAgIGNvbnN0IGl0ZW1faWQgPSBpLklEXG4gICAgICBnZXRJdGVtQnlJZCggaXRlbV9pZCwgdGhpcy4kc3RvcmUuc3RhdGUuc2VhcmNoLmVuZHBvaW50KVxuICAgICAgICAudGhlbihpdGVtID0+IHtcbiAgICAgICAgICAvLyB0aGlzLiRzdG9yZS5jb21taXQoJ3NldERpc3BsYXllZFByb2plY3QnLCB7aXRlbX0pXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCIgLSAtIER5bmFtaWNEZXRhaWwgLyBpdGVtIDogXCIsIGl0ZW0pXG4gICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEl0ZW0gPSBpdGVtO1xuICAgICAgICAgIHRoaXMuaXRlbUxvYWRlZCA9IHRydWVcbiAgICAgICAgICAvLyB0aGlzLml0ZW1Mb2FkaW5nID0gZmFsc2VcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikgeyB0aGlzLmlzRXJyb3IgPSB0cnVlIDsgY29uc29sZS5lcnJvcignaXRlbSByb3V0ZSBlcnJvcicsIGVycikgfSlcbiAgICB9LFxuXG5cblxuXG4gICAgaWNvbkNyZWF0ZUZ1bmN0aW9uKGNsdXN0ZXIpe1xuICAgICAgY29uc3QgbWFya2VyQ291bnQgPSBjbHVzdGVyLmdldENoaWxkQ291bnQoKTtcblxuICAgICAgcmV0dXJuIG5ldyBMLkRpdkljb24oe1xuICAgICAgICBodG1sOiBgPHNwYW4+JHttYXJrZXJDb3VudH08L3NwYW4+YCwgXG4gICAgICAgIGNsYXNzTmFtZTogJ2Npcy1tYXJrZXItY2x1c3RlcicsXG4gICAgICAgIGljb25TaXplOiBuZXcgTC5Qb2ludCg0MCwgNDApXG4gICAgICB9KTtcbiAgICB9LFxuXG4gIH0sXG5cblxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIFxuICAvKiBMT0FERVJTICovXG4gIC5mbG9hdGluZyB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHotaW5kZXg6MjAwO1xuICAgIHRvcDogNTAlO1xuICAgIGxlZnQ6IDUwJTtcbiAgfVxuXG4gIC8qIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3RlZmFub2N1ZGluaS9sZWFmbGV0LWxvYWRlciAqL1xuICAubGVhZmxldC1jb250cm9sLWxvYWRlciB7XG4gICAgLyogcG9zaXRpb246IGFic29sdXRlO1xuICAgIHotaW5kZXg6MjAwO1xuICAgIHRvcDogNTAlO1xuICAgIGxlZnQ6IDUwJTsgKi9cbiAgICBtYXJnaW4tdG9wOiAtNDBweDtcbiAgICBtYXJnaW4tbGVmdDogLTUwcHg7XG4gICAgaGVpZ2h0OiA4MHB4O1xuICAgIHdpZHRoOiAxMDBweDtcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xuICAgIGJhY2tncm91bmQ6IHVybCgnL3N0YXRpYy9pbGx1c3RyYXRpb25zL2xlYWZsZXQtbG9hZGVyLmdpZicpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0IHJnYmEoMjU1LDI1NSwyNTUsMC44KTtcbiAgfVxuXG4gIC8qIGZyb20gOiBodHRwczovL2xvYWRpbmcuaW8vY3NzLyAqL1xuICAubGRzLXJvbGxlciB7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIC8qIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB6LWluZGV4OjIwMDtcbiAgICB0b3A6IDUwJTtcbiAgICBsZWZ0OiA1MCU7ICovXG4gICAgLyogbWFyZ2luLXRvcDogLTQwcHg7ICovXG4gICAgbWFyZ2luLWxlZnQ6IDMwcHg7XG4gICAgaGVpZ2h0OiA4MHB4O1xuICAgIHdpZHRoOiAxMDBweDtcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xuICB9XG4gIC5sZHMtcm9sbGVyIGRpdiB7XG4gICAgYW5pbWF0aW9uOiBsZHMtcm9sbGVyIDEuMnMgY3ViaWMtYmV6aWVyKDAuNSwgMCwgMC41LCAxKSBpbmZpbml0ZTtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiAzMnB4IDMycHg7XG4gIH1cbiAgLmxkcy1yb2xsZXIgZGl2OmFmdGVyIHtcbiAgICBjb250ZW50OiBcIiBcIjtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDZweDtcbiAgICBoZWlnaHQ6IDZweDtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgYmFja2dyb3VuZDogICM1MTMwODU7XG4gICAgbWFyZ2luOiAtM3B4IDAgMCAtM3B4O1xuICB9XG4gIC5sZHMtcm9sbGVyIGRpdjpudGgtY2hpbGQoMSkge1xuICAgIGFuaW1hdGlvbi1kZWxheTogLTAuMDM2cztcbiAgfVxuICAubGRzLXJvbGxlciBkaXY6bnRoLWNoaWxkKDEpOmFmdGVyIHtcbiAgICB0b3A6IDUwcHg7XG4gICAgbGVmdDogNTBweDtcbiAgfVxuICAubGRzLXJvbGxlciBkaXY6bnRoLWNoaWxkKDIpIHtcbiAgICBhbmltYXRpb24tZGVsYXk6IC0wLjA3MnM7XG4gIH1cbiAgLmxkcy1yb2xsZXIgZGl2Om50aC1jaGlsZCgyKTphZnRlciB7XG4gICAgdG9wOiA1NHB4O1xuICAgIGxlZnQ6IDQ1cHg7XG4gIH1cbiAgLmxkcy1yb2xsZXIgZGl2Om50aC1jaGlsZCgzKSB7XG4gICAgYW5pbWF0aW9uLWRlbGF5OiAtMC4xMDhzO1xuICB9XG4gIC5sZHMtcm9sbGVyIGRpdjpudGgtY2hpbGQoMyk6YWZ0ZXIge1xuICAgIHRvcDogNTdweDtcbiAgICBsZWZ0OiAzOXB4O1xuICB9XG4gIC5sZHMtcm9sbGVyIGRpdjpudGgtY2hpbGQoNCkge1xuICAgIGFuaW1hdGlvbi1kZWxheTogLTAuMTQ0cztcbiAgfVxuICAubGRzLXJvbGxlciBkaXY6bnRoLWNoaWxkKDQpOmFmdGVyIHtcbiAgICB0b3A6IDU4cHg7XG4gICAgbGVmdDogMzJweDtcbiAgfVxuICAubGRzLXJvbGxlciBkaXY6bnRoLWNoaWxkKDUpIHtcbiAgICBhbmltYXRpb24tZGVsYXk6IC0wLjE4cztcbiAgfVxuICAubGRzLXJvbGxlciBkaXY6bnRoLWNoaWxkKDUpOmFmdGVyIHtcbiAgICB0b3A6IDU3cHg7XG4gICAgbGVmdDogMjVweDtcbiAgfVxuICAubGRzLXJvbGxlciBkaXY6bnRoLWNoaWxkKDYpIHtcbiAgICBhbmltYXRpb24tZGVsYXk6IC0wLjIxNnM7XG4gIH1cbiAgLmxkcy1yb2xsZXIgZGl2Om50aC1jaGlsZCg2KTphZnRlciB7XG4gICAgdG9wOiA1NHB4O1xuICAgIGxlZnQ6IDE5cHg7XG4gIH1cbiAgLmxkcy1yb2xsZXIgZGl2Om50aC1jaGlsZCg3KSB7XG4gICAgYW5pbWF0aW9uLWRlbGF5OiAtMC4yNTJzO1xuICB9XG4gIC5sZHMtcm9sbGVyIGRpdjpudGgtY2hpbGQoNyk6YWZ0ZXIge1xuICAgIHRvcDogNTBweDtcbiAgICBsZWZ0OiAxNHB4O1xuICB9XG4gIC5sZHMtcm9sbGVyIGRpdjpudGgtY2hpbGQoOCkge1xuICAgIGFuaW1hdGlvbi1kZWxheTogLTAuMjg4cztcbiAgfVxuICAubGRzLXJvbGxlciBkaXY6bnRoLWNoaWxkKDgpOmFmdGVyIHtcbiAgICB0b3A6IDQ1cHg7XG4gICAgbGVmdDogMTBweDtcbiAgfVxuICBAa2V5ZnJhbWVzIGxkcy1yb2xsZXIge1xuICAgIDAlIHtcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICAgIH1cbiAgICAxMDAlIHtcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG4gICAgfVxuICB9XG5cblxuICAuYXBwLWxvYWRlciB7XG4gICAgbWFyZ2luOiAxLjVlbTtcbiAgICBwYWRkaW5nOiAxLjVlbVxuICB9XG4gIC5tYXAgeyBcbiAgICBoZWlnaHQ6IGNhbGMoMTAwdmggLSAxMjBweCk7IFxuICAgIHdpZHRoOiAxMDAlO1xuICB9XG5cbiAgLypcbiAgICBMZWFmbGV0IGFkZHMgaXRzIG93biB6LWluZGV4IHRvIGEgYnVuY2ggb2YgZWxlbWVudHMgd2hpY2ggbWFrZXMgdGhlIG1hcCBhcHBlYXIgb24gdG9wIG9mIFxuICAgIG90aGVyIGVsZW1lbnRzIHdpdGggbm8gZ29vZCByZWFzb25cbiAgICBUaGlzIGxpbmUgYWxsb3dzIGZvciB0aGUgbWFwIHRvIGJlIHVzYWJsZSB3aXRob3V0IGtub3duIGxpbWl0IHlldCB3aGlsZSBsZWF2aW5nIHRoZSBtYXAgYmVsb3dcbiAgICBvdGhlciBlbGVtZW50c1xuICAqL1xuICAubWFwIC5sZWFmbGV0LWNvbnRhaW5lciAqe1xuICAgIHotaW5kZXg6IDE7XG4gIH1cblxuXG4gIC5tYXB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG4gIC5tYXAgLmNvdW50LWFuZC10YWJzLWNvbnRhaW5lcntcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAxcmVtO1xuICAgIHdpZHRoOiAxMDAlO1xuICB9XG5cbiAgLm1hcCAuY291bnQtYW5kLXRhYnMtY29udGFpbmVyIC5yZXN1bHQtY291bnQtcGFyZW50LFxuICAubWFwIC5jb3VudC1hbmQtdGFicy1jb250YWluZXIgLmJ1dHRvbnN7XG4gICAgei1pbmRleDogMjtcbiAgfVxuXG4gIC5tYXAgLmNpcy1tYXJrZXItY2x1c3RlcntcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblxuICAgIGJhY2tncm91bmQtY29sb3I6ICNhMTc0YWM7XG4gICAgY29sb3I6IHdoaXRlO1xuXG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICB9XG5cbiAgLmhpZ2hsaWdodGVkLXByb2plY3R7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIG1hcmdpbi1ib3R0b206IDFlbTtcbiAgfVxuXG4gIC5oaWdobGlnaHRlZC1wcm9qZWN0IGJ1dHRvbi5jbG9zZXtcbiAgICBtYXJnaW46IDAuNWVtIDA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyOiAwO1xuXG4gICAgYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gIH1cblxuICAuaGlnaGxpZ2h0ZWQtcHJvamVjdCAuY2FyZHtcbiAgICBmb250LXNpemU6IDAuOWVtO1xuICAgICAgXG4gICAgYm94LXNoYWRvdzogbm9uZTtcbiAgfVxuXG4gIC5oaWdobGlnaHRlZC1wcm9qZWN0IC5jYXJkIC5jYXJkLWNvbnRlbnR7XG4gICAgcGFkZGluZzogMC4yZW0gMC41ZW07ICAgXG4gIH1cblxuICAuaGlnaGxpZ2h0ZWQtcHJvamVjdCAuY2FyZCAuY2FyZC1jb250ZW50OmZpcnN0LW9mLXR5cGV7XG4gICAgcGFkZGluZy10b3A6IDAuNWVtO1xuICB9XG4gIC5oaWdobGlnaHRlZC1wcm9qZWN0IC5jYXJkIC5jYXJkLWNvbnRlbnQ6bGFzdC1vZi10eXBle1xuICAgIHBhZGRpbmctYm90dG9tOiAwLjVlbTtcbiAgfVxuXG4gIC5oaWdobGlnaHRlZC1wcm9qZWN0IC5jYXJkIC5jYXJkLWNvbnRlbnQgaDF7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgfVxuXG4gIC8qIFRPRE8gU0FTUyA6IHNoYXJlIHRoaXMgc3R5bGUgd2l0aCBzZWFyY2ggcmVzdWx0IHByb2plY3QgY2FyZCB0YWcgc3R5bGUgKi9cbiAgLmhpZ2hsaWdodGVkLXByb2plY3QgLnRhZ3tcbiAgICBtYXJnaW4tcmlnaHQ6IDAuNWVtO1xuICAgIG1hcmdpbi1ib3R0b206IDAuNWVtO1xuICAgIHBhZGRpbmc6IDAuMmVtIDFlbTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzY3Njc2O1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgfVxuXG48L3N0eWxlPiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cInNlYXJjaC1iYXIgbmF2YmFyIGlzLXdoaXRlIGlzLWZpeGVkLXRvcFwiIHJvbGU9XCJtZW51YmFyXCIgYXJpYS1sYWJlbD1cImZpbHRlcnMgbmF2aWdhdGlvblwiPlxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICAgIFxuXG4gICAgICA8IS0tIElOUFVUIFRFWFQgLS0+XG4gICAgICA8ZGl2IGNsYXNzPVwic2VhcmNoIGNvbnRyb2wgaXMtZXhwYW5kZWRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImltYWdlLWNvbnRhaW5lclwiPjxpbWcgc3JjPVwiL3N0YXRpYy9pY29ucy9pY29uX3NlYXJjaF92aW9sZXQuc3ZnXCI+PC9kaXY+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJzZWFyY2hcIlxuICAgICAgICAgIHYtbW9kZWw9XCJzZWFyY2hlZFRleHRcIlxuICAgICAgICAgIGNsYXNzPVwiaW5wdXQgaXMtbGFyZ2UgaXMtbGlnaHQgaW5wdXQtbmF2YmFyXCJcbiAgICAgICAgICA6cGxhY2Vob2xkZXI9XCJ0cmFuc2xhdGUoZW5kcG9pbnRDb25maWdGaWx0ZXJzLCAncGxhY2Vob2xkZXInIClcIlxuICAgICAgICAgIEBpbnB1dD1cInNlYXJjaGVkVGV4dENoYW5nZWRcIlxuICAgICAgICAgID5cbiAgICAgIDwvZGl2PlxuXG5cbiAgICAgIDwhLS0gSU5QVVQgRklMVEVSUyAtLT5cbiAgICAgIDxociBjbGFzcz1cImlzLWZsZXgtdG91Y2ggZmlsdGVycy1kZWxpbWl0ZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItZW5kIGhhcy1iYWNrZ3JvdW5kLXdoaXRlIFwiPiA8IS0tIGlzLWhpZGRlbi10b3VjaCAodG8gY29tcGxldGVseSBoaWRlIGZyb20gbW9iaWxlKS0tPlxuXG5cbiAgICAgICAgPHNwYW4gdi1mb3I9XCJmaWx0ZXIgaW4gZmlsdGVyRGVzY3JpcHRpb25zXCJcbiAgICAgICAgICA6a2V5PVwiZmlsdGVyLm5hbWVcIlxuICAgICAgICAgIDppZD1cImZpbHRlci5uYW1lXCJcbiAgICAgICAgICBocmVmPVwiI1wiXG4gICAgICAgICAgY2xhc3M9XCJuYXZiYXItaXRlbSBuYXZiYXItaXRlbS1maWx0ZXIgaGFzLWRyb3Bkb3duIGlzLWhvdmVyYWJsZSBcIlxuICAgICAgICAgID5cblxuICAgICAgICAgIDxhIFxuICAgICAgICAgICAgOmNsYXNzPSdbXCJuYXZiYXItbGlua1wiLCB7XCJoYXMtdGV4dC13ZWlnaHQtc2VtaWJvbGRcIiA6IHNlbGVjdGVkRmlsdGVycy5nZXQoZmlsdGVyLm5hbWUpLnNpemUgPj0gMSB9IF0nXG4gICAgICAgICAgICBAY2xpY2s9XCJjb2xsYXBzZUNob2ljZXMoZmlsdGVyLm5hbWUpXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgPCEtLSA8YSA6Y2xhc3M9J1tcIm5hdmJhci1saW5rXCIsIHtcImhhcy10ZXh0LXdlaWdodC1zZW1pYm9sZFwiIDogaXNGaWx0ZXJGcm9tU2VsZWN0ZWRGaWx0ZXJzQm9sZChmaWx0ZXIubmFtZSkgfSBdJz4gLS0+XG4gICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAge3sgZmlsdGVyLmZ1bGxuYW1lIH19XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPC9hPlxuXG4gICAgICAgICAgPGRpdiAgXG4gICAgICAgICAgICA6aWQ9XCJmaWx0ZXIubmFtZVwiIFxuICAgICAgICAgICAgOnJlZj1cImZpbHRlci5uYW1lXCJcbiAgICAgICAgICAgIGNsYXNzPVwibmF2YmFyLWRyb3Bkb3duIGlzLXJpZ2h0IGhpZGUtY2hvaWNlc1wiXG4gICAgICAgICAgICA+IDwhLS0gaGVyZSBtYWtlIGl0IGNvbGxhcHNhYmxlIC0tPlxuXG4gICAgICAgICAgICA8YVxuICAgICAgICAgICAgICBjbGFzcz1cIm5hdmJhci1pdGVtXCJcbiAgICAgICAgICAgICAgdi1mb3I9XCJjaG9pY2UgaW4gZmlsdGVyLmNob2ljZXNcIiA6a2V5PVwiY2hvaWNlLm5hbWVcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZCBpcy1uYXJyb3dcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgXHRjbGFzcz1cImlzLWNoZWNrcmFkaW8gaXMtZGVmYXVsdCBpcy1ub3JtYWxcIlxuICAgICAgICAgICAgICAgICAgOmlkPVwiY2hvaWNlLm5hbWVcIlxuICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICAgIDpjaGVja2VkPVwic2VsZWN0ZWRGaWx0ZXJzLmdldChmaWx0ZXIubmFtZSkuaGFzKGNob2ljZS5uYW1lKVwiXG4gICAgICAgICAgICAgICAgICA6ZGF0YS1maWx0ZXI9XCJmaWx0ZXIubmFtZVwiXG4gICAgICAgICAgICAgICAgICA6ZGF0YS1jaG9pY2U9XCJjaG9pY2UubmFtZVwiXG4gICAgICAgICAgICAgICAgICBAY2hhbmdlPVwiY2hhbmdlRmlsdGVyXCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8bGFiZWwgOmZvcj1cImNob2ljZS5uYW1lXCI+XG4gICAgICAgICAgICAgICAgICB7eyBjaG9pY2UuZnVsbG5hbWUgfX1cbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvYT5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1pdGVtXCI+XG4gICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gaXMtdGV4dCBpcy1mdWxsd2lkdGggaGFzLXRleHQtcHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgOmRhdGEtZmlsdGVyPVwiZmlsdGVyLm5hbWVcIlxuICAgICAgICAgICAgICAgIEBjbGljaz1cImVtcHR5T25lRmlsdGVyKHtmaWx0ZXI6IGZpbHRlci5uYW1lfSlcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3t0cmFuc2xhdGUoZW5kcG9pbnRDb25maWdGaWx0ZXJzLCAncmVzZXQnICl9fVxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDxociBjbGFzcz1cImlzLWZsZXgtdG91Y2ggZmlsdGVycy1kZWxpbWl0ZXJcIj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHttYXBTdGF0ZX0gZnJvbSAndnVleCdcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIGNvbXB1dGVkOlxuICAgIHtcbiAgICAgIC4uLm1hcFN0YXRlKHtcbiAgICAgICAgc2VsZWN0ZWRGaWx0ZXJzOiAoe3NlYXJjaH0pID0+IHNlYXJjaC5xdWVzdGlvbi5zZWxlY3RlZEZpbHRlcnMsXG4gICAgICAgICdmaWx0ZXJEZXNjcmlwdGlvbnMnOiAnZmlsdGVyRGVzY3JpcHRpb25zJ1xuICAgICAgfSksXG4gICAgICBzZWFyY2hlZFRleHQ6IHtcbiAgICAgICAgZ2V0ICgpIHsgcmV0dXJuIHRoaXMuJHN0b3JlLnN0YXRlLnNlYXJjaC5xdWVzdGlvbi5xdWVyeSB9LFxuICAgICAgICBzZXQgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ3NlYXJjaGVkVGV4dENoYW5nZWQnLCB7c2VhcmNoZWRUZXh0OiB2YWx1ZX0pXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGVuZHBvaW50Q29uZmlnRmlsdGVycygpIHtcbiAgICAgICAgbGV0IGNvbmZpZ0ZpbHRlciA9IHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0RW5kcG9pbnRDb25maWdGaWx0ZXJzXG4gICAgICAgIHJldHVybiBjb25maWdGaWx0ZXJcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgbWV0aG9kczoge1xuXG4gICAgY29sbGFwc2VDaG9pY2VzKGZpbHRlck5hbWUpe1xuICAgICAgLy8gY29uc29sZS5sb2coXCJjb2xsYXBzZUNob2ljZXMgLyBmaWx0ZXJOYW1lIDogXCIsIGZpbHRlck5hbWUpXG4gICAgICBsZXQgZWxlbWVudCA9IHRoaXMuJHJlZnNbZmlsdGVyTmFtZV1bMF1cbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiY29sbGFwc2VDaG9pY2VzIC8gZWxlbWVudCA6IFwiLCBlbGVtZW50KVxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZS1jaG9pY2VzXCIpXG4gICAgfSxcblxuICAgIGVtcHR5T25lRmlsdGVyKHtmaWx0ZXJ9KXtcbiAgICAgIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCAnZW1wdHlPbmVGaWx0ZXInLCB7ZmlsdGVyfSApXG4gICAgfSxcbiAgICBjaGFuZ2VGaWx0ZXIoe3RhcmdldH0pe1xuICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goXG4gICAgICAgICd0b2dnbGVGaWx0ZXInLFxuICAgICAgICB7ZmlsdGVyOiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWZpbHRlcicpLCB2YWx1ZTogdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1jaG9pY2UnKX1cbiAgICAgIClcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlKCB0ZXh0c1RvVHJhbnNsYXRlLCBsaXN0RmllbGQgKSB7XG4gICAgICBsZXQgbGlzdFRleHRzID0gdGV4dHNUb1RyYW5zbGF0ZVtsaXN0RmllbGRdXG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRUcmFuc2xhdGlvbih7IHRleHRzIDogbGlzdFRleHRzIH0pXG4gICAgfSxcbiAgICBpc0ZpbHRlckZyb21TZWxlY3RlZEZpbHRlcnNCb2xkKGZpbHRlck5hbWUpe1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAvLyByZXR1cm4gKHRoaXMuc2VsZWN0ZWRGaWx0ZXJzLmdldChmaWx0ZXJOYW1lKSkgPyB0aGlzLnNlbGVjdGVkRmlsdGVycy5nZXQoZmlsdGVyTmFtZSkgOiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGlzRmlsdGVyRnJvbVNlbGVjdGVkRmlsdGVyc0NoZWNrZWQoZmlsdGVyTmFtZSl7XG4gICAgICAvLyAgOmNoZWNrZWQ9XCJzZWxlY3RlZEZpbHRlcnMuZ2V0KGZpbHRlci5uYW1lKS5oYXMoY2hvaWNlLm5hbWUpXCJcbiAgICAgIHJldHVybiBmYWxzZVxuICAgICAgLy8gcmV0dXJuICh0aGlzLnNlbGVjdGVkRmlsdGVycy5nZXQoZmlsdGVyTmFtZSkpID8gdGhpcy5zZWxlY3RlZEZpbHRlcnMuZ2V0KGZpbHRlck5hbWUpIDogdW5kZWZpbmVkXG4gICAgfSxcbiAgfSxcblxuICBtb3VudGVkKCl7XG4gICAgaWYoIXRoaXMuJHN0b3JlLnN0YXRlLnNlYXJjaC5hbnN3ZXIucmVzdWx0KXtcbiAgICAgIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdzZWFyY2hlZFRleHRDaGFuZ2VkJywge3NlYXJjaGVkVGV4dDogdGhpcy5zZWFyY2hlZFRleHR9KVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbiAgQGltcG9ydCAnLi4vLi4vc3R5bGVzL2FwaXZpei1jb2xvcnMuc2Nzcyc7XG4gIEBpbXBvcnQgJy4uLy4uL3N0eWxlcy9hcGl2aXotbWlzYy5zY3NzJztcbiAgQGltcG9ydCAnLi4vLi4vc3R5bGVzL3JlbS5zY3NzJztcblxuICAuaGlkZS1jaG9pY2Vze1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cbiAgLmZpbHRlcnMtZGVsaW1pdGVye1xuICAgIG1hcmdpbjowZW07XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJGFwaXZpei1wcmltYXJ5O1xuICB9XG5cblxuICAuc2VhcmNoLWJhciB7XG4gICAgdG9wOiAkYXBpdml6LW5hdmJhci1oZWlnaHQ7XG4gICAgaGVpZ2h0OiAkYXBpdml6LXNlYXJjaC1iYXItaGVpZ2h0O1xuICAgIHotaW5kZXg6IDEwO1xuICAgIGZvbnQtc2l6ZTogJGFwaXZpei1uYXZiYXItZm9udC1zaXplO1xuXG4gICAgLnNlYXJjaHtcbiAgICAgIGZsZXg6IDE7XG5cbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgLy9qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgIC5pbWFnZS1jb250YWluZXJ7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgIGltZ3tcbiAgICAgICAgICAgIHdpZHRoOiByZW0oMzZweCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5wdXRbdHlwZT1cInNlYXJjaFwiXXtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBib3JkZXI6IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLm5hdmJhci1lbmR7XG5cbiAgICAgIC5uYXZiYXItbGluazo6YWZ0ZXJ7XG4gICAgICAgIGNvbnRlbnQ6IHVybChcIi9zdGF0aWMvaWNvbnMvaWNvbl9jaGV2cm9uMy5zdmdcIik7XG4gICAgICAgIGJvcmRlcjogMDtcblxuICAgICAgICB0cmFuc2Zvcm06IG5vbmU7XG5cbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAtMC41ZW07XG4gICAgICAgIHdpZHRoOiByZW0oMjBweCk7XG5cbiAgICAgICAgcmlnaHQ6IDFlbTtcbiAgICAgICAgdG9wOiA0NyU7XG4gICAgICB9XG5cbiAgICAgIC5uYXZiYXItaXRlbXtcbiAgICAgICAgcGFkZGluZzogMC4yZW0gMC4yZW07XG4gICAgICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI0NCQ0JDQjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cblxuICA8ZGl2PlxuXG4gICAgPGRpdiBcbiAgICAgIGNsYXNzPVwiY2FyZFwiXG4gICAgICA+XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWhlYWRlclwiPlxuICAgICAgICA8YSBcbiAgICAgICAgICBjbGFzcz1cImNhcmQtaGVhZGVyLXRpdGxlXCJcbiAgICAgICAgICBAY2xpY2s9XCJ0b2dnbGVDb250ZW50XCJcbiAgICAgICAgICA+XG4gICAgICAgICAge3sgZmllbGRDb25maWcuZmllbGQgfX1cbiAgICAgICAgPC9hPlxuICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzPVwiY2FyZC1oZWFkZXItaWNvblwiIGFyaWEtbGFiZWw9XCJtb3JlIG9wdGlvbnNcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLWFuZ2xlLWRvd25cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2E+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBcbiAgICAgICAgdi1zaG93PVwiaXNPcGVuXCJcbiAgICAgICAgY2xhc3M9XCJjYXJkLWNvbnRlbnRcIlxuICAgICAgICA+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cblxuICAgICAgICAgIDwhLS0gREVCVUcgLS0+XG4gICAgICAgICAgcm9vdFVybEJhY2tlbmQgOiA8Y29kZT57eyByb290VXJsQmFja2VuZCB9fTwvY29kZT48YnI+XG4gICAgICAgICAgPCEtLSBqd3QgOiA8Y29kZT57eyBqd3QgfX08L2NvZGU+PGJyPiAtLT5cbiAgICAgICAgICBqd3QuYWNjZXNzX3Rva2VuIDogPGNvZGU+e3sgand0LmFjY2Vzc190b2tlbiB9fTwvY29kZT48YnI+XG4gICAgICAgICAgPCEtLSBqd3RbJ2FjY2Vzc190b2tlbiddIDogPGNvZGU+e3sgand0WydhY2Nlc3NfdG9rZW4nXSB9fTwvY29kZT48YnI+IC0tPlxuXG4gICAgICAgICAgY29uZmlnQ29sbGVjdGlvbiA6IDxjb2RlPnt7IGNvbmZpZ0NvbGxlY3Rpb24gfX08L2NvZGU+PGJyPlxuICAgICAgICAgIGN1cnJlbnRUYWIgOiA8Y29kZT57eyBjdXJyZW50VGFiIH19PC9jb2RlPjxicj5cbiAgICAgICAgICBmaWVsZENvbmZpZyA6IDxjb2RlPnt7IGZpZWxkQ29uZmlnIH19PC9jb2RlPjxicj5cbiAgICAgICAgICA8IS0tIGNvbmZpZ1tmaWVsZENvbmZpZy5maWVsZF0gOiA8Y29kZT57eyBjb25maWdbZmllbGRDb25maWcuZmllbGRdIH19PC9jb2RlPjxicj4gLS0+XG4gICAgICAgICAgY29uZmlnQmxvYyA6IDxjb2RlPnt7IGNvbmZpZ0Jsb2MgfX08L2NvZGU+PGJyPlxuICAgICAgICAgIDxocj5cblxuICAgICAgICAgIDxmb3JtIFxuICAgICAgICAgICAgdi1vbjpzdWJtaXQucHJldmVudD1cInNlbmRDb25maWdNb2RpZlwiIFxuICAgICAgICAgICAgbmFtZT1cImZvcm1Db25maWdcIiBcbiAgICAgICAgICAgID5cblxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICB2LWZvcj1cIihjb25mLCBpbmRleCkgaW4gZmllbGRDb25maWcuZWRpdFwiIFxuICAgICAgICAgICAgICA6a2V5PVwiaW5kZXhcIlxuICAgICAgICAgICAgICA+XG5cbiAgICAgICAgICAgICAgPCEtLSB0ZXh0IGZpZWxkIC0tPlxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgdi1pZj1cImNvbmYudHlwZSA9PT0gJ3RleHQnXCIgXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImxhYmVsXCI+e3tjb25mLnN1YmZpZWxkfX08L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICAgICAgICA8aW5wdXQgXG4gICAgICAgICAgICAgICAgICAgIDp2YWx1ZT1cImNvbmZpZ0Jsb2NbY29uZi5zdWJmaWVsZF1cIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImlucHV0XCIgXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCIgXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVGV4dCBpbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImhlbHBcIj5cbiAgICAgICAgICAgICAgICAgIHt7IGNvbmZpZ0Jsb2NbJ2hlbHAnXSB9fVxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgPCEtLSBzZWxlY3QgZmllbGQgLS0+XG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICB2LWlmPVwiY29uZi50eXBlID09PSAnc2VsZWN0J1wiIFxuICAgICAgICAgICAgICAgIGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbFwiPlN1YmplY3Q8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VsZWN0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbj5TZWxlY3QgZHJvcGRvd248L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uPldpdGggb3B0aW9uczwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICA8IS0tIHRleHRhcmVhIGZpZWxkIC0tPlxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgdi1pZj1cImNvbmYudHlwZSA9PT0gJ3RleHRhcmVhJ1wiIFxuICAgICAgICAgICAgICAgIGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbFwiPk1lc3NhZ2U8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJ0ZXh0YXJlYVwiIHBsYWNlaG9sZGVyPVwiVGV4dGFyZWFcIj48L3RleHRhcmVhPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICA8IS0tIGNoZWNrIGZpZWxkIC0tPlxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgdi1pZj1cImNvbmYudHlwZSA9PT0gJ2NoZWNrJ1wiIFxuICAgICAgICAgICAgICAgIGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiY2hlY2tib3hcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgSSBhZ3JlZSB0byB0aGUgPGEgaHJlZj1cIiNcIj50ZXJtcyBhbmQgY29uZGl0aW9uczwvYT5cbiAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgIDwhLS0gcmFkaW8gZmllbGQgLS0+XG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICB2LWlmPVwiY29uZi50eXBlID09PSAnYm9vbCdcIiBcbiAgICAgICAgICAgICAgICBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2xcIj5cbiAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInJhZGlvXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwicXVlc3Rpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgWWVzXG4gICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwicmFkaW9cIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJxdWVzdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICBOb1xuICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgPGJyPiBcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8aHI+XG5cbiAgICAgICAgICAgIDwhLS0gSVNfREVGQVVMVCByYWRpbyBmaWVsZCAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImNoZWNrYm94XCI+XG4gICAgICAgICAgICAgICAgICA8aW5wdXQgXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgIDp2YWx1ZT1cImlzRGVmYXVsdFwiXG4gICAgICAgICAgICAgICAgICAgIDpjaGVja2VkPVwiaXNEZWZhdWx0XCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgaXMgZGVmYXVsdCB2YWx1ZSAod2lsbCBiZSByZXNldCBpZiBzZXJ2ZXIgcmVzdGFydHMpXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGhyPlxuXG4gICAgICAgICAgICA8IS0tIFNVQk1JVCAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZCBpcy1ncm91cGVkXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBpcy1saW5rXCI+U3VibWl0PC9idXR0b24+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gaXMtdGV4dFwiPkNhbmNlbDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPC9mb3JtPlxuXG4gICAgICAgIDwvZGl2PlxuXG4gICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuICAgIDxiciAvPlxuXG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuaW1wb3J0IHsgbWFwU3RhdGUgfSBmcm9tICd2dWV4J1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gIH0sXG4gIHByb3BzOiBbXG4gICAgJ2NvbmZpZ0NvbGxlY3Rpb24nLFxuICAgICdjdXJyZW50VGFiJyxcbiAgICAnZmllbGRDb25maWcnLFxuICAgICdjb25maWcnXG4gIF0sXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNPcGVuIDogZmFsc2UsXG4gICAgICBjdXN0b21mb3JtRXJyb3IgOiAnJyxcblxuICAgICAgY29uZmlnQmxvYyA6IHVuZGVmaW5lZCxcbiAgICAgIGRvY0lkIDogdW5kZWZpbmVkLFxuXG4gICAgICBpc0RlZmF1bHQgOiB1bmRlZmluZWQsXG4gICAgfVxuICB9LFxuICBjb21wdXRlZCA6IHtcbiAgICAuLi5tYXBTdGF0ZSh7XG4gICAgICBhcGl2aXpGcm9udFVVSUQgOiAnYXBpdml6RnJvbnRVVUlEJyxcbiAgICAgIHJvb3RVcmxCYWNrZW5kOiAncm9vdFVybEJhY2tlbmQnLFxuICAgICAgand0OiAnand0JyxcbiAgICB9KSxcbiAgfSxcblxuICBiZWZvcmVNb3VudCgpe1xuICAgIGxldCBjb25maWdCbG9jID0gdGhpcy5jb25maWdbdGhpcy5maWVsZENvbmZpZy5maWVsZF1cbiAgICB0aGlzLmNvbmZpZ0Jsb2MgPSBjb25maWdCbG9jXG4gICAgdGhpcy5pc0RlZmF1bHQgPSBjb25maWdCbG9jWydpc19kZWZhdWx0J11cbiAgICB0aGlzLmRvY0lkID0gY29uZmlnQmxvYy5faWRcbiAgfSxcblxuICBtZXRob2RzIDoge1xuICAgIFxuICAgIHRvZ2dsZUNvbnRlbnQoKSB7XG4gICAgICB0aGlzLmlzT3BlbiA9ICF0aGlzLmlzT3BlblxuICAgIH0sXG5cbiAgICBnZXRUZXh0KHRleHRDb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kZWZhdWx0VGV4dCh7dHh0OnRleHRDb2RlfSlcbiAgICB9LFxuXG4gICAgc2VuZENvbmZpZ01vZGlmKGUpe1xuXG4gICAgICBsZXQgY3VycmVudENvbGwgPSB0aGlzLmNvbmZpZ0NvbGxlY3Rpb25cbiAgICAgIGxldCBhcmdzQ29uZmlnID0gJydcbiAgICAgIGlmIChjdXJyZW50Q29sbCA9PT0gJ3JvdXRlcycgfHwgY3VycmVudENvbGwgPT09ICdlbmRwb2ludHMnKXtcbiAgICAgICAgYXJnc0NvbmZpZyA9ICcmYXNfbGlzdD10cnVlJ1xuICAgICAgfSBcblxuICAgICAgdGhpcy5jdXN0b21mb3JtRXJyb3IgPSAnJ1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgIGxldCBwYXlsb2FkID0ge1xuICAgICAgICAvLyBUTyBETyBcbiAgICAgICAgdGVzdCA6ICd0ZXN0IHBheWxvYWQnLFxuICAgICAgICB0b2tlbiA6IHRoaXMuand0LmFjY2Vzc190b2tlbixcbiAgICAgICAgLy8gdXVpZCA6IHRoaXMuYXBpdml6RnJvbnRVVUlELFxuICAgICAgICBkb2NfaWQgOiB0aGlzLmRvY0lkLFxuICAgICAgICAvLyBkb2NfZGF0YSA6IHRoaXMuY29uZmlnQmxvY1xuICAgICAgfVxuXG4gICAgICAvLyBidWlsZCByZXF1ZXN0IFVSTFxuICAgICAgbGV0IHJlcXVlc3RVcmwgPSB0aGlzLnJvb3RVcmxCYWNrZW5kKycvY29uZmlnLycrY3VycmVudENvbGwrXCI/dXVpZD1cIit0aGlzLmFwaXZpekZyb250VVVJRFxuICAgICAgY29uc29sZS5sb2coJ3JlcXVlc3RVcmwgOiAnLCByZXF1ZXN0VXJsKVxuXG4gICAgICAvLyBwb3N0IHJlcXVlc3RcbiAgICAgIGF4aW9zXG4gICAgICAgIC5wb3N0KCByZXF1ZXN0VXJsLCBwYXlsb2FkIClcbiAgICAgICAgLmNhdGNoKCAoZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcilcbiAgICAgICAgICB0aGlzLmN1c3RvbWZvcm1FcnJvciA9ICdNb2RpZiBmYWlsZWQnXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IFxuICAgICAgICAgIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdnZXRDb25maWdUeXBlJyx7dHlwZTpjdXJyZW50Q29sbCwgY29uZmlnVHlwZUVuZHBvaW50OmN1cnJlbnRDb2xsLCBhcmdzOmFyZ3NDb25maWd9KSBcbiAgICAgICAgKVxuXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXG48L3N0eWxlPiIsIjx0ZW1wbGF0ZT5cblxuICA8IS0tIGNmIDogaHR0cHM6Ly9jb2RlcGVuLmlvL2FuZHJlaWNoMTk4MC9wZW4vT21vYkpRIC0tPlxuICA8c2VjdGlvbiBjbGFzcz1cIm1haW4tY29udGVudCBza2lwLW5hdmJhciBjb2x1bW5zIGlzLWZ1bGxoZWlnaHRcIj5cbiAgICBcbiAgICA8IS0tIFNJREUgTUVOVSAtLT5cbiAgICA8YXNpZGUgY2xhc3M9XCJjb2x1bW4gaXMtMyBpcy1uYXJyb3ctbW9iaWxlIGlzLWZ1bGxoZWlnaHQgc2VjdGlvblwiPlxuICAgICAgXG4gICAgICA8cCBcbiAgICAgICAgdi1pZj1cInVzZXIuaXNMb2dnZWRpblwiXG4gICAgICAgIGNsYXNzPVwibWVudS1sYWJlbCBpcy1oaWRkZW4tdG91Y2hcIlxuICAgICAgICA+XG4gICAgICAgIFBSRUZFUkVOQ0VTXG4gICAgICA8L3A+XG4gICAgICA8dWwgXG4gICAgICAgIHYtaWY9XCJ1c2VyLmlzTG9nZ2VkaW5cIlxuICAgICAgICBjbGFzcz1cIm1lbnUtbGlzdFwiPlxuICAgICAgICA8bGkgXG4gICAgICAgICAgdi1mb3I9XCJ1TWVudSBpbiB1c2VyTWVudVwiXG4gICAgICAgICAgOmtleT1cInVNZW51LmNvbmZpZ19jb2xsXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgPGEgXG4gICAgICAgICAgICBocmVmPVwiI1wiIFxuICAgICAgICAgICAgOmNsYXNzPVwiYCR7dU1lbnUuY29uZmlnX2NvbGwgPT0gYWN0aXZlTWVudSA/ICdpcy1hY3RpdmUnIDogJyd9YFwiXG4gICAgICAgICAgICBAY2xpY2s9XCJzZXRBY3RpdmVNZW51KHVNZW51LmNvbmZpZ19jb2xsKVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIj5cbiAgICAgICAgICAgICAgPGkgOmNsYXNzPVwidU1lbnUuaWNvblwiPjwvaT5cbiAgICAgICAgICAgIDwvc3Bhbj4gXG4gICAgICAgICAgICB7eyB1TWVudS50aXRsZSB9fVxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9saT5cbiAgICAgIDwvdWw+XG5cbiAgICAgIDxwIFxuICAgICAgICBjbGFzcz1cIm1lbnUtbGFiZWwgaXMtaGlkZGVuLXRvdWNoXCJcbiAgICAgICAgPlxuICAgICAgICBBUFAgU0VUVElOR1NcbiAgICAgIDwvcD5cblxuICAgICAgPCEtLSBNRU5VUyAtLT5cbiAgICAgIDx1bCBjbGFzcz1cIm1lbnUtbGlzdFwiPlxuICAgICAgICA8bGkgXG4gICAgICAgICAgdi1mb3I9XCJtZW51IGluIGJhY2tPZmZpY2VNZW51XCJcbiAgICAgICAgICA6a2V5PVwibWVudS5jb25maWdfY29sbFwiXG4gICAgICAgICAgPlxuICAgICAgICAgIDxhIFxuICAgICAgICAgICAgaHJlZj1cIiNcIiBcbiAgICAgICAgICAgIDpjbGFzcz1cImAke21lbnUuY29uZmlnX2NvbGwgPT0gYWN0aXZlTWVudSA/ICdpcy1hY3RpdmUnIDogJyd9YFwiXG4gICAgICAgICAgICBAY2xpY2s9XCJzZXRBY3RpdmVNZW51KG1lbnUuY29uZmlnX2NvbGwpXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuICAgICAgICAgICAgICA8aSA6Y2xhc3M9XCJtZW51Lmljb25cIj48L2k+XG4gICAgICAgICAgICA8L3NwYW4+IFxuICAgICAgICAgICAge3sgbWVudS50aXRsZSB9fVxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9saT5cbiAgICAgIDwvdWw+XG5cbiAgICA8L2FzaWRlPlxuXG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciBjb2x1bW4gaXMtOVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb25cIj5cblxuICAgICAgICA8IS0tIFRBQlMgLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzIGlzLWNlbnRlcmVkXCI+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAgPGxpXG4gICAgICAgICAgICAgIHYtZm9yPVwidGFiIGluIG1lbnVUYWJzKGFjdGl2ZU1lbnUpXCIgXG4gICAgICAgICAgICAgIDprZXk9XCJ0YWIudGFiX2NvZGVcIlxuICAgICAgICAgICAgICA6Y2xhc3M9XCJgJHt0YWIudGFiX2NvZGUgPT0gYWN0aXZlVGFiID8gJ2lzLWFjdGl2ZScgOiAnJ31gXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgIEBjbGljaz1cInNldEFjdGl2ZVRhYih0YWIudGFiX2NvZGUpXCIgIFxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7eyB0YWIudGl0bGUgfX1cbiAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8IS0tIENPTlRFTlRTIC0tPlxuICAgICAgICA8IS0tIDxkaXYgY2xhc3M9XCJjYXJkXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtaGVhZGVyXCI+PHAgY2xhc3M9XCJjYXJkLWhlYWRlci10aXRsZVwiPkhlYWRlcjwvcD48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1jb250ZW50XCI+PGRpdiBjbGFzcz1cImNvbnRlbnRcIj5Db250ZW50PC9kaXY+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnIgLz4gLS0+XG4gICAgICAgIFxuICAgICAgICA8dGVtcGxhdGVcbiAgICAgICAgICA+XG5cbiAgICAgICAgICA8QmFja09mZmljZUZvcm1cbiAgICAgICAgICAgIHYtZm9yPVwiZmllbGRDb25maWcgaW4gdGFiRmllbGRzKClcIlxuICAgICAgICAgICAgOmtleT1cImZpZWxkQ29uZmlnLmZpZWxkXCJcbiAgICAgICAgICAgIDpjb25maWdDb2xsZWN0aW9uPVwiYWN0aXZlTWVudVwiXG4gICAgICAgICAgICA6Y3VycmVudFRhYj1cImFjdGl2ZVRhYlwiXG4gICAgICAgICAgICA6ZmllbGRDb25maWc9XCJmaWVsZENvbmZpZ1wiXG4gICAgICAgICAgICA6Y29uZmlnPVwiY29uZmlnW2FjdGl2ZU1lbnVdXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICA8L0JhY2tPZmZpY2VGb3JtPlxuXG4gICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIFxuICA8L3NlY3Rpb24+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gJ3Z1ZXgnXG5cbmltcG9ydCBCYWNrT2ZmaWNlRm9ybSBmcm9tICcuLi9iYWNrb2ZmaWNlL0JhY2tPZmZpY2VGb3JtLnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIEJhY2tPZmZpY2VGb3JtXG4gIH0sXG4gIHByb3BzOiBbXG4gICAgJ2xvZ28nLCBcbiAgICAnYnJhbmQnXG4gIF0sXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXG4gICAgICBhY3RpdmVNZW51IDogJ2dsb2JhbCcsXG4gICAgICBhY3RpdmVUYWIgOiAnZ2xfZ2VuZXJhbCcsXG5cbiAgICAgIHVzZXJNZW51IDogW1xuICAgICAgICB7ICdjb25maWdfY29sbCcgOiAndV9pbmZvcycsIFxuICAgICAgICAgICd0aXRsZScgOiAnaW5mb3MnLFxuICAgICAgICAgIFwiaXNfZGl2aWRlclwiIDogZmFsc2UsXG4gICAgICAgICAgJ2ljb24nIDogJ2ZhciBmYS11c2VyJyxcbiAgICAgICAgfSxcbiAgICAgICAgeyAnY29uZmlnX2NvbGwnIDogJ3VfcGFzc3dvcmQnLCBcbiAgICAgICAgICAndGl0bGUnIDogJ3Bhc3N3b3JkJyxcbiAgICAgICAgICBcImlzX2RpdmlkZXJcIiA6IGZhbHNlLFxuICAgICAgICAgICdpY29uJyA6ICdmYXMgZmEtdW5sb2NrJyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG5cbiAgICAgIGJhY2tPZmZpY2VNZW51OiBbXG5cbiAgICAgICAgeyAnY29uZmlnX2NvbGwnIDogJ2dsb2JhbCcsIFxuICAgICAgICAgICd0aXRsZScgOiAnZ2xvYmFsIHNldHRpbmdzJyxcbiAgICAgICAgICBcImlzX2RpdmlkZXJcIiA6IGZhbHNlLFxuICAgICAgICAgICdpY29uJyA6ICdmYXMgZmEtY29nJyxcbiAgICAgICAgICAndGFicycgIDogW1xuICAgICAgICAgICAgeyAndGFiX2NvZGUnIDogJ2dsX2dlbmVyYWwnICwgXG4gICAgICAgICAgICAgICd0aXRsZScgOiAnZ2VuZXJhbCcsXG4gICAgICAgICAgICAgICdmaWVsZHMnIDogW1xuICAgICAgICAgICAgICAgIHsgJ2ZpZWxkJyA6ICdhcHBfdGl0bGUnLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogJ2Jsb2MnLCBcbiAgICAgICAgICAgICAgICAgICdlZGl0JyA6IFtcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAnY29udGVudCcsICd0eXBlJyA6ICd0ZXh0JywgJ2xpc3QnIDogZmFsc2V9XG4gICAgICAgICAgICAgICAgICBdLCBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgJ2ZpZWxkJyA6ICdhcHBfZGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogJ2Jsb2MnLCBcbiAgICAgICAgICAgICAgICAgICdlZGl0JyA6IFtcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAnY29udGVudCcsICd0eXBlJyA6ICd0ZXh0LWxhbmcnLCAnbGlzdCcgOiBmYWxzZX1cbiAgICAgICAgICAgICAgICAgIF0sIFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeyAnZmllbGQnIDogJ2FwcF9sYW5ndWFnZXMnLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogJ2Jsb2MnLCBcbiAgICAgICAgICAgICAgICAgICdlZGl0JyA6IFtcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAnbG9jYWxlJywgJ3R5cGUnIDogJ3RleHQnLCAnbGlzdCcgOiBmYWxzZX0sIFxuICAgICAgICAgICAgICAgICAgICB7J3N1YmZpZWxkJyA6ICdsYW5ndWFnZXMnLCAndHlwZScgOiAndGV4dCcsICdsaXN0JyA6IHRydWV9XG4gICAgICAgICAgICAgICAgICBdLCBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyAndGFiX2NvZGUnIDogJ2dsX2lkZW50aXR5JywgXG4gICAgICAgICAgICAgICd0aXRsZScgOiAnc2l0ZSBpZGVudGl0eScsXG4gICAgICAgICAgICAgICdmaWVsZHMnIDogW1xuICAgICAgICAgICAgICAgIHsgJ2ZpZWxkJyA6ICdhcHBfbG9nbycsXG4gICAgICAgICAgICAgICAgICAndHlwZScgOiAnYmxvYycsIFxuICAgICAgICAgICAgICAgICAgJ2VkaXQnIDogW1xuICAgICAgICAgICAgICAgICAgICB7J3N1YmZpZWxkJyA6ICd1cmwnLCAndHlwZScgOiAndGV4dCcsICdsaXN0JyA6IGZhbHNlfVxuICAgICAgICAgICAgICAgICAgXSwgXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7ICdmaWVsZCcgOiAnYXBwX2Zhdmljb24nLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogJ2Jsb2MnLCBcbiAgICAgICAgICAgICAgICAgICdlZGl0JyA6IFtcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAndXJsJywgJ3R5cGUnIDogJ3RleHQnLCAnbGlzdCcgOiBmYWxzZX1cbiAgICAgICAgICAgICAgICAgIF0sIFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeyAnZmllbGQnIDogJ2FwcF93ZWxjb21lJyxcbiAgICAgICAgICAgICAgICAgICd0eXBlJyA6ICdibG9jJywgXG4gICAgICAgICAgICAgICAgICAnZWRpdCcgOiBbXG4gICAgICAgICAgICAgICAgICAgIHsnc3ViZmllbGQnIDogJ2NvbnRlbnQnLCAndHlwZScgOiAndGV4dC1sYW5nJywgJ2xpc3QnIDogZmFsc2V9XG4gICAgICAgICAgICAgICAgICBdLCBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgJ2ZpZWxkJyA6ICdhcHBfcGl0Y2gnLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogJ2Jsb2MnLCBcbiAgICAgICAgICAgICAgICAgICdlZGl0JyA6IFtcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAnY29udGVudCcsICd0eXBlJyA6ICd0ZXh0LWxhbmcnLCAnbGlzdCcgOiBmYWxzZX1cbiAgICAgICAgICAgICAgICAgIF0sIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RhYl9jb2RlJyA6ICdnbF9tZXRhJywgXG4gICAgICAgICAgICAgICd0aXRsZScgOiAnbWV0YScsXG4gICAgICAgICAgICAgICdmaWVsZHMnIDogW1xuICAgICAgICAgICAgICAgIHsgJ2ZpZWxkJyA6ICdhcHBfa2V5d29yZHMnLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogJ2Jsb2MnLCBcbiAgICAgICAgICAgICAgICAgICdlZGl0JyA6IFtcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAnY29udGVudCcsICd0eXBlJyA6ICd0ZXh0JywgJ2xpc3QnIDogZmFsc2V9XG4gICAgICAgICAgICAgICAgICBdLCBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgJ2ZpZWxkJyA6ICdhcHBfY29kZScsXG4gICAgICAgICAgICAgICAgICAndHlwZScgOiAnYmxvYycsIFxuICAgICAgICAgICAgICAgICAgJ2VkaXQnIDogW1xuICAgICAgICAgICAgICAgICAgICB7J3N1YmZpZWxkJyA6ICd1cmwnLCAndHlwZScgOiAndGV4dCcsICdsaXN0JyA6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAnY29udGVudCcsICd0eXBlJyA6ICd0ZXh0LWxhbmcnLCAnbGlzdCcgOiBmYWxzZX1cbiAgICAgICAgICAgICAgICAgIF0sIFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7ICd0YWJfY29kZScgOiAnZ2xfc2VvJywgXG4gICAgICAgICAgICAgICd0aXRsZScgOiAnc2VvJyxcbiAgICAgICAgICAgICAgJ2ZpZWxkcycgOiBbXG4gICAgICAgICAgICAgICAgeyAnZmllbGQnIDogJ2FwcF9hbmFseXRpY3MnLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogJ2Jsb2MnLCBcbiAgICAgICAgICAgICAgICAgICdlZGl0JyA6IFtcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAnY29udGVudCcsICd0eXBlJyA6ICd0ZXh0JywgJ2xpc3QnIDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7J3N1YmZpZWxkJyA6ICd1cmwnLCAndHlwZScgOiAndGV4dCcsICdsaXN0JyA6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAnYWN0aXZhdGVkJywgJ3R5cGUnIDogJ2Jvb2wnLCAnbGlzdCcgOiBmYWxzZX1cbiAgICAgICAgICAgICAgICAgIF0sIFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeyAnZmllbGQnIDogJ2FwcF9zdXBwb3J0JyxcbiAgICAgICAgICAgICAgICAgICd0eXBlJyA6ICdibG9jJywgXG4gICAgICAgICAgICAgICAgICAnZWRpdCcgOiBbXG4gICAgICAgICAgICAgICAgICAgIHsnc3ViZmllbGQnIDogJ2NvbnRlbnQnLCAndHlwZScgOiAndGV4dCcsICdsaXN0JyA6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAndXJsJywgJ3R5cGUnIDogJ3RleHQnLCAnbGlzdCcgOiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHsnc3ViZmllbGQnIDogJ2FjdGl2YXRlZCcsICd0eXBlJyA6ICdib29sJywgJ2xpc3QnIDogZmFsc2V9XG4gICAgICAgICAgICAgICAgICBdLCBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgJ2ZpZWxkJyA6ICdhcHBfaW5kZXhpbmcnLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogJ2Jsb2MnLCBcbiAgICAgICAgICAgICAgICAgICdlZGl0JyA6IFtcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAnY29udGVudCcsICd0eXBlJyA6ICd0ZXh0JywgJ2xpc3QnIDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7J3N1YmZpZWxkJyA6ICdhY3RpdmF0ZWQnLCAndHlwZScgOiAnYm9vbCcsICdsaXN0JyA6IGZhbHNlfVxuICAgICAgICAgICAgICAgICAgXSwgXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgJ3RhYl9jb2RlJyA6ICdnbF9sYW5nJywgXG4gICAgICAgICAgICAgICd0aXRsZScgOiAnaW50ZXJuYXRpb25hbCcsXG4gICAgICAgICAgICAgICdmaWVsZHMnIDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICdmaWVsZCcgOiAnYXBwX2Jhc2ljX2RpY3QnLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogJ2Jsb2MnLCBcbiAgICAgICAgICAgICAgICAgICdlZGl0JyA6IFsnY29udGVudCddLCBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIHsgJ2NvbmZpZ19jb2xsJyA6ICduYXZiYXInLFxuICAgICAgICAgICd0aXRsZScgOiAnbmF2YmFyJyxcbiAgICAgICAgICBcImlzX2RpdmlkZXJcIiA6IGZhbHNlLFxuICAgICAgICAgICdpY29uJyA6ICdmYXMgZmEtYmFycycsXG4gICAgICAgICAgJ3RhYnMnICA6IFtcbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgICd0YWJfY29kZScgOiAnbmFfbG9nbycsIFxuICAgICAgICAgICAgICAndGl0bGUnIDogJ2xvZ28nIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgICd0YWJfY29kZScgOiAnbmFfbGlua3MnLCBcbiAgICAgICAgICAgICAgJ3RpdGxlJyA6ICdsaW5rcycgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgJ3RhYl9jb2RlJyA6ICduYV9idG4nICAsIFxuICAgICAgICAgICAgICAndGl0bGUnIDogJ2NhbGxfYnV0dG9uJyBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICBcbiAgICAgICAgeyAnY29uZmlnX2NvbGwnIDogJ3JvdXRlcycsXG4gICAgICAgICAgJ3RpdGxlJyA6ICdyb3V0ZXMnLFxuICAgICAgICAgIFwiaXNfZGl2aWRlclwiIDogZmFsc2UsXG4gICAgICAgICAgJ2ljb24nIDogJ2ZhciBmYS1zdGlja3ktbm90ZScsXG4gICAgICAgICAgJ3RhYnMnICA6IFtcbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgICd0YWJfY29kZScgOiAncm9faG9tZScsIFxuICAgICAgICAgICAgICAndGl0bGUnIDogJ2hvbWUgcGFnZScgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgJ3RhYl9jb2RlJyA6ICdyb19kYXRhJywgXG4gICAgICAgICAgICAgICd0aXRsZScgOiAnZGF0YXNldHMgcGFnZXMnIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgICd0YWJfY29kZScgOiAncm9fc3RhdGljcycsIFxuICAgICAgICAgICAgICAndGl0bGUnIDogJ3N0YXRpYyBwYWdlcycgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHsgJ2NvbmZpZ19jb2xsJyA6ICdlbmRwb2ludHMnLFxuICAgICAgICAgICd0aXRsZScgOiAnQVBJIGVuZHBvaW50cycsXG4gICAgICAgICAgXCJpc19kaXZpZGVyXCIgOiBmYWxzZSxcbiAgICAgICAgICAnaWNvbicgOiAnZmFzIGZhLWRhdGFiYXNlJyxcbiAgICAgICAgICAndGFicycgIDogW1xuICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgJ3RhYl9jb2RlJyA6ICdlcF9kYXRhJywgXG4gICAgICAgICAgICAgICd0aXRsZScgOiAnZGF0YXNldHMnIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgICd0YWJfY29kZScgOiAnZXBfdXNlcicsIFxuICAgICAgICAgICAgICAndGl0bGUnIDogJ3VzZXInIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgICd0YWJfY29kZScgOiAnZXBfYXV0aCcsIFxuICAgICAgICAgICAgICAndGl0bGUnIDogJ2F1dGhlbnRpY2F0aW9uJyBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIHsgJ2NvbmZpZ19jb2xsJyA6ICdmb290ZXInLFxuICAgICAgICAgICd0aXRsZScgOiAnZm9vdGVyJyxcbiAgICAgICAgICBcImlzX2RpdmlkZXJcIiA6IGZhbHNlLFxuICAgICAgICAgICdpY29uJyA6ICdmYXMgZmEtbGluaycsXG4gICAgICAgICAgJ3RhYnMnICA6IFtcbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgICd0YWJfY29kZScgOiAnZm9fc2V0dGluZ3MnLCBcbiAgICAgICAgICAgICAgJ3RpdGxlJyA6ICdzZXR0aW5ncycgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgJ3RhYl9jb2RlJyA6ICdmb19jb250ZW50cycsIFxuICAgICAgICAgICAgICAndGl0bGUnIDogJ2NvbnRlbnRzJyBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IFxuICAgICAgICAgICAgICAndGFiX2NvZGUnIDogJ2ZvX3VpJywgXG4gICAgICAgICAgICAgICd0aXRsZScgOiAndWknIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgICd0YWJfY29kZScgOiAnZm9fbGlua3MnLCBcbiAgICAgICAgICAgICAgJ3RpdGxlJyA6ICdsaW5rcycgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICB7ICdjb25maWdfY29sbCcgOiAnc29jaWFscycsXG4gICAgICAgICAgJ3RpdGxlJyA6ICdzb2NpYWxzJyxcbiAgICAgICAgICBcImlzX2RpdmlkZXJcIiA6IGZhbHNlLFxuICAgICAgICAgICdpY29uJyA6ICdmYXMgZmEtc2hhcmUtYWx0JyxcbiAgICAgICAgICAndGFicycgIDogW1xuICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgJ3RhYl9jb2RlJyA6ICdzb19zZXR0aW5ncycsIFxuICAgICAgICAgICAgICAndGl0bGUnIDogJ3NldHRpbmdzJyxcbiAgICAgICAgICAgICAgJ2ZpZWxkcycgOiBbXG4gICAgICAgICAgICAgICAgeyAnZmllbGQnIDogJ2FwcF90d2l0dGVyJyxcbiAgICAgICAgICAgICAgICAgICd0eXBlJyA6ICdibG9jJywgXG4gICAgICAgICAgICAgICAgICAnZWRpdCcgOiBbXG4gICAgICAgICAgICAgICAgICAgIHsnc3ViZmllbGQnIDogJ3VybCcsICd0eXBlJyA6ICd0ZXh0JywgJ2xpc3QnIDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7J3N1YmZpZWxkJyA6ICd0b29sdGlwJywgJ3R5cGUnIDogJ3RleHQtbGFuZycsICdsaXN0JyA6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAnaW5fZm9vdGVyJywgJ3R5cGUnIDogJ2Jvb2wnLCAnbGlzdCcgOiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICBdLCBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgJ2ZpZWxkJyA6ICdhcHBfZmFjZWJvb2snLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogJ2Jsb2MnLCBcbiAgICAgICAgICAgICAgICAgICdlZGl0JyA6IFtcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAndXJsJywgJ3R5cGUnIDogJ3RleHQnLCAnbGlzdCcgOiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHsnc3ViZmllbGQnIDogJ3Rvb2x0aXAnLCAndHlwZScgOiAndGV4dC1sYW5nJywgJ2xpc3QnIDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7J3N1YmZpZWxkJyA6ICdpbl9mb290ZXInLCAndHlwZScgOiAnYm9vbCcsICdsaXN0JyA6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgIF0sIFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeyAnZmllbGQnIDogJ2FwcF9naXRodWInLFxuICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogJ2Jsb2MnLCBcbiAgICAgICAgICAgICAgICAgICdlZGl0JyA6IFtcbiAgICAgICAgICAgICAgICAgICAgeydzdWJmaWVsZCcgOiAndXJsJywgJ3R5cGUnIDogJ3RleHQnLCAnbGlzdCcgOiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHsnc3ViZmllbGQnIDogJ3Rvb2x0aXAnLCAndHlwZScgOiAndGV4dC1sYW5nJywgJ2xpc3QnIDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7J3N1YmZpZWxkJyA6ICdpbl9mb290ZXInLCAndHlwZScgOiAnYm9vbCcsICdsaXN0JyA6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgIF0sIFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0gXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICB7ICdjb25maWdfY29sbCcgOiAnc3R5bGVzJyxcbiAgICAgICAgICAndGl0bGUnIDogJ3N0eWxlcycsXG4gICAgICAgICAgXCJpc19kaXZpZGVyXCIgOiBmYWxzZSxcbiAgICAgICAgICAnaWNvbicgOiAnZmFzIGZhLXBhaW50LWJydXNoJyxcbiAgICAgICAgICAndGFicycgIDogW1xuICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgJ3RhYl9jb2RlJyA6ICdzdF9jb2xvcnMnLCBcbiAgICAgICAgICAgICAgJ3RpdGxlJyA6ICdhcHAgY29sb3JzJyBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IFxuICAgICAgICAgICAgICAndGFiX2NvZGUnIDogJ3N0X3R5cG8nLCBcbiAgICAgICAgICAgICAgJ3RpdGxlJyA6ICdhcHAgdHlwbycgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgJ3RhYl9jb2RlJyA6ICdzdF90eXBvY29sb3JzJywgXG4gICAgICAgICAgICAgICd0aXRsZScgOiAnYXBwIHR5cG8gY29sb3JzJyBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IFxuICAgICAgICAgICAgICAndGFiX2NvZGUnIDogJ3N0X2Jhbm5lcnMnLCBcbiAgICAgICAgICAgICAgJ3RpdGxlJyA6ICdhcHAgYmFubmVycycgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgJ3RhYl9jb2RlJyA6ICdzdF9pbWFnZXMnLCBcbiAgICAgICAgICAgICAgJ3RpdGxlJyA6ICdhcHAgZGVmYXVsdCBpbWFnZXMgc2V0cycgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICB7ICdjb25maWdfY29sbCcgOiAndXNlcnMnLFxuICAgICAgICAgICd0aXRsZScgOiAndXNlcnMnLFxuICAgICAgICAgIFwiaXNfZGl2aWRlclwiIDogZmFsc2UsXG4gICAgICAgICAgJ2ljb24nIDogJ2ZhcyBmYS11c2VycycsXG4gICAgICAgICAgJ3RhYnMnICA6IFtcbiAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgICd0YWJfY29kZScgOiAndXNfdXNlcnMnLCBcbiAgICAgICAgICAgICAgJ3RpdGxlJyA6ICd1c2VycycsXG4gICAgICAgICAgICAgICdmaWVsZHMnIDogW1xuXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IFxuICAgICAgICAgICAgICAndGFiX2NvZGUnIDogJ3VzX3RlYW1zJywgXG4gICAgICAgICAgICAgICd0aXRsZScgOiAndGVhbXMnLFxuICAgICAgICAgICAgICAnZmllbGRzJyA6IFtcblxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF1cbiAgICAgICAgfVxuXG4gICAgICBdLFxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICAuLi5tYXBTdGF0ZSh7XG4gICAgICB1c2VyOiAndXNlcicsXG4gICAgICBjb25maWc6ICdjb25maWcnXG4gICAgfSksXG4gICAgaXNVc2VyQWRtaW4gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0Q2hlY2tVc2VyUm9sZSgnYWRtaW4nKVxuICAgIH0sXG4gICAgaXNVc2VyU3RhZmYgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0Q2hlY2tVc2VyUm9sZSgnc3RhZmYnKVxuICAgIH0sXG4gIH0sXG5cbiAgbW91bnRlZCgpe1xuICAgIC8vIGhhY2sgdG8gc2Nyb2xsIHRvcCBiZWNhdXNlIHZ1ZS1yb3V0ZXIgc2Nyb2xsQmVoYXZpb3IgdGhpbmcgZG9lc24ndCBzZWVtIHRvIHdvcmsgb24gRmlyZWZveCBvbiBMaW51eCBhdCBsZWFzdFxuICAgIGNvbnN0IGludCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmKHdpbmRvdy5wYWdlWU9mZnNldCA8IDUwKXtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnQpXG4gICAgICB9XG4gICAgICBlbHNle1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcblxuICAgIGdldE1lbnVDb25maWcobWVudUNvbmZpZ0ZpZWxkKSB7XG4gICAgICBsZXQgbWVudUNvbmZpZyA9IHRoaXMuYmFja09mZmljZU1lbnUuZmluZChmdW5jdGlvbihtZW51KSB7XG4gICAgICAgIHJldHVybiBtZW51LmNvbmZpZ19jb2xsID09PSBtZW51Q29uZmlnRmllbGRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1lbnVDb25maWdcbiAgICB9LFxuXG4gICAgbWVudVRhYnMobWVudUNvbmZpZ0ZpZWxkKSB7XG4gICAgICBsZXQgbWVudUNvbmZpZyA9IHRoaXMuZ2V0TWVudUNvbmZpZyhtZW51Q29uZmlnRmllbGQpXG4gICAgICByZXR1cm4gbWVudUNvbmZpZy50YWJzXG4gICAgfSxcblxuICAgIGdldFRhYkNvbmZpZygpIHtcbiAgICAgIGxldCBtZW51VGFicyA9IHRoaXMubWVudVRhYnModGhpcy5hY3RpdmVNZW51KVxuICAgICAgbGV0IGFjdGl2ZVRhYiA9IHRoaXMuYWN0aXZlVGFiXG4gICAgICAvLyBjb25zb2xlLmxvZygnbWVudVRhYnMgOiAnLCBtZW51VGFicylcbiAgICAgIGxldCB0YWJDb25maWcgPSBtZW51VGFicy5maW5kKGZ1bmN0aW9uKHRhYikge1xuICAgICAgICByZXR1cm4gdGFiLnRhYl9jb2RlID09PSBhY3RpdmVUYWJcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coJ3RhYkNvbmZpZyA6ICcsIHRhYkNvbmZpZylcbiAgICAgIHJldHVybiB0YWJDb25maWdcbiAgICB9LFxuXG4gICAgdGFiRmllbGRzKCkge1xuICAgICAgbGV0IHRhYkNvbmZpZyA9IHRoaXMuZ2V0VGFiQ29uZmlnKClcbiAgICAgIHJldHVybiB0YWJDb25maWcuZmllbGRzXG4gICAgfSxcblxuICAgIHNldEFjdGl2ZU1lbnUobWVudUNvbmZpZ0ZpZWxkKSB7XG4gICAgICB0aGlzLmFjdGl2ZU1lbnUgPSBtZW51Q29uZmlnRmllbGRcbiAgICAgIGxldCBtZW51Q29uZmlnID0gdGhpcy5nZXRNZW51Q29uZmlnKG1lbnVDb25maWdGaWVsZClcbiAgICAgIHRoaXMuYWN0aXZlVGFiID0gbWVudUNvbmZpZy50YWJzWzBdWyd0YWJfY29kZSddXG4gICAgfSxcblxuICAgIHNldEFjdGl2ZVRhYih0YWJDb2RlKSB7XG4gICAgICB0aGlzLmFjdGl2ZVRhYiA9IHRhYkNvZGVcbiAgICB9LFxuXG4gICAgZ2V0VGV4dCh0ZXh0Q29kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDp0ZXh0Q29kZX0pXG4gICAgfSxcblxuICAgIGdvQmFjayhlKXtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgdGhpcy4kcm91dGVyLmJhY2soKVxuICAgIH1cbiAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cblxuICAgIDwhLS0gTkFWQkFSIC0tPlxuICAgIDxOYXZCYXIgXG4gICAgICB2LWlmPVwidGhpcy5oYXNfbmF2YmFyXCJcbiAgICAgIDpuYXZiYXJDb25maWc9XCJ0aGlzLm5hdmJhckNvbmZpZ1wiIFxuICAgICAgOmxvZ289XCJ0aGlzLmdsb2JhbENvbmZpZy5hcHBfbG9nb1wiXG4gICAgICA6YnJhbmQ9XCJ0aGlzLmdsb2JhbENvbmZpZy5hcHBfdGl0bGUuY29udGVudFwiXG4gICAgICA6YXBwTG9jYWxlcz1cInRoaXMuZ2xvYmFsQ29uZmlnLmFwcF9sYW5ndWFnZXNcIiBcbiAgICAgIDpjdXJyZW50RGF0YXNldFVSST1cImN1cnJlbnREYXRhc2V0VVJJXCJcbiAgICAgIDpsb2NhbFJvdXRlQ29uZmlnPVwibG9jYWxSb3V0ZUNvbmZpZ1wiXG4gICAgPjwvTmF2QmFyPlxuICAgICAgPCEtLSA6Y3VycmVudFJvdXRlQ29uZmlnPVwidGhpcy5yb3V0ZUNvbmZpZ1wiXG4gICAgICA6bG9jYWxSb3V0ZUNvbmZpZz1cImxvY2FsUm91dGVDb25maWcuZmllbGRcIiAtLT5cbiAgICAgICAgPCEtLSA6bG9nbz1cImxvZ29cIiBcbiAgICAgICAgOmJyYW5kPVwiYnJhbmRcIiAgLS0+XG5cblxuICAgIDwhLS0gRFlOQU1JQyBDT01QT05FTlQgLS0+XG5cbiAgICA8IS0tIDxjb21wb25lbnQgXG4gICAgICA6aXM9XCJ0aGlzLmR5bmFtaWNfdGVtcGxhdGVcIiBcbiAgICAgIDpyb3V0ZUNvbmZpZz1cInRoaXMubG9jYWxSb3V0ZUNvbmZpZ1wiXG4gICAgPjwvY29tcG9uZW50PiAtLT5cblxuICAgIDwhLS0gREVCVUdHSU5HIC0tPlxuICAgIDwhLS0gPGRpdj4gLS0+XG4gICAgICA8IS0tIDxicj48YnI+PGJyPjxicj48YnI+IC0tPlxuICAgICAgPCEtLSBuYXZiYXJDb25maWcgOiA8YnI+PGNvZGU+IHt7IHRoaXMubmF2YmFyQ29uZmlnIH19IDwvY29kZT4gPGJyPjxicj4+IC0tPlxuICAgICAgPCEtLSBnbG9iYWxDb25maWcgOiA8YnI+PGNvZGU+IHt7IHRoaXMuZ2xvYmFsQ29uZmlnIH19IDwvY29kZT4gPGJyPjxicj4gLS0+XG4gICAgICA8IS0tIHN0eWxlc0NvbmZpZyA6IDxicj48Y29kZT4ge3sgdGhpcy5zdHlsZXNDb25maWcgfX0gPC9jb2RlPiA8YnI+PGJyPiAtLT5cbiAgICAgIDwhLS0gcm91dGVDb25maWcuZmllbGQgOiA8Y29kZT57eyB0aGlzLnJvdXRlQ29uZmlnLmZpZWxkIH19IDwvY29kZT4gPGJyPjxicj4gLS0+XG4gICAgICA8IS0tIHJvdXRlQ29uZmlnIDogPGNvZGU+e3sgdGhpcy5yb3V0ZUNvbmZpZyB9fSA8L2NvZGU+IDxicj48YnI+IC0tPlxuICAgICAgPCEtLSBmb290ZXJDb25maWcgOiA8YnI+PGNvZGU+IHt7IHRoaXMuZm9vdGVyQ29uZmlnIH19IDwvY29kZT4gPGJyPjxicj4gLS0+XG4gICAgICA8IS0tIHNlYXJjaC5lbmRwb2ludF90eXBlIDogPGJyPjxjb2RlPiB7eyB0aGlzLiRzdG9yZS5zdGF0ZS5zZWFyY2guZW5kcG9pbnRfdHlwZSB9fSA8L2NvZGU+IDxicj48YnI+IC0tPlxuICAgICAgPCEtLSBzZWFyY2guZW5kcG9pbnQgOiA8YnI+PGNvZGU+IHt7IHRoaXMuJHN0b3JlLnN0YXRlLnNlYXJjaC5lbmRwb2ludCB9fSA8L2NvZGU+IDxicj48YnI+IC0tPlxuICAgICAgPCEtLSBnZXRDdXJyZW50QmFubmVyIDogPGJyPjxjb2RlPiB7eyB0aGlzLmdldEN1cnJlbnRCYW5uZXIgfX0gPC9jb2RlPiA8YnI+PGJyPiAtLT5cblxuICAgICAgPCEtLSBsb2NhbFJvdXRlQ29uZmlnLmZpZWxkIDo8YnI+PGNvZGU+IHt7IGxvY2FsUm91dGVDb25maWcuZmllbGQgfX0gPC9jb2RlPiA8YnI+PGJyPiAtLT5cbiAgICAgIDwhLS0gbG9jYWxFbmRwb2ludENvbmZpZyA6PGJyPjxjb2RlPiB7eyBsb2NhbEVuZHBvaW50Q29uZmlnIH19IDwvY29kZT4gPGJyPjxicj4gLS0+XG4gICAgICA8IS0tIGxvY2FsRmlsdGVyc0NvbmZpZyA6PGJyPjxjb2RlPiB7eyBsb2NhbEZpbHRlcnNDb25maWcgfX0gPC9jb2RlPiA8YnI+PGJyPiAtLT5cbiAgICAgIDwhLS0gPGJyPjxicj4gLS0+XG5cbiAgICA8IS0tIDwvZGl2PiAtLT5cblxuXG4gICAgPCEtLSBCQU5ORVIgLS0+XG4gICAgPER5bmFtaWNCYW5uZXIgXG4gICAgICB2LWlmPVwidGhpcy5oYXNfYmFubmVyXCJcbiAgICAgIDp0ZW1wbGF0ZV91cmw9XCJ0aGlzLmdldEN1cnJlbnRCYW5uZXIudGVtcGxhdGVfdXJsXCJcbiAgICAgIDpkeW5hbWljVGVtcGxhdGU9XCJsb2NhbFJvdXRlQ29uZmlnLmR5bmFtaWNfdGVtcGxhdGVcIlxuICAgID48L0R5bmFtaWNCYW5uZXI+IFxuXG5cbiAgICA8IS0tIFJFTU9URSBTVEFUSUNTIC0tPlxuICAgIDxEeW5hbWljU3RhdGljIFxuICAgICAgdi1pZj1cImxvY2FsUm91dGVDb25maWcuZHluYW1pY190ZW1wbGF0ZSA9PSAnRHluYW1pY1N0YXRpYycgXCJcbiAgICAgIDpyb3V0ZUNvbmZpZz1cImxvY2FsUm91dGVDb25maWdcIlxuICAgID48L0R5bmFtaWNTdGF0aWM+XG5cbiAgICA8IS0tIExPQ0FMIFRFU1QgU1RBVElDIC0tPlxuICAgIDxEeW5hbWljU3RhdGljVGVzdCBcbiAgICAgIHYtaWY9XCJsb2NhbFJvdXRlQ29uZmlnLmR5bmFtaWNfdGVtcGxhdGUgPT0gJ0R5bmFtaWNTdGF0aWNUZXN0JyBcIlxuICAgID48L0R5bmFtaWNTdGF0aWNUZXN0PlxuXG5cbiAgICA8IS0tIERBVEEgVklTVUFMSVNBVElPTiAtLT5cbiAgICA8RHluYW1pY0xpc3QgXG4gICAgICB2LWlmPVwibG9jYWxSb3V0ZUNvbmZpZy5keW5hbWljX3RlbXBsYXRlID09ICdEeW5hbWljTGlzdCcgXCJcbiAgICAgIDpyb3V0ZUNvbmZpZz1cImxvY2FsUm91dGVDb25maWdcIlxuICAgICAgOmVuZFBvaW50Q29uZmlnPVwibG9jYWxFbmRwb2ludENvbmZpZ1wiXG4gICAgICA6ZmlsdGVyc0NvbmZpZz1cImxvY2FsRmlsdGVyc0NvbmZpZ1wiXG4gICAgPjwvRHluYW1pY0xpc3Q+XG5cbiAgICA8RHluYW1pY01hcCBcbiAgICAgIHYtaWY9XCJsb2NhbFJvdXRlQ29uZmlnLmR5bmFtaWNfdGVtcGxhdGUgPT0gJ0R5bmFtaWNNYXAnIFwiXG4gICAgICA6cm91dGVDb25maWc9XCJsb2NhbFJvdXRlQ29uZmlnXCJcbiAgICAgIDplbmRQb2ludENvbmZpZz1cImxvY2FsRW5kcG9pbnRDb25maWdcIlxuICAgICAgOmZpbHRlcnNDb25maWc9XCJsb2NhbEZpbHRlcnNDb25maWdcIlxuICAgID48L0R5bmFtaWNNYXA+XG5cbiAgICA8RHluYW1pY0RldGFpbCBcbiAgICAgIHYtaWY9XCJsb2NhbFJvdXRlQ29uZmlnLmR5bmFtaWNfdGVtcGxhdGUgPT0gJ0R5bmFtaWNEZXRhaWwnIFwiXG4gICAgICA6cm91dGVDb25maWc9XCJsb2NhbFJvdXRlQ29uZmlnXCJcbiAgICAgIDplbmRQb2ludENvbmZpZz1cImxvY2FsRW5kcG9pbnRDb25maWdcIlxuICAgID48L0R5bmFtaWNEZXRhaWw+XG5cblxuXG4gICAgPCEtLSBMT0dJTi9MT0dPVVQvUkVHSVNURVIgUk9VVEVTIC0tPlxuICAgIDxMb2dpblNjcmVlbiBcbiAgICAgIHYtaWY9XCJsb2NhbFJvdXRlQ29uZmlnLmR5bmFtaWNfdGVtcGxhdGUgPT0gJ0xvZ2luJyBcIlxuICAgICAgOnJvdXRlQ29uZmlnPVwibG9jYWxSb3V0ZUNvbmZpZ1wiXG4gICAgICA6ZW5kUG9pbnRDb25maWc9XCJsb2NhbEVuZHBvaW50Q29uZmlnXCJcbiAgICA+PC9Mb2dpblNjcmVlbj5cblxuICAgIDxMb2dvdXRTY3JlZW4gXG4gICAgICB2LWlmPVwibG9jYWxSb3V0ZUNvbmZpZy5keW5hbWljX3RlbXBsYXRlID09ICdMb2dvdXQnIFwiXG4gICAgICA6cm91dGVDb25maWc9XCJsb2NhbFJvdXRlQ29uZmlnXCJcbiAgICAgIDplbmRQb2ludENvbmZpZz1cImxvY2FsRW5kcG9pbnRDb25maWdcIlxuICAgID48L0xvZ291dFNjcmVlbj5cblxuICAgIDxSZWdpc3RlclNjcmVlbiBcbiAgICAgIHYtaWY9XCJsb2NhbFJvdXRlQ29uZmlnLmR5bmFtaWNfdGVtcGxhdGUgPT0gJ1JlZ2lzdGVyJyBcIlxuICAgICAgOnJvdXRlQ29uZmlnPVwibG9jYWxSb3V0ZUNvbmZpZ1wiXG4gICAgICA6ZW5kUG9pbnRDb25maWc9XCJsb2NhbEVuZHBvaW50Q29uZmlnXCJcbiAgICA+PC9SZWdpc3RlclNjcmVlbj5cblxuXG4gICAgPCEtLSBCQUNLT0ZGSUNFIFJPVVRFUyAtLT5cbiAgICA8QmFja09mZmljZVNjcmVlbiBcbiAgICAgIHYtaWY9XCJsb2NhbFJvdXRlQ29uZmlnLmR5bmFtaWNfdGVtcGxhdGUgPT0gJ0JhY2tPZmZpY2UnIFwiXG4gICAgICA6cm91dGVDb25maWc9XCJsb2NhbFJvdXRlQ29uZmlnXCJcbiAgICAgIDplbmRQb2ludENvbmZpZz1cImxvY2FsRW5kcG9pbnRDb25maWdcIlxuICAgID48L0JhY2tPZmZpY2VTY3JlZW4+XG5cblxuICAgIDwhLS0gRk9PVEVSUyAtLT5cbiAgICA8Rm9vdGVyIFxuICAgICAgdi1pZj1cInRoaXMuaGFzX2Zvb3RlclwiXG4gICAgICA6Zm9vdGVyQ29uZmlnPVwidGhpcy5mb290ZXJDb25maWdcIiBcbiAgICAgIDphcHBTb2NpYWxzPVwidGhpcy5zb2NpYWxzQ29uZmlnXCIgXG4gICAgPjwvRm9vdGVyPlxuXG4gICAgPCEtLSBQUk9KRUNUJ3MgUEFSVE5FUlMgRk9PVEVSIC0tPlxuICAgIDxEeW5hbWljU3RhdGljUmF3IFxuICAgICAgdi1pZj1cInRoaXMuaGFzX2NyZWRpdHNfZm9vdGVyXCJcbiAgICAgIDp0ZW1wbGF0ZVVSTD1cInRoaXMuZm9vdGVyQ29uZmlnLmNyZWRpdHNfZm9vdGVyX3VybFwiXG4gICAgPjwvRHluYW1pY1N0YXRpY1Jhdz5cblxuICAgIDwhLS0gQ1JFRElUUyBDT0RFTU9TIC8gUkVNT1RFIEZPT1RFUiAtLT5cbiAgICA8RHluYW1pY1N0YXRpY1JhdyBcbiAgICAgIDp0ZW1wbGF0ZVVSTD1cIidodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vY28tZGVtb3Mvc3RydWN0dXJlL21hc3Rlci9wYWdlcy1odG1sL2NvZGVtb3MtZm9vdGVyLmh0bWwnXCJcbiAgICA+PC9EeW5hbWljU3RhdGljUmF3PlxuXG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7bWFwU3RhdGV9IGZyb20gJ3Z1ZXgnXG5cbmltcG9ydCBOYXZCYXIgZnJvbSAnLi4vTmF2QmFyLnZ1ZSc7XG5pbXBvcnQgRm9vdGVyIGZyb20gJy4uL0Zvb3Rlci52dWUnO1xuXG5pbXBvcnQgRHluYW1pY0Jhbm5lciAgICAgZnJvbSAnLi4vRHluYW1pY0Jhbm5lci52dWUnO1xuaW1wb3J0IER5bmFtaWNTdGF0aWMgICAgIGZyb20gJy4uL0R5bmFtaWNTdGF0aWMudnVlJztcbmltcG9ydCBEeW5hbWljU3RhdGljUmF3ICBmcm9tICcuLi9EeW5hbWljU3RhdGljUmF3LnZ1ZSc7XG5pbXBvcnQgRHluYW1pY1N0YXRpY1Rlc3QgZnJvbSAnLi4vRHluYW1pY1N0YXRpY1Rlc3QudnVlJztcbmltcG9ydCBEeW5hbWljTGlzdCAgICAgICBmcm9tICcuLi9EeW5hbWljTGlzdC52dWUnO1xuaW1wb3J0IER5bmFtaWNNYXAgICAgICAgIGZyb20gJy4uL0R5bmFtaWNNYXAudnVlJztcbmltcG9ydCBEeW5hbWljRGV0YWlsICAgICBmcm9tICcuLi9EeW5hbWljRGV0YWlsLnZ1ZSc7XG5cbmltcG9ydCBMb2dpblNjcmVlbiAgICAgICBmcm9tICcuL0xvZ2luU2NyZWVuLnZ1ZSc7XG5pbXBvcnQgTG9nb3V0U2NyZWVuICAgICAgZnJvbSAnLi9Mb2dvdXRTY3JlZW4udnVlJztcbmltcG9ydCBSZWdpc3RlclNjcmVlbiAgICBmcm9tICcuL1JlZ2lzdGVyU2NyZWVuLnZ1ZSc7XG5cbmltcG9ydCBCYWNrT2ZmaWNlU2NyZWVuICBmcm9tICcuL0JhY2tPZmZpY2VTY3JlZW4udnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgTmF2QmFyLCBcbiAgICBGb290ZXIsIFxuICAgIER5bmFtaWNCYW5uZXIsXG4gICAgRHluYW1pY1N0YXRpYywgXG4gICAgRHluYW1pY1N0YXRpY1JhdyxcbiAgICBEeW5hbWljU3RhdGljVGVzdCxcbiAgICBEeW5hbWljTGlzdCwgXG4gICAgRHluYW1pY01hcCwgXG4gICAgRHluYW1pY0RldGFpbCxcblxuICAgIExvZ2luU2NyZWVuLFxuICAgIExvZ291dFNjcmVlbixcbiAgICBSZWdpc3RlclNjcmVlbixcblxuICAgIEJhY2tPZmZpY2VTY3JlZW5cbiAgfSxcblxuICBwcm9wczogW1xuICAvLyAgICdsb2dvJywgXG4gIC8vICAgJ2JyYW5kJ1xuICBdLFxuXG4gIGRhdGE6ICgpID0+IHtcbiAgICByZXR1cm4gICB7XG4gICAgICBsb2NhbFJvdXRlQ29uZmlnIDogdW5kZWZpbmVkLFxuICAgICAgbG9jYWxFbmRwb2ludENvbmZpZyA6IHVuZGVmaW5lZCxcbiAgICAgIGxvY2FsRmlsdGVyc0NvbmZpZyA6IHVuZGVmaW5lZCxcbiAgICAgIGN1cnJlbnREYXRhc2V0VVJJIDogdW5kZWZpbmVkXG4gICAgfVxuICB9LFxuXG4gIC8vIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAvLyAgIGNvbnNvbGUubG9nKFwiXFxuIC0gLSBEeW5hbWljU2NyZWVuIC8gYmVmb3JlQ3JlYXRlIC4uLiBcIilcbiAgLy8gfSxcbiAgLy8gY3JlYXRlZDogZnVuY3Rpb24gKCkge1xuICAvLyAgIGNvbnNvbGUubG9nKFwiXFxuIC0gLSBEeW5hbWljU2NyZWVuIC8gY3JlYXRlZCAuLi4gXCIpXG4gIC8vIH0sXG4gIFxuICBiZWZvcmVNb3VudDogZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3QgRHluYW1pY0NvbXBvbmVudHMgPSBbIFxuICAgICAgJ0R5bmFtaWNMaXN0JyAsIFxuICAgICAgJ0R5bmFtaWNEZXRhaWwnICwgXG4gICAgICAnRHluYW1pY01hcCcgLCBcbiAgICAgIC8vICdEeW5hbWljU3RhdCcsIFxuICAgICAgLy8gJ0R5bmFtaWNMaXN0RGVuc2UnIFxuICAgIF1cblxuICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuIC0gLSBEeW5hbWljU2NyZWVuIC8gYmVmb3JlTW91bnQgLi4uIFwiKVxuICAgIC8vIGNvbnNvbGUubG9nKFwiIC0gLSBzdGF0ZS5jb25maWcgOiBcXG4gXCIsIHRoaXMuJHN0b3JlLnN0YXRlLmNvbmZpZylcbiAgICAvLyBjb25zb2xlLmxvZyhcIiAtIC0gRHluYW1pY1NjcmVlbiAvIHRoaXMucm91dGVDb25maWcgOiBcXG4gXCIsIHRoaXMucm91dGVDb25maWcpXG4gICAgXG4gICAgLy8gc2V0IGxvY2FsIHJvdXRlIGFuZCBlbmRwb2ludCBjb25maWdcbiAgICB0aGlzLmxvY2FsUm91dGVDb25maWcgPSB0aGlzLnJvdXRlQ29uZmlnXG5cbiAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSB0aGlzLmxvY2FsUm91dGVDb25maWcuZHluYW1pY190ZW1wbGF0ZSBcbiAgICAvLyBjb25zb2xlLmxvZyhcIiAtIC0gRHluYW1pY1NjcmVlbiAvIGN1cnJlbnRUZW1wbGF0ZSA6IFwiLCBjdXJyZW50VGVtcGxhdGUpXG4gICAgLy8gY29uc29sZS5sb2coXCIgLSAtIER5bmFtaWNTY3JlZW4gLyBsb2NhbFJvdXRlQ29uZmlnLmR5bmFtaWNfdGVtcGxhdGVzICA6IFwiLCB0aGlzLmxvY2FsUm91dGVDb25maWcuZHluYW1pY190ZW1wbGF0ZXMgKVxuXG4gICAgLy8gaWYoIHRoaXMucm91dGVDb25maWcuZHluYW1pY190ZW1wbGF0ZSAhPT0gJ0R5bmFtaWNTdGF0aWMnICkge1xuICAgIGlmKCBEeW5hbWljQ29tcG9uZW50cy5pbmRleE9mKHRoaXMucm91dGVDb25maWcuZHluYW1pY190ZW1wbGF0ZSkgIT09IC0xICkge1xuXG4gICAgICAvLyBzZXR0aW5nIGxvY2FsRW5kcG9pbnRDb25maWdcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiIC0gLSBEeW5hbWljU2NyZWVuIC8gcm91dGUgSVMgZm9yIGEgZHluYW1pYyBjb250ZW50IC4uLiBcIilcbiAgICAgIGxldCBwYXRoID0gdGhpcy4kcm91dGVyLmN1cnJlbnRSb3V0ZS5wYXRoXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIiAtIC0gRHluYW1pY1NjcmVlbiAvIHBhdGggOiBcIiwgcGF0aCApXG4gICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnc2V0U2VhcmNoRW5kcG9pbnRDb25maWcnLCB7IHBhdGggOiBwYXRoIH0pXG4gICAgICAvLyB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnc2V0U2VhcmNoRW5kcG9pbnQnKVxuICAgICAgdGhpcy5sb2NhbEVuZHBvaW50Q29uZmlnID0gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRFbmRwb2ludENvbmZpZ1xuICAgICAgLy8gY29uc29sZS5sb2coXCIgLSAtIER5bmFtaWNTY3JlZW4gLyBsb2NhbEVuZHBvaW50Q29uZmlnIDogXCIsIHRoaXMubG9jYWxFbmRwb2ludENvbmZpZyApXG5cbiAgICAgIC8vIHNldHRpbmcgbG9jYWxEYXRhc2V0VVJJXG4gICAgICAvLyB0aGlzLmN1cnJlbnREYXRhc2V0VVJJID0gdGhpcy4kc3RvcmUuc3RhdGUuc2VhcmNoLmRhdGFzZXRfdXJpXG4gICAgICB0aGlzLmN1cnJlbnREYXRhc2V0VVJJID0gdGhpcy5sb2NhbEVuZHBvaW50Q29uZmlnLmRhdGFzZXRfdXJpXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIiAtIC0gRHluYW1pY1NjcmVlbiAvIGN1cnJlbnREYXRhc2V0VVJJIDogXCIsIHRoaXMuY3VycmVudERhdGFzZXRVUkkpXG4gICAgICBcbiAgICAgIC8vIHNldHRpbmcgZmlsdGVyc1xuICAgICAgLy8gY29uc29sZS5sb2coXCJcXG4gLSAtIER5bmFtaWNTY3JlZW4gLyBzZXR0aW5nIGZpbHRlcnMgLi4uIFwiKVxuICAgICAgdGhpcy5sb2NhbEZpbHRlcnNDb25maWcgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldEVuZHBvaW50Q29uZmlnRmlsdGVyc1xuICAgICAgLy8gY29uc29sZS5sb2coXCIgLSAtIER5bmFtaWNTY3JlZW4gLyB0aGlzLmxvY2FsRmlsdGVyc0NvbmZpZyA6IFwiLCB0aGlzLmxvY2FsRmlsdGVyc0NvbmZpZylcbiAgICAgIC8vIHRoaXMuJHN0b3JlLmNvbW1pdCgnc2V0RGF0YXNldEZpbHRlcnMnLCB0aGlzLmxvY2FsRmlsdGVyc0NvbmZpZyApXG4gICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnY3JlYXRlRGF0YXNldEZpbHRlcnMnKVxuICAgICAgXG4gICAgICAvLyBzZXR0aW5nIE1hcFNlYXJjaFxuICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KCdzZXRJc01hcFNlYXJjaCcsIHRoaXMucm91dGVDb25maWcpXG5cbiAgICB9XG5cbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJcXG4gLSAtIER5bmFtaWNTY3JlZW4gLyBtb3VudGVkIC4uLiBcIilcbiAgICAvLyBoZXJlIHdlIGNoZWNrIHdoYXQga2luZCBvZiBkeW5hbWljIHJvdXRlIHdlIGhhdmUgdG8gcHJvdmlkZVxuICAgIGlmKCF0aGlzLnJvdXRlQ29uZmlnKSB7XG4gICAgICB0aGlzLiRyb3V0ZXIucHVzaCh7bmFtZTonZXJyb3InfSlcbiAgICB9XG4gIH0sXG5cblxuICB3YXRjaDoge1xuICAgIFxuICAgIC8vIHdhdGNoIHRoZSByb3V0ZSBwYXRoXG4gICAgJyRyb3V0ZS5mdWxsUGF0aCc6IGZ1bmN0aW9uIChuZXdQYXRoLCBvbGRQYXRoKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnXFxuLSAtIER5bmFtaWNTY3JlZW4gLyB3YXRjaCAvICRyb3V0ZS5mdWxsUGF0aCA6ICcsIHRoaXMuJHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCctIC0gRHluYW1pY1NjcmVlbiAvIG5ld1BhdGggOiAnLCBuZXdQYXRoKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCctIC0gRHluYW1pY1NjcmVlbiAvIG9sZFBhdGggOiAnLCBvbGRQYXRoKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCctIC0gRHluYW1pY1NjcmVlbiAvIHdhdGNoIC8gJHJvdXRlIDogJywgdGhpcy4kcm91dGUpO1xuICAgICAgLy8gY29uc29sZS5sb2coJy0gLSBEeW5hbWljU2NyZWVuIC8gd2F0Y2ggLyAoYmVmb3JlKSBzdGF0ZSA6ICcsIHRoaXMuJHN0b3JlLnN0YXRlKTtcblxuICAgICAgLy8gZmluZCBuZXcgcm91dGUgY29uZmlnIGNvcnJlc3BvbmRpbmcgdG8gcmVxdWVzdGVkIHBhdGhcbiAgICAgIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdzZXRTZWFyY2hFbmRwb2ludENvbmZpZycsIHsgcGF0aCA6IHRoaXMuJHJvdXRlLnBhdGh9KVxuICAgICAgLy8gdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ3NldFNlYXJjaEVuZHBvaW50JylcbiAgICAgIC8vIGNvbnNvbGUubG9nKCctIC0gRHluYW1pY1NjcmVlbiAvIHdhdGNoIC8gKGFmdGVyKSBzdGF0ZSA6ICcsIHRoaXMuJHN0b3JlLnN0YXRlKTtcblxuICAgICAgLy8gdGhpcy5sb2NhbFJvdXRlQ29uZmlnID0gdGhpcy4kc3RvcmUuc3RhdGUuc2VhcmNoLmN1cnJlbnRSb3V0ZUNvbmZpZ1xuICAgICAgdGhpcy5sb2NhbFJvdXRlQ29uZmlnID0gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRDdXJyZW50Um91dGVDb25maWcoIHRoaXMuJHJvdXRlLnBhdGggKVxuICAgICAgLy8gY29uc29sZS5sb2coJy0gLSBEeW5hbWljU2NyZWVuIC8gd2F0Y2ggLyBsb2NhbFJvdXRlQ29uZmlnIDogJywgdGhpcy5sb2NhbFJvdXRlQ29uZmlnKTtcblxuICAgICAgLy8gbGV0IHByZXZpb3VzRGF0YXNldFVSSSA9IHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0U2VhcmNoRGF0YXNldFVSSVxuICAgICAgLy8gY29uc29sZS5sb2coJy0gLSBEeW5hbWljU2NyZWVuIC8gd2F0Y2ggLyBwcmV2aW91c0RhdGFzZXRVUkkgOiAnLCBwcmV2aW91c0RhdGFzZXRVUkkpO1xuICAgICAgLy8gbGV0IGN1cnJlbnREYXRhc2V0VVJJID0gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRTZWFyY2hEYXRhc2V0VVJJXG4gICAgICBsZXQgY3VycmVudERhdGFzZXRVUkkgPSB0aGlzLmxvY2FsUm91dGVDb25maWcuZGF0YXNldF91cmlcbiAgICAgIC8vIGNvbnNvbGUubG9nKCctIC0gRHluYW1pY1NjcmVlbiAvIHdhdGNoIC8gdGhpcy5jdXJyZW50RGF0YXNldFVSSSA6ICcsIHRoaXMuY3VycmVudERhdGFzZXRVUkkpO1xuICAgICAgLy8gY29uc29sZS5sb2coJy0gLSBEeW5hbWljU2NyZWVuIC8gd2F0Y2ggLyBjdXJyZW50RGF0YXNldFVSSSA6ICcsIGN1cnJlbnREYXRhc2V0VVJJKTtcbiAgICAgIC8vIGNvbW1pdCgnc2V0RGF0YXNldFVSSScsIGN1cnJlbnREYXRhc2V0VVJJKVxuXG4gICAgICAvLyBjaGVjayBzZWFyY2ggZm9yIE1hcFxuICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KCdzZXRJc01hcFNlYXJjaCcsIHRoaXMubG9jYWxSb3V0ZUNvbmZpZylcblxuICAgICAgaWYoIHRoaXMubG9jYWxSb3V0ZUNvbmZpZy5keW5hbWljX3RlbXBsYXRlcyAhPT0gJ0R5bmFtaWNTdGF0aWMnICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLSAtIER5bmFtaWNTY3JlZW4gLyB3YXRjaCAvIGxvY2FsUm91dGVDb25maWcgOiAnLCB0aGlzLmxvY2FsUm91dGVDb25maWcpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5sb2NhbEVuZHBvaW50Q29uZmlnID0gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRFbmRwb2ludENvbmZpZ1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLSAtIER5bmFtaWNTY3JlZW4gLyB3YXRjaCAvIGxvY2FsRW5kcG9pbnRDb25maWcgOiAnLCB0aGlzLmxvY2FsRW5kcG9pbnRDb25maWcpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCBjdXJyZW50RGF0YXNldFVSSSAhPT0gdGhpcy5jdXJyZW50RGF0YXNldFVSSSApIHtcbiAgICAgICAgLy8gaWYgKCB0aGlzLmxvY2FsRW5kcG9pbnRDb25maWcgJiYgY3VycmVudERhdGFzZXRVUkkgIT09IHRoaXMuY3VycmVudERhdGFzZXRVUkkgKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJy0gLSBEeW5hbWljU2NyZWVuIC8gd2F0Y2ggLyBuZWVkIHRvIHJlaW5pdCBmaWx0ZXJzIC4uLiAnKVxuICAgICAgICAgIHRoaXMuY3VycmVudERhdGFzZXRVUkkgPSBjdXJyZW50RGF0YXNldFVSSVxuICAgICAgICAgIHRoaXMubG9jYWxGaWx0ZXJzQ29uZmlnID0gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRFbmRwb2ludENvbmZpZ0ZpbHRlcnNcbiAgICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnY3JlYXRlRGF0YXNldEZpbHRlcnMnKVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvY2FsRW5kcG9pbnRDb25maWcpIHtcbiAgICAgICAgICAvLyByZWxvYWQgcmVzdWx0cyBcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLSAtIER5bmFtaWNTY3JlZW4gLyB3YXRjaCAvIChhZnRlcikgZGlzcGF0Y2ggc2VhcmNoLi4uICcpO1xuICAgICAgICAgIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdzZWFyY2gnKVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9jYWxFbmRwb2ludENvbmZpZyA9IHVuZGVmaW5lZFxuICAgICAgICB0aGlzLmxvY2FsRmlsdGVyc0NvbmZpZyA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgfSxcblxuXG4gIH0sXG5cblxuXG4gIGNvbXB1dGVkOiB7XG4gICAgXG4gICAgLi4ubWFwU3RhdGUoe1xuICAgICAgICB1c2VyOiAndXNlcidcbiAgICB9KSxcbiAgICBcbiAgICAvLyBHTE9CQUwgQ09ORklHIEVMRU1FTlRTXG4gICAgZ2xvYmFsQ29uZmlnKCl7XG4gICAgICBsZXQgZ2xvYmFsQ29uZmlnID0gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRHbG9iYWxDb25maWdcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiIC0gLSBnbG9iYWxDb25maWcgOiBcIiwgZ2xvYmFsQ29uZmlnKVxuICAgICAgcmV0dXJuIGdsb2JhbENvbmZpZ1xuICAgIH0sXG4gICAgc3R5bGVzQ29uZmlnKCl7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRTdHlsZXNDb25maWdcbiAgICB9LFxuICAgIHNvY2lhbHNDb25maWcoKXtcbiAgICAgIGxldCBzb2NpYWxzQ29uZiA9IHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0U29jaWFsc0NvbmZpZ1xuICAgICAgLy8gY29uc29sZS5sb2coXCIgLSAtIHNvY2lhbHNDb25mIDogXCIsIHNvY2lhbHNDb25mKVxuICAgICAgcmV0dXJuIHNvY2lhbHNDb25mXG4gICAgfSxcbiAgICBuYXZiYXJDb25maWcoKXtcbiAgICAgIGxldCBuYXZiYXJDb25mID0gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXROYXZiYXJDb25maWdcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiIC0gLSBuYXZiYXJDb25mIDogXCIsIG5hdmJhckNvbmYpXG4gICAgICByZXR1cm4gbmF2YmFyQ29uZlxuICAgIH0sXG4gICAgZm9vdGVyQ29uZmlnKCl7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRGb290ZXJDb25maWdcbiAgICB9LFxuXG4gICAgLy8gUk9VVEUgQU5EIEVORFBPSU5UIENPTkZJRyBFTEVNRU5UU1xuICAgIGR5bmFtaWNfdGVtcGxhdGUoKXtcbiAgICAgIHJldHVybiAodGhpcy5yb3V0ZUNvbmZpZykgPyB0aGlzLnJvdXRlQ29uZmlnLmR5bmFtaWNfdGVtcGxhdGUgOiB1bmRlZmluZWQgXG4gICAgfSxcbiAgICByb3V0ZUNvbmZpZygpe1xuICAgICAgLy8gY29uc29sZS5sb2coXCIgLSAtIER5bmFtaWNTY3JlZW4gLyB0aGlzLiRyb3V0ZXIuY3VycmVudFJvdXRlLnBhdGggOiBcIiwgdGhpcy4kcm91dGVyLmN1cnJlbnRSb3V0ZS5wYXRoKVxuICAgICAgbGV0IHJvdXRlQ29uZiA9IHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0Q3VycmVudFJvdXRlQ29uZmlnKHRoaXMuJHJvdXRlci5jdXJyZW50Um91dGUucGF0aClcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiIC0gLSBEeW5hbWljU2NyZWVuIC8gcm91dGVDb25mIDogXCIsIHJvdXRlQ29uZilcbiAgICAgIHJldHVybiByb3V0ZUNvbmZcbiAgICB9LFxuICAgIC8vIGVuZFBvaW50Q29uZmlnKCl7ICAgICBcbiAgICAvLyAgIGxldCBlbmRQb2ludENvbmZpZyA9ICB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldEVuZHBvaW50Q29uZmlnXG4gICAgLy8gICAvLyBjb25zb2xlLmxvZyhcIiAtIC0gZW5kUG9pbnRDb25maWcgOiBcIiwgZW5kUG9pbnRDb25maWcpXG4gICAgLy8gICByZXR1cm4gZW5kUG9pbnRDb25maWdcbiAgICAvLyB9LFxuXG4gICAgLy8gU1dJVENIRVJTXG4gICAgaGFzX25hdmJhcigpeyAgICAgIFxuICAgICAgcmV0dXJuICh0aGlzLnJvdXRlQ29uZmlnKSA/IHRoaXMucm91dGVDb25maWcuaGFzX25hdmJhciA6IHVuZGVmaW5lZCBcbiAgICB9LFxuICAgIGhhc19mb290ZXIoKXsgICAgICBcbiAgICAgIHJldHVybiAodGhpcy5yb3V0ZUNvbmZpZykgPyB0aGlzLnJvdXRlQ29uZmlnLmhhc19mb290ZXIgOiB1bmRlZmluZWQgXG4gICAgfSxcbiAgICBoYXNfY3JlZGl0c19mb290ZXIoKXsgICAgICBcbiAgICAgIHJldHVybiAodGhpcy5mb290ZXJDb25maWcpID8gdGhpcy5mb290ZXJDb25maWcuaGFzX2NyZWRpdHNfZm9vdGVyIDogdW5kZWZpbmVkIFxuICAgIH0sXG4gICAgaGFzX2Jhbm5lcigpeyAgICAgIFxuICAgICAgcmV0dXJuICh0aGlzLmxvY2FsUm91dGVDb25maWcpID8gdGhpcy5sb2NhbFJvdXRlQ29uZmlnLmJhbm5lci5hY3RpdmF0ZWQgOiBmYWxzZSBcbiAgICB9LFxuXG4gICAgLy8gQkFOTkVSXG4gICAgZ2V0Q3VycmVudEJhbm5lciAoKSB7XG4gICAgICBsZXQgYmFubmVyc1NldCA9IHRoaXMuc3R5bGVzQ29uZmlnLmFwcF9iYW5uZXJzLmJhbm5lcnNfc2V0XG4gICAgICBjb25zdCByb3V0ZUJhbm5lclVyaSA9IHRoaXMubG9jYWxSb3V0ZUNvbmZpZy5iYW5uZXIuYmFubmVyX3VyaVxuICAgICAgbGV0IHJlc3VsdFNldCA9IGJhbm5lcnNTZXQuZmluZChmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBiLmJhbm5lcl91cmkgPT0gcm91dGVCYW5uZXJVcmlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmVzdWx0U2V0XG4gICAgfSxcblxuICB9LFxuXG5cblxuICBtZXRob2RzOiB7XG4gICAgZ29CYWNrKGUpe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB0aGlzLiRyb3V0ZXIuYmFjaygpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCAnLi4vLi4vLi4vc3R5bGVzL2FwaXZpei1jb2xvcnMuc2Nzcyc7XG5AaW1wb3J0ICcuLi8uLi8uLi9zdHlsZXMvYXBpdml6LW1pc2Muc2Nzcyc7XG5cbi5leHRyYS1mb290ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yIDogJGFwaXZpei1wcmltYXJ5IDtcbiAgY29sb3IgOiAjZmZmZmZmO1xuICBwYWRkaW5nLXRvcCA6IDEwcHggO1xuICBwYWRkaW5nLWJvdHRvbSA6IDEwcHg7XG5cbiAgYSB7XG4gICAgY29sb3IgOiB3aGl0ZTtcbiAgfVxufVxuXG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICA8IS0tIDxkaXY+IC0tPlxuICAgICAgPCEtLSA8TmF2QmFyIDpsb2dvPVwibG9nb1wiIDpicmFuZD1cImJyYW5kXCIvPiAtLT5cblxuICA8c2VjdGlvbiBjbGFzcz1cImhlcm8gaGFzLWJhY2tncm91bmQtd2hpdGUtdGVyIGlzLWZ1bGxoZWlnaHQgc2tpcC1uYXZiYXJcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJoZXJvLWJvZHlcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXIgaGFzLXRleHQtY2VudGVyZWRcIj5cbiAgICAgICBcbiAgICAgICAgPCEtLSBERUJVR0dJTkcgLS0+XG4gICAgICAgIDwhLS0gdXNlciA6IDxjb2RlPnt7IHVzZXIgfX08L2NvZGU+PGJyPiAtLT5cbiAgICAgICAgPCEtLSBqd3QgOiA8Y29kZT57eyBqd3QgfX08L2NvZGU+PC9icj4gLS0+XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbnMgaXMtbW9iaWxlIGlzLWNlbnRlcmVkXCI+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLTZcIiBcbiAgICAgICAgICAgIHYtaWY9XCIhdXNlci5pc0xvZ2dlZGluXCJcbiAgICAgICAgICAgID5cblxuICAgICAgICAgICAgPHAgY2xhc3M9XCJzdWJ0aXRsZSBoYXMtdGV4dC1ncmV5XCI+XG4gICAgICAgICAgICAgIHt7IGdldFRleHQoJ2lzX2FjY291bnQnKSB9fVxuICAgICAgICAgICAgPC9wPlxuXG4gICAgICAgICAgICA8IS0tIG1haW4gbG9naW4gZm9ybSAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJib3hcIj5cbiAgICAgICAgICAgICAgPEZvcm1Mb2dpbi8+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbnMgaXMtbW9iaWxlIGlzLWNlbnRlcmVkXCI+XG5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy02XCIgPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwiaGFzLXRleHQtZ3JleVwiPlxuICAgICAgICAgICAgICAgICAgPHJvdXRlci1saW5rIDp0bz1cIicvcmVnaXN0ZXInXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7IGdldFRleHQoJ2NyZWF0ZV9hY2NvdW50JykgfX1cbiAgICAgICAgICAgICAgICAgIDwvcm91dGVyLWxpbms+XG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLTZcIiA+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJoYXMtdGV4dC1ncmV5XCI+XG4gICAgICAgICAgICAgICAgICA8cm91dGVyLWxpbmsgZGlzYWJsZWQgOnRvPVwiJy9mb3Jnb3QtcGFzc3dvcmQnXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7IGdldFRleHQoJ2ZvcmdvdF9wYXNzd29yZCcpIH19XG4gICAgICAgICAgICAgICAgICA8L3JvdXRlci1saW5rPlxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8YnI+XG4gICAgICAgICAgICA8YnI+XG5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtNlwiIFxuICAgICAgICAgICAgdi1pZj1cInVzZXIuaXNMb2dnZWRpblwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8cCBjbGFzcz1cInN1YnRpdGxlIGhhcy10ZXh0LWdyZXlcIj5cbiAgICAgICAgICAgICAgPCEtLSBCb25qb3VyICAtLT5cbiAgICAgICAgICAgICAge3sgZ2V0VGV4dCgnaGVsbG8nKSB9fVxuICAgICAgICAgICAgICB7eyB1c2VyLmluZm9zLm5hbWUgfX1cbiAgICAgICAgICAgIDwvcD5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJveFwiPlxuICAgICAgICAgICAgICA8Rm9ybUxvZ2luLz5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICA8L3NlY3Rpb24+XG5cbiAgICAgIDwhLS0gPEZvb3Rlci8+IC0tPlxuICA8IS0tIDwvZGl2PiAtLT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gJ3Z1ZXgnXG5cbi8vIGltcG9ydCBOYXZCYXIgZnJvbSAnLi4vTmF2QmFyLnZ1ZSc7XG4vLyBpbXBvcnQgRm9vdGVyIGZyb20gJy4uL0Zvb3Rlci52dWUnO1xuaW1wb3J0IEZvcm1Mb2dpbiBmcm9tICcuLi9Gb3JtTG9naW4udnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgLy8gTmF2QmFyLCBcbiAgICAvLyBGb290ZXIsIFxuICAgIEZvcm1Mb2dpblxuICB9LFxuICBwcm9wczogW1xuICAgICdsb2dvJywgXG4gICAgJ2JyYW5kJ1xuICBdLFxuXG4gIGNvbXB1dGVkOiBtYXBTdGF0ZSh7XG4gICAgdXNlciA6ICd1c2VyJyxcbiAgICBqd3QgOiAnand0J1xuICB9KSxcblxuICBtb3VudGVkKCl7XG4gICAgLy8gaGFjayB0byBzY3JvbGwgdG9wIGJlY2F1c2UgdnVlLXJvdXRlciBzY3JvbGxCZWhhdmlvciB0aGluZyBkb2Vzbid0IHNlZW0gdG8gd29yayBvbiBGaXJlZm94IG9uIExpbnV4IGF0IGxlYXN0XG4gICAgY29uc3QgaW50ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYod2luZG93LnBhZ2VZT2Zmc2V0IDwgNTApe1xuICAgICAgICBjbGVhckludGVydmFsKGludClcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuXG4gICAgZ2V0VGV4dCh0ZXh0Q29kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZGVmYXVsdFRleHQoe3R4dDp0ZXh0Q29kZX0pXG4gICAgfSxcblxuICAgIGdvQmFjayhlKXtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgdGhpcy4kcm91dGVyLmJhY2soKVxuICAgIH1cbiAgfVxuXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPCEtLSA8ZGl2PiAtLT5cbiAgICAgIDwhLS0gPE5hdkJhciA6bG9nbz1cImxvZ29cIiA6YnJhbmQ9XCJicmFuZFwiLz4gLS0+XG5cbiAgPHNlY3Rpb24gY2xhc3M9XCJoZXJvIGhhcy1iYWNrZ3JvdW5kLXdoaXRlLXRlciBpcy1mdWxsaGVpZ2h0IHNraXAtbmF2YmFyXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaGVyby1ib2R5XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIGhhcy10ZXh0LWNlbnRlcmVkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zIGlzLW1vYmlsZSBpcy1jZW50ZXJlZFwiPlxuXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy02XCIgXG4gICAgICAgICAgICB2LWlmPVwiIXVzZXIuaXNMb2dnZWRpblwiPlxuICAgICAgICAgICAgPGgzIGNsYXNzPVwidGl0bGUgaGFzLXRleHQtZ3JleVwiPlxuICAgICAgICAgICAgICA8IS0tIFZvdXMgYXZleiDDqXTDqSBkw6ljb25uZWN0w6kgLS0+XG4gICAgICAgICAgICAgIHt7IGdldFRleHQoJ2Rpc2Nvbm5lY3RfbXNnJykgfX1cbiAgICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYm94XCI+XG4gICAgICAgICAgICAgIDxyb3V0ZXItbGluayBcbiAgICAgICAgICAgICAgICBjbGFzcz1cImJ1dHRvbiBpcy1ibG9jayBpcy1wcmltYXJ5IGlzLWZ1bGx3aWR0aFwiIFxuICAgICAgICAgICAgICAgIHR5cGU9XCJzdWJtaXRcIiBcbiAgICAgICAgICAgICAgICA6dG89XCInL2xvZ2luJ1wiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwhLS0gU2UgcmUtY29ubmVjdGVyIC0tPlxuICAgICAgICAgICAgICAgIHt7IGdldFRleHQoJ3JlY29ubmVjdCcpIH19XG4gICAgICAgICAgICAgIDwvcm91dGVyLWxpbms+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtNlwiIFxuICAgICAgICAgICAgdi1pZj1cInVzZXIuaXNMb2dnZWRpblwiPlxuICAgICAgICAgICAgPGgzIGNsYXNzPVwidGl0bGUgaGFzLXRleHQtZ3JleVwiPlxuICAgICAgICAgICAgICA8IS0tIFZvdXMgdm91bGV6IHZvdXMgZMOpY29ubmVjdGVyPyAtLT5cbiAgICAgICAgICAgICAge3sgZ2V0VGV4dCgnd2FudF9kaXNjb25uZWN0JykgfX1cbiAgICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYm94XCI+XG4gICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJidXR0b24gaXMtYmxvY2sgaXMtcHJpbWFyeSBpcy1mdWxsd2lkdGhcIiBcbiAgICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCIgXG4gICAgICAgICAgICAgICAgQGNsaWNrPVwic2VuZExvZ291dFwiPlxuICAgICAgICAgICAgICAgIHt7IGdldFRleHQoJ2Rpc2Nvbm5lY3QnKSB9fVxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuXG5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICA8L3NlY3Rpb24+XG5cbiAgICAgIDwhLS0gPEZvb3Rlci8+IC0tPlxuICA8IS0tIDwvZGl2PiAtLT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gJ3Z1ZXgnXG5cbi8vIGltcG9ydCBOYXZCYXIgZnJvbSAnLi4vTmF2QmFyLnZ1ZSc7XG4vLyBpbXBvcnQgRm9vdGVyIGZyb20gJy4uL0Zvb3Rlci52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICAvLyBOYXZCYXIsIFxuICAgIC8vIEZvb3RlclxuICB9LFxuICBwcm9wczogW1xuICAgICdsb2dvJywgXG4gICAgJ2JyYW5kJ1xuICBdLFxuXG4gIGNvbXB1dGVkOiBtYXBTdGF0ZSh7XG4gICAgdXNlcjogJ3VzZXInXG4gIH0pLFxuXG4gIG1vdW50ZWQoKXtcbiAgICAvLyBoYWNrIHRvIHNjcm9sbCB0b3AgYmVjYXVzZSB2dWUtcm91dGVyIHNjcm9sbEJlaGF2aW9yIHRoaW5nIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIG9uIEZpcmVmb3ggb24gTGludXggYXQgbGVhc3RcbiAgICBjb25zdCBpbnQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZih3aW5kb3cucGFnZVlPZmZzZXQgPCA1MCl7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApXG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG5cbiAgICBnZXRUZXh0KHRleHRDb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kZWZhdWx0VGV4dCh7dHh0OnRleHRDb2RlfSlcbiAgICB9LFxuXG4gICAgZ29CYWNrKGUpe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB0aGlzLiRyb3V0ZXIuYmFjaygpXG4gICAgfSxcbiAgICBzZW5kTG9nb3V0KGUpe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB0aGlzLnVzZXJFbWFpbCA9ICcnXG4gICAgICB0aGlzLnVzZXJQYXNzd29yZCA9ICcnXG4gICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnbG9nb3V0JylcbiAgICB9XG4gIH1cblxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdj5cbiAgICAgICAgPE5hdkJhciA6bG9nbz1cImxvZ29cIiA6YnJhbmQ9XCJicmFuZFwiLz5cbiAgICAgICAgPE5vdEZvdW5kRXJyb3IvPlxuICAgICAgICA8Rm9vdGVyLz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTmF2QmFyIGZyb20gJy4uL05hdkJhci52dWUnO1xuaW1wb3J0IE5vdEZvdW5kRXJyb3IgZnJvbSAnLi4vTm90Rm91bmRFcnJvci52dWUnO1xuaW1wb3J0IEZvb3RlciBmcm9tICcuLi9Gb290ZXIudnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdOb3RGb3VuZFNjcmVlbicsXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBOYXZCYXIsIE5vdEZvdW5kRXJyb3IsIEZvb3RlclxuICAgIH0sXG4gICAgcHJvcHM6IFtcbiAgICAgICAgJ2xvZ28nLCAnYnJhbmQnXG4gICAgXVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbi5saXN0IC5maWx0ZXItZmVlZGJhY2t7XG4gICAgcGFkZGluZy1ib3R0b206IDA7XG59XG48L3N0eWxlPiIsIjx0ZW1wbGF0ZT5cbiAgICA8IS0tIDxkaXY+IC0tPlxuICAgICAgICA8IS0tIDxOYXZCYXIgOmxvZ289XCJsb2dvXCIgOmJyYW5kPVwiYnJhbmRcIi8+IC0tPlxuXG4gIDxzZWN0aW9uIGNsYXNzPVwiaGVybyBoYXMtYmFja2dyb3VuZC13aGl0ZS10ZXIgaXMtZnVsbGhlaWdodCBza2lwLW5hdmJhclwiPlxuXG4gICAgPGRpdiBjbGFzcz1cImhlcm8tYm9keVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciBoYXMtdGV4dC1jZW50ZXJlZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1ucyBpcy1tb2JpbGUgaXMtY2VudGVyZWRcIj5cblxuXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy02XCIgdi1pZj1cIiF1c2VyLmlzTG9nZ2VkaW5cIj5cblxuICAgICAgICAgICAgPHAgY2xhc3M9XCJzdWJ0aXRsZSBoYXMtdGV4dC1ncmV5XCI+XG4gICAgICAgICAgICAgIDwhLS0gVm91cyBuJ2F2ZXogcGFzIGVuY29yZSBkZSBjb21wdGUgPyAtLT5cbiAgICAgICAgICAgICAge3sgZ2V0VGV4dCgnbm9fYWNjb3VudCcpIH19XG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8IS0tIDxoMyBjbGFzcz1cInRpdGxlIGhhcy10ZXh0LWdyZXlcIj5TJ2VucmVnaXN0cmVyPC9oMz4gLS0+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJib3hcIj5cbiAgICAgICAgICAgICAgPEZvcm1SZWdpc3Rlci8+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPHAgY2xhc3M9XCJoYXMtdGV4dC1ncmV5XCI+ICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgPHJvdXRlci1saW5rIDp0bz1cIicvbG9naW4nXCI+XG4gICAgICAgICAgICAgICAgPCEtLSBjcsOpZXIgdW4gY29tcHRlIC0tPlxuICAgICAgICAgICAgICAgIHt7IGdldFRleHQoJ2Nvbm5lY3QnKSB9fVxuICAgICAgICAgICAgICA8L3JvdXRlci1saW5rPlxuICAgICAgICAgICAgPC9wPlxuXG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLTZcIiB2LWlmPVwidXNlci5pc0xvZ2dlZGluXCI+XG4gICAgICAgICAgICA8cCBjbGFzcz1cInN1YnRpdGxlIGhhcy10ZXh0LWdyZXlcIj5cbiAgICAgICAgICAgICAgPCEtLSBCb25qb3VyICAtLT5cbiAgICAgICAgICAgICAge3sgZ2V0VGV4dCgnaGVsbG8nKSB9fVxuICAgICAgICAgICAgICB7e3VzZXIuaW5mb3MuZW1haWx9fSwgXG4gICAgICAgICAgICAgIDwhLS0gdm91cyDDqnRlcyBkw6lqw6AgZW5yZWdpc3Ryw6kuZSAtLT5cbiAgICAgICAgICAgICAge3sgZ2V0VGV4dCgnaXNfcmVnaXN0ZXJlZCcpIH19XG4gICAgICAgICAgICA8L3A+XG5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L3NlY3Rpb24+XG5cbiAgICAgICAgPCEtLSA8Rm9vdGVyLz5cbiAgICA8L2Rpdj4gLS0+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHttYXBTdGF0ZX0gZnJvbSAndnVleCdcblxuLy8gaW1wb3J0IE5hdkJhciBmcm9tICcuLi9OYXZCYXIudnVlJztcbi8vIGltcG9ydCBGb290ZXIgZnJvbSAnLi4vRm9vdGVyLnZ1ZSc7XG5pbXBvcnQgRm9ybVJlZ2lzdGVyIGZyb20gJy4uL0Zvcm1SZWdpc3Rlci52dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICAvLyBOYXZCYXIsIFxuICAgIC8vIEZvb3RlciwgXG4gICAgRm9ybVJlZ2lzdGVyXG4gIH0sXG4gIHByb3BzOiBbXG4gICAgLy8gJ2xvZ28nLCBcbiAgICAvLyAnYnJhbmQnXG4gIF0sXG5cbiAgY29tcHV0ZWQ6IG1hcFN0YXRlKHtcbiAgICB1c2VyOiAndXNlcidcbiAgfSksXG5cbiAgbW91bnRlZCgpe1xuICAgIC8vIGhhY2sgdG8gc2Nyb2xsIHRvcCBiZWNhdXNlIHZ1ZS1yb3V0ZXIgc2Nyb2xsQmVoYXZpb3IgdGhpbmcgZG9lc24ndCBzZWVtIHRvIHdvcmsgb24gRmlyZWZveCBvbiBMaW51eCBhdCBsZWFzdFxuICAgIGNvbnN0IGludCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmKHdpbmRvdy5wYWdlWU9mZnNldCA8IDUwKXtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnQpXG4gICAgICB9XG4gICAgICBlbHNle1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcblxuICAgIGdldFRleHQodGV4dENvZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmRlZmF1bHRUZXh0KHt0eHQ6dGV4dENvZGV9KVxuICAgIH0sXG5cbiAgICBnb0JhY2soZSl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0aGlzLiRyb3V0ZXIuYmFjaygpXG4gICAgfVxuICB9XG5cbn1cbjwvc2NyaXB0PlxuIiwiZXhwb3J0IGNvbnN0IGFwaXZpekZyb250VVVJRCA9IE9iamVjdC5mcmVlemUoe1xuICBhcGl2aXpfZnJvbnRfdXVpZCA6IFwiYzVlZmFmYWItMTczMy00YWQxLTllYjgtZDUyOWJjODdjNDgxXCIgLy8gY29uZmlnIFNPTlVNXG4gIC8vIGFwaXZpel9mcm9udF91dWlkIDogXCJmMGE0ODJkYS0yOGJlLTQ5MjktYTQ0My1mMjJlY2IwM2VlNjhcIiAvLyBjb25maWcgQVBDSVNcbn0pXG5cbmV4cG9ydCBjb25zdCBhcGlDb25maWcgPSBPYmplY3QuZnJlZXplKHtcblxuICAvLyBBUElWSVogYmFja2VuZCBVUkxcbiAgLy8gU1dJVENIRVMgRk9SIERZTkFNSUMgU0VUVElOR1xuICBcbiAgZGVmYXVsdCA6IHtcbiAgICByb290VVJMOiAnaHR0cDovL2xvY2FsaG9zdDo4MTAwL2JhY2tlbmQvYXBpJyxcbiAgfSxcblxuICBkZWZhdWx0X2RvY2tlciA6IHtcbiAgICByb290VVJMOiAnaHR0cDovL2xvY2FsaG9zdDo4MDgxL2JhY2tlbmQvYXBpJyxcbiAgfSxcblxuICBwcmVwcm9kIDoge1xuICAgIHJvb3RVUkw6ICdodHRwczovL3ByZXByb2Quc29udW0tYmV0YS5mci9iYWNrZW5kL2FwaScsXG4gIH0sXG5cbiAgcHJvZHVjdGlvbiA6IHtcbiAgICByb290VVJMOiAnaHR0cHM6Ly9zb251bS1iZXRhLmZyL2JhY2tlbmQvYXBpJyxcbiAgfVxuXG59KVxuIiwiZXhwb3J0IGNvbnN0IFZJRVdfTElTVCA9ICdWSUVXX0xJU1QnO1xuZXhwb3J0IGNvbnN0IFZJRVdfTUFQID0gJ1ZJRVdfTUFQJztcbmV4cG9ydCBjb25zdCBWSUVXX1NUQVQgPSAnVklFV19TVEFUJztcbiIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBWdWVSb3V0ZXIgZnJvbSAndnVlLXJvdXRlcidcbmltcG9ydCBWZWVWYWxpZGF0ZSBmcm9tICd2ZWUtdmFsaWRhdGUnXG5pbXBvcnQgeyBzeW5jIH0gZnJvbSAndnVleC1yb3V0ZXItc3luYydcblxuVnVlLnVzZShWZWVWYWxpZGF0ZSk7XG5WdWUudXNlKFZ1ZVJvdXRlcilcblxuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUvc3RvcmUuanMnO1xuaW1wb3J0IHJvdXRlckdlbmVyYXRvciBmcm9tICcuL3JvdXRlcy9tYWluLmpzJ1xuLy8gaW1wb3J0IHsgZ2V0Q29uZmlnTmFtZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vLyBiZWNhdXNlIG9mIHRoaXMgY2FsbCAnYmVmb3JlRW50ZXInIGluIGR5bmFtaWNSb3V0ZXNHZW5lcmF0b3IgaXMgdHJpZ2dlcmVkIGZpcnN0XG5jb25zdCByb3V0ZXIgPSByb3V0ZXJHZW5lcmF0b3Ioc3RvcmUpXG5cbmNvbnN0IHVuc3luYyA9IHN5bmMoc3RvcmUsIHJvdXRlcilcbi8vIHVuc3luYygpIHRvIFVuc3luY3Mgc3RvcmUgZnJvbSByb3V0ZXJcblxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuXG4gIG5ldyBWdWUoe1xuICAgIGVsOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdnVlLWNvbnRlbnQnKSxcbiAgICByb3V0ZXIsXG4gICAgc3RvcmUsXG4gICAgcmVuZGVyOiBoID0+IGgoIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci12aWV3JykgKVxuICB9KVxuXG59LCB7b25jZTogdHJ1ZX0pXG4iLCJcbi8vIGltcG9ydCB7IGFwaUNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy9hcGkuanMnO1xuXG5pbXBvcnQgRHluYW1pY1NjcmVlbiBmcm9tICcuLi9jb21wb25lbnRzL3NjcmVlbnMvRHluYW1pY1NjcmVlbi52dWUnXG5pbXBvcnQgTm90Rm91bmRTY3JlZW4gZnJvbSAnLi4vY29tcG9uZW50cy9zY3JlZW5zL05vdEZvdW5kU2NyZWVuLnZ1ZSdcbmltcG9ydCB7IGdldENvbmZpZ05hbWUgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8vIGltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG4vLyBpbXBvcnQgeyBCUkFORF9EQVRBIH0gZnJvbSAnLi4vY29uZmlnL2JyYW5kLmpzJztcblxuLy8gRlVOQ1RJT04gVE8gR0VUIFRIRSBSVU4gTU9ERSBGUk9NIDxIRUFEPlxuLy8gZnVuY3Rpb24gZ2V0Q29uZmlnTmFtZShtZXRhTmFtZSkge1xuLy8gICBjb25zdCBtZXRhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdtZXRhJyk7XG4vLyAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcbi8vICAgICBpZiAobWV0YXNbaV0uZ2V0QXR0cmlidXRlKCduYW1lJykgPT09IG1ldGFOYW1lKSB7XG4vLyAgICAgICByZXR1cm4gbWV0YXNbaV0uZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIHJldHVybiAnJztcbi8vIH1cblxuZXhwb3J0IGNvbnN0IGR5bmFtaWNSb3V0ZXNHZW5lcmF0b3IgPSBmdW5jdGlvbihzdG9yZSl7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgbmFtZTogJ2R5bmFtaWMnLFxuICAgICAgcGF0aDogJy8qJyxcbiAgICAgIGNvbXBvbmVudDogRHluYW1pY1NjcmVlbixcbiAgICAgIC8vIHByb3BzKHJvdXRlKXtcbiAgICAgIC8vICAgcmV0dXJuIHtcbiAgICAgIC8vICAgICAgIC4uLkJSQU5EX0RBVEFcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfSxcblxuICAgICAgLy8gYmVmb3JlRWFjaCh0bywgZnJvbSwgbmV4dCkge1xuICAgICAgLy8gICBjb25zb2xlLmxvZyhcIlxcbi4uLiBkeW5hbWljUm91dGVzR2VuZXJhdG9yIC8gYmVmb3JlRWFjaCAuLi4gXCIpXG4gICAgICAvLyAgIGNvbnNvbGUubG9nKFwiLi4uIGR5bmFtaWNSb3V0ZXNHZW5lcmF0b3IgLyB0byA6IFwiLCB0bylcbiAgICAgIC8vIH0sXG5cbiAgICAgIGJlZm9yZUVudGVyKHRvLCBmcm9tLCBuZXh0KXtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcbi4uLiBkeW5hbWljUm91dGVzR2VuZXJhdG9yIC8gYmVmb3JlRW50ZXIgLi4uIFwiKVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiLi4uIHByb2Nlc3MuZW52Lk5PREVfRU5WIDogXFxuXCIsIHByb2Nlc3MuZW52Lk5PREVfRU5WKVxuXG4gICAgICAgIGlmICggdHlwZW9mIHN0b3JlLmFwaXZpekZyb250VVVJRCA9PT0gJ3VuZGVmaW5lZCcgKXtcbiAgICAgICAgICBzdG9yZS5jb21taXQoJ3NldEFwaXZpekZyb250VVVJRCcpXG4gICAgICAgIH1cbiAgICAgICAgLy8gU0VUIFJVTiBNT0RFIEFORCByb290VXJsQmFja2VuZCBGT1IgU0VBUkNIRVNcbiAgICAgICAgaWYgKCB0eXBlb2Ygc3RvcmUuc3RhdGUucnVuTW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHN0b3JlLnN0YXRlLnJvb3RVcmxCYWNrZW5kID09PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICBjb25zdCBjb25maWdOYW1lID0gZ2V0Q29uZmlnTmFtZSgnY29uZmlnX25hbWUnKVxuICAgICAgICAgIHN0b3JlLmNvbW1pdCgnc2V0UnVuTW9kZScsIGNvbmZpZ05hbWUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIi4uLiBkeW5hbWljUm91dGVzR2VuZXJhdG9yIC8gc3RvcmUuc3RhdGUgOiAgXFxuIFwiLCBzdG9yZS5zdGF0ZSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCIuLi4gZHluYW1pY1JvdXRlc0dlbmVyYXRvciAvIHN0b3JlLnN0YXRlLmNvbmZpZyA6ICBcXG4gXCIsIHN0b3JlLnN0YXRlLmNvbmZpZylcblxuXG4gICAgICAgIC8vIENIRUNLIElGIGNvbmZpZy5nbG9iYWwgaXMgdW5kZWZpbmVkIHlldFxuICAgICAgICBpZiAoIHR5cGVvZiBzdG9yZS5zdGF0ZS5jb25maWcuZ2xvYmFsID09PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIi4uLiBkeW5hbWljUm91dGVzR2VuZXJhdG9yIC8gc3RvcmUuc3RhdGUuY29uZmlnLmdsb2JhbCBpcyB1bmRlZmluZWQgLi4uXCIpXG4gICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ2dldENvbmZpZ0FsbCcpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCIuLi4gZHluYW1pY1JvdXRlc0dlbmVyYXRvciAvIGFmdGVyIGdldENvbmZpZ0FsbCAuLi4gXCIpO1xuICAgICAgICAgICAgbGV0IGF1dGhVcmxSb290cyA9IHN0b3JlLmdldHRlcnMuZ2V0RW5kcG9pbnRDb25maWdBdXRoU3BlY2lmaWMoJ2F1dGhfcm9vdCcpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIi4uLiBkeW5hbWljUm91dGVzR2VuZXJhdG9yIC8gYXV0aFVybFJvb3RzIDogXCIsIGF1dGhVcmxSb290cyk7XG4gICAgICAgICAgICBjb25zdCBydW5Nb2RlID0gc3RvcmUuZ2V0dGVycy5nZXRSdW5Nb2RlXG4gICAgICAgICAgICBjb25zdCBhdXRoVXJsUm9vdCA9IGF1dGhVcmxSb290cy5yb290X3VybFtydW5Nb2RlXVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCIuLi4gZHluYW1pY1JvdXRlc0dlbmVyYXRvciAvIGF1dGhVcmxSb290IDogXCIsIGF1dGhVcmxSb290KTtcbiAgICAgICAgICAgIHN0b3JlLmNvbW1pdCgnc2V0QXV0aFVybFJvb3QnLCBhdXRoVXJsUm9vdClcbiAgICAgICAgICAgIG5leHQoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKCgpID0+IHtjb25zb2xlLmxvZyggJ2Vycm9yLi4uJyk7IG5leHQoJ2Vycm9yJyl9KVxuICAgICAgICB9IGVsc2UgeyBcbiAgICAgICAgICBuZXh0KCkgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBwYXRoOiAnKicsXG4gICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgY29tcG9uZW50OiBOb3RGb3VuZFNjcmVlbixcbiAgICAgIC8vIHByb3BzKHJvdXRlKXtcbiAgICAgIC8vICAgcmV0dXJuIHtcbiAgICAgIC8vICAgICAgIC4uLkJSQU5EX0RBVEFcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfSxcbiAgICB9XG4gIF1cbn1cbiIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBWdWVSb3V0ZXIgZnJvbSAndnVlLXJvdXRlcidcblxuVnVlLnVzZShWdWVSb3V0ZXIpXG5cbi8vIGltcG9ydCB7IHVzZXJSb3V0ZXNHZW5lcmF0b3IgfSBmcm9tICcuL3VzZXJSb3V0ZXMuanMnO1xuaW1wb3J0IHsgZHluYW1pY1JvdXRlc0dlbmVyYXRvciB9IGZyb20gJy4vZHluYW1pY1JvdXRlcy5qcyc7XG5cblxuY29uc3Qgcm91dGVyR2VuZXJhdG9yID0gZnVuY3Rpb24oc3RvcmUpe1xuXG4gIGNvbnN0IHJvdXRlcyA9IFtcbiAgICAvLyAuLi51c2VyUm91dGVzR2VuZXJhdG9yKHN0b3JlKSxcbiAgICAuLi5keW5hbWljUm91dGVzR2VuZXJhdG9yKHN0b3JlKVxuICBdXG5cbiAgcmV0dXJuIG5ldyBWdWVSb3V0ZXIoe1xuICAgICAgbW9kZTogJ2hpc3RvcnknLFxuICAgICAgcm91dGVzLFxuICAgICAgcHJvcHM6dHJ1ZSxcbiAgICAgIHNjcm9sbEJlaGF2aW9yICh0bywgZnJvbSwgc2F2ZWRQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gc2F2ZWRQb3NpdGlvbiA/IHNhdmVkUG9zaXRpb24gOiB7IHg6IDAsIHk6IDAgfTtcbiAgICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgcm91dGVyR2VuZXJhdG9yXG4iLCJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuLy8gaW1wb3J0IHthcGlDb25maWd9IGZyb20gJy4uL2NvbmZpZy9hcGkuanMnO1xuaW1wb3J0IHsgY3N2UGFyc2UgfSBmcm9tICdkMy1kc3YnO1xuaW1wb3J0IHsgIGdldE9iamVjdERhdGFGcm9tUGF0aCxcbiAgICAgICAgICBzZWFyY2hJdGVtcywgXG4gICAgICAgICAgc2VhcmNoRW5wb2ludENyZWF0b3IsIFxuICAgICAgICAgIHNlYXJjaEVuZHBvaW50R2VuZXJhdG9yLCBcbiAgICAgICAgICBjcmVhdGVTZWxlY3RlZEZpbHRlcnNGb3JTZWFyY2hcbiAgICAgICAgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuXG5cbiAgLy8gRk9SIEZJTFRFUlNcbiAgY3JlYXRlRGF0YXNldEZpbHRlcnMoe3N0YXRlLCBnZXR0ZXJzLCBjb21taXR9KXtcbiAgICAvLyBjb25zb2xlLmxvZyhcIlxcbi8vIGNyZWF0ZURhdGFzZXRGaWx0ZXJzIC8gc3RhdGUgOiBcIiwgc3RhdGUgKVxuICAgIGNvbnN0IGN1cnJlbnRGaWx0ZXJzQ29uZmlnID0gZ2V0dGVycy5nZXRFbmRwb2ludENvbmZpZ0ZpbHRlcnNcbiAgICAvLyBjb25zb2xlLmxvZyhcIi8vIGNyZWF0ZURhdGFzZXRGaWx0ZXJzIC8gY3VycmVudEZpbHRlcnNDb25maWcgOiBcIiwgY3VycmVudEZpbHRlcnNDb25maWcpXG4gICAgaWYgKGN1cnJlbnRGaWx0ZXJzQ29uZmlnICYmIGN1cnJlbnRGaWx0ZXJzQ29uZmlnLmZpbHRlcl9vcHRpb25zKXtcbiAgICAgIGxldCBmaWx0ZXJEZXNjcmlwdGlvbnMgPSBjdXJyZW50RmlsdGVyc0NvbmZpZy5maWx0ZXJfb3B0aW9uc1xuICAgICAgY29tbWl0KCdzZXRGaWx0ZXJEZXNjcmlwdGlvbnMnLCBmaWx0ZXJEZXNjcmlwdGlvbnMpXG4gICAgICBjb21taXQoJ2NsZWFyQWxsRmlsdGVycycpXG4gICAgfVxuICB9LFxuXG4gIC8vIEZPUiBRVUVSWSBTRUFSQ0ggRklMVEVSU1xuICB0b2dnbGVGaWx0ZXIoe3N0YXRlLCBjb21taXQsIGRpc3BhdGNoLCBnZXR0ZXJzfSwge2ZpbHRlciwgdmFsdWV9KXtcbiAgICAvLyBjb25zb2xlLmxvZyhcIlxcbi8vIHRvZ2dsZUZpbHRlciAuLi5cIiApXG4gICAgY29uc3Qgc2VsZWN0ZWRGaWx0ZXJzID0gbmV3IE1hcChnZXR0ZXJzLmdldFNlbGVjdGVkRmlsdGVycylcbiAgICAvLyBjb25zb2xlLmxvZyhcIi8vIHRvZ2dsZUZpbHRlciAvIHNlbGVjdGVkRmlsdGVycyA6IFwiLCBzZWxlY3RlZEZpbHRlcnMpO1xuICAgIGNvbnN0IHNlbGVjdGVkVmFsdWVzID0gc2VsZWN0ZWRGaWx0ZXJzLmdldChmaWx0ZXIpXG4gICAgaWYoc2VsZWN0ZWRWYWx1ZXMuaGFzKHZhbHVlKSlcbiAgICAgIHNlbGVjdGVkVmFsdWVzLmRlbGV0ZSh2YWx1ZSlcbiAgICBlbHNlXG4gICAgICBzZWxlY3RlZFZhbHVlcy5hZGQodmFsdWUpXG5cbiAgICBjb21taXQoJ3NldFNlbGVjdGVkRmlsdGVycycsIHtzZWxlY3RlZEZpbHRlcnN9KVxuICAgIGRpc3BhdGNoKCdzZWFyY2gnKVxuICB9LFxuXG4gIGVtcHR5T25lRmlsdGVyKHtzdGF0ZSwgY29tbWl0LCBkaXNwYXRjaCwgZ2V0dGVyc30sIHtmaWx0ZXJ9KXtcbiAgICAvLyBjb25zb2xlLmxvZyhcIlxcbi8vIGVtcHR5T25lRmlsdGVyIC4uLlwiIClcbiAgICBjb25zdCBzZWxlY3RlZEZpbHRlcnMgPSBuZXcgTWFwKGdldHRlcnMuZ2V0U2VsZWN0ZWRGaWx0ZXJzKVxuICAgIHNlbGVjdGVkRmlsdGVycy5zZXQoZmlsdGVyLCBuZXcgU2V0KCkpXG5cbiAgICBjb21taXQoJ3NldFNlbGVjdGVkRmlsdGVycycsIHtzZWxlY3RlZEZpbHRlcnN9KVxuICAgIGRpc3BhdGNoKCdzZWFyY2gnKVxuICB9LFxuXG4gIGNsZWFyQWxsRmlsdGVycyh7Y29tbWl0LCBkaXNwYXRjaH0pe1xuICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuLy8gY2xlYXJBbGxGaWx0ZXJzIC4uLlwiIClcbiAgICBjb21taXQoJ2NsZWFyQWxsRmlsdGVycycpXG4gICAgZGlzcGF0Y2goJ3NlYXJjaCcpXG4gIH0sXG5cbiAgLy8gRk9SIFFVRVJZIFNFQVJDSCBURVhUXG4gIHNlYXJjaGVkVGV4dENoYW5nZWQoe2NvbW1pdCwgZGlzcGF0Y2h9LCB7c2VhcmNoZWRUZXh0fSl7XG4gICAgLy8gY29uc29sZS5sb2coXCJcXG4vLyBzZWFyY2hlZFRleHRDaGFuZ2VkIC4uLlwiIClcbiAgICBjb21taXQoJ3NldFNlYXJjaGVkVGV4dCcsIHtzZWFyY2hlZFRleHR9KVxuICAgIGRpc3BhdGNoKCdzZWFyY2gnKVxuICB9LFxuXG5cbiAgLy8gTUFJTiBTRUFSQ0ggQUNUSU9OXG4gIHNlYXJjaCh7c3RhdGUsIGNvbW1pdCwgZGlzcGF0Y2gsIGdldHRlcnN9KXtcblxuICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuLy8gc2VhcmNoIC8gbWFpbiBhY3Rpb24gdG8gcXVlcnkgZW5kcG9pbnQuLi5cIiApXG4gICAgY29uc3Qge3NlYXJjaH0gPSBzdGF0ZTtcbiAgICAvLyBjb25zb2xlLmxvZyhcIi8vIHNlYXJjaCAvIHNlYXJjaCA6IFwiLCBzZWFyY2ggKVxuXG4gICAgY29uc3Qgc2VsZWN0ZWRGaWx0ZXJzID0gY3JlYXRlU2VsZWN0ZWRGaWx0ZXJzRm9yU2VhcmNoKGdldHRlcnMuZ2V0U2VsZWN0ZWRGaWx0ZXJzKVxuICAgIC8vIGNvbnNvbGUubG9nKCdzZWxlY3RlZEZpbHRlcnMnLHNlbGVjdGVkRmlsdGVycyk7XG4gICAgLy8gYWJvcnQgcHJldmlvdXMgc2VhcmNoIGlmIGFueVxuICAgIGlmKHNlYXJjaC5hbnN3ZXIucGVuZGluZ0Fib3J0KXtcbiAgICAgIHNlYXJjaC5hbnN3ZXIucGVuZGluZ0Fib3J0LmFib3J0KClcbiAgICB9XG5cblxuICAgIC8vY3JlYXRlIHRoZSBlbmRwb2ludHNcbiAgICAvLyBsZXQgcm9vdF91cmwgPSAoc3RhdGUuc2VhcmNoICYmIHN0YXRlLnNlYXJjaC5lbmRwb2ludCkgPyBzdGF0ZS5zZWFyY2guZW5kcG9pbnQucm9vdF91cmwgOiBkaXNwYXRjaCgnZ2V0Q29uZmlnVHlwZScse3R5cGU6J2VuZHBvaW50cycsY29uZmlnVHlwZUVuZHBvaW50OidlbmRwb2ludHMnfSlcblxuICAgIC8vIGxldCBlbmRwb2ludCA9IHNlYXJjaEVucG9pbnRDcmVhdG9yKHtcbiAgICAvLyAgIGJhc2VVcmw6cm9vdF91cmwsXG4gICAgLy8gICAvLyBxdWVyeSBmcm9tIG1haW4gaW5wdXQgaW4gc2VhcmNoIGJhclxuICAgIC8vICAgc2VhcmNoOiBzZWFyY2gucXVlc3Rpb24ucXVlcnksXG4gICAgLy8gICAvLyB0YWdzIC8gZmlsdGVyc1xuICAgIC8vICAgc2VhcmNoX2ZpbHRlcnM6c2VsZWN0ZWRGaWx0ZXJzLFxuICAgIC8vICAgLy8gcGFnaW5hdGlvblxuICAgIC8vICAgcGFnZToxLFxuICAgIC8vICAgcGVyX3BhZ2U6MTAwLFxuICAgIC8vICAgLy8gaGVyZSBmb3IgbWFwIHJlcXVlc3RzXG4gICAgLy8gICBtYXBfbGlzdCA6IHNlYXJjaC5xdWVzdGlvbi5mb3JfbWFwLFxuICAgIC8vICAgYXNfbGF0bG5nIDogc2VhcmNoLnF1ZXN0aW9uLmZvcl9tYXBcblxuICAgIC8vIH0pXG4gICAgLy8gY29uc29sZS5sb2coXCItLSBzZWFyY2ggLyBlbmRwb2ludCA6IFxcblwiLCBlbmRwb2ludCApXG5cbiAgICAvLyBFTkRQT0lOVCBHRU5FUkFUT1JcbiAgICBsZXQgZW5kcG9pbnRHZW5lcmF0ZWQgPSBzZWFyY2hFbmRwb2ludEdlbmVyYXRvcih7XG4gICAgICBlbmRwb2ludENvbmZpZyA6IHN0YXRlLnNlYXJjaC5lbmRwb2ludCxcbiAgICAgIHF1ZXN0aW9uUGFyYW1zIDogc3RhdGUuc2VhcmNoLnF1ZXN0aW9uLFxuICAgICAgc2VsZWN0ZWRGaWx0ZXJzIDogc2VsZWN0ZWRGaWx0ZXJzLFxuICAgIH0pXG4gICAgLy8gY29uc29sZS5sb2coXCItLSBzZWFyY2ggLyBlbmRwb2ludEJpcyA6IFxcblwiLCBlbmRwb2ludEdlbmVyYXRlZCApXG5cblxuICAgIC8vIHBlcmZvcm0gc2VhcmNoIC0tPiAhISEgb25seSByZXF1ZXN0IG1hcCBzZWFyY2ggaWYgbWFwIHNlYXJjaCByZXN1bHRzIGVtcHR5IGluIHN0b3JlICEhISBcbiAgICAvLyBjb25zdCBzZWFyY2hQZW5kaW5nQWJvcnQgPSBzZWFyY2hJdGVtcyhlbmRwb2ludClcbiAgICBjb25zdCBzZWFyY2hQZW5kaW5nQWJvcnQgPSBzZWFyY2hJdGVtcyhlbmRwb2ludEdlbmVyYXRlZClcbiAgICBjb21taXQoJ3NldFNlYXJjaFBlbmRpbmcnLCB7IHBlbmRpbmdBYm9ydDogc2VhcmNoUGVuZGluZ0Fib3J0IH0pXG5cbiAgICBzZWFyY2hQZW5kaW5nQWJvcnQucHJvbWlzZVxuICAgICAgLnRoZW4oKHtwcm9qZWN0cywgdG90YWx9KSA9PiB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiLS0gc2VhcmNoIC8gdG90YWwgOiBcXG5cIiwgdG90YWwgKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIi0tIHNlYXJjaCAvIHByb2plY3RzIDogXFxuXCIsIHByb2plY3RzIClcblxuICAgICAgICAvLyBpZiBzZWFyY2ggaXMgZm9yIG1hcCBlaXRoZXIgZmlsbCByZXN1bHRNYXAgaWYgZW1wdHkgb3IgZG8gbm90aGluZ1xuICAgICAgICBjb21taXQoJ3NldFNlYXJjaFJlc3VsdCcsIHtyZXN1bHQ6IHtwcm9qZWN0cywgdG90YWx9fSlcbiAgICAgICAgLy8gY29tbWl0ICgnc2V0U2VhcmNoUmVzdWx0TWFwJywge3Jlc3VsdE1hcDoge3Byb2plY3RzLCB0b3RhbH19KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIC8vIGRvbid0IHJlcG9ydCBhYm9ydGVkIGZldGNoIGFzIGVycm9yc1xuICAgICAgICBpZiAoZXJyb3IubmFtZSAhPT0gJ0Fib3J0RXJyb3InKVxuICAgICAgICAgIGNvbW1pdCgnc2V0U2VhcmNoRXJyb3InLCB7ZXJyb3J9KVxuICAgICAgfSlcbiAgfSxcblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBUTyBDT01NRU5UIEFCU09MVVRMWSAtPiBkYXRhIG11c3QgYmUgcHJlLWdlb2NvZGVkIHdoZW4gYXJyaXZpbmcgYXMgcmVzcG9uc2VcbiAgZmluZFByb2plY3RzR2VvbG9jcyh7Y29tbWl0fSwgcHJvamVjdHMpe1xuICAgIGNvbnN0IHByb2plY3RXaXRoVmFsaWRBZGRyZXNzID0gcHJvamVjdHMuZmlsdGVyKHAgPT4gcFsnYWRkcmVzcyddKVxuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHByb2plY3RXaXRoVmFsaWRBZGRyZXNzLm1hcChwID0+IHBbJ2FkZHJlc3MnXS5yZXBsYWNlKC9bXihcXHd8XFxzKV0vZywgJycpLnNsaWNlKDAsIDIwMCkgKVxuXG4gICAgY29uc3QgYWRyZXNzZXNDU1YgPSAnYWRyZXNzZVxcbicgKyBhZGRyZXNzZXMuam9pbignXFxuJylcbiAgICBjb25zdCBhZHJlc3NlQ1NWQkFOQm9keSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGFkcmVzc2VDU1ZCQU5Cb2R5LmFwcGVuZCgnZGF0YScsIG5ldyBGaWxlKFthZHJlc3Nlc0NTVl0sICdhZHJlc3Nlcy5jc3YnKSlcblxuICAgIHJldHVybiBmZXRjaCgnaHR0cHM6Ly9hcGktYWRyZXNzZS5kYXRhLmdvdXYuZnIvc2VhcmNoL2Nzdi8nLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IGFkcmVzc2VDU1ZCQU5Cb2R5LFxuICAgIH0pXG4gICAgLnRoZW4ociA9PiByLnRleHQoKSlcbiAgICAudGhlbihnZW9sb2NzVHh0ID0+IHtcbiAgICAgIGNvbnN0IGdlb2xvY3MgPSBjc3ZQYXJzZShnZW9sb2NzVHh0KTtcblxuICAgICAgY29uc3QgZ2VvbG9jQnlQcm9qZWN0SWQgPSBuZXcgTWFwKCk7XG5cbiAgICAgIHByb2plY3RXaXRoVmFsaWRBZGRyZXNzLmZvckVhY2goKHtpZH0sIGkpID0+IHtcbiAgICAgICAgY29uc3Qge2xhdGl0dWRlLCBsb25naXR1ZGV9ID0gZ2VvbG9jc1tpXTtcblxuICAgICAgICBnZW9sb2NCeVByb2plY3RJZC5zZXQoXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgKE51bWJlci5pc0Zpbml0ZShwYXJzZUZsb2F0KGxhdGl0dWRlKSkgJiYgTnVtYmVyLmlzRmluaXRlKHBhcnNlRmxvYXQobG9uZ2l0dWRlKSkpID9cbiAgICAgICAgICAgIHtsYXRpdHVkZTogcGFyc2VGbG9hdChsYXRpdHVkZSksIGxvbmdpdHVkZTogcGFyc2VGbG9hdChsb25naXR1ZGUpfSA6XG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApXG4gICAgICB9KVxuXG4gICAgICBwcm9qZWN0cy5mb3JFYWNoKCh7aWR9KSA9PiB7XG4gICAgICAgIGlmKCFnZW9sb2NCeVByb2plY3RJZC5oYXMoaWQpKXtcbiAgICAgICAgICBnZW9sb2NCeVByb2plY3RJZC5zZXQoaWQsIGZhbHNlKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBjb21taXQoJ2FkZEdlb2xvY3MnLCB7Z2VvbG9jQnlQcm9qZWN0SWR9KVxuICAgIH0pO1xuICB9LFxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vOlxuXG5cblxuICAvLyBGT1IgQ09ORklHc1xuICBnZXRDb25maWdBbGwoe2Rpc3BhdGNofSkge1xuICAgIGxldCBhcnIgPSBbXVxuICAgIGFyci5wdXNoKGRpc3BhdGNoKCdnZXRDb25maWdUeXBlJyx7dHlwZTonZ2xvYmFsJywgICAgY29uZmlnVHlwZUVuZHBvaW50OidnbG9iYWwnLCBhcmdzOicnfSkgKVxuICAgIGFyci5wdXNoKGRpc3BhdGNoKCdnZXRDb25maWdUeXBlJyx7dHlwZTonc3R5bGVzJywgICAgY29uZmlnVHlwZUVuZHBvaW50OidzdHlsZXMnLCBhcmdzOicnfSkgKVxuICAgIGFyci5wdXNoKGRpc3BhdGNoKCdnZXRDb25maWdUeXBlJyx7dHlwZTonc29jaWFscycsICAgY29uZmlnVHlwZUVuZHBvaW50Oidzb2NpYWxzJywgYXJnczonJ30pIClcbiAgICBhcnIucHVzaChkaXNwYXRjaCgnZ2V0Q29uZmlnVHlwZScse3R5cGU6J2Zvb3RlcicsICAgIGNvbmZpZ1R5cGVFbmRwb2ludDonZm9vdGVyJywgYXJnczonJ30pIClcbiAgICBhcnIucHVzaChkaXNwYXRjaCgnZ2V0Q29uZmlnVHlwZScse3R5cGU6J25hdmJhcicsICAgIGNvbmZpZ1R5cGVFbmRwb2ludDonbmF2YmFyJywgYXJnczonJ30pIClcbiAgICBhcnIucHVzaChkaXNwYXRjaCgnZ2V0Q29uZmlnVHlwZScse3R5cGU6J3JvdXRlcycsICAgIGNvbmZpZ1R5cGVFbmRwb2ludDoncm91dGVzJywgYXJnczonJmFzX2xpc3Q9dHJ1ZSd9KSApXG4gICAgYXJyLnB1c2goZGlzcGF0Y2goJ2dldENvbmZpZ1R5cGUnLHt0eXBlOid0YWJzJywgICAgICBjb25maWdUeXBlRW5kcG9pbnQ6J3RhYnMnLCBhcmdzOicmYXNfbGlzdD10cnVlJ30pIClcbiAgICBhcnIucHVzaChkaXNwYXRjaCgnZ2V0Q29uZmlnVHlwZScse3R5cGU6J2VuZHBvaW50cycsIGNvbmZpZ1R5cGVFbmRwb2ludDonZW5kcG9pbnRzJywgYXJnczonJmFzX2xpc3Q9dHJ1ZSd9KSApXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGFycilcbiAgfSxcblxuICBnZXRDb25maWdUeXBlKHtjb21taXQsIGdldHRlcnN9LHt0eXBlLGNvbmZpZ1R5cGVFbmRwb2ludCxhcmdzfSkge1xuICAgIGNvbnN0IHJvb3RVUkxiYWNrZW5kID0gZ2V0dGVycy5nZXRSb290VXJsQmFja2VuZFxuICAgIGNvbnN0IGFwaXZpekZyb250VVVJRCA9IGdldHRlcnMuZ2V0QXBpdml6RnJvbnRVVUlEXG4gICAgcmV0dXJuIGF4aW9zXG4gICAgLmdldChyb290VVJMYmFja2VuZCsnL2NvbmZpZy8nK2NvbmZpZ1R5cGVFbmRwb2ludCtcIj91dWlkPVwiK2FwaXZpekZyb250VVVJRCthcmdzKVxuICAgIC8vIC5nZXQoYXBpQ29uZmlnLnJvb3RVUkwrJy9jb25maWcvJytjb25maWdUeXBlRW5kcG9pbnQpXG4gICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJ0eXBlIDogXCIsIHR5cGUsXCIgLyByZXNwb25zZSA6IFwiLCByZXNwb25zZSlcbiAgICAgIGxldCBhcHBfY29uZmlnID0gKHJlc3BvbnNlICYmIHJlc3BvbnNlLmRhdGEgJiYgcmVzcG9uc2UuZGF0YS5hcHBfY29uZmlnKSA/IHJlc3BvbnNlLmRhdGEuYXBwX2NvbmZpZyA6IHVuZGVmaW5lZFxuICAgICAgY29tbWl0KCdzZXRDb25maWcnLCB7dHlwZTp0eXBlLHJlc3VsdDphcHBfY29uZmlnfSk7IFxuICAgICAgcmV0dXJuIGFwcF9jb25maWdcbiAgICB9KVxuICAgIC5jYXRjaCggZXJyID0+IGNvbnNvbGUubG9nKCd0aGVyZSB3YXMgYW4gZXJyb3IgdHJ5aW5nIHRvIGZldGNoIHNvbWUgY29uZmlndXJhdGlvbiBmaWxlJyxlcnIpIClcbiAgfSxcblxuXG4gIC8vIFRPIFZBUklBQklMSVpFXG4gIHNldFNlYXJjaENvbmZpZ0Rpc3BsYXkoe2NvbW1pdH0pIHtcbiAgICAvLyBoZXJlIHRoaXMgZnVuY3Rpb24gd2lsbCBwcm9iYWJseSBjaGFuZ2Ugd2hlbiB0aGlzIG1heSBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgY29uZmlndXJhdGlvbiBmaWxlc1xuICAgIGNvbnN0IGRlZmF1bHREaXNwbGF5ID0ge1xuICAgICAgY29sdW1uQ291bnQgOiA0LFxuICAgICAgZGVmYXVsdFNob3dDb3VudCA6IDUwLFxuICAgICAgbW9yZVByb2plY3RPblNjcm9sbENvdW50IDogMjAsXG4gICAgICBzY3JvbGxCZWZvcmVCb3R0b21UcmlnZ2VyIDogNTAwXG4gICAgfVxuICAgIGNvbW1pdCgnc2V0U2VhcmNoQ29uZmlnJywge3R5cGU6J2Rpc3BsYXknLHJlc3VsdDpkZWZhdWx0RGlzcGxheX0pO1xuICB9LFxuXG4gIC8vIFVTRVItUkVMQVRFRFxuICBzYXZlTG9naW5JbmZvcyh7Y29tbWl0LCBnZXR0ZXJzfSwge0FQSXJlc3BvbnNlfSl7XG5cbiAgICBjb25zdCBhdXRoQ29uZmlnID0gZ2V0dGVycy5nZXRDb25maXJtVG9rZW5Db25maWdcbiAgICBjb25zb2xlLmxvZyhcIlxcbi8vIGF1dGhDb25maWcgOiBcXG5cIiwgYXV0aENvbmZpZyApXG5cbiAgICBjb25zdCBhY2Nlc3NUb2tlblBhdGggPSBhdXRoQ29uZmlnLnJlc3BfZmllbGRzLmFjY2Vzc190b2tlbi5wYXRoXG4gICAgY29uc3QgcmVmcmVzaFRva2VuUGF0aCA9IGF1dGhDb25maWcucmVzcF9maWVsZHMucmVmcmVzaF90b2tlbi5wYXRoXG4gICAgY29uc3QgdXNlclJvbGVQYXRoID0gYXV0aENvbmZpZy5yZXNwX2ZpZWxkcy51c2VyX3JvbGUucGF0aFxuICAgIGNvbnN0IHVzZXJJZFBhdGggPSBhdXRoQ29uZmlnLnJlc3BfZmllbGRzLnVzZXJfaWQucGF0aFxuICAgIGNvbnN0IHVzZXJOYW1lUGF0aCA9IGF1dGhDb25maWcucmVzcF9maWVsZHMudXNlcl9uYW1lLnBhdGhcbiAgICBjb25zdCB1c2VyU3VybmFtZVBhdGggPSBhdXRoQ29uZmlnLnJlc3BfZmllbGRzLnVzZXJfc3VybmFtZS5wYXRoXG4gICAgY29uc3QgdXNlclBzZXVkb1BhdGggPSBhdXRoQ29uZmlnLnJlc3BfZmllbGRzLnVzZXJfcHNldWRvLnBhdGhcbiAgICBjb25zdCB1c2VyRW1haWxQYXRoID0gYXV0aENvbmZpZy5yZXNwX2ZpZWxkcy51c2VyX2VtYWlsLnBhdGhcblxuICAgIGxldCByID0gQVBJcmVzcG9uc2VcbiAgICBjb25zb2xlLmxvZyhcIlxcbi8vIHIgPSBBUElyZXNwb25zZSA6IFxcblwiLCByIClcblxuICAgIC8vIGxldCB0b2tlbnMgPSAociAmJiByLmRhdGEgJiYgci5kYXRhLmRhdGEgJiYgci5kYXRhLmRhdGEudG9rZW5zKSA/IHIuZGF0YS5kYXRhLnRva2VucyA6IHVuZGVmaW5lZFxuICAgIGxldCB0b2tlbnMgPSAociAmJiByLmRhdGEgKSA/IHsgXG4gICAgICBhY2Nlc3NfdG9rZW4gICA6IGdldE9iamVjdERhdGFGcm9tUGF0aChyLmRhdGEsIGFjY2Vzc1Rva2VuUGF0aCksIFxuICAgICAgcmVmcmVzaF90b2tlbiA6IGdldE9iamVjdERhdGFGcm9tUGF0aChyLmRhdGEsIHJlZnJlc2hUb2tlblBhdGgpLCBcbiAgICB9IDogdW5kZWZpbmVkIDtcbiAgICAvLyBjb25zb2xlLmxvZygndG9rZW5zIDogXFxuJywgdG9rZW5zKVxuXG4gICAgLy8gbGV0IGluZm9zID0gKHIgJiYgci5kYXRhICYmIHIuZGF0YS5kYXRhICYmIHIuZGF0YS5kYXRhLmluZm9zKSA/IHIuZGF0YS5kYXRhLmluZm9zIDogdW5kZWZpbmVkXG4gICAgbGV0IGluZm9zID0gKCByICYmIHIuZGF0YSApID8ge1xuICAgICAgICBuYW1lICAgIDogZ2V0T2JqZWN0RGF0YUZyb21QYXRoKHIuZGF0YSwgdXNlck5hbWVQYXRoKSwgXG4gICAgICAgIHN1cm5hbWUgOiBnZXRPYmplY3REYXRhRnJvbVBhdGgoci5kYXRhLCB1c2VyU3VybmFtZVBhdGgpLCBcbiAgICAgICAgZW1haWwgICA6IGdldE9iamVjdERhdGFGcm9tUGF0aChyLmRhdGEsIHVzZXJFbWFpbFBhdGgpLCBcbiAgICAgICAgaWQgICAgICA6IGdldE9iamVjdERhdGFGcm9tUGF0aChyLmRhdGEsIHVzZXJJZFBhdGgpLCBcbiAgICAgICAgcHNldWRvICA6IGdldE9iamVjdERhdGFGcm9tUGF0aChyLmRhdGEsIHVzZXJQc2V1ZG9QYXRoKSwgXG4gICAgfSA6IHVuZGVmaW5lZCA7XG4gICAgLy8gY29uc29sZS5sb2coJ2luZm9zIDogXFxuJywgaW5mb3MpXG5cbiAgICAvLyBsZXQgcm9sZSA9IChyICYmIHIuZGF0YSAmJiByLmRhdGEuZGF0YSAmJiByLmRhdGEuZGF0YS5hdXRoICYmIHIuZGF0YS5kYXRhLmF1dGgucm9sZSkgPyByLmRhdGEuZGF0YS5hdXRoLnJvbGUgOiB1bmRlZmluZWRcbiAgICBsZXQgcm9sZSA9ICggciAmJiByLmRhdGEgKSA/IGdldE9iamVjdERhdGFGcm9tUGF0aChyLmRhdGEsIHVzZXJSb2xlUGF0aCkgOiB1bmRlZmluZWRcblxuICAgIGNvbW1pdCgnc2V0VG9rZW5zJywge3Rva2Vuc30pXG4gICAgY29tbWl0KCdzZXRJbmZvcycsICB7aW5mb3N9KVxuICAgIGNvbW1pdCgnc2V0Um9sZScsICAge3JvbGV9KVxuXG4gICAgLy8gdGVzdCB1c2VyIHJvbGVcbiAgICBjb25zb2xlLmxvZygndGhlbi4uLiBnZXRDaGVja1VzZXJSb2xlIC0gZ3Vlc3QgOiAnLCBnZXR0ZXJzLmdldENoZWNrVXNlclJvbGUoJ2d1ZXN0JykpXG4gICAgY29uc29sZS5sb2coJ3RoZW4uLi4gZ2V0Q2hlY2tVc2VyUm9sZSAtIGFkbWluIDogJywgZ2V0dGVycy5nZXRDaGVja1VzZXJSb2xlKCdhZG1pbicpKVxuICB9LFxuICBsb2dvdXQoe2NvbW1pdH0pe1xuICAgIGNvbW1pdCgnc2V0VG9rZW5zJywge30pXG4gICAgY29tbWl0KCdzZXRJbmZvcycsICB7fSlcbiAgICBjb21taXQoJ3NldFJvbGUnLCAgIHt9KVxuICB9LFxuXG5cbiAgLy8gRk9SIEVORFBPSU5UIENPTkZJR1xuICBzZXRTZWFyY2hFbmRwb2ludENvbmZpZyh7Y29tbWl0LGdldHRlcnMsc3RhdGV9LHtwYXRofSkge1xuXG4gICAgbGV0IHJvdXRlQ29uZmlnID0gZ2V0dGVycy5nZXRDdXJyZW50Um91dGVDb25maWcocGF0aClcblxuICAgIGNvbW1pdCgnc2V0U2VhcmNoUGFyYW0nLHt0eXBlOidjdXJyZW50Um91dGVDb25maWcnLCByZXN1bHQ6cm91dGVDb25maWd9KVxuICAgIGNvbW1pdCgnc2V0U2VhcmNoUGFyYW0nLHt0eXBlOidkYXRhc2V0X3VyaScsIHJlc3VsdDpyb3V0ZUNvbmZpZy5kYXRhc2V0X3VyaX0pXG4gICAgY29tbWl0KCdzZXRTZWFyY2hQYXJhbScse3R5cGU6J2VuZHBvaW50X3R5cGUnLCByZXN1bHQ6cm91dGVDb25maWcuZW5kcG9pbnRfdHlwZX0pXG4gICAgXG4gICAgbGV0IGVuZHBvaW50Q29uZmlnID0gZ2V0dGVycy5nZXRFbmRwb2ludENvbmZpZ1xuICAgIGNvbW1pdCgnc2V0U2VhcmNoUGFyYW0nLHt0eXBlOidlbmRwb2ludCcscmVzdWx0OmVuZHBvaW50Q29uZmlnfSlcblxuICB9LFxuICBcbn1cbiIsIlxuaW1wb3J0IHsgdGV4dEZyb21Mb2NhbGUgfSBmcm9tICcuLi91dGlscyc7XG5cblxuY29uc3QgZ2V0U2VhcmNoQ29uZmlnQ29sdW1uQ291bnQgPSBzdGF0ZSA9PiBzdGF0ZS5zZWFyY2guY29uZmlnLmRpc3BsYXkuY29sdW1uQ291bnQ7XG5jb25zdCBnZXRTZWFyY2hDb25maWdEZWZhdWx0U2hvd0NvdW50ID0gc3RhdGUgPT4gc3RhdGUuc2VhcmNoLmNvbmZpZy5kaXNwbGF5LmRlZmF1bHRTaG93Q291bnQ7XG5jb25zdCBnZXRTZWFyY2hDb25maWdNb3JlUHJvamVjdE9uU2Nyb2xsQ291bnQgPSBzdGF0ZSA9PiBzdGF0ZS5zZWFyY2guY29uZmlnLmRpc3BsYXkubW9yZVByb2plY3RPblNjcm9sbENvdW50O1xuY29uc3QgZ2V0U2VhcmNoQ29uZmlnU2Nyb2xsQmVmb3JlQm90dG9tVHJpZ2dlciA9IHN0YXRlID0+IHN0YXRlLnNlYXJjaC5jb25maWcuZGlzcGxheS5zY3JvbGxCZWZvcmVCb3R0b21UcmlnZ2VyO1xuXG4vLyBGT1IgVFJBTlNMQVRJT05TXG4vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAvL1xuICBjb25zdCBnZXRUcmFuc2xhdGlvbiA9IChzdGF0ZSkgPT4gKHRleHRzRGF0YSkgPT4ge1xuICAgIGNvbnN0IGxvY2FsZSA9IHN0YXRlLmxvY2FsZVxuICAgIGNvbnN0IHRleHRGaWVsZCA9ICd0ZXh0J1xuICAgIC8vIGNvbnNvbGUubG9nKFwidGV4dHNEYXRhIDogXCIsIHRleHRzRGF0YSlcbiAgICByZXR1cm4gdGV4dEZyb21Mb2NhbGUoIHRleHRzRGF0YS50ZXh0cywgbG9jYWxlLCB0ZXh0RmllbGQgKVxuICB9XG5cbi8vIFVYIEdFVFRFUlNcbiAgY29uc3QgZ2V0TmF2YmFyVmlzaWJpbGl0eSA9IHN0YXRlID0+IHtcbiAgICByZXR1cm4gc3RhdGUuc2hvd05hdlxuICB9XG5cbi8vIEdMT0JBTCBBUFAgQ09ORklHIEdFVFRFUlNcbi8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC8vXG4gIGNvbnN0IGdldEFwaXZpekZyb250VVVJRCA9IHN0YXRlID0+IHtcbiAgICBjb25zb2xlLmxvZyggXCIuLi5JJ20geW91LCBJIGRlZS4uLiBcIiwgc3RhdGUuYXBpdml6RnJvbnRVVUlEIClcbiAgICByZXR1cm4gc3RhdGUuYXBpdml6RnJvbnRVVUlEXG4gIH1cbiAgY29uc3QgZ2V0UnVuTW9kZSA9IHN0YXRlID0+IHtcbiAgICByZXR1cm4gc3RhdGUucnVuTW9kZVxuICB9XG4gIGNvbnN0IGdldFJvb3RVcmxCYWNrZW5kID0gc3RhdGUgPT4ge1xuICAgIGNvbnNvbGUubG9nKCBcIi4uLkknbSByb29vb3QuLi4gXCIsIHN0YXRlLnJvb3RVcmxCYWNrZW5kIClcbiAgICByZXR1cm4gc3RhdGUucm9vdFVybEJhY2tlbmRcbiAgfVxuICBjb25zdCBnZXRSb290VXJsQXV0aCA9IHN0YXRlID0+IHtcbiAgICByZXR1cm4gc3RhdGUucm9vdFVybEF1dGhcbiAgfVxuICAvLyBjb25zdCBnZXRSb290VXJsVXNlciA9IHN0YXRlID0+IHtcbiAgLy8gICByZXR1cm4gc3RhdGUucm9vdFVybFVzZXJcbiAgLy8gfVxuXG4gIGNvbnN0IGdldEdsb2JhbENvbmZpZyA9IHN0YXRlID0+IHtcbiAgICAvLyBjb25zb2xlLmxvZyhcInN0YXRlLmNvbmZpZyA6IFxcblwiLCBzdGF0ZS5jb25maWcgKVxuICAgIGlmICghc3RhdGUuY29uZmlnXG4gICAgICB8fCAhc3RhdGUuY29uZmlnLmdsb2JhbFxuICAgICAgKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdnZXRHbG9iYWxDb25maWcgLSBzb21lIGNvbmRpdGlvbiBub3QgcmVzcGVjdGVkJyk7ICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5jb25maWcuZ2xvYmFsXG4gIH1cbiAgY29uc3QgZ2V0U3R5bGVzQ29uZmlnID0gc3RhdGUgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKFwic3RhdGUuY29uZmlnIDogXFxuXCIsIHN0YXRlLmNvbmZpZyApXG4gICAgaWYgKCFzdGF0ZS5jb25maWdcbiAgICAgIHx8ICFzdGF0ZS5jb25maWcuc3R5bGVzXG4gICAgICApIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2dldFN0eWxlc0NvbmZpZyAtIHNvbWUgY29uZGl0aW9uIG5vdCByZXNwZWN0ZWQnKTsgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5zdHlsZXNcbiAgfVxuICBjb25zdCBnZXRTb2NpYWxzQ29uZmlnID0gc3RhdGUgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKFwic3RhdGUuY29uZmlnIDogXFxuXCIsIHN0YXRlLmNvbmZpZyApXG4gICAgLy8gaWYgKCFzdGF0ZS5jb25maWdcbiAgICAvLyAgIHx8ICFzdGF0ZS5jb25maWcuc29jaWFsc1xuICAgIC8vICAgKSB7XG4gICAgLy8gICAgIGNvbnNvbGUubG9nKCdnZXRTb2NpYWxzQ29uZmlnIC0gc29tZSBjb25kaXRpb24gbm90IHJlc3BlY3RlZCcpOyAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIC8vIH1cbiAgICByZXR1cm4gc3RhdGUuY29uZmlnLnNvY2lhbHNcbiAgfVxuICBjb25zdCBnZXROYXZiYXJDb25maWcgPSBzdGF0ZSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coXCJzdGF0ZS5jb25maWcgOiBcXG5cIiwgc3RhdGUuY29uZmlnIClcbiAgICBpZiAoIXN0YXRlLmNvbmZpZ1xuICAgICAgfHwgIXN0YXRlLmNvbmZpZy5uYXZiYXJcbiAgICAgICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZ2V0TmF2YmFyQ29uZmlnIC0gc29tZSBjb25kaXRpb24gbm90IHJlc3BlY3RlZCcpOyAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuY29uZmlnLm5hdmJhci5hcHBfbmF2YmFyXG4gIH1cbiAgY29uc3QgZ2V0Rm9vdGVyQ29uZmlnID0gc3RhdGUgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKFwic3RhdGUuY29uZmlnIDogXFxuXCIsIHN0YXRlLmNvbmZpZyApXG4gICAgaWYgKCFzdGF0ZS5jb25maWdcbiAgICAgIHx8ICFzdGF0ZS5jb25maWcuZm9vdGVyXG4gICAgICApIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2dldEZvb3RlckNvbmZpZyAtIHNvbWUgY29uZGl0aW9uIG5vdCByZXNwZWN0ZWQnKTsgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5mb290ZXIuYXBwX2Zvb3RlclxuICB9XG5cbi8vIFJPVVRFIENPTkZJRyBHRVRURVJTXG4vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAvL1xuICBjb25zdCBnZXRDdXJyZW50Um91dGVDb25maWcgPSAoc3RhdGUpID0+IChjdXJyZW50Um91dGUpID0+IHtcbiAgICAvLyBjb25zb2xlLmxvZygnXFxuICsrIGdldEN1cnJlbnRSb3V0ZUNvbmZpZyAvIGN1cnJlbnRSb3V0ZSA6IFxcbicsIGN1cnJlbnRSb3V0ZSlcbiAgICAvLyBjb25zb2xlLmxvZygnICsrIGdldEN1cnJlbnRSb3V0ZUNvbmZpZyAvIHN0YXRlLmNvbmZpZy5yb3V0ZXMgOiBcXG4nLCBzdGF0ZS5jb25maWcucm91dGVzKVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3RhdGUuY29uZmlnLnJvdXRlcy5maW5kKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHIudXJscy5pbmRleE9mKGN1cnJlbnRSb3V0ZSkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coJ2VycicsZSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICB9XG4gIGNvbnN0IGdldFJvdXRlQ29uZmlnTGlzdEZvckRhdGFzZXQgPSBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5yb3V0ZXMuZmluZChmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gci5lbmRwb2ludF90eXBlID09PSAnbGlzdCdcbiAgICAgICYmIHIuZGF0YXNldF91cmkgPT09IHN0YXRlLnNlYXJjaC5kYXRhc2V0X3VyaTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBnZXRSb3V0ZUNvbmZpZ01hcEZvckRhdGFzZXQgPSBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5yb3V0ZXMuZmluZChmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gci5lbmRwb2ludF90eXBlID09PSAnbWFwJ1xuICAgICAgJiYgci5kYXRhc2V0X3VyaSA9PT0gc3RhdGUuc2VhcmNoLmRhdGFzZXRfdXJpO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGdldFJvdXRlQ29uZmlnU3RhdEZvckRhdGFzZXQgPSBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5yb3V0ZXMuZmluZChmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gci5lbmRwb2ludF90eXBlID09PSAnc3RhdCdcbiAgICAgICYmIHIuZGF0YXNldF91cmkgPT09IHN0YXRlLnNlYXJjaC5kYXRhc2V0X3VyaTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBnZXRSb3V0ZUNvbmZpZ0RlZmF1bHREYXRhc2V0SW1hZ2VzID0gc3RhdGUgPT4ge1xuICAgIHJldHVybiBzdGF0ZS5jb25maWcuc3R5bGVzLmFwcF9zZWFyY2hfZGVmYXVsdF9pbWFnZXNfc2V0cy5pbWFnZXNfc2V0cy5maW5kKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiByLmRhdGFzZXRfdXJpID09PSBzdGF0ZS5zZWFyY2guZGF0YXNldF91cmk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZ2V0U2VhcmNoRGF0YXNldFVSSSA9IHN0YXRlID0+IHtcbiAgICByZXR1cm4gc3RhdGUuc2VhcmNoLmRhdGFzZXRfdXJpXG4gIH1cblxuLy8gREVGQVVMVCBURVhUUyBHRVRURVJTXG4vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAvL1xuICBjb25zdCBkZWZhdWx0VGV4dCA9IChzdGF0ZSkgPT4gKGZpZWxkKSA9PiB7XG4gICAgLy8gZGVmYXVsdCB0ZXh0cyBmaWVsZHMgYXJlIDpcbiAgICAvLyAncmVpbml0X2ZpbHRlcnMnLCAnbm9fYWJzdHJhY3QnLCAnbm9fYWRkcmVzcydcbiAgICAvLyAnc291cmNlJywgJ25vX2luZm8nXG4gICAgY29uc3QgZiA9IGZpZWxkLnR4dFxuICAgIGNvbnN0IG5vQWJzdHJhY3REaWN0ID0gc3RhdGUuY29uZmlnLmdsb2JhbC5hcHBfYmFzaWNfZGljdFtmXVxuICAgIGxldCB0ZXh0ID0gbm9BYnN0cmFjdERpY3QuZmluZCh0PT50LmxvY2FsZSA9PSBzdGF0ZS5sb2NhbGUgKVxuICAgIHJldHVybiB0ZXh0LnRleHRcbiAgfVxuXG4vLyBJVEVNUyBDT05GSUcgR0VUVEVSU1xuLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLy9cbiAgY29uc3QgZ2V0UHJvamVjdENvbmZpZyA9IChzdGF0ZSkgPT4gKHBvc2l0aW9uKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzdGF0ZS5zZWFyY2guY3VycmVudFJvdXRlQ29uZmlnLmNvbnRlbnRzX2ZpZWxkcy5maW5kKCBmdW5jdGlvbihmKSB7ICByZXR1cm4gZi5wb3NpdGlvbiA9PT0gcG9zaXRpb247IH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coJ2VycicsZSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICB9XG4gIGNvbnN0IGdldFByb2plY3RDb25maWdVbmlmb3JtID0gKHN0YXRlLCBnZXR0ZXJzKSA9PiAoaXRlbURhdGEpID0+IHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIiArKyBnZXRQcm9qZWN0Q29uZmlnVW5pZm9ybSAtIGl0ZW1EYXRhIDogXCIsIGl0ZW1EYXRhKVxuICAgIGxldCByZXMgPSB7fVxuICAgIGNvbnN0IGluZm9UeXBlcyA9IFsnaWQnLCd0aXRsZScsJ2ltYWdlJywnYWRkcmVzcycsJ3RhZ3MnXVxuICAgIGluZm9UeXBlcy5mb3JFYWNoKCBmdW5jdGlvbihpbmZvVHlwZSl7XG4gICAgICBsZXQgZmllbGRPYmogPSBnZXR0ZXJzLmdldFByb2plY3RDb25maWcoJ2Jsb2NrXycraW5mb1R5cGUpXG4gICAgICByZXNbaW5mb1R5cGVdID0gKGZpZWxkT2JqICYmIGZpZWxkT2JqLmZpZWxkKSA/IGl0ZW1EYXRhW2ZpZWxkT2JqLmZpZWxkXSA6IHVuZGVmaW5lZFxuICAgIH0pXG4gICAgcmVzLmltYWdlID0gZ2V0dGVycy5nZXRJbWdVcmwocmVzKVxuICAgIHJlcy5mdWxsSXRlbSA9IGl0ZW1EYXRhXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIGNvbnN0IGdldFJlc3VsdHMgPSAoc3RhdGUpID0+IHtcbiAgICByZXR1cm4gc3RhdGUuc2VhcmNoLmFuc3dlci5yZXN1bHQgJiYgc3RhdGUuc2VhcmNoLmFuc3dlci5yZXN1bHQucHJvamVjdHNcbiAgfVxuICBjb25zdCBnZXRHZW9SZXN1bHRzID0gKHN0YXRlLCBnZXR0ZXJzKSA9PiB7XG4gICAgbGV0IGFsbFJlc3VsdHMgPSBnZXR0ZXJzLmdldFJlc3VsdHNcbiAgICAvLyBjb25zb2xlLmxvZyhcIiArKyBnZXRHZW9SZXN1bHRzIC8gYWxsUmVzdWx0cyA6IFwiLCBhbGxSZXN1bHRzKVxuICAgIGlmICh0eXBlb2YgYWxsUmVzdWx0cyAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgbGV0IGZpbHRlcmVkID0gYWxsUmVzdWx0cy5maWx0ZXIoaSA9PiAhaS5sYXQgJiYgIWkubG9uKVxuICAgICAgLy8gY29uc29sZS5sb2coXCIgKysgZ2V0R2VvUmVzdWx0cyAvIGZpbHRlcmVkIDogXCIsIGZpbHRlcmVkKVxuICAgICAgcmV0dXJuIGZpbHRlcmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuXG4vLyBJTUFHRVMgQ09ORklHIEdFVFRFUlNcbi8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC8vXG4gIGNvbnN0IGdldEltZ1VybCA9IChzdGF0ZSwgZ2V0dGVycykgPT4gKG9iaikgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiZ2V0SW1nVXJsIC0gb2JqIDogXCIsIG9iailcbiAgICBsZXQgaW1hZ2UgPSBvYmouaW1hZ2VcblxuICAgIGlmKCFpbWFnZSl7XG4gICAgICBsZXQgaW1hZ2VzX3NldCA9IHVuZGVmaW5lZFxuICAgICAgaWYgKHN0YXRlLnNlYXJjaC5kYXRhc2V0X3VyaVxuICAgICAgICAmJiBzdGF0ZS5jb25maWcuc3R5bGVzXG4gICAgICAgICYmIHN0YXRlLmNvbmZpZy5zdHlsZXMuYXBwX3NlYXJjaF9kZWZhdWx0X2ltYWdlc19zZXRzXG4gICAgICAgICYmIHN0YXRlLmNvbmZpZy5zdHlsZXMuYXBwX3NlYXJjaF9kZWZhdWx0X2ltYWdlc19zZXRzLmltYWdlc19zZXRzKSB7XG4gICAgICAgIGxldCBkID0gc3RhdGUuY29uZmlnLnN0eWxlcy5hcHBfc2VhcmNoX2RlZmF1bHRfaW1hZ2VzX3NldHMuaW1hZ2VzX3NldHMuZmluZChmdW5jdGlvbihkKXtcbiAgICAgICAgICByZXR1cm4gZC5kYXRhc2V0X3VyaSA9PT0gc3RhdGUuc2VhcmNoLmRhdGFzZXRfdXJpO1xuICAgICAgICB9KVxuICAgICAgICBpbWFnZXNfc2V0ICA9IChkKSA/IGQuaW1hZ2VzX3NldCA6IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAoaW1hZ2VzX3NldCAmJiBpbWFnZXNfc2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZUNvdW50ID0gaW1hZ2VzX3NldC5sZW5ndGggKyAxXG4gICAgICAgIGxldCBpZCA9IChvYmouaWQpID8gcGFyc2VJbnQob2JqLmlkLnN1YnN0cihvYmouaWQubGVuZ3RoIC0gNiksIDE2KSAlIHRleHR1cmVDb3VudCA6IDExMTExMTExMTExMTExMTExMVxuICAgICAgICBsZXQgcmVzdGUgPSBpZCAlIGltYWdlc19zZXQubGVuZ3RoICsgMTtcbiAgICAgICAgbGV0IGltYWdlT2JqID0gaW1hZ2VzX3NldC5maW5kKGZ1bmN0aW9uKGkpe1xuICAgICAgICAgIHJldHVybiBpLmRmdF90ZXh0ID09PSAnaW1nXycrcmVzdGU7XG4gICAgICAgIH0pXG4gICAgICAgIGltYWdlID0gaW1hZ2VPYmouc3JjX2ltYWdlXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGxldCByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoNyAtIDEpICsgMSlcbiAgICAgICAgaW1hZ2UgPSBgL3N0YXRpYy9pbGx1c3RyYXRpb25zL3RleHR1cmVzL21lZGl1bV9maWNoZV8keyAocGFyc2VJbnQoaWQuc3Vic3RyKGlkLmxlbmd0aCAtIDYpLCAxNikldGV4dHVyZUNvdW50KSArIDF9LnBuZ2BcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltYWdlXG4gIH1cbiAgY29uc3QgZ2V0SW1hZ2VVcmwgPSAoc3RhdGUsIGdldHRlcnMpID0+IChvYmopID0+IHtcblxuICAgIC8vIGNvbnNvbGUubG9nKFwiZ2V0SW1hZ2VVcmwgLSBvYmogOiBcIiwgb2JqKVxuICAgIGNvbnN0IGl0ZW0gPSBvYmouaXRlbVxuICAgIGNvbnNvbGUubG9nKFwiZ2V0SW1hZ2VVcmwgLSBpdGVtIDogXCIsIGl0ZW0pXG4gICAgXG4gICAgY29uc3QgcG9zaXRpb24gPSBvYmoucG9zaXRpb25cbiAgICBjb25zb2xlLmxvZyhcImdldEltYWdlVXJsIC0gcG9zaXRpb24gOiBcIiwgcG9zaXRpb24pXG5cbiAgICBjb25zdCBkZWZhdWx0SW1hZ2VzID0gZ2V0dGVycy5nZXRSb3V0ZUNvbmZpZ0RlZmF1bHREYXRhc2V0SW1hZ2VzXG4gICAgLy8gY29uc29sZS5sb2coXCJnZXRJbWFnZVVybCAtIGRlZmF1bHRJbWFnZXMgOiBcIiwgZGVmYXVsdEltYWdlcylcblxuICAgIGNvbnNvbGUubG9nKFwiZ2V0SW1hZ2VVcmwgLSBzdGF0ZS5zZWFyY2guY3VycmVudFJvdXRlQ29uZmlnIDogXCIsIHN0YXRlLnNlYXJjaC5jdXJyZW50Um91dGVDb25maWcpXG4gICAgY29uc3Qgcm91dGVDb250ZW50SW1hZ2VzRmllbGRzID0gc3RhdGUuc2VhcmNoLmN1cnJlbnRSb3V0ZUNvbmZpZy5pbWFnZXNfZmllbGRzXG4gICAgLy8gY29uc29sZS5sb2coXCJnZXRJbWFnZVVybCAtIHJvdXRlQ29udGVudEltYWdlc0ZpZWxkcyA6IFwiLCByb3V0ZUNvbnRlbnRJbWFnZXNGaWVsZHMpXG5cbiAgICBsZXQgZmllbGRUb0dldCA9IHJvdXRlQ29udGVudEltYWdlc0ZpZWxkc1twb3NpdGlvbl1cbiAgICBsZXQgZmllbGRJbWFnZSA9IGZpZWxkVG9HZXQuZmllbGRcbiAgICAvLyBjb25zb2xlLmxvZyhcImdldEltYWdlVXJsIC0gZmllbGRJbWFnZSA6IFwiLCBmaWVsZEltYWdlKVxuXG4gICAgbGV0IGltYWdlID0gaXRlbVtmaWVsZEltYWdlXVxuICAgIGNvbnNvbGUubG9nKFwiZ2V0SW1hZ2VVcmwgLSBpbWFnZSAoQSkgOiBcIiwgaW1hZ2UpXG5cbiAgICBpZighaW1hZ2Upe1xuICAgICAgbGV0IGQgPSBkZWZhdWx0SW1hZ2VzXG4gICAgICBsZXQgaW1hZ2VzX3NldCAgPSAoZCkgPyBkLmltYWdlc19zZXQgOiB1bmRlZmluZWRcblxuICAgICAgaWYgKGltYWdlc19zZXQgJiYgaW1hZ2VzX3NldC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmVDb3VudCA9IGltYWdlc19zZXQubGVuZ3RoICsgMVxuICAgICAgICBsZXQgaWQgPSAoaXRlbS5pZCkgPyBwYXJzZUludChpdGVtLmlkLnN1YnN0cihpdGVtLmlkLmxlbmd0aCAtIDYpLCAxNikgJSB0ZXh0dXJlQ291bnQgOiAxMTExMTExMTExMTExMTExMTFcbiAgICAgICAgbGV0IHRhaWwgPSBpZCAlIGltYWdlc19zZXQubGVuZ3RoICsgMTtcbiAgICAgICAgbGV0IGltYWdlT2JqID0gaW1hZ2VzX3NldC5maW5kKGZ1bmN0aW9uKGkpe1xuICAgICAgICAgIHJldHVybiBpLmRmdF90ZXh0ID09PSAnaW1nXycrdGFpbDtcbiAgICAgICAgfSlcbiAgICAgICAgaW1hZ2UgPSBpbWFnZU9iai5zcmNfaW1hZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlID0gYC9zdGF0aWMvaWxsdXN0cmF0aW9ucy90ZXh0dXJlcy9tZWRpdW1fZmljaGVfJHsgKHBhcnNlSW50KGlkLnN1YnN0cihpZC5sZW5ndGggLSA2KSwgMTYpJXRleHR1cmVDb3VudCkgKyAxfS5wbmdgXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiZ2V0SW1hZ2VVcmwgLSBpbWFnZSAoQikgOiBcIiwgaW1hZ2UpXG4gICAgcmV0dXJuIGltYWdlXG4gIH1cblxuLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLy9cbi8vIEJST0FERVIgQ09ORklHIEdFVFRFUlNcbi8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC8vXG5cblxuLy8gVVNFUi1SRUxBVEVEIC8gQkFDS09GRklDRSBHRVRURVJTXG4vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAvL1xuICBjb25zdCBnZXRDb25maXJtVG9rZW5Db25maWcgPSAoc3RhdGUpID0+IHtcbiAgICByZXR1cm4gc3RhdGUuY29uZmlnLmVuZHBvaW50cy5maW5kKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiByLmZpZWxkID09PSAnYXBwX2RhdGFfQVBJX3VzZXJfYXV0aCdcbiAgICB9KTtcbiAgfVxuICBjb25zdCBnZXRDaGVja1VzZXJSb2xlID0gKHN0YXRlLCBnZXR0ZXJzKSA9PiAocm9sZVRvQ2hlY2spID0+IHtcbiAgICBjb25zdCB1c2VyID0gc3RhdGUudXNlclxuICAgIGNvbnN0IHVzZXJSb2xlID0gdXNlci5yb2xlIC8vIHJvbGUgZnJvbSBhdXRoIGNvbmZpcm0gYWNjZXNzIHJlc3BvbnNlXG4gICAgY29uc3QgYXV0aENvbmZpZyA9IGdldHRlcnMuZ2V0Q29uZmlybVRva2VuQ29uZmlnIFxuICAgIGNvbnN0IHJvbGVVc2VyVG9DaGVjayA9IGF1dGhDb25maWcucm9sZXNbcm9sZVRvQ2hlY2tdWydyZXNwX3JvbGUnXSAvLyByb2xlIGNvcnJlc3BvbmRpbmcgdG8gcm9sZVRvQ2hlY2tcbiAgICByZXR1cm4gcm9sZVVzZXJUb0NoZWNrID09PSB1c2VyUm9sZVxuICB9XG4gIGNvbnN0IGdldEVuZHBvaW50Q29uZmlnQXV0aFVzZXJzID0gc3RhdGUgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiZ2V0RW5kcG9pbnRDb25maWdBdXRoVXNlcnMuLi5cIilcbiAgICByZXR1cm4gc3RhdGUuY29uZmlnLmVuZHBvaW50cy5maWx0ZXIoZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHIuZGF0YV90eXBlID09PSBcInVzZXJcIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGdldEVuZHBvaW50Q29uZmlnQXV0aFNwZWNpZmljID0gKHN0YXRlLCBnZXR0ZXJzKSA9PiAoZW5kcG9pbnRUeXBlKSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coXCJnZXRFbmRwb2ludENvbmZpZ0F1dGhTcGVjaWZpYyAvIGVuZHBvaW50VHlwZSA6IFwiLCBlbmRwb2ludFR5cGUpXG4gICAgbGV0IGFsbEF1dGhFbmRwb2ludHMgPSAgZ2V0dGVycy5nZXRFbmRwb2ludENvbmZpZ0F1dGhVc2Vyc1xuICAgIC8vIGNvbnNvbGUubG9nKFwiZ2V0RW5kcG9pbnRDb25maWdBdXRoU3BlY2lmaWMgLyBhbGxBdXRoRW5kcG9pbnRzXCIsIGFsbEF1dGhFbmRwb2ludHMpXG4gICAgcmV0dXJuIGFsbEF1dGhFbmRwb2ludHMuZmluZChmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gci5lbmRwb2ludF90eXBlID09PSBlbmRwb2ludFR5cGVcbiAgICB9KTtcbiAgfVxuICBjb25zdCBnZXRFbmRwb2ludENvbmZpZyA9IHN0YXRlID0+IHtcbiAgICByZXR1cm4gc3RhdGUuY29uZmlnLmVuZHBvaW50cy5maW5kKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiByLmVuZHBvaW50X3R5cGUgPT09IHN0YXRlLnNlYXJjaC5lbmRwb2ludF90eXBlXG4gICAgICAmJiByLmRhdGFzZXRfdXJpID09PSBzdGF0ZS5zZWFyY2guZGF0YXNldF91cmk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZ2V0RW5kcG9pbnRDb25maWdGaWx0ZXJzID0gc3RhdGUgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiZ2V0RW5kcG9pbnRDb25maWdGaWx0ZXJzIC0gc3RhdGUuY29uZmlnLmVuZHBvaW50cyA6IFxcblwiLCBzdGF0ZS5jb25maWcuZW5kcG9pbnRzKVxuICAgIHJldHVybiBzdGF0ZS5jb25maWcuZW5kcG9pbnRzLmZpbmQoZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHIuZW5kcG9pbnRfdHlwZSA9PT0gJ2ZpbHRlcnMnXG4gICAgICAmJiByLmRhdGFzZXRfdXJpID09PSBzdGF0ZS5zZWFyY2guZGF0YXNldF91cmk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZ2V0RW5kcG9pbnRDb25maWdMaXN0ID0gc3RhdGUgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiZ2V0RW5kcG9pbnRDb25maWdMaXN0IC0gc3RhdGUuY29uZmlnLmVuZHBvaW50cyA6IFxcblwiLCBzdGF0ZS5jb25maWcuZW5kcG9pbnRzKVxuICAgIHJldHVybiBzdGF0ZS5jb25maWcuZW5kcG9pbnRzLmZpbmQoZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHIuZW5kcG9pbnRfdHlwZSA9PT0gJ2xpc3QnXG4gICAgICAmJiByLmRhdGFzZXRfdXJpID09PSBzdGF0ZS5zZWFyY2guZGF0YXNldF91cmk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZ2V0RW5kcG9pbnRDb25maWdNYXAgPSBzdGF0ZSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coXCJnZXRFbmRwb2ludENvbmZpZ01hcCAtIHN0YXRlLmNvbmZpZy5lbmRwb2ludHMgOiBcXG5cIiwgc3RhdGUuY29uZmlnLmVuZHBvaW50cylcbiAgICByZXR1cm4gc3RhdGUuY29uZmlnLmVuZHBvaW50cy5maW5kKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiByLmVuZHBvaW50X3R5cGUgPT09ICdtYXAnXG4gICAgICAmJiByLmRhdGFzZXRfdXJpID09PSBzdGF0ZS5zZWFyY2guZGF0YXNldF91cmk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZ2V0RW5kcG9pbnRDb25maWdEZXRhaWwgPSBzdGF0ZSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coXCJnZXRFbmRwb2ludENvbmZpZ0RldGFpbCAtIHN0YXRlLmNvbmZpZy5lbmRwb2ludHMgOiBcXG5cIiwgc3RhdGUuY29uZmlnLmVuZHBvaW50cylcbiAgICByZXR1cm4gc3RhdGUuY29uZmlnLmVuZHBvaW50cy5maW5kKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiByLmVuZHBvaW50X3R5cGUgPT09ICdkZXRhaWwnXG4gICAgICAmJiByLmRhdGFzZXRfdXJpID09PSBzdGF0ZS5zZWFyY2guZGF0YXNldF91cmk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZ2V0RW5kcG9pbnRDb25maWdTdGF0ID0gc3RhdGUgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiZ2V0RW5kcG9pbnRDb25maWdTdGF0IC0gc3RhdGUuY29uZmlnLmVuZHBvaW50cyA6IFxcblwiLCBzdGF0ZS5jb25maWcuZW5kcG9pbnRzKVxuICAgIHJldHVybiBzdGF0ZS5jb25maWcuZW5kcG9pbnRzLmZpbmQoZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHIuZW5kcG9pbnRfdHlwZSA9PT0gJ3N0YXQnXG4gICAgICAmJiByLmRhdGFzZXRfdXJpID09PSBzdGF0ZS5zZWFyY2guZGF0YXNldF91cmk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZ2V0U2VsZWN0ZWRGaWx0ZXJzID0gc3RhdGUgPT4ge1xuICAgIHJldHVybiBzdGF0ZS5zZWFyY2gucXVlc3Rpb24uc2VsZWN0ZWRGaWx0ZXJzXG4gIH1cblxuLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLy9cbi8vIEZJTkFMTFkgRVhQT1JUIEdFVFRFUlNcbi8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC8vXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBnZXRUcmFuc2xhdGlvbixcbiAgICBnZXROYXZiYXJWaXNpYmlsaXR5LFxuICAgIFxuICAgIGdldEFwaXZpekZyb250VVVJRCxcbiAgICBnZXRSdW5Nb2RlLFxuICAgIGdldFJvb3RVcmxCYWNrZW5kLFxuICAgIGdldFJvb3RVcmxBdXRoLFxuICAgIC8vIGdldFJvb3RVcmxVc2VyLFxuXG4gICAgZ2V0U2VhcmNoQ29uZmlnQ29sdW1uQ291bnQsXG4gICAgZ2V0U2VhcmNoQ29uZmlnRGVmYXVsdFNob3dDb3VudCxcbiAgICBnZXRTZWFyY2hDb25maWdNb3JlUHJvamVjdE9uU2Nyb2xsQ291bnQsXG4gICAgZ2V0U2VhcmNoQ29uZmlnU2Nyb2xsQmVmb3JlQm90dG9tVHJpZ2dlcixcblxuICAgIGdldEdsb2JhbENvbmZpZyxcbiAgICBnZXRTdHlsZXNDb25maWcsXG4gICAgZ2V0U29jaWFsc0NvbmZpZyxcblxuICAgIGdldE5hdmJhckNvbmZpZyxcbiAgICBnZXRGb290ZXJDb25maWcsXG4gICAgXG4gICAgZ2V0RW5kcG9pbnRDb25maWcsXG4gICAgZ2V0Q3VycmVudFJvdXRlQ29uZmlnLFxuICAgIGdldFJvdXRlQ29uZmlnTGlzdEZvckRhdGFzZXQsXG4gICAgZ2V0Um91dGVDb25maWdNYXBGb3JEYXRhc2V0LFxuICAgIGdldFJvdXRlQ29uZmlnU3RhdEZvckRhdGFzZXQsXG4gICAgZ2V0Um91dGVDb25maWdEZWZhdWx0RGF0YXNldEltYWdlcyxcbiAgICBnZXRTZWFyY2hEYXRhc2V0VVJJLFxuICAgIFxuICAgIGdldENvbmZpcm1Ub2tlbkNvbmZpZywgXG4gICAgZ2V0Q2hlY2tVc2VyUm9sZSxcbiAgICBcbiAgICBnZXRFbmRwb2ludENvbmZpZ0F1dGhVc2VycyxcbiAgICBnZXRFbmRwb2ludENvbmZpZ0F1dGhTcGVjaWZpYyxcblxuICAgIGdldEVuZHBvaW50Q29uZmlnRmlsdGVycyxcbiAgICBnZXRFbmRwb2ludENvbmZpZ0xpc3QsXG4gICAgZ2V0RW5kcG9pbnRDb25maWdNYXAsXG4gICAgZ2V0RW5kcG9pbnRDb25maWdEZXRhaWwsXG4gICAgZ2V0RW5kcG9pbnRDb25maWdTdGF0LFxuXG4gICAgZGVmYXVsdFRleHQsXG5cbiAgICBnZXRSZXN1bHRzLFxuICAgIGdldEdlb1Jlc3VsdHMsXG4gICAgZ2V0UHJvamVjdENvbmZpZyxcbiAgICBnZXRQcm9qZWN0Q29uZmlnVW5pZm9ybSxcbiAgICBnZXRJbWdVcmwsXG4gICAgZ2V0SW1hZ2VVcmwsXG5cbiAgICBnZXRTZWxlY3RlZEZpbHRlcnMsXG5cbiAgfTtcbiIsImltcG9ydCB7IGFwaXZpekZyb250VVVJRCwgYXBpQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2FwaS5qcyc7XG5pbXBvcnQgeyBtYWtlRW1wdHlTZWxlY3RlZEZpbHRlcnMgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvLyBBUFAgVVVJRCwgQVBQIE1PREUsIEFORCBST09UIFVSTCBCQUNLRU5EXG5cbiAgc2V0QXBpdml6RnJvbnRVVUlEIChzdGF0ZSl7XG4gICAgLy8gY29uc29sZS5sb2coXCJcXG49PT0gc2V0QXBpdml6RnJvbnRVVUlEIC8gYXBpdml6RnJvbnRVVUlEIDogXCIsIGFwaXZpekZyb250VVVJRCApXG4gICAgc3RhdGUuYXBpdml6RnJvbnRVVUlEID0gYXBpdml6RnJvbnRVVUlELmFwaXZpel9mcm9udF91dWlkXG4gIH0sXG5cbiAgc2V0UnVuTW9kZSggc3RhdGUsIHJ1bk1vZGUgKXtcbiAgICAvLyBjb25zb2xlLmxvZyhcIlxcbj09PSBzZXRSdW5Nb2RlIC8gcnVuTW9kZSA6IFwiLCBydW5Nb2RlIClcbiAgICBzdGF0ZS5ydW5Nb2RlID0gcnVuTW9kZVxuICAgIC8vIGNvbnNvbGUubG9nKFwiPT09IHNldFJ1bk1vZGUgLyBhcGlDb25maWcgOiBcXG4gXCIsIGFwaUNvbmZpZyApXG4gICAgY29uc3Qgcm9vdHMgPSBhcGlDb25maWdbcnVuTW9kZV1cbiAgICBzdGF0ZS5yb290VXJsQmFja2VuZCA9IHJvb3RzLnJvb3RVUkxcblxuICAgIC8vIFRPIERPIC0tPiBjaGVjayBpbiBjb25maWcgd2hpY2ggYXV0aFVSTCBhbmQgXG4gICAgLy8gc3RhdGUucm9vdFVybEF1dGggPSByb290cy5hdXRoVVJMXG4gICAgLy8gc3RhdGUucm9vdFVybFVzZXIgPSByb290cy51c2VyVVJMXG4gIH0sXG4gIHNldEF1dGhVcmxSb290KCBzdGF0ZSwgdXJsUm9vdCApe1xuICAgIHN0YXRlLnJvb3RVcmxBdXRoID0gdXJsUm9vdFxuICB9LFxuXG4gIC8vIFVYIE9QVElPTlMtUkVMQVRFRFxuICBkaXNhYmxlQmFubmVycyhzdGF0ZSl7XG4gICAgc3RhdGUuYmFubmVyVmlzaWJsZSA9IGZhbHNlXG4gIH0sXG4gIHN3aXRjaE5hdmJhck1lbnUoc3RhdGUpe1xuICAgIHN0YXRlLnNob3dOYXYgPSAhc3RhdGUuc2hvd05hdlxuICB9LFxuXG4gIC8vIEZJTFRFUlMtUkVMQVRFRFxuICBzZXREYXRhc2V0RmlsdGVycyhzdGF0ZSwgZGF0YXNldEZpbHRlciApe1xuICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuPT09IHNldERhdGFzZXRGaWx0ZXJzIC8gZGF0YXNldEZpbHRlciA6IFwiLCBkYXRhc2V0RmlsdGVyIClcbiAgICBjb25zdCBmaWx0ZXJPcHRpb25zID0gZGF0YXNldEZpbHRlci5maWx0ZXJfb3B0aW9uc1xuICAgIC8vIGNvbnNvbGUubG9nKFwiPT09IHNldERhdGFzZXRGaWx0ZXJzIC8gZmlsdGVyT3B0aW9ucyA6IFwiLCBmaWx0ZXJPcHRpb25zIClcbiAgICBzdGF0ZS5kYXRhc2V0RmlsdGVycyA9IGZpbHRlck9wdGlvbnNcbiAgfSxcbiAgXG4gIC8vIFNFQVJDSC1SRUxBVEVEXG4gIHNldERhdGFzZXRVUkkoc3RhdGUsIGRhdGFzZXRVUkkpe1xuICAgIHN0YXRlLnNlYXJjaC5kYXRhc2V0X3VyaSA9IGRhdGFzZXRVUklcbiAgfSxcbiAgc2V0SXNNYXBTZWFyY2ggKHN0YXRlLCByb3V0ZUNvbmZpZykge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuPT09IHNldElzTWFwU2VhcmNoIC8gcm91dGVDb25maWcgOiBcIiwgcm91dGVDb25maWcgKVxuICAgIHN0YXRlLnNlYXJjaC5xdWVzdGlvbi5mb3JNYXAgPSAoIHJvdXRlQ29uZmlnLmR5bmFtaWNfdGVtcGxhdGUgPT09ICdEeW5hbWljTWFwJyApID8gdHJ1ZSA6IGZhbHNlXG4gICAgLy8gY29uc29sZS5sb2coXCI9PT0gc2V0SXNNYXBTZWFyY2ggLyBzdGF0ZS5zZWFyY2ggOiBcIiwgc3RhdGUuc2VhcmNoIClcbiAgfSxcbiAgc2V0U2VhcmNoZWRUZXh0IChzdGF0ZSwge3NlYXJjaGVkVGV4dH0pIHtcbiAgICBzdGF0ZS5zZWFyY2gucXVlc3Rpb24ucXVlcnkgPSBzZWFyY2hlZFRleHRcbiAgfSxcbiAgc2V0U2VsZWN0ZWRGaWx0ZXJzIChzdGF0ZSwge3NlbGVjdGVkRmlsdGVyc30pIHtcbiAgICAvLyB0cmlnZ2VyIHJlLXJlbmRlclxuICAgIHN0YXRlLnNlYXJjaC5xdWVzdGlvbi5zZWxlY3RlZEZpbHRlcnMgPSBuZXcgTWFwKHNlbGVjdGVkRmlsdGVycylcbiAgfSxcbiAgc2V0RmlsdGVyRGVzY3JpcHRpb25zIChzdGF0ZSwgZmlsdGVyRGVzY3JpcHRpb25zKSB7XG4gICAgc3RhdGUuZmlsdGVyRGVzY3JpcHRpb25zID0gZmlsdGVyRGVzY3JpcHRpb25zXG4gIH0sXG4gIGVtcHR5T25lRmlsdGVyIChzdGF0ZSwge2ZpbHRlcn0pIHtcbiAgICBzdGF0ZS5zZWFyY2gucXVlc3Rpb24uc2VsZWN0ZWRGaWx0ZXJzLnNldChmaWx0ZXIsIG5ldyBTZXQoKSlcblxuICAgIC8vIHRyaWdnZXIgcmUtcmVuZGVyXG4gICAgc3RhdGUuc2VhcmNoLnF1ZXN0aW9uLnNlbGVjdGVkRmlsdGVycyA9IG5ldyBNYXAoc3RhdGUuc2VhcmNoLnF1ZXN0aW9uLnNlbGVjdGVkRmlsdGVycylcbiAgfSxcbiAgY2xlYXJBbGxGaWx0ZXJzKHN0YXRlKXtcbiAgICBzdGF0ZS5zZWFyY2gucXVlc3Rpb24uc2VsZWN0ZWRGaWx0ZXJzID0gbWFrZUVtcHR5U2VsZWN0ZWRGaWx0ZXJzKHN0YXRlLmZpbHRlckRlc2NyaXB0aW9ucylcbiAgfSxcbiAgc2V0U2VhcmNoUGFyYW0oc3RhdGUse3R5cGUscmVzdWx0fSl7XG4gICAgLy8gY29uc29sZS5sb2coXCJcXG49PSBzZXRTZWFyY2hQYXJhbSAvIHN0YXRlLnNlYXJjaCA6IFwiLCBzdGF0ZS5zZWFyY2gpXG4gICAgLy8gY29uc29sZS5sb2coXCI9PSBzZXRTZWFyY2hQYXJhbSAvIHR5cGUgOiBcIiwgdHlwZSlcbiAgICAvLyBjb25zb2xlLmxvZyhcIj09IHNldFNlYXJjaFBhcmFtIC8gcmVzdWx0IDogXCIsIHJlc3VsdClcbiAgICBzdGF0ZS5zZWFyY2hbdHlwZV0gPSByZXN1bHRcbiAgfSxcbiAgc2V0U2VhcmNoQ29uZmlnKHN0YXRlLCB7dHlwZSxyZXN1bHR9KSB7XG4gICAgc3RhdGUuc2VhcmNoLmNvbmZpZ1t0eXBlXSA9IHJlc3VsdFxuICB9LFxuXG4gIC8vIFJFU1VMVFMtUkVMQVRFRFxuICBzZXRTZWFyY2hSZXN1bHQoc3RhdGUsIHtyZXN1bHR9KXtcbiAgICAvLyBjb25zb2xlLmxvZyhcIj09IHNldFNlYXJjaFJlc3VsdCAvIHJlc3VsdCA6IFwiLCByZXN1bHQpXG4gICAgc3RhdGUuc2VhcmNoLmFuc3dlciA9IHtcbiAgICAgIHBlbmRpbmdBYm9ydDogdW5kZWZpbmVkLFxuICAgICAgcmVzdWx0LFxuICAgICAgLy8gcmVzdWx0TWFwOiB1bmRlZmluZWQsXG4gICAgICBlcnJvcjogdW5kZWZpbmVkXG4gICAgfVxuICB9LFxuICAvLyBzZXRTZWFyY2hSZXN1bHRNYXAoc3RhdGUsIHtyZXN1bHRNYXB9KXtcbiAgLy8gICBjb25zb2xlLmxvZyhcIj09IHNldFNlYXJjaFJlc3VsdE1hcCAvIHJlc3VsdE1hcCA6IFwiLCByZXN1bHRNYXApXG4gIC8vICAgc3RhdGUuc2VhcmNoLmFuc3dlciA9IHtcbiAgLy8gICAgIHBlbmRpbmdBYm9ydDogdW5kZWZpbmVkLFxuICAvLyAgICAgcmVzdWx0OnVuZGVmaW5lZCxcbiAgLy8gICAgIC8vIHJlc3VsdE1hcCxcbiAgLy8gICAgIGVycm9yOiB1bmRlZmluZWRcbiAgLy8gICB9XG4gIC8vIH0sXG4gIHNldFNlYXJjaFBlbmRpbmcoc3RhdGUsIHtwZW5kaW5nQWJvcnR9KXtcbiAgICBzdGF0ZS5zZWFyY2guYW5zd2VyID0ge1xuICAgICAgcGVuZGluZ0Fib3J0LFxuICAgICAgcmVzdWx0OiB1bmRlZmluZWQsXG4gICAgICAvLyByZXN1bHRNYXA6IHVuZGVmaW5lZCxcbiAgICAgIGVycm9yOiB1bmRlZmluZWRcbiAgICB9XG4gIH0sXG4gIHNldFNlYXJjaEVycm9yKHN0YXRlLCB7ZXJyb3J9KXtcbiAgICBjb25zb2xlLmVycm9yKCdzZWFyY2ggZXJyb3InLCBlcnJvcilcbiAgICBzdGF0ZS5zZWFyY2guYW5zd2VyID0ge1xuICAgICAgcGVuZGluZ0Fib3J0OiB1bmRlZmluZWQsXG4gICAgICByZXN1bHQ6IHVuZGVmaW5lZCxcbiAgICAgIC8vIHJlc3VsdE1hcDogdW5kZWZpbmVkLFxuICAgICAgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgc2V0RGlzcGxheWVkUHJvamVjdChzdGF0ZSwge3Byb2plY3R9KXtcbiAgICBzdGF0ZS5kaXNwbGF5ZWRQcm9qZWN0ID0gcHJvamVjdDtcbiAgfSxcblxuXG4gIC8vIEdFT0xPQ1xuICBhZGRHZW9sb2NzKHN0YXRlLCB7Z2VvbG9jQnlQcm9qZWN0SWR9KXtcbiAgICBzdGF0ZS5nZW9sb2NCeVByb2plY3RJZCA9IG5ldyBNYXAoWy4uLnN0YXRlLmdlb2xvY0J5UHJvamVjdElkLCAuLi5nZW9sb2NCeVByb2plY3RJZF0pXG4gIH0sXG5cbiAgLy8gQ09ORklHXG4gIHNldENvbmZpZyhzdGF0ZSwge3R5cGUscmVzdWx0fSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwicmVzdWx0IDogXCIsIHJlc3VsdClcbiAgICBzdGF0ZS5jb25maWdbdHlwZV0gPSByZXN1bHRcbiAgfSxcblxuICAvLyBVU0VSLVJFTEFURURcbiAgc2V0VG9rZW5zIChzdGF0ZSwge3Rva2Vuc30gKSB7XG4gICAgY29uc29sZS5sb2coJ3Rva2VucyA6ICcsIHRva2VucylcbiAgICAvLyBzdGF0ZS5qd3QgPSAodG9rZW5zICYmIHRva2Vucy5hY2Nlc3NfdG9rZW4gJiYgdG9rZW5zLnJlZnJlc2hfdG9rZW4pID8gdG9rZW5zIDogdW5kZWZpbmVkXG4gICAgc3RhdGUuand0ID0gdG9rZW5zXG4gICAgY29uc29sZS5sb2coJ3N0YXRlLmp3dCA6ICcsIHN0YXRlLmp3dClcbiAgfSxcbiAgc2V0SW5mb3MgKHN0YXRlLCB7aW5mb3N9KSB7XG4gICAgc3RhdGUudXNlci5pbmZvcyA9IChpbmZvcyAmJiBpbmZvcy5lbWFpbCkgPyBpbmZvcyA6IHVuZGVmaW5lZFxuICAgIHN0YXRlLnVzZXIuaXNMb2dnZWRpbiA9IChpbmZvcyAmJiBpbmZvcy5lbWFpbCkgPyB0cnVlIDogZmFsc2VcbiAgfSxcbiAgc2V0Um9sZSAoc3RhdGUsIHtyb2xlfSkge1xuICAgIHN0YXRlLnVzZXIucm9sZSA9ICh0eXBlb2Ygcm9sZSA9PT0gJ3N0cmluZycpID8gcm9sZSA6IHVuZGVmaW5lZFxuICB9LFxuXG5cbn1cbiIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBWdWV4IGZyb20gJ3Z1ZXgnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuaW1wb3J0IGdldHRlcnMgZnJvbSAnLi9nZXR0ZXJzJztcbmltcG9ydCBhY3Rpb25zIGZyb20gJy4vYWN0aW9ucyc7XG5pbXBvcnQgbXV0YXRpb25zIGZyb20gJy4vbXV0YXRpb25zJztcblxuVnVlLnVzZShWdWV4KVxuXG4vLyBNQUlOIFNUT1JFXG5jb25zdCBzdG9yZUdlbmVyYXRvciA9IG5ldyBWdWV4LlN0b3JlKHtcbiAgc3RyaWN0OiB0cnVlLFxuXG4gIHN0YXRlOiB7XG5cbiAgICAvLyBBUElWSVogRlJPTlRFTkQgVVVJRFxuICAgIGFwaXZpekZyb250VVVJRCA6IHVuZGVmaW5lZCxcblxuICAgIC8vIEFQUCBNT0RFIDogZGVmYXVsdCB8IHByZXByb2QgfCBwcm9kXG4gICAgcnVuTW9kZSA6IHVuZGVmaW5lZCxcbiAgICByb290VXJsQmFja2VuZCA6IHVuZGVmaW5lZCxcbiAgICByb290VXJsQXV0aCA6IHVuZGVmaW5lZCxcbiAgICAvLyByb290VXJsVXNlciA6IHVuZGVmaW5lZCxcblxuICAgIC8vIFVYIE9QVElPTlNcbiAgICBzaG93TmF2IDogZmFsc2UsXG4gICAgYmFubmVyVmlzaWJsZSA6IHRydWUsXG4gICAgXG4gICAgLy8gRk9SIFRSQU5TTEFUSU9OU1xuICAgIGxvY2FsZTogJ2ZyJyxcblxuICAgIC8vIFVTRVItUkVMQVRFRFxuICAgIHVzZXIgOiB7XG4gICAgICBpbmZvczogdW5kZWZpbmVkLFxuICAgICAgcm9sZTogdW5kZWZpbmVkLFxuICAgICAgaXNMb2dnZWRpbjogZmFsc2VcbiAgICB9LFxuICAgIGp3dCA6IHVuZGVmaW5lZCxcblxuICAgIC8vIExFR0FDWVxuICAgIGdlb2xvY0J5UHJvamVjdElkOiBuZXcgTWFwKCksXG5cbiAgICAvLyBDVVJSRU5UXG4gICAgZGlzcGxheWVkUHJvamVjdDogdW5kZWZpbmVkLFxuXG4gICAgLy8gRklMVEVSU1xuICAgIGZpbHRlckRlc2NyaXB0aW9uczogdW5kZWZpbmVkLFxuICAgIGRhdGFzZXRGaWx0ZXJzOiB1bmRlZmluZWQsXG5cbiAgICAvLyBBUElWSVogQ09ORklHXG4gICAgY29uZmlnOiB7fSxcblxuICAgIC8vIFNFQVJDSCBQQVJBTUVURVJTXG4gICAgc2VhcmNoOiB7XG5cbiAgICAgIC8vIERBVEFTRVRcbiAgICAgIGRhdGFzZXRfdXJpOiB1bmRlZmluZWQsXG4gICAgICBlbmRwb2ludF90eXBlOiB1bmRlZmluZWQsXG4gICAgICBlbmRwb2ludDogdW5kZWZpbmVkLFxuXG4gICAgICAvLyBRVUVSWSBGUk9NIFVTRVJcbiAgICAgIHF1ZXN0aW9uOiB7XG4gICAgICAgIHF1ZXJ5OiBuZXcgVVJMKGxvY2F0aW9uKS5zZWFyY2hQYXJhbXMuZ2V0KCd0ZXh0JykgfHwgJycsXG4gICAgICAgIGZvck1hcCA6IGZhbHNlLFxuICAgICAgICBvbmx5R2VvY29kZWQgOiB0cnVlLFxuICAgICAgICBzaHVmZmxlU2VlZCA6IDEyMzQsXG4gICAgICAgIHBhZ2U6MSxcbiAgICAgICAgcGVyUGFnZToxMDAsXG4gICAgICAgIHNlbGVjdGVkRGF0YXNldEZpbHRlcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VsZWN0ZWRGaWx0ZXJzOiBuZXcgTWFwKCksXG4gICAgICB9LFxuICAgICAgLy8gUkVTVUxUU1xuICAgICAgYW5zd2VyOiB7XG4gICAgICAgIHBlbmRpbmdBYm9ydDogdW5kZWZpbmVkLCAvLyBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFib3J0IHRoZSBjdXJyZW50IHBlbmRpbmcgc2VhcmNoXG4gICAgICAgIHJlc3VsdDogdW5kZWZpbmVkLCAvLyBzZWFyY2ggcmVzdWx0cyB7cHJvamVjdHMsIHRvdGFsfVxuICAgICAgICAvLyByZXN1bHRNYXAgOiB1bmRlZmluZWQsIC8vIGNvbXBsZXRlIHNlYXJjaCByZXN1bHRzIHdpdGggbWluaW1hbCBpdGVtcyBhcyB7IF9pZCwgbGF0bG5nIH0gLS0+IHRvIGJlIGxvYWRlZCBqdXN0IG9uY2UgZm9yIGJldHRlciBleHBlcmllbmNlICsgZ2V0dGVyc1xuICAgICAgICBlcnJvcjogdW5kZWZpbmVkIC8vIGlmIGxhc3Qgc2VhcmNoIGVuZGVkIGluIGFuIGVycm9yXG4gICAgICB9LFxuICAgICAgLy8gVUkgSU4gU0VBUkNIIFBBR0VTIENPTkZJR1xuICAgICAgY29uZmlnOntcbiAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgIGNvbHVtbkNvdW50IDogdW5kZWZpbmVkLFxuICAgICAgICAgIGRlZmF1bHRTaG93Q291bnQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbW9yZVByb2plY3RPblNjcm9sbENvdW50IDogdW5kZWZpbmVkLFxuICAgICAgICAgIHNjcm9sbEJlZm9yZUJvdHRvbVRyaWdnZXIgOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBTVE9SRSBNT0RVTEVTXG4gICAgZ2V0dGVycyxcbiAgICBtdXRhdGlvbnMsXG4gICAgYWN0aW9uc1xufSlcblxuZXhwb3J0IGRlZmF1bHQgc3RvcmVHZW5lcmF0b3JcbiIsIlxuLy8gZmVhdHVyZSB0ZXN0IGZvciBBYm9ydENvbnRyb2xsZXIgdGhhdCB3b3JrcyBpbiBTYWZhcmkgMTJcbmxldCBhYm9ydGFibGVGZXRjaFN1cHBvcnRlZCA9IGZhbHNlO1xuXG50cnl7XG4gIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG5cbiAgZmV0Y2goJy4nLCB7c2lnbmFsOiBhYy5zaWduYWx9KVxuICAudGhlbihyID0+IHIudGV4dCgpKVxuICAudGhlbihyZXN1bHQgPT4ge1xuICAgIGFib3J0YWJsZUZldGNoU3VwcG9ydGVkID0gZmFsc2U7XG4gIH0pXG4gIC5jYXRjaChlcnIgPT4ge1xuICAgIGFib3J0YWJsZUZldGNoU3VwcG9ydGVkID0gZXJyLm5hbWUgPT09ICdBYm9ydEVycm9yJ1xuICB9KVxuXG4gIGFjLmFib3J0KCk7XG59XG5jYXRjaChlKXtcbiAgYWJvcnRhYmxlRmV0Y2hTdXBwb3J0ZWQgPSBmYWxzZTtcbn1cblxuLy8gRlVOQ1RJT04gVE8gUEFSU0UgQU4gT0JKRUNUIEdJVkVOIEEgUEFUSFxuZXhwb3J0IGZ1bmN0aW9uIGdldE9iamVjdERhdGFGcm9tUGF0aChvYmosIHBhdGgsIHNwbGl0dGVyPScvJykge1xuICBsZXQgY3VycmVudCA9IG9iajsgXG4gIC8vIGNvbnNvbGUubG9nKFwiKyArICsgZ2V0T2JqZWN0RGF0YUZyb21QYXRoIC8gY3VycmVudCByYXcgOiBcXG5cIiwgY3VycmVudCApXG4gIHRyeSB7XG4gICAgbGV0IGN1cnJlbnRfdGVtcCA9IGN1cnJlbnRcbiAgICBwYXRoLnNwbGl0KHNwbGl0dGVyKS5mb3JFYWNoKCBmdW5jdGlvbihwKSB7IFxuICAgICAgY3VycmVudF90ZW1wID0gY3VycmVudF90ZW1wW3BdOyBcbiAgICB9KTsgXG4gICAgLy8gY29uc29sZS5sb2coXCIrICsgKyBnZXRPYmplY3REYXRhRnJvbVBhdGggLyBjdXJyZW50IGZpbmFsIDogXFxuXCIsIGN1cnJlbnQgKVxuICAgIHJldHVybiBjdXJyZW50X3RlbXBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBcIlwiXG4gIH1cbn1cblxuLy8gRlVOQ1RJT04gVE8gR0VUIFRIRSBSVU4gTU9ERSBGUk9NIDxIRUFEPlxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbmZpZ05hbWUobWV0YU5hbWUpIHtcblxuICBjb25zdCBtZXRhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdtZXRhJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWV0YXNbaV0uZ2V0QXR0cmlidXRlKCduYW1lJykgPT09IG1ldGFOYW1lKSB7XG4gICAgICByZXR1cm4gbWV0YXNbaV0uZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuXG4vLyBzZXJ2ZXItc2lkZSBlbmQtcG9pbnQgdG8gZ2V0IG9ubHkgb25lIHByb2plY3RcbmV4cG9ydCBmdW5jdGlvbiBnZXRJdGVtQnlJZChpZCxlbmRwb2ludENvbmZpZyl7XG5cbiAgLy8gY29uc3QgdXJsID0gc2VhcmNoRW5wb2ludENyZWF0b3Ioe1xuICAvLyAgIHBhZ2U6MSxcbiAgLy8gICBwZXJfcGFnZToxLFxuICAvLyAgIGJhc2VVcmw6cm9vdF91cmwsXG4gIC8vICAgaXRlbV9pZDppZFxuICAvLyB9KVxuXG4gIGNvbnN0IHVybCA9IHNlYXJjaEVuZHBvaW50R2VuZXJhdG9yKHtcbiAgICBlbmRwb2ludENvbmZpZyA6IGVuZHBvaW50Q29uZmlnLFxuICAgIHF1ZXN0aW9uUGFyYW1zIDogeyBpdGVtSWQgOiBpZCB9LFxuICAgIHNlbGVjdGVkRmlsdGVycyA6IFtdLFxuICB9KVxuXG4gIHJldHVybiBmZXRjaCh1cmwpXG4gIC50aGVuKHIgPT4gci5qc29uKCkpXG4gIC50aGVuKCh7ZGF0YSwgcXVlcnl9KSA9PlxuICAgIGRhdGEgJiYgZGF0YS5kYXRhX3JhdyAmJiBkYXRhLmRhdGFfcmF3LmZfZGF0YSAgJiYgQXJyYXkuaXNBcnJheShkYXRhLmRhdGFfcmF3LmZfZGF0YSlcbiAgICAgID8gZGF0YS5kYXRhX3Jhdy5mX2RhdGFbMF1cbiAgICAgIDogdW5kZWZpbmVkXG4gIClcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoSXRlbXModXJsID0gdW5kZWZpbmVkKXtcblxuICAvLyBjb25zb2xlLmxvZyhcIisgKyArIHNlYXJjaEl0ZW1zIC4uLiBcIik7XG5cbiAgLy8gYWJvcnQgZmV0Y2ggaWYgdGhpcyBpcyBzdXBwb3J0ZWRcbiAgLy8gYWJvcnQgbWFudWFsbHkgd2hlbiByZXNwb25zZSBhcnJpdmVzIG90aGVyd2lzZVxuICBjb25zdCBhYyA9IGFib3J0YWJsZUZldGNoU3VwcG9ydGVkID8gbmV3IEFib3J0Q29udHJvbGxlcigpIDogdW5kZWZpbmVkXG4gIGxldCBzZWFyY2hBYm9ydGVkID0gZmFsc2VcblxuICByZXR1cm4ge1xuICAgIGFib3J0KCl7XG4gICAgICBzZWFyY2hBYm9ydGVkID0gdHJ1ZVxuICAgICAgaWYoYWMpXG4gICAgICAgICAgYWMuYWJvcnQoKVxuICAgIH0sXG4gICAgcHJvbWlzZTogKGFjID8gZmV0Y2godXJsLCB7c2lnbmFsOiBhYy5zaWduYWx9ICkgOiBmZXRjaCh1cmwpKVxuICAgIC50aGVuKHIgPT4gci5qc29uKCkpXG4gICAgLnRoZW4oKHtkYXRhLCBxdWVyeX0pID0+IHtcbiAgICAgIGlmKHNlYXJjaEFib3J0ZWQpe1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignU2VhcmNoIGFib3J0ZWQnKVxuICAgICAgICBlcnJvci5uYW1lID0gJ0Fib3J0RXJyb3InXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBlbHNle1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIisgKyArIHNlYXJjaEl0ZW1zIChyZXNwb25zZSkgLyBkYXRhIDpcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJvamVjdHM6IGRhdGFcbiAgICAgICAgICAmJiBkYXRhLmRhdGFfcmF3XG4gICAgICAgICAgJiYgZGF0YS5kYXRhX3Jhdy5mX2RhdGFcbiAgICAgICAgICAmJiBBcnJheS5pc0FycmF5KGRhdGEuZGF0YV9yYXcuZl9kYXRhKVxuICAgICAgICAgID8gZGF0YS5kYXRhX3Jhdy5mX2RhdGFcbiAgICAgICAgICA6IFtdLFxuICAgICAgICAgIHRvdGFsOiAoZGF0YSAmJiBkYXRhLmRhdGFfcmF3ICYmIGRhdGEuZGF0YV9yYXcuZl9kYXRhX2NvdW50KSA/IGRhdGEuZGF0YV9yYXcuZl9kYXRhX2NvdW50IDogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICB9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaEVuZHBvaW50R2VuZXJhdG9yKG9iaikge1xuICBpZiAoIW9iaikgeyB0aHJvdyAnZXJyb3IgaW4gc2VhcmNoRW5kcG9pbnRHZW5lcmF0b3I6IG5vIHBhcmFtZXRlciBkZWZpbmVkJyB9XG5cbiAgLy8gY29uc29sZS5sb2coXCIrICsgKyBzZWFyY2hFbmRwb2ludEdlbmVyYXRvciAvIC4uLlwiKVxuICAvLyBjb25zb2xlLmxvZyhcIisgKyArIHNlYXJjaEVuZHBvaW50R2VuZXJhdG9yIC8gb2JqIDogXFxuIFwiLCBvYmopXG5cbiAgLy8gZW5kcG9pbnQgY29uZmlnIHJlbGF0ZWRcbiAgY29uc3QgZW5kcG9pbnRDb25maWcgPSBvYmouZW5kcG9pbnRDb25maWdcbiAgY29uc3QgZW5kcG9pbnRDb25maWdBcmdzID0gZW5kcG9pbnRDb25maWcuYXJnc19vcHRpb25zXG5cbiAgLy8gcXVlc3Rpb24gcmVsYXRlZFxuICBjb25zdCBxdWVzdGlvblBhcmFtcyA9IG9iai5xdWVzdGlvblBhcmFtc1xuICBjb25zdCBzZWxlY3RlZEZpbHRlcnMgPSBvYmouc2VsZWN0ZWRGaWx0ZXJzXG5cbiAgLy8gYmFzZSBxdWVyeSB0byBiZSBjb21wbGV0ZWQgd2l0aCBhcmdzICsgcXVlc3Rpb25zXG4gIGxldCBiYXNlUXVlcnkgPSBlbmRwb2ludENvbmZpZy5yb290X3VybCArICc/J1xuXG4gIGNvbnN0IGFwcEFyZ3MgPSBbJ3F1ZXJ5JywgJ2Zvck1hcCcsICdwYWdlJywgJ3BlclBhZ2UnLCAnb25seUdlb2NvZGVkJywgJ2l0ZW1JZCcsICdzaHVmZmxlU2VlZCcgXVxuICBcbiAgLy8gbG9vcCBpbiByb3V0ZUFyZ3MgKyBxdWVyaWVzIHRoZW4gYXBwZW5kIHRvIGJhc2VRdWVyeVxuICBsZXQgYXJnc0FycmF5ID0gW11cbiAgZm9yIChsZXQga2V5IGluIGVuZHBvaW50Q29uZmlnQXJncyApIHtcbiAgICBjb25zdCBFbmRwb2ludEFyZyA9IGVuZHBvaW50Q29uZmlnQXJnc1trZXldXG4gICAgLy8gY29uc29sZS5sb2coXCIrICsgKyBzZWFyY2hFbmRwb2ludEdlbmVyYXRvciAvIEVuZHBvaW50QXJnIDogXCIsIEVuZHBvaW50QXJnKVxuICAgIGlmICggIUVuZHBvaW50QXJnLm9wdGlvbmFsIHx8IGFwcEFyZ3MuaW5kZXhPZihFbmRwb2ludEFyZy5hcHBfYXJnKSAhPT0gLTEgKXtcbiAgICAgIGlmICggcXVlc3Rpb25QYXJhbXNbRW5kcG9pbnRBcmcuYXBwX2FyZ10gKSB7XG4gICAgICAgIGxldCBhcmdTdHJpbmcgPSBFbmRwb2ludEFyZy5hcmcgKyAnPScgKyBxdWVzdGlvblBhcmFtc1tFbmRwb2ludEFyZy5hcHBfYXJnXVxuICAgICAgICBhcmdzQXJyYXkucHVzaChhcmdTdHJpbmcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbG9vcCBpbiBzZWxlY3RlZEZpbHRlcnMgdG8gYWRkIGZpbHRlcnMgcmVxdWVzdCBpZiBhbnlcbiAgLy8gZmluZCBjb3JyZXNwb25kaW5nIG1hcHBlciBpbiBlbmRQb2ludENvbmZpZ1xuICBjb25zdCBmaWx0ZXJNYXBwZXIgPSBlbmRwb2ludENvbmZpZ0FyZ3MuZmluZCggYyA9PiBjLmFwcF9hcmcgPT09ICdmaWx0ZXJzJylcbiAgLy8gY29uc29sZS5sb2coXCIrICsgKyBzZWFyY2hFbmRwb2ludEdlbmVyYXRvciAvIGZpbHRlck1hcHBlciA6IFxcbiBcIiwgZmlsdGVyTWFwcGVyKVxuICBpZiAoZmlsdGVyTWFwcGVyICYmIHNlbGVjdGVkRmlsdGVycy5sZW5ndGggPiAwICl7XG4gICAgY29uc3QgRW5kcG9pbnRBcmcgPSBmaWx0ZXJNYXBwZXIuYXJnXG4gICAgZm9yIChsZXQgaW5kZXggaW4gc2VsZWN0ZWRGaWx0ZXJzKSB7XG4gICAgICBsZXQgYXJnRmlsdGVyU3RyaW5nID0gRW5kcG9pbnRBcmcgKyAnPScgKyBzZWxlY3RlZEZpbHRlcnNbaW5kZXhdXG4gICAgICBhcmdzQXJyYXkucHVzaChhcmdGaWx0ZXJTdHJpbmcpXG4gICAgfVxuICB9XG5cbiAgbGV0IGFyZ3NMb25nU3RyaW5nID0gYXJnc0FycmF5LmpvaW4oJyYnKVxuICBiYXNlUXVlcnkgKz0gYXJnc0xvbmdTdHJpbmdcblxuXG4gIC8vIGNvbnNvbGUubG9nKFwiKyArICsgc2VhcmNoRW5kcG9pbnRHZW5lcmF0b3IgLyBiYXNlUXVlcnkgOiBcXG4gXCIsIGJhc2VRdWVyeSlcblxuICByZXR1cm4gYmFzZVF1ZXJ5XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBzZWFyY2hFbnBvaW50Q3JlYXRvcihvYmope1xuXG4vLyAgIC8vICh0ZXh0LCB0YWdzLCBwYWdlPTEsIHBlcl9wYWdlPTEwMCwgYmFzZVVybCA9IGAke0FQSVNlYXJjaE9yaWdpbn1gLCB0b2tlbiA9IHVuZGVmaW5lZCApe1xuLy8gICBpZiAoIW9iaikgeyB0aHJvdyAnZXJyb3IgaW4gc2VhcmNoRW5wb2ludENyZWF0b3I6IG5vIHBhcmFtZXRlciBkZWZpbmVkJyB9XG5cbi8vICAgLy8gY29uc29sZS5sb2coXCIrICsgKyBzZWFyY2hFbnBvaW50Q3JlYXRvciAvIC4uLlwiKVxuLy8gICBjb25zb2xlLmxvZyhcIisgKyArIHNlYXJjaEVucG9pbnRDcmVhdG9yIC8gb2JqIDogXFxuIFwiLCBvYmopXG5cbi8vICAgLy8gdGhlIGZpcnN0IGFyZ3VtZW50OiBubyAmIGF0IHRoZSBiZWdpbmluZ1xuLy8gICBjb25zdCBwYWdlQXJnID0gKHR5cGVvZiBvYmoucGFnZSA9PSAnbnVtYmVyJykgPyAncGFnZT0nK29iai5wYWdlIDogJ3BhZ2U9MSc7XG5cbi8vICAgLy8gdGhlbiBjb21lIHRoZSBvdGhlciBhcmd1bWVudHNcbi8vICAgY29uc3Qgc2VhcmNoQXJnID0gKHR5cGVvZiBvYmouc2VhcmNoID09PSAnc3RyaW5nJyAmJiBvYmouc2VhcmNoLmxlbmd0aCA+PSAxKSA/ICcmc2VhcmNoX2Zvcj0nK2VuY29kZVVSSUNvbXBvbmVudCggb2JqLnNlYXJjaC50cmltKCkgKSA6ICcnO1xuLy8gICBjb25zdCBzaHVmZmxlX3NlZWRBcmcgPSAodHlwZW9mIG9iai5zaHVmZmxlX3NlZWQgPT0gJ251bWJlcicpID8gJyZzaHVmZmxlX3NlZWQ9JytvYmouc2h1ZmZsZV9zZWVkIDogJyZzaHVmZmxlX3NlZWQ9JyArIE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgKyAxKSA7XG4vLyAgIGNvbnN0IHRhZ3NBcmcgPSAob2JqLnRhZ3MgJiYgb2JqLnRhZ3Muc2l6ZSA+PSAxKSA/IGAmc2VhcmNoX2luX3RhZ3M9JHtlbmNvZGVVUklDb21wb25lbnQoWy4uLm9iai50YWdzXS5qb2luKCcsJykpfWAgOiAnJztcbi8vICAgY29uc3QgdG9rZW5BcmcgPSAob2JqLnRva2VuKSA/IGAmdG9rZW49JHtlbmNvZGVVUklDb21wb25lbnQob2JqLnRva2VuKX1gIDogJydcblxuLy8gICAvL2lmIG5vbmUsIGRlZmF1bHQgdmFsdWUgcHJvdmlkZWQgKG90aGVyd2lzZSB0aGUgYmFja2VuZCB3aWxsIHByb3ZpZGUgYW55d2F5KVxuLy8gICBjb25zdCBwZXJfcGFnZUFyZyA9ICh0eXBlb2Ygb2JqLnBlcl9wYWdlID09ICdudW1iZXInKSA/ICcmcGVyX3BhZ2U9JytvYmoucGVyX3BhZ2UgOiAnJnBlcl9wYWdlPTEwMCc7XG4vLyAgIGNvbnN0IG1hcF9saXN0QXJnID0gKHR5cGVvZiBvYmoubWFwX2xpc3QgPT0gJ2Jvb2xlYW4nKSA/ICcmbWFwX2xpc3Q9JytvYmoubWFwX2xpc3QgOiAnJm1hcF9saXN0PWZhbHNlJztcbi8vICAgY29uc3QgYXNfbGF0bG5nQXJnID0gKHR5cGVvZiBvYmouYXNfbGF0bG5nID09ICdib29sZWFuJykgPyAnJmFzX2xhdGxuZz0nK29iai5hc19sYXRsbmcgOiAnJmFzX2xhdGxuZz1mYWxzZSc7XG4vLyAgIGNvbnN0IG9ubHlfZ2VvY29kZWRBcmcgPSAodHlwZW9mIG9iai5vbmx5X2dlb2NvZGVkID09ICdib29sZWFuJykgPyAnJm9ubHlfZ2VvY29kZWQ9JytvYmoub25seV9nZW9jb2RlZCA6ICcmb25seV9nZW9jb2RlZD10cnVlJztcbi8vICAgY29uc3QgZ2VvX3ByZWNpc2lvbkFyZyA9ICh0eXBlb2Ygb2JqLmdlb19wcmVjaXNpb24gPT0gJ251bWJlcicpID8gJyZnZW9fcHJlY2lzaW9uPScrb2JqLmdlb19wcmVjaXNpb24gOiAnJmdlb19wcmVjaXNpb249Nic7XG4vLyAgIGNvbnN0IGdldF9maWx0ZXJzQXJnID0gKHR5cGVvZiBvYmouZ2V0X2ZpbHRlcnMgPT0gJ2Jvb2xlYW4nKSA/ICcmZ2V0X2ZpbHRlcnM9JytvYmouZ2V0X2ZpbHRlcnMgOiAnJmdldF9maWx0ZXJzPWZhbHNlJztcbi8vICAgY29uc3QgaXNfY29tcGxldGVBcmcgPSAodHlwZW9mIG9iai5pc19jb21wbGV0ZSA9PSAnYm9vbGVhbicpID8gJyZpc19jb21wbGV0ZT0nK29iai5pc19jb21wbGV0ZSA6ICcmaXNfY29tcGxldGU9ZmFsc2UnO1xuLy8gICBjb25zdCBvbmx5X3N0YXRzQXJnID0gKHR5cGVvZiBvYmoub25seV9zdGF0cyA9PSAnYm9vbGVhbicpID8gJyZvbmx5X3N0YXRzPScrb2JqLm9ubHlfc3RhdHMgOiAnJm9ubHlfc3RhdHM9ZmFsc2UnO1xuLy8gICBjb25zdCBub3JtYWxpemVBcmcgPSAodHlwZW9mIG9iai5ub3JtYWxpemUgPT0gJ2Jvb2xlYW4nKSA/ICcmbm9ybWFsaXplPScrb2JqLm5vcm1hbGl6ZSA6ICcmbm9ybWFsaXplPWZhbHNlJztcblxuLy8gICAvLyBpZiBub25lLCBkb24ndCBkb1xuLy8gICBjb25zdCBzZWFyY2hfZm9yQXJnID0gKHR5cGVvZiBvYmouc2VhcmNoX2ZvciA9PSAnc3RyaW5nJykgPyAnJnNlYXJjaF9mb3I9JytvYmouc2VhcmNoX2ZvciA6ICcnO1xuLy8gICBjb25zdCBzZWFyY2hfaW5BcmcgPSAodHlwZW9mIG9iai5zZWFyY2hfaW4gPT0gJ3N0cmluZycpID8gJyZzZWFyY2hfaW49JytvYmouc2VhcmNoX2luIDogJyc7XG4vLyAgIGNvbnN0IHNlYXJjaF90YWdzQXJnID0gKHR5cGVvZiBvYmouc2VhcmNoX3RhZ3MgPT0gJ3N0cmluZycpID8gJyZzZWFyY2hfdGFncz0nK29iai5zZWFyY2hfdGFncyA6ICcnO1xuLy8gICBjb25zdCBzZWFyY2hfZmlsdGVyc0FyZyA9IChvYmouc2VhcmNoX2ZpbHRlcnMgJiYgb2JqLnNlYXJjaF9maWx0ZXJzLmxlbmd0aCA+PSAxKSA/IGAmc2VhcmNoX2ZpbHRlcnM9JHtbLi4ub2JqLnNlYXJjaF9maWx0ZXJzXS5qb2luKCcmc2VhcmNoX2ZpbHRlcnM9Jyl9YCA6ICcnO1xuLy8gICBjb25zdCBzZWFyY2hfaW50QXJnID0gKHR5cGVvZiBvYmouc2VhcmNoX2ludCA9PSAnbnVtYmVyJykgPyAnJnNlYXJjaF9pbnQ9JytvYmouc2VhcmNoX2ludCA6ICcnO1xuLy8gICBjb25zdCBzZWFyY2hfZmxvYXRBcmcgPSAodHlwZW9mIG9iai5zZWFyY2hfZmxvYXQgPT0gJ251bWJlcicpID8gJyZzZWFyY2hfZmxvYXQ9JytvYmouc2VhcmNoX2Zsb2F0IDogJyc7XG4vLyAgIGNvbnN0IGl0ZW1faWRBcmcgPSAodHlwZW9mIG9iai5pdGVtX2lkID09ICdzdHJpbmcnKSA/ICcmaXRlbV9pZD0nK29iai5pdGVtX2lkIDogJyc7XG4vLyAgIGNvbnN0IHNvcnRfYnlBcmcgPSAodHlwZW9mIG9iai5zb3J0X2J5ID09ICdzdHJpbmcnKSA/ICcmc29ydF9ieT0nK29iai5zb3J0X2J5IDogJyc7XG4vLyAgIGNvbnN0IGRlc2NlbmRpbmdBcmcgPSAodHlwZW9mIG9iai5kZXNjZW5kaW5nID09ICdib29sZWFuJykgPyAnJmRlc2NlbmRpbmc9JytvYmouZGVzY2VuZGluZyA6ICcnO1xuXG5cbi8vICAgLy8gV0lUSE9VVCBTSFVGRkxFXG4vLyAgIC8vIHJldHVybiBvYmouYmFzZVVybCtgPyR7cGFnZUFyZ30ke3Blcl9wYWdlQXJnfSR7c2VhcmNoQXJnfSR7dGFnc0FyZ30ke3Rva2VuQXJnfSR7bWFwX2xpc3RBcmd9JHthc19sYXRsbmdBcmd9JHtvbmx5X2dlb2NvZGVkQXJnfSR7Z2VvX3ByZWNpc2lvbkFyZ30ke2dldF9maWx0ZXJzQXJnfSR7aXNfY29tcGxldGVBcmd9JHtvbmx5X3N0YXRzQXJnfSR7bm9ybWFsaXplQXJnfSR7c2VhcmNoX2ZvckFyZ30ke3NlYXJjaF9pbkFyZ30ke3NlYXJjaF90YWdzQXJnfSR7c2VhcmNoX2ludEFyZ30ke3NlYXJjaF9mbG9hdEFyZ30ke2l0ZW1faWRBcmd9JHtzb3J0X2J5QXJnfSR7ZGVzY2VuZGluZ0FyZ31gXG5cbi8vICAgLy8gV0lUSCBTSFVGRkxFXG4vLyAgIHJldHVybiBvYmouYmFzZVVybCtgPyR7cGFnZUFyZ30ke3Blcl9wYWdlQXJnfSR7c2h1ZmZsZV9zZWVkQXJnfSR7c2VhcmNoQXJnfSR7dGFnc0FyZ30ke3Rva2VuQXJnfSR7bWFwX2xpc3RBcmd9JHthc19sYXRsbmdBcmd9JHtvbmx5X2dlb2NvZGVkQXJnfSR7Z2VvX3ByZWNpc2lvbkFyZ30ke2dldF9maWx0ZXJzQXJnfSR7aXNfY29tcGxldGVBcmd9JHtvbmx5X3N0YXRzQXJnfSR7bm9ybWFsaXplQXJnfSR7c2VhcmNoX2ZvckFyZ30ke3NlYXJjaF9pbkFyZ30ke3NlYXJjaF90YWdzQXJnfSR7c2VhcmNoX2ZpbHRlcnNBcmd9JHtzZWFyY2hfaW50QXJnfSR7c2VhcmNoX2Zsb2F0QXJnfSR7aXRlbV9pZEFyZ30ke3NvcnRfYnlBcmd9JHtkZXNjZW5kaW5nQXJnfWBcbi8vIH1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRW1wdHlTZWxlY3RlZEZpbHRlcnMoZmlsdGVyRGVzY3JpcHRpb25zKXtcbiAgLy8gY29uc29sZS5sb2coXCI6OjogbWFrZUVtcHR5U2VsZWN0ZWRGaWx0ZXJzIC8gZmlsdGVyRGVzY3JpcHRpb25zIDogXCIsIGZpbHRlckRlc2NyaXB0aW9ucylcbiAgY29uc3Qgc2VsZWN0ZWRGaWx0ZXJzID0gbmV3IE1hcCgpXG4gIGZvcihjb25zdCBmIG9mIGZpbHRlckRlc2NyaXB0aW9ucyl7XG4gICAgc2VsZWN0ZWRGaWx0ZXJzLnNldChmLm5hbWUsIG5ldyBTZXQoKSlcbiAgfVxuICByZXR1cm4gc2VsZWN0ZWRGaWx0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGV4dEZyb21Mb2NhbGUodGV4dHNMaXN0LCBsb2NhbGUsIGZpZWxkKXtcbiAgLy8gY29uc29sZS5sb2coXCI6OjogdGV4dEZyb21Mb2NhbGUgLyB0ZXh0c0xpc3QgOiBcIiwgdGV4dHNMaXN0KVxuICAvLyBjb25zb2xlLmxvZyhcIjo6OiB0ZXh0RnJvbUxvY2FsZSAvIGxvY2FsZSA6IFwiLCBsb2NhbGUpXG4gIC8vIGNvbnNvbGUubG9nKFwiOjo6IHRleHRGcm9tTG9jYWxlIC8gZmllbGQgOiBcIiwgZmllbGQpXG4gIGxldCB0ZXh0T2JqZWN0ID0gdGV4dHNMaXN0LmZpbmQodCA9PiB0LmxvY2FsZSA9PSBsb2NhbGUgKVxuICBsZXQgdGV4dE91dCA9IHRleHRPYmplY3RbZmllbGRdXG4gIC8vIGNvbnNvbGUubG9nKFwiOjo6IHRleHRGcm9tTG9jYWxlIC8gdGV4dE91dCA6IFwiLCB0ZXh0T3V0KVxuICByZXR1cm4gdGV4dE91dFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0ZWRGaWx0ZXJzRm9yU2VhcmNoKHNlbGVjdGVkRmlsdGVyc01hcCl7XG4gIGxldCBmaWx0ZXJzVXJpID0gW11cbiAgc2VsZWN0ZWRGaWx0ZXJzTWFwLmZvckVhY2goICh2YWwsa2V5LG1hcCkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCd2YWwsa2V5LG1hcCcsdmFsLGtleSxtYXApO1xuICAgIHZhbC5mb3JFYWNoKCAodikgPT4ge1xuICAgICAgZmlsdGVyc1VyaS5wdXNoKGtleSArIHYpXG4gICAgfSlcbiAgfSlcbiAgLy8gY29uc29sZS5sb2coZmlsdGVyc1VyaSk7XG4gIHJldHVybiBmaWx0ZXJzVXJpXG59XG5cblxuLy8gVG8gbG9hZCBleHRlcm5hbCBsaWJyYWlyaWVzIGluIGNvbXBvbmVudHNcbmV4cG9ydCBmdW5jdGlvbiBsb2FkU2NyaXB0KHVybCwgY2FsbGJhY2spe1xuICBjb25zb2xlLmxvZyhcInRyeSB0byBsb2FkIHNjcmlwdDpcIiwgdXJsKTtcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gIHNjcmlwdC5zcmMgPSB1cmw7XG5cbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGNhbGxiYWNrO1xuICBzY3JpcHQub25sb2FkID0gY2FsbGJhY2s7XG5cbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xufVxuXG4vLyBUbyBhY3RpdmF0ZSBjYXJvdXNlbHMgZnJvbSBjb21wb25lbnRzXG5leHBvcnQgZnVuY3Rpb24gYWN0aXZhdGVDYXJvdXNlbChzbGlkZXNOdW1iZXI9MiwgaXNJbmZpbml0ZT10cnVlLCBoYXNQYWdpbmF0aW9uPWZhbHNlKXtcbiAgY29uc29sZS5sb2coXCJhY3RpdmF0ZSBjYXJvdXNlbCBmcm9tIHV0aWxzXCIpXG4gIHZhciBjYXJvdXNlbHMgPSBidWxtYUNhcm91c2VsLmF0dGFjaCgnLmNhcm91c2VsJywge1xuICAgIC8vIFRPRE86IGdpdmUgdGhlIHBhcmFtZXRlcnMgYXMgYXJncz9cbiAgICBzbGlkZXNUb1Nob3c6IDIsXG4gICAgaW5maW5pdGU6IHRydWUsXG4gICAgcGFnaW5hdGlvbjogZmFsc2VcblxuICAgIC8vIHNsaWRlc1RvU2hvdzogc2xpZGVzTnVtYmVyLFxuICAgIC8vIGluZmluaXRlOiBpc0luZmluaXRlLFxuICAgIC8vIHBhZ2luYXRpb246IGhhc1BhZ2luYXRpb25cbiAgfSk7XG5cbiAgICAvLyBcImhhY2t5XCIgd2F5IHRvIGdldCBjdXN0b20gaWNvbnNcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInNsaWRlci1uYXZpZ2F0aW9uLXByZXZpb3VzXCIpWzBdLmNoaWxkTm9kZXNbMF0ucmVtb3ZlKCk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJzbGlkZXItbmF2aWdhdGlvbi1uZXh0XCIpWzBdLmNoaWxkTm9kZXNbMF0ucmVtb3ZlKCk7XG59IiwiXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG59KSgpO1xudmFyIFBydW5lQ2x1c3RlcjtcbihmdW5jdGlvbiAoUHJ1bmVDbHVzdGVyXzEpIHtcbiAgdmFyIFBvaW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBvaW50KCkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIFBvaW50O1xuICB9KCkpO1xuICBQcnVuZUNsdXN0ZXJfMS5Qb2ludCA9IFBvaW50O1xuICB2YXIgQ2x1c3Rlck9iamVjdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDbHVzdGVyT2JqZWN0KCkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIENsdXN0ZXJPYmplY3Q7XG4gIH0oKSk7XG4gIFBydW5lQ2x1c3Rlcl8xLkNsdXN0ZXJPYmplY3QgPSBDbHVzdGVyT2JqZWN0O1xuICB2YXIgaGFzaENvZGVDb3VudGVyID0gMTtcbiAgdmFyIG1heEhhc2hDb2RlVmFsdWUgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgTWFya2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhNYXJrZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBNYXJrZXIobGF0LCBsbmcsIGRhdGEsIGNhdGVnb3J5LCB3ZWlnaHQsIGZpbHRlcmVkKSB7XG4gICAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkgeyBkYXRhID0ge307IH1cbiAgICAgICAgICBpZiAod2VpZ2h0ID09PSB2b2lkIDApIHsgd2VpZ2h0ID0gMTsgfVxuICAgICAgICAgIGlmIChmaWx0ZXJlZCA9PT0gdm9pZCAwKSB7IGZpbHRlcmVkID0gZmFsc2U7IH1cbiAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICAgIF90aGlzLnBvc2l0aW9uID0geyBsYXQ6ICtsYXQsIGxuZzogK2xuZyB9O1xuICAgICAgICAgIF90aGlzLndlaWdodCA9IHdlaWdodDtcbiAgICAgICAgICBfdGhpcy5jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICAgICAgICAgIF90aGlzLmZpbHRlcmVkID0gZmlsdGVyZWQ7XG4gICAgICAgICAgX3RoaXMuaGFzaENvZGUgPSBoYXNoQ29kZUNvdW50ZXIrKztcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG4gICAgICBNYXJrZXIucHJvdG90eXBlLk1vdmUgPSBmdW5jdGlvbiAobGF0LCBsbmcpIHtcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uLmxhdCA9ICtsYXQ7XG4gICAgICAgICAgdGhpcy5wb3NpdGlvbi5sbmcgPSArbG5nO1xuICAgICAgfTtcbiAgICAgIE1hcmtlci5wcm90b3R5cGUuU2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgdGhpcy5kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBNYXJrZXI7XG4gIH0oQ2x1c3Rlck9iamVjdCkpO1xuICBQcnVuZUNsdXN0ZXJfMS5NYXJrZXIgPSBNYXJrZXI7XG4gIHZhciBDbHVzdGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhDbHVzdGVyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2x1c3RlcihtYXJrZXIpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgIF90aGlzLnN0YXRzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICAgIF90aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgICBpZiAoIW1hcmtlcikge1xuICAgICAgICAgICAgICBfdGhpcy5oYXNoQ29kZSA9IDE7XG4gICAgICAgICAgICAgIGlmIChDbHVzdGVyLkVOQUJMRV9NQVJLRVJTX0xJU1QpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9jbHVzdGVyTWFya2VycyA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKENsdXN0ZXIuRU5BQkxFX01BUktFUlNfTElTVCkge1xuICAgICAgICAgICAgICBfdGhpcy5fY2x1c3Rlck1hcmtlcnMgPSBbbWFya2VyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMubGFzdE1hcmtlciA9IG1hcmtlcjtcbiAgICAgICAgICBfdGhpcy5oYXNoQ29kZSA9IDMxICsgbWFya2VyLmhhc2hDb2RlO1xuICAgICAgICAgIF90aGlzLnBvcHVsYXRpb24gPSAxO1xuICAgICAgICAgIGlmIChtYXJrZXIuY2F0ZWdvcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0c1ttYXJrZXIuY2F0ZWdvcnldID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMudG90YWxXZWlnaHQgPSBtYXJrZXIud2VpZ2h0O1xuICAgICAgICAgIF90aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICBsYXQ6IG1hcmtlci5wb3NpdGlvbi5sYXQsXG4gICAgICAgICAgICAgIGxuZzogbWFya2VyLnBvc2l0aW9uLmxuZ1xuICAgICAgICAgIH07XG4gICAgICAgICAgX3RoaXMuYXZlcmFnZVBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICBsYXQ6IG1hcmtlci5wb3NpdGlvbi5sYXQsXG4gICAgICAgICAgICAgIGxuZzogbWFya2VyLnBvc2l0aW9uLmxuZ1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuICAgICAgQ2x1c3Rlci5wcm90b3R5cGUuQWRkTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICAgIGlmIChDbHVzdGVyLkVOQUJMRV9NQVJLRVJTX0xJU1QpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY2x1c3Rlck1hcmtlcnMucHVzaChtYXJrZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaCA9IHRoaXMuaGFzaENvZGU7XG4gICAgICAgICAgaCA9ICgoaCA8PCA1KSAtIGgpICsgbWFya2VyLmhhc2hDb2RlO1xuICAgICAgICAgIGlmIChoID49IG1heEhhc2hDb2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5oYXNoQ29kZSA9IGggJSBtYXhIYXNoQ29kZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5oYXNoQ29kZSA9IGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubGFzdE1hcmtlciA9IG1hcmtlcjtcbiAgICAgICAgICB2YXIgd2VpZ2h0ID0gbWFya2VyLndlaWdodCwgY3VycmVudFRvdGFsV2VpZ2h0ID0gdGhpcy50b3RhbFdlaWdodCwgbmV3V2VpZ2h0ID0gd2VpZ2h0ICsgY3VycmVudFRvdGFsV2VpZ2h0O1xuICAgICAgICAgIHRoaXMuYXZlcmFnZVBvc2l0aW9uLmxhdCA9XG4gICAgICAgICAgICAgICh0aGlzLmF2ZXJhZ2VQb3NpdGlvbi5sYXQgKiBjdXJyZW50VG90YWxXZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgbWFya2VyLnBvc2l0aW9uLmxhdCAqIHdlaWdodCkgLyBuZXdXZWlnaHQ7XG4gICAgICAgICAgdGhpcy5hdmVyYWdlUG9zaXRpb24ubG5nID1cbiAgICAgICAgICAgICAgKHRoaXMuYXZlcmFnZVBvc2l0aW9uLmxuZyAqIGN1cnJlbnRUb3RhbFdlaWdodCArXG4gICAgICAgICAgICAgICAgICBtYXJrZXIucG9zaXRpb24ubG5nICogd2VpZ2h0KSAvIG5ld1dlaWdodDtcbiAgICAgICAgICArK3RoaXMucG9wdWxhdGlvbjtcbiAgICAgICAgICB0aGlzLnRvdGFsV2VpZ2h0ID0gbmV3V2VpZ2h0O1xuICAgICAgICAgIGlmIChtYXJrZXIuY2F0ZWdvcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRzW21hcmtlci5jYXRlZ29yeV0gPSAodGhpcy5zdGF0c1ttYXJrZXIuY2F0ZWdvcnldICsgMSkgfHwgMTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ2x1c3Rlci5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5oYXNoQ29kZSA9IDE7XG4gICAgICAgICAgdGhpcy5sYXN0TWFya2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMucG9wdWxhdGlvbiA9IDA7XG4gICAgICAgICAgdGhpcy50b3RhbFdlaWdodCA9IDA7XG4gICAgICAgICAgdGhpcy5zdGF0cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgICBpZiAoQ2x1c3Rlci5FTkFCTEVfTUFSS0VSU19MSVNUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NsdXN0ZXJNYXJrZXJzID0gW107XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIENsdXN0ZXIucHJvdG90eXBlLkNvbXB1dGVCb3VuZHMgPSBmdW5jdGlvbiAoY2x1c3Rlcikge1xuICAgICAgICAgIHZhciBwcm9qID0gY2x1c3Rlci5Qcm9qZWN0KHRoaXMucG9zaXRpb24ubGF0LCB0aGlzLnBvc2l0aW9uLmxuZyk7XG4gICAgICAgICAgdmFyIHNpemUgPSBjbHVzdGVyLlNpemU7XG4gICAgICAgICAgdmFyIG5iWCA9IE1hdGguZmxvb3IocHJvai54IC8gc2l6ZSksIG5iWSA9IE1hdGguZmxvb3IocHJvai55IC8gc2l6ZSksIHN0YXJ0WCA9IG5iWCAqIHNpemUsIHN0YXJ0WSA9IG5iWSAqIHNpemU7XG4gICAgICAgICAgdmFyIGEgPSBjbHVzdGVyLlVuUHJvamVjdChzdGFydFgsIHN0YXJ0WSksIGIgPSBjbHVzdGVyLlVuUHJvamVjdChzdGFydFggKyBzaXplLCBzdGFydFkgKyBzaXplKTtcbiAgICAgICAgICB0aGlzLmJvdW5kcyA9IHtcbiAgICAgICAgICAgICAgbWluTGF0OiBiLmxhdCxcbiAgICAgICAgICAgICAgbWF4TGF0OiBhLmxhdCxcbiAgICAgICAgICAgICAgbWluTG5nOiBhLmxuZyxcbiAgICAgICAgICAgICAgbWF4TG5nOiBiLmxuZ1xuICAgICAgICAgIH07XG4gICAgICB9O1xuICAgICAgQ2x1c3Rlci5wcm90b3R5cGUuR2V0Q2x1c3Rlck1hcmtlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NsdXN0ZXJNYXJrZXJzO1xuICAgICAgfTtcbiAgICAgIENsdXN0ZXIucHJvdG90eXBlLkFwcGx5Q2x1c3RlciA9IGZ1bmN0aW9uIChuZXdDbHVzdGVyKSB7XG4gICAgICAgICAgdGhpcy5oYXNoQ29kZSA9IHRoaXMuaGFzaENvZGUgKiA0MSArIG5ld0NsdXN0ZXIuaGFzaENvZGUgKiA0MztcbiAgICAgICAgICBpZiAodGhpcy5oYXNoQ29kZSA+IG1heEhhc2hDb2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5oYXNoQ29kZSA9IHRoaXMuaGFzaENvZGUgPSBtYXhIYXNoQ29kZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgd2VpZ2h0ID0gbmV3Q2x1c3Rlci50b3RhbFdlaWdodCwgY3VycmVudFRvdGFsV2VpZ2h0ID0gdGhpcy50b3RhbFdlaWdodCwgbmV3V2VpZ2h0ID0gd2VpZ2h0ICsgY3VycmVudFRvdGFsV2VpZ2h0O1xuICAgICAgICAgIHRoaXMuYXZlcmFnZVBvc2l0aW9uLmxhdCA9XG4gICAgICAgICAgICAgICh0aGlzLmF2ZXJhZ2VQb3NpdGlvbi5sYXQgKiBjdXJyZW50VG90YWxXZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgbmV3Q2x1c3Rlci5hdmVyYWdlUG9zaXRpb24ubGF0ICogd2VpZ2h0KSAvIG5ld1dlaWdodDtcbiAgICAgICAgICB0aGlzLmF2ZXJhZ2VQb3NpdGlvbi5sbmcgPVxuICAgICAgICAgICAgICAodGhpcy5hdmVyYWdlUG9zaXRpb24ubG5nICogY3VycmVudFRvdGFsV2VpZ2h0ICtcbiAgICAgICAgICAgICAgICAgIG5ld0NsdXN0ZXIuYXZlcmFnZVBvc2l0aW9uLmxuZyAqIHdlaWdodCkgLyBuZXdXZWlnaHQ7XG4gICAgICAgICAgdGhpcy5wb3B1bGF0aW9uICs9IG5ld0NsdXN0ZXIucG9wdWxhdGlvbjtcbiAgICAgICAgICB0aGlzLnRvdGFsV2VpZ2h0ID0gbmV3V2VpZ2h0O1xuICAgICAgICAgIHRoaXMuYm91bmRzLm1pbkxhdCA9IE1hdGgubWluKHRoaXMuYm91bmRzLm1pbkxhdCwgbmV3Q2x1c3Rlci5ib3VuZHMubWluTGF0KTtcbiAgICAgICAgICB0aGlzLmJvdW5kcy5taW5MbmcgPSBNYXRoLm1pbih0aGlzLmJvdW5kcy5taW5MbmcsIG5ld0NsdXN0ZXIuYm91bmRzLm1pbkxuZyk7XG4gICAgICAgICAgdGhpcy5ib3VuZHMubWF4TGF0ID0gTWF0aC5tYXgodGhpcy5ib3VuZHMubWF4TGF0LCBuZXdDbHVzdGVyLmJvdW5kcy5tYXhMYXQpO1xuICAgICAgICAgIHRoaXMuYm91bmRzLm1heExuZyA9IE1hdGgubWF4KHRoaXMuYm91bmRzLm1heExuZywgbmV3Q2x1c3Rlci5ib3VuZHMubWF4TG5nKTtcbiAgICAgICAgICBmb3IgKHZhciBjYXRlZ29yeSBpbiBuZXdDbHVzdGVyLnN0YXRzKSB7XG4gICAgICAgICAgICAgIGlmIChuZXdDbHVzdGVyLnN0YXRzLmhhc093blByb3BlcnR5KGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHMuaGFzT3duUHJvcGVydHkoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0c1tjYXRlZ29yeV0gKz0gbmV3Q2x1c3Rlci5zdGF0c1tjYXRlZ29yeV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRzW2NhdGVnb3J5XSA9IG5ld0NsdXN0ZXIuc3RhdHNbY2F0ZWdvcnldO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChDbHVzdGVyLkVOQUJMRV9NQVJLRVJTX0xJU1QpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY2x1c3Rlck1hcmtlcnMgPSB0aGlzLl9jbHVzdGVyTWFya2Vycy5jb25jYXQobmV3Q2x1c3Rlci5HZXRDbHVzdGVyTWFya2VycygpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ2x1c3Rlci5FTkFCTEVfTUFSS0VSU19MSVNUID0gZmFsc2U7XG4gICAgICByZXR1cm4gQ2x1c3RlcjtcbiAgfShDbHVzdGVyT2JqZWN0KSk7XG4gIFBydW5lQ2x1c3Rlcl8xLkNsdXN0ZXIgPSBDbHVzdGVyO1xuICBmdW5jdGlvbiBjaGVja1Bvc2l0aW9uSW5zaWRlQm91bmRzKGEsIGIpIHtcbiAgICAgIHJldHVybiAoYS5sYXQgPj0gYi5taW5MYXQgJiYgYS5sYXQgPD0gYi5tYXhMYXQpICYmXG4gICAgICAgICAgYS5sbmcgPj0gYi5taW5MbmcgJiYgYS5sbmcgPD0gYi5tYXhMbmc7XG4gIH1cbiAgZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChsaXN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMSwgaiwgdG1wLCB0bXBMbmcsIGxlbmd0aCA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0bXAgPSBsaXN0W2ldO1xuICAgICAgICAgIHRtcExuZyA9IHRtcC5wb3NpdGlvbi5sbmc7XG4gICAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMCAmJiBsaXN0W2pdLnBvc2l0aW9uLmxuZyA+IHRtcExuZzsgLS1qKSB7XG4gICAgICAgICAgICAgIGxpc3RbaiArIDFdID0gbGlzdFtqXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlzdFtqICsgMV0gPSB0bXA7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkVXNlSW5zZXJ0aW9uU29ydCh0b3RhbCwgbmJDaGFuZ2VzKSB7XG4gICAgICBpZiAobmJDaGFuZ2VzID4gMzAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChuYkNoYW5nZXMgLyB0b3RhbCkgPCAwLjI7XG4gICAgICB9XG4gIH1cbiAgdmFyIFBydW5lQ2x1c3RlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQcnVuZUNsdXN0ZXIoKSB7XG4gICAgICAgICAgdGhpcy5fbWFya2VycyA9IFtdO1xuICAgICAgICAgIHRoaXMuX25iQ2hhbmdlcyA9IDA7XG4gICAgICAgICAgdGhpcy5fY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLlNpemUgPSAxNjY7XG4gICAgICAgICAgdGhpcy5WaWV3UGFkZGluZyA9IDAuMjtcbiAgICAgIH1cbiAgICAgIFBydW5lQ2x1c3Rlci5wcm90b3R5cGUuUmVnaXN0ZXJNYXJrZXIgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgICAgaWYgKG1hcmtlci5fcmVtb3ZlRmxhZykge1xuICAgICAgICAgICAgICBkZWxldGUgbWFya2VyLl9yZW1vdmVGbGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9tYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICAgICAgICB0aGlzLl9uYkNoYW5nZXMgKz0gMTtcbiAgICAgIH07XG4gICAgICBQcnVuZUNsdXN0ZXIucHJvdG90eXBlLlJlZ2lzdGVyTWFya2VycyA9IGZ1bmN0aW9uIChtYXJrZXJzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBtYXJrZXJzLmZvckVhY2goZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICAgICAgICBfdGhpcy5SZWdpc3Rlck1hcmtlcihtYXJrZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFBydW5lQ2x1c3Rlci5wcm90b3R5cGUuX3NvcnRNYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBtYXJrZXJzID0gdGhpcy5fbWFya2VycywgbGVuZ3RoID0gbWFya2Vycy5sZW5ndGg7XG4gICAgICAgICAgaWYgKHRoaXMuX25iQ2hhbmdlcyAmJiAhc2hvdWxkVXNlSW5zZXJ0aW9uU29ydChsZW5ndGgsIHRoaXMuX25iQ2hhbmdlcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWFya2Vycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnBvc2l0aW9uLmxuZyAtIGIucG9zaXRpb24ubG5nOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGluc2VydGlvblNvcnQobWFya2Vycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX25iQ2hhbmdlcyA9IDA7XG4gICAgICB9O1xuICAgICAgUHJ1bmVDbHVzdGVyLnByb3RvdHlwZS5fc29ydENsdXN0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluc2VydGlvblNvcnQodGhpcy5fY2x1c3RlcnMpO1xuICAgICAgfTtcbiAgICAgIFBydW5lQ2x1c3Rlci5wcm90b3R5cGUuX2luZGV4TG93ZXJCb3VuZExuZyA9IGZ1bmN0aW9uIChsbmcpIHtcbiAgICAgICAgICB2YXIgbWFya2VycyA9IHRoaXMuX21hcmtlcnMsIGl0LCBzdGVwLCBmaXJzdCA9IDAsIGNvdW50ID0gbWFya2Vycy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICBzdGVwID0gTWF0aC5mbG9vcihjb3VudCAvIDIpO1xuICAgICAgICAgICAgICBpdCA9IGZpcnN0ICsgc3RlcDtcbiAgICAgICAgICAgICAgaWYgKG1hcmtlcnNbaXRdLnBvc2l0aW9uLmxuZyA8IGxuZykge1xuICAgICAgICAgICAgICAgICAgZmlyc3QgPSArK2l0O1xuICAgICAgICAgICAgICAgICAgY291bnQgLT0gc3RlcCArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb3VudCA9IHN0ZXA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgICAgfTtcbiAgICAgIFBydW5lQ2x1c3Rlci5wcm90b3R5cGUuX3Jlc2V0Q2x1c3RlclZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2x1c3RlcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBjbHVzdGVyID0gdGhpcy5fY2x1c3RlcnNbaV07XG4gICAgICAgICAgICAgIGNsdXN0ZXIuUmVzZXQoKTtcbiAgICAgICAgICAgICAgY2x1c3Rlci5Db21wdXRlQm91bmRzKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBQcnVuZUNsdXN0ZXIucHJvdG90eXBlLlByb2Nlc3NWaWV3ID0gZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICAgIHZhciBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhib3VuZHMubWF4TGF0IC0gYm91bmRzLm1pbkxhdCkgKiB0aGlzLlZpZXdQYWRkaW5nLCB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKGJvdW5kcy5tYXhMbmcgLSBib3VuZHMubWluTG5nKSAqIHRoaXMuVmlld1BhZGRpbmc7XG4gICAgICAgICAgdmFyIGV4dGVuZGVkQm91bmRzID0ge1xuICAgICAgICAgICAgICBtaW5MYXQ6IGJvdW5kcy5taW5MYXQgLSBoZWlnaHRCdWZmZXIgLSBoZWlnaHRCdWZmZXIsXG4gICAgICAgICAgICAgIG1heExhdDogYm91bmRzLm1heExhdCArIGhlaWdodEJ1ZmZlciArIGhlaWdodEJ1ZmZlcixcbiAgICAgICAgICAgICAgbWluTG5nOiBib3VuZHMubWluTG5nIC0gd2lkdGhCdWZmZXIgLSB3aWR0aEJ1ZmZlcixcbiAgICAgICAgICAgICAgbWF4TG5nOiBib3VuZHMubWF4TG5nICsgd2lkdGhCdWZmZXIgKyB3aWR0aEJ1ZmZlclxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fc29ydE1hcmtlcnMoKTtcbiAgICAgICAgICB0aGlzLl9yZXNldENsdXN0ZXJWaWV3cygpO1xuICAgICAgICAgIHZhciBmaXJzdEluZGV4ID0gdGhpcy5faW5kZXhMb3dlckJvdW5kTG5nKGV4dGVuZGVkQm91bmRzLm1pbkxuZyk7XG4gICAgICAgICAgdmFyIG1hcmtlcnMgPSB0aGlzLl9tYXJrZXJzLCBjbHVzdGVycyA9IHRoaXMuX2NsdXN0ZXJzO1xuICAgICAgICAgIHZhciB3b3JraW5nQ2x1c3Rlckxpc3QgPSBjbHVzdGVycy5zbGljZSgwKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RJbmRleCwgbCA9IG1hcmtlcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBtYXJrZXJQb3NpdGlvbiA9IG1hcmtlci5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgaWYgKG1hcmtlclBvc2l0aW9uLmxuZyA+IGV4dGVuZGVkQm91bmRzLm1heExuZykge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1hcmtlclBvc2l0aW9uLmxhdCA+IGV4dGVuZGVkQm91bmRzLm1pbkxhdCAmJlxuICAgICAgICAgICAgICAgICAgbWFya2VyUG9zaXRpb24ubGF0IDwgZXh0ZW5kZWRCb3VuZHMubWF4TGF0ICYmXG4gICAgICAgICAgICAgICAgICAhbWFya2VyLmZpbHRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2x1c3RlckZvdW5kID0gZmFsc2UsIGNsdXN0ZXI7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGwgPSB3b3JraW5nQ2x1c3Rlckxpc3QubGVuZ3RoOyBqIDwgbGw7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIgPSB3b3JraW5nQ2x1c3Rlckxpc3Rbal07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNsdXN0ZXIuYm91bmRzLm1heExuZyA8IG1hcmtlci5wb3NpdGlvbi5sbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ0NsdXN0ZXJMaXN0LnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAtLWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrUG9zaXRpb25JbnNpZGVCb3VuZHMobWFya2VyUG9zaXRpb24sIGNsdXN0ZXIuYm91bmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLkFkZE1hcmtlcihtYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIWNsdXN0ZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIgPSBuZXcgQ2x1c3RlcihtYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIuQ29tcHV0ZUJvdW5kcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVycy5wdXNoKGNsdXN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdDbHVzdGVyTGlzdC5wdXNoKGNsdXN0ZXIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZXdDbHVzdGVyc0xpc3QgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gY2x1c3RlcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXIgPSBjbHVzdGVyc1tpXTtcbiAgICAgICAgICAgICAgaWYgKGNsdXN0ZXIucG9wdWxhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG5ld0NsdXN0ZXJzTGlzdC5wdXNoKGNsdXN0ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NsdXN0ZXJzID0gbmV3Q2x1c3RlcnNMaXN0O1xuICAgICAgICAgIHRoaXMuX3NvcnRDbHVzdGVycygpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jbHVzdGVycztcbiAgICAgIH07XG4gICAgICBQcnVuZUNsdXN0ZXIucHJvdG90eXBlLlJlbW92ZU1hcmtlcnMgPSBmdW5jdGlvbiAobWFya2Vycykge1xuICAgICAgICAgIGlmICghbWFya2Vycykge1xuICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJzID0gW107XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBtYXJrZXJzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICBtYXJrZXJzW2ldLl9yZW1vdmVGbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld01hcmtlcnNMaXN0ID0gW107XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuX21hcmtlcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5fbWFya2Vyc1tpXS5fcmVtb3ZlRmxhZykge1xuICAgICAgICAgICAgICAgICAgbmV3TWFya2Vyc0xpc3QucHVzaCh0aGlzLl9tYXJrZXJzW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tYXJrZXJzW2ldLl9yZW1vdmVGbGFnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21hcmtlcnMgPSBuZXdNYXJrZXJzTGlzdDtcbiAgICAgIH07XG4gICAgICBQcnVuZUNsdXN0ZXIucHJvdG90eXBlLkZpbmRNYXJrZXJzSW5BcmVhID0gZnVuY3Rpb24gKGFyZWEpIHtcbiAgICAgICAgICB2YXIgYU1pbkxhdCA9IGFyZWEubWluTGF0LCBhTWF4TGF0ID0gYXJlYS5tYXhMYXQsIGFNaW5MbmcgPSBhcmVhLm1pbkxuZywgYU1heExuZyA9IGFyZWEubWF4TG5nLCBtYXJrZXJzID0gdGhpcy5fbWFya2VycywgcmVzdWx0ID0gW107XG4gICAgICAgICAgdmFyIGZpcnN0SW5kZXggPSB0aGlzLl9pbmRleExvd2VyQm91bmRMbmcoYU1pbkxuZyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0SW5kZXgsIGwgPSBtYXJrZXJzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgcG9zID0gbWFya2Vyc1tpXS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgaWYgKHBvcy5sbmcgPiBhTWF4TG5nKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocG9zLmxhdCA+PSBhTWluTGF0ICYmIHBvcy5sYXQgPD0gYU1heExhdCAmJlxuICAgICAgICAgICAgICAgICAgcG9zLmxuZyA+PSBhTWluTG5nKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXJrZXJzW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFBydW5lQ2x1c3Rlci5wcm90b3R5cGUuQ29tcHV0ZUJvdW5kcyA9IGZ1bmN0aW9uIChtYXJrZXJzLCB3aXRoRmlsdGVyZWQpIHtcbiAgICAgICAgICBpZiAod2l0aEZpbHRlcmVkID09PSB2b2lkIDApIHsgd2l0aEZpbHRlcmVkID0gdHJ1ZTsgfVxuICAgICAgICAgIGlmICghbWFya2VycyB8fCAhbWFya2Vycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByTWluTGF0ID0gTnVtYmVyLk1BWF9WQUxVRSwgck1heExhdCA9IC1OdW1iZXIuTUFYX1ZBTFVFLCByTWluTG5nID0gTnVtYmVyLk1BWF9WQUxVRSwgck1heExuZyA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbWFya2Vycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKCF3aXRoRmlsdGVyZWQgJiYgbWFya2Vyc1tpXS5maWx0ZXJlZCkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHBvcyA9IG1hcmtlcnNbaV0ucG9zaXRpb247XG4gICAgICAgICAgICAgIGlmIChwb3MubGF0IDwgck1pbkxhdClcbiAgICAgICAgICAgICAgICAgIHJNaW5MYXQgPSBwb3MubGF0O1xuICAgICAgICAgICAgICBpZiAocG9zLmxhdCA+IHJNYXhMYXQpXG4gICAgICAgICAgICAgICAgICByTWF4TGF0ID0gcG9zLmxhdDtcbiAgICAgICAgICAgICAgaWYgKHBvcy5sbmcgPCByTWluTG5nKVxuICAgICAgICAgICAgICAgICAgck1pbkxuZyA9IHBvcy5sbmc7XG4gICAgICAgICAgICAgIGlmIChwb3MubG5nID4gck1heExuZylcbiAgICAgICAgICAgICAgICAgIHJNYXhMbmcgPSBwb3MubG5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBtaW5MYXQ6IHJNaW5MYXQsXG4gICAgICAgICAgICAgIG1heExhdDogck1heExhdCxcbiAgICAgICAgICAgICAgbWluTG5nOiByTWluTG5nLFxuICAgICAgICAgICAgICBtYXhMbmc6IHJNYXhMbmdcbiAgICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIFBydW5lQ2x1c3Rlci5wcm90b3R5cGUuRmluZE1hcmtlcnNCb3VuZHNJbkFyZWEgPSBmdW5jdGlvbiAoYXJlYSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLkNvbXB1dGVCb3VuZHModGhpcy5GaW5kTWFya2Vyc0luQXJlYShhcmVhKSk7XG4gICAgICB9O1xuICAgICAgUHJ1bmVDbHVzdGVyLnByb3RvdHlwZS5Db21wdXRlR2xvYmFsQm91bmRzID0gZnVuY3Rpb24gKHdpdGhGaWx0ZXJlZCkge1xuICAgICAgICAgIGlmICh3aXRoRmlsdGVyZWQgPT09IHZvaWQgMCkgeyB3aXRoRmlsdGVyZWQgPSB0cnVlOyB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuQ29tcHV0ZUJvdW5kcyh0aGlzLl9tYXJrZXJzLCB3aXRoRmlsdGVyZWQpO1xuICAgICAgfTtcbiAgICAgIFBydW5lQ2x1c3Rlci5wcm90b3R5cGUuR2V0TWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWFya2VycztcbiAgICAgIH07XG4gICAgICBQcnVuZUNsdXN0ZXIucHJvdG90eXBlLkdldFBvcHVsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMubGVuZ3RoO1xuICAgICAgfTtcbiAgICAgIFBydW5lQ2x1c3Rlci5wcm90b3R5cGUuUmVzZXRDbHVzdGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9jbHVzdGVycyA9IFtdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQcnVuZUNsdXN0ZXI7XG4gIH0oKSk7XG4gIFBydW5lQ2x1c3Rlcl8xLlBydW5lQ2x1c3RlciA9IFBydW5lQ2x1c3Rlcjtcbn0pKFBydW5lQ2x1c3RlciB8fCAoUHJ1bmVDbHVzdGVyID0ge30pKTtcblxuLy8gdmFyIFBydW5lQ2x1c3Rlcjtcbi8vIChmdW5jdGlvbiAoUHJ1bmVDbHVzdGVyKSB7XG4vLyB9KShQcnVuZUNsdXN0ZXIgfHwgKFBydW5lQ2x1c3RlciA9IHt9KSk7XG5cbnZhciBQcnVuZUNsdXN0ZXJGb3JMZWFmbGV0ID0gKEwuTGF5ZXIgPyBMLkxheWVyIDogTC5DbGFzcykuZXh0ZW5kKHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHNpemUsIGNsdXN0ZXJNYXJnaW4pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7IHNpemUgPSAxMjA7IH1cbiAgICAgIGlmIChjbHVzdGVyTWFyZ2luID09PSB2b2lkIDApIHsgY2x1c3Rlck1hcmdpbiA9IDIwOyB9XG4gICAgICB0aGlzLkNsdXN0ZXIgPSBuZXcgUHJ1bmVDbHVzdGVyLlBydW5lQ2x1c3RlcigpO1xuICAgICAgdGhpcy5DbHVzdGVyLlNpemUgPSBzaXplO1xuICAgICAgdGhpcy5jbHVzdGVyTWFyZ2luID0gTWF0aC5taW4oY2x1c3Rlck1hcmdpbiwgc2l6ZSAvIDQpO1xuICAgICAgdGhpcy5DbHVzdGVyLlByb2plY3QgPSBmdW5jdGlvbiAobGF0LCBsbmcpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX21hcC5wcm9qZWN0KG5ldyBMLkxhdExuZyhsYXQsIGxuZyksIE1hdGguZmxvb3IoX3RoaXMuX21hcC5nZXRab29tKCkpKTtcbiAgICAgIH07XG4gICAgICB0aGlzLkNsdXN0ZXIuVW5Qcm9qZWN0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX21hcC51bnByb2plY3QobmV3IEwuUG9pbnQoeCwgeSksIE1hdGguZmxvb3IoX3RoaXMuX21hcC5nZXRab29tKCkpKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9vYmplY3RzT25NYXAgPSBbXTtcbiAgICAgIHRoaXMuc3BpZGVyZmllciA9IG5ldyBQcnVuZUNsdXN0ZXJMZWFmbGV0U3BpZGVyZmllcih0aGlzKTtcbiAgICAgIHRoaXMuX2hhcmRNb3ZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZXNldEljb25zID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZW1vdmVUaW1lb3V0SWQgPSAwO1xuICAgICAgdGhpcy5fbWFya2Vyc1JlbW92ZUxpc3RUaW1lb3V0ID0gW107XG4gIH0sXG4gIFJlZ2lzdGVyTWFya2VyOiBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICB0aGlzLkNsdXN0ZXIuUmVnaXN0ZXJNYXJrZXIobWFya2VyKTtcbiAgfSxcbiAgUmVnaXN0ZXJNYXJrZXJzOiBmdW5jdGlvbiAobWFya2Vycykge1xuICAgICAgdGhpcy5DbHVzdGVyLlJlZ2lzdGVyTWFya2VycyhtYXJrZXJzKTtcbiAgfSxcbiAgUmVtb3ZlTWFya2VyczogZnVuY3Rpb24gKG1hcmtlcnMpIHtcbiAgICAgIHRoaXMuQ2x1c3Rlci5SZW1vdmVNYXJrZXJzKG1hcmtlcnMpO1xuICB9LFxuICBCdWlsZExlYWZsZXRDbHVzdGVyOiBmdW5jdGlvbiAoY2x1c3RlciwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgbSA9IG5ldyBMLk1hcmtlcihwb3NpdGlvbiwge1xuICAgICAgICAgIGljb246IHRoaXMuQnVpbGRMZWFmbGV0Q2x1c3Rlckljb24oY2x1c3RlcilcbiAgICAgIH0pO1xuICAgICAgbS5fbGVhZmxldENsdXN0ZXJCb3VuZHMgPSBjbHVzdGVyLmJvdW5kcztcbiAgICAgIG0ub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBjYm91bmRzID0gbS5fbGVhZmxldENsdXN0ZXJCb3VuZHM7XG4gICAgICAgICAgdmFyIG1hcmtlcnNBcmVhID0gX3RoaXMuQ2x1c3Rlci5GaW5kTWFya2Vyc0luQXJlYShjYm91bmRzKTtcbiAgICAgICAgICB2YXIgYiA9IF90aGlzLkNsdXN0ZXIuQ29tcHV0ZUJvdW5kcyhtYXJrZXJzQXJlYSk7XG4gICAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcyhuZXcgTC5MYXRMbmcoYi5taW5MYXQsIGIubWF4TG5nKSwgbmV3IEwuTGF0TG5nKGIubWF4TGF0LCBiLm1pbkxuZykpO1xuICAgICAgICAgICAgICB2YXIgem9vbUxldmVsQmVmb3JlID0gX3RoaXMuX21hcC5nZXRab29tKCksIHpvb21MZXZlbEFmdGVyID0gX3RoaXMuX21hcC5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIG5ldyBMLlBvaW50KDIwLCAyMCkpO1xuICAgICAgICAgICAgICBpZiAoem9vbUxldmVsQWZ0ZXIgPT09IHpvb21MZXZlbEJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkQm91bmRzID0gW107XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF90aGlzLl9vYmplY3RzT25NYXAubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBfdGhpcy5fb2JqZWN0c09uTWFwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmRhdGEuX2xlYWZsZXRNYXJrZXIgIT09IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8uYm91bmRzLm1pbkxhdCA+PSBjYm91bmRzLm1pbkxhdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5ib3VuZHMubWF4TGF0IDw9IGNib3VuZHMubWF4TGF0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLmJvdW5kcy5taW5MbmcgPj0gY2JvdW5kcy5taW5MbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uYm91bmRzLm1heExuZyA8PSBjYm91bmRzLm1heExuZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRCb3VuZHMucHVzaChvLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRCb3VuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdNYXJrZXJzQXJlYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBsbCA9IGZpbHRlcmVkQm91bmRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gbWFya2Vyc0FyZWEubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJrZXJQb3MgPSBtYXJrZXJzQXJlYVtpXS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRmlsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsbDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEZpbHRlcmVkQm91bmRzID0gZmlsdGVyZWRCb3VuZHNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFya2VyUG9zLmxhdCA+PSBjdXJyZW50RmlsdGVyZWRCb3VuZHMubWluTGF0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyUG9zLmxhdCA8PSBjdXJyZW50RmlsdGVyZWRCb3VuZHMubWF4TGF0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyUG9zLmxuZyA+PSBjdXJyZW50RmlsdGVyZWRCb3VuZHMubWluTG5nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyUG9zLmxuZyA8PSBjdXJyZW50RmlsdGVyZWRCb3VuZHMubWF4TG5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGaWx0ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ZpbHRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdNYXJrZXJzQXJlYS5wdXNoKG1hcmtlcnNBcmVhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJzQXJlYSA9IG5ld01hcmtlcnNBcmVhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlcnNBcmVhLmxlbmd0aCA8IDIwMCB8fCB6b29tTGV2ZWxBZnRlciA+PSBfdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXAuZmlyZSgnb3ZlcmxhcHBpbmdtYXJrZXJzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyOiBfdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyczogbWFya2Vyc0FyZWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlcjogbS5nZXRMYXRMbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyOiBtXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB6b29tTGV2ZWxBZnRlcisrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX3RoaXMuX21hcC5zZXRWaWV3KG0uZ2V0TGF0TG5nKCksIHpvb21MZXZlbEFmdGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtO1xuICB9LFxuICBCdWlsZExlYWZsZXRDbHVzdGVySWNvbjogZnVuY3Rpb24gKGNsdXN0ZXIpIHtcbiAgICAgIHZhciBjID0gJ3BydW5lY2x1c3RlciBwcnVuZWNsdXN0ZXItJztcbiAgICAgIHZhciBpY29uU2l6ZSA9IDM4O1xuICAgICAgdmFyIG1heFBvcHVsYXRpb24gPSB0aGlzLkNsdXN0ZXIuR2V0UG9wdWxhdGlvbigpO1xuICAgICAgaWYgKGNsdXN0ZXIucG9wdWxhdGlvbiA8IE1hdGgubWF4KDEwLCBtYXhQb3B1bGF0aW9uICogMC4wMSkpIHtcbiAgICAgICAgICBjICs9ICdzbWFsbCc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjbHVzdGVyLnBvcHVsYXRpb24gPCBNYXRoLm1heCgxMDAsIG1heFBvcHVsYXRpb24gKiAwLjA1KSkge1xuICAgICAgICAgIGMgKz0gJ21lZGl1bSc7XG4gICAgICAgICAgaWNvblNpemUgPSA0MDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIGMgKz0gJ2xhcmdlJztcbiAgICAgICAgICBpY29uU2l6ZSA9IDQ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMLkRpdkljb24oe1xuICAgICAgICAgIGh0bWw6IFwiPGRpdj48c3Bhbj5cIiArIGNsdXN0ZXIucG9wdWxhdGlvbiArIFwiPC9zcGFuPjwvZGl2PlwiLFxuICAgICAgICAgIGNsYXNzTmFtZTogYyxcbiAgICAgICAgICBpY29uU2l6ZTogTC5wb2ludChpY29uU2l6ZSwgaWNvblNpemUpXG4gICAgICB9KTtcbiAgfSxcbiAgQnVpbGRMZWFmbGV0TWFya2VyOiBmdW5jdGlvbiAobWFya2VyLCBwb3NpdGlvbikge1xuICAgICAgdmFyIG0gPSBuZXcgTC5NYXJrZXIocG9zaXRpb24pO1xuICAgICAgdGhpcy5QcmVwYXJlTGVhZmxldE1hcmtlcihtLCBtYXJrZXIuZGF0YSwgbWFya2VyLmNhdGVnb3J5KTtcbiAgICAgIHJldHVybiBtO1xuICB9LFxuICBQcmVwYXJlTGVhZmxldE1hcmtlcjogZnVuY3Rpb24gKG1hcmtlciwgZGF0YSwgY2F0ZWdvcnkpIHtcbiAgICAgIGlmIChkYXRhLmljb24pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEuaWNvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBtYXJrZXIuc2V0SWNvbihkYXRhLmljb24oZGF0YSwgY2F0ZWdvcnkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG1hcmtlci5zZXRJY29uKGRhdGEuaWNvbik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRhdGEucG9wdXApIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IHR5cGVvZiBkYXRhLnBvcHVwID09PSAnZnVuY3Rpb24nID8gZGF0YS5wb3B1cChkYXRhLCBjYXRlZ29yeSkgOiBkYXRhLnBvcHVwO1xuICAgICAgICAgIGlmIChtYXJrZXIuZ2V0UG9wdXAoKSkge1xuICAgICAgICAgICAgICBtYXJrZXIuc2V0UG9wdXBDb250ZW50KGNvbnRlbnQsIGRhdGEucG9wdXBPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG1hcmtlci5iaW5kUG9wdXAoY29udGVudCwgZGF0YS5wb3B1cE9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfSxcbiAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgIG1hcC5vbignbW92ZXN0YXJ0JywgdGhpcy5fbW92ZVN0YXJ0LCB0aGlzKTtcbiAgICAgIG1hcC5vbignbW92ZWVuZCcsIHRoaXMuX21vdmVFbmQsIHRoaXMpO1xuICAgICAgbWFwLm9uKCd6b29tZW5kJywgdGhpcy5fem9vbVN0YXJ0LCB0aGlzKTtcbiAgICAgIG1hcC5vbignem9vbWVuZCcsIHRoaXMuX3pvb21FbmQsIHRoaXMpO1xuICAgICAgdGhpcy5Qcm9jZXNzVmlldygpO1xuICAgICAgbWFwLmFkZExheWVyKHRoaXMuc3BpZGVyZmllcik7XG4gIH0sXG4gIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICBtYXAub2ZmKCdtb3Zlc3RhcnQnLCB0aGlzLl9tb3ZlU3RhcnQsIHRoaXMpO1xuICAgICAgbWFwLm9mZignbW92ZWVuZCcsIHRoaXMuX21vdmVFbmQsIHRoaXMpO1xuICAgICAgbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX3pvb21TdGFydCwgdGhpcyk7XG4gICAgICBtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fem9vbUVuZCwgdGhpcyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX29iamVjdHNPbk1hcC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBtYXAucmVtb3ZlTGF5ZXIodGhpcy5fb2JqZWN0c09uTWFwW2ldLmRhdGEuX2xlYWZsZXRNYXJrZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fb2JqZWN0c09uTWFwID0gW107XG4gICAgICB0aGlzLkNsdXN0ZXIuUmVzZXRDbHVzdGVycygpO1xuICAgICAgbWFwLnJlbW92ZUxheWVyKHRoaXMuc3BpZGVyZmllcik7XG4gICAgICB0aGlzLl9tYXAgPSBudWxsO1xuICB9LFxuICBfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9tb3ZlSW5Qcm9ncmVzcyA9IHRydWU7XG4gIH0sXG4gIF9tb3ZlRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fbW92ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2hhcmRNb3ZlID0gZS5oYXJkO1xuICAgICAgdGhpcy5Qcm9jZXNzVmlldygpO1xuICB9LFxuICBfem9vbVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl96b29tSW5Qcm9ncmVzcyA9IHRydWU7XG4gIH0sXG4gIF96b29tRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl96b29tSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgdGhpcy5Qcm9jZXNzVmlldygpO1xuICB9LFxuICBQcm9jZXNzVmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX3pvb21JblByb2dyZXNzIHx8IHRoaXMuX21vdmVJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCwgYm91bmRzID0gbWFwLmdldEJvdW5kcygpLCB6b29tID0gTWF0aC5mbG9vcihtYXAuZ2V0Wm9vbSgpKSwgbWFyZ2luUmF0aW8gPSB0aGlzLmNsdXN0ZXJNYXJnaW4gLyB0aGlzLkNsdXN0ZXIuU2l6ZSwgcmVzZXRJY29ucyA9IHRoaXMuX3Jlc2V0SWNvbnM7XG4gICAgICB2YXIgc291dGhXZXN0ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLCBub3J0aEVhc3QgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCk7XG4gICAgICB2YXIgY2x1c3RlcnMgPSB0aGlzLkNsdXN0ZXIuUHJvY2Vzc1ZpZXcoe1xuICAgICAgICAgIG1pbkxhdDogc291dGhXZXN0LmxhdCxcbiAgICAgICAgICBtaW5Mbmc6IHNvdXRoV2VzdC5sbmcsXG4gICAgICAgICAgbWF4TGF0OiBub3J0aEVhc3QubGF0LFxuICAgICAgICAgIG1heExuZzogbm9ydGhFYXN0LmxuZ1xuICAgICAgfSk7XG4gICAgICB2YXIgb2JqZWN0c09uTWFwID0gdGhpcy5fb2JqZWN0c09uTWFwLCBuZXdPYmplY3RzT25NYXAgPSBbXSwgbWFya2Vyc09uTWFwID0gbmV3IEFycmF5KG9iamVjdHNPbk1hcC5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmplY3RzT25NYXAubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgdmFyIG1hcmtlciA9IG9iamVjdHNPbk1hcFtpXS5kYXRhLl9sZWFmbGV0TWFya2VyO1xuICAgICAgICAgIG1hcmtlcnNPbk1hcFtpXSA9IG1hcmtlcjtcbiAgICAgICAgICBtYXJrZXIuX3JlbW92ZUZyb21NYXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGNsdXN0ZXJDcmVhdGlvbkxpc3QgPSBbXTtcbiAgICAgIHZhciBjbHVzdGVyQ3JlYXRpb25MaXN0UG9wT25lID0gW107XG4gICAgICB2YXIgb3BhY2l0eVVwZGF0ZUxpc3QgPSBbXTtcbiAgICAgIHZhciB3b3JraW5nTGlzdCA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGNsdXN0ZXJzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgIHZhciBpY2x1c3RlciA9IGNsdXN0ZXJzW2ldLCBpY2x1c3RlckRhdGEgPSBpY2x1c3Rlci5kYXRhO1xuICAgICAgICAgIHZhciBsYXRNYXJnaW4gPSAoaWNsdXN0ZXIuYm91bmRzLm1heExhdCAtIGljbHVzdGVyLmJvdW5kcy5taW5MYXQpICogbWFyZ2luUmF0aW8sIGxuZ01hcmdpbiA9IChpY2x1c3Rlci5ib3VuZHMubWF4TG5nIC0gaWNsdXN0ZXIuYm91bmRzLm1pbkxuZykgKiBtYXJnaW5SYXRpbztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGwgPSB3b3JraW5nTGlzdC5sZW5ndGg7IGogPCBsbDsgKytqKSB7XG4gICAgICAgICAgICAgIHZhciBjID0gd29ya2luZ0xpc3Rbal07XG4gICAgICAgICAgICAgIGlmIChjLmJvdW5kcy5tYXhMbmcgPCBpY2x1c3Rlci5ib3VuZHMubWluTG5nKSB7XG4gICAgICAgICAgICAgICAgICB3b3JraW5nTGlzdC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICAgICAgICAtLWxsO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG9sZE1heExuZyA9IGMuYXZlcmFnZVBvc2l0aW9uLmxuZyArIGxuZ01hcmdpbiwgb2xkTWluTGF0ID0gYy5hdmVyYWdlUG9zaXRpb24ubGF0IC0gbGF0TWFyZ2luLCBvbGRNYXhMYXQgPSBjLmF2ZXJhZ2VQb3NpdGlvbi5sYXQgKyBsYXRNYXJnaW4sIG5ld01pbkxuZyA9IGljbHVzdGVyLmF2ZXJhZ2VQb3NpdGlvbi5sbmcgLSBsbmdNYXJnaW4sIG5ld01pbkxhdCA9IGljbHVzdGVyLmF2ZXJhZ2VQb3NpdGlvbi5sYXQgLSBsYXRNYXJnaW4sIG5ld01heExhdCA9IGljbHVzdGVyLmF2ZXJhZ2VQb3NpdGlvbi5sYXQgKyBsYXRNYXJnaW47XG4gICAgICAgICAgICAgIGlmIChvbGRNYXhMbmcgPiBuZXdNaW5MbmcgJiYgb2xkTWF4TGF0ID4gbmV3TWluTGF0ICYmIG9sZE1pbkxhdCA8IG5ld01heExhdCkge1xuICAgICAgICAgICAgICAgICAgaWNsdXN0ZXJEYXRhLl9sZWFmbGV0Q29sbGlzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGMuQXBwbHlDbHVzdGVyKGljbHVzdGVyKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaWNsdXN0ZXJEYXRhLl9sZWFmbGV0Q29sbGlzaW9uKSB7XG4gICAgICAgICAgICAgIHdvcmtpbmdMaXN0LnB1c2goaWNsdXN0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNsdXN0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGNsdXN0ZXIpIHtcbiAgICAgICAgICB2YXIgbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB2YXIgZGF0YSA9IGNsdXN0ZXIuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5fbGVhZmxldENvbGxpc2lvbikge1xuICAgICAgICAgICAgICBkYXRhLl9sZWFmbGV0Q29sbGlzaW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgIGRhdGEuX2xlYWZsZXRPbGRQb3B1bGF0aW9uID0gMDtcbiAgICAgICAgICAgICAgZGF0YS5fbGVhZmxldE9sZEhhc2hDb2RlID0gMDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSBuZXcgTC5MYXRMbmcoY2x1c3Rlci5hdmVyYWdlUG9zaXRpb24ubGF0LCBjbHVzdGVyLmF2ZXJhZ2VQb3NpdGlvbi5sbmcpO1xuICAgICAgICAgIHZhciBvbGRNYXJrZXIgPSBkYXRhLl9sZWFmbGV0TWFya2VyO1xuICAgICAgICAgIGlmIChvbGRNYXJrZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGNsdXN0ZXIucG9wdWxhdGlvbiA9PT0gMSAmJiBkYXRhLl9sZWFmbGV0T2xkUG9wdWxhdGlvbiA9PT0gMSAmJiBjbHVzdGVyLmhhc2hDb2RlID09PSBvbGRNYXJrZXIuX2hhc2hDb2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzZXRJY29ucyB8fCBvbGRNYXJrZXIuX3pvb21MZXZlbCAhPT0gem9vbSB8fCBjbHVzdGVyLmxhc3RNYXJrZXIuZGF0YS5mb3JjZUljb25SZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5QcmVwYXJlTGVhZmxldE1hcmtlcihvbGRNYXJrZXIsIGNsdXN0ZXIubGFzdE1hcmtlci5kYXRhLCBjbHVzdGVyLmxhc3RNYXJrZXIuY2F0ZWdvcnkpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjbHVzdGVyLmxhc3RNYXJrZXIuZGF0YS5mb3JjZUljb25SZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3Rlci5sYXN0TWFya2VyLmRhdGEuZm9yY2VJY29uUmVkcmF3ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb2xkTWFya2VyLnNldExhdExuZyhwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICBtID0gb2xkTWFya2VyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGNsdXN0ZXIucG9wdWxhdGlvbiA+IDEgJiYgZGF0YS5fbGVhZmxldE9sZFBvcHVsYXRpb24gPiAxICYmIChvbGRNYXJrZXIuX3pvb21MZXZlbCA9PT0gem9vbSB8fFxuICAgICAgICAgICAgICAgICAgZGF0YS5fbGVhZmxldFBvc2l0aW9uLmVxdWFscyhwb3NpdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgICBvbGRNYXJrZXIuc2V0TGF0TG5nKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXNldEljb25zIHx8IGNsdXN0ZXIucG9wdWxhdGlvbiAhPSBkYXRhLl9sZWFmbGV0T2xkUG9wdWxhdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIuaGFzaENvZGUgIT09IGRhdGEuX2xlYWZsZXRPbGRIYXNoQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBib3VuZHNDb3B5ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgTC5VdGlsLmV4dGVuZChib3VuZHNDb3B5LCBjbHVzdGVyLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgICAgb2xkTWFya2VyLl9sZWFmbGV0Q2x1c3RlckJvdW5kcyA9IGJvdW5kc0NvcHk7XG4gICAgICAgICAgICAgICAgICAgICAgb2xkTWFya2VyLnNldEljb24oX3RoaXMuQnVpbGRMZWFmbGV0Q2x1c3Rlckljb24oY2x1c3RlcikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGF0YS5fbGVhZmxldE9sZFBvcHVsYXRpb24gPSBjbHVzdGVyLnBvcHVsYXRpb247XG4gICAgICAgICAgICAgICAgICBkYXRhLl9sZWFmbGV0T2xkSGFzaENvZGUgPSBjbHVzdGVyLmhhc2hDb2RlO1xuICAgICAgICAgICAgICAgICAgbSA9IG9sZE1hcmtlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgaWYgKGNsdXN0ZXIucG9wdWxhdGlvbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgY2x1c3RlckNyZWF0aW9uTGlzdFBvcE9uZS5wdXNoKGNsdXN0ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY2x1c3RlckNyZWF0aW9uTGlzdC5wdXNoKGNsdXN0ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGEuX2xlYWZsZXRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICBkYXRhLl9sZWFmbGV0T2xkUG9wdWxhdGlvbiA9IGNsdXN0ZXIucG9wdWxhdGlvbjtcbiAgICAgICAgICAgICAgZGF0YS5fbGVhZmxldE9sZEhhc2hDb2RlID0gY2x1c3Rlci5oYXNoQ29kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG0uX3JlbW92ZUZyb21NYXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbmV3T2JqZWN0c09uTWFwLnB1c2goY2x1c3Rlcik7XG4gICAgICAgICAgICAgIG0uX3pvb21MZXZlbCA9IHpvb207XG4gICAgICAgICAgICAgIG0uX2hhc2hDb2RlID0gY2x1c3Rlci5oYXNoQ29kZTtcbiAgICAgICAgICAgICAgbS5fcG9wdWxhdGlvbiA9IGNsdXN0ZXIucG9wdWxhdGlvbjtcbiAgICAgICAgICAgICAgZGF0YS5fbGVhZmxldE1hcmtlciA9IG07XG4gICAgICAgICAgICAgIGRhdGEuX2xlYWZsZXRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2x1c3RlckNyZWF0aW9uTGlzdCA9IGNsdXN0ZXJDcmVhdGlvbkxpc3RQb3BPbmUuY29uY2F0KGNsdXN0ZXJDcmVhdGlvbkxpc3QpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG9iamVjdHNPbk1hcC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBpY2x1c3RlciA9IG9iamVjdHNPbk1hcFtpXTtcbiAgICAgICAgICB2YXIgaWRhdGEgPSBpY2x1c3Rlci5kYXRhO1xuICAgICAgICAgIG1hcmtlciA9IGlkYXRhLl9sZWFmbGV0TWFya2VyO1xuICAgICAgICAgIGlmIChpZGF0YS5fbGVhZmxldE1hcmtlci5fcmVtb3ZlRnJvbU1hcCkge1xuICAgICAgICAgICAgICB2YXIgcmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKG1hcmtlci5fem9vbUxldmVsID09PSB6b29tKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGEgPSBpY2x1c3Rlci5hdmVyYWdlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgICBsYXRNYXJnaW4gPSAoaWNsdXN0ZXIuYm91bmRzLm1heExhdCAtIGljbHVzdGVyLmJvdW5kcy5taW5MYXQpICogbWFyZ2luUmF0aW8sXG4gICAgICAgICAgICAgICAgICAgICAgbG5nTWFyZ2luID0gKGljbHVzdGVyLmJvdW5kcy5tYXhMbmcgLSBpY2x1c3Rlci5ib3VuZHMubWluTG5nKSAqIG1hcmdpblJhdGlvO1xuICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbGwgPSBjbHVzdGVyQ3JlYXRpb25MaXN0Lmxlbmd0aDsgaiA8IGxsOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgamNsdXN0ZXIgPSBjbHVzdGVyQ3JlYXRpb25MaXN0W2pdLCBqZGF0YSA9IGpjbHVzdGVyLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlci5fcG9wdWxhdGlvbiA9PT0gMSAmJiBqY2x1c3Rlci5wb3B1bGF0aW9uID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlci5faGFzaENvZGUgPT09IGpjbHVzdGVyLmhhc2hDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNldEljb25zIHx8IGpjbHVzdGVyLmxhc3RNYXJrZXIuZGF0YS5mb3JjZUljb25SZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuUHJlcGFyZUxlYWZsZXRNYXJrZXIobWFya2VyLCBqY2x1c3Rlci5sYXN0TWFya2VyLmRhdGEsIGpjbHVzdGVyLmxhc3RNYXJrZXIuY2F0ZWdvcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpjbHVzdGVyLmxhc3RNYXJrZXIuZGF0YS5mb3JjZUljb25SZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqY2x1c3Rlci5sYXN0TWFya2VyLmRhdGEuZm9yY2VJY29uUmVkcmF3ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLnNldExhdExuZyhqZGF0YS5fbGVhZmxldFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGIgPSBqY2x1c3Rlci5hdmVyYWdlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRNaW5MbmcgPSBwYS5sbmcgLSBsbmdNYXJnaW4sIG5ld01heExuZyA9IHBiLmxuZyArIGxuZ01hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkTWF4TG5nID0gcGEubG5nICsgbG5nTWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRNaW5MYXQgPSBwYS5sYXQgLSBsYXRNYXJnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9sZE1heExhdCA9IHBhLmxhdCArIGxhdE1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWluTG5nID0gcGIubG5nIC0gbG5nTWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdNaW5MYXQgPSBwYi5sYXQgLSBsYXRNYXJnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ld01heExhdCA9IHBiLmxhdCArIGxhdE1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYXJrZXIuX3BvcHVsYXRpb24gPiAxICYmIGpjbHVzdGVyLnBvcHVsYXRpb24gPiAxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9sZE1heExuZyA+IG5ld01pbkxuZyAmJiBvbGRNaW5MbmcgPCBuZXdNYXhMbmcgJiYgb2xkTWF4TGF0ID4gbmV3TWluTGF0ICYmIG9sZE1pbkxhdCA8IG5ld01heExhdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlci5zZXRMYXRMbmcoamRhdGEuX2xlYWZsZXRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIuc2V0SWNvbih0aGlzLkJ1aWxkTGVhZmxldENsdXN0ZXJJY29uKGpjbHVzdGVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pc3NvbiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTC5VdGlsLmV4dGVuZChwb2lzc29uLCBqY2x1c3Rlci5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLl9sZWFmbGV0Q2x1c3RlckJvdW5kcyA9IHBvaXNzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqZGF0YS5fbGVhZmxldE9sZFBvcHVsYXRpb24gPSBqY2x1c3Rlci5wb3B1bGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgamRhdGEuX2xlYWZsZXRPbGRIYXNoQ29kZSA9IGpjbHVzdGVyLmhhc2hDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLl9wb3B1bGF0aW9uID0gamNsdXN0ZXIucG9wdWxhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGpkYXRhLl9sZWFmbGV0TWFya2VyID0gbWFya2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIuX3JlbW92ZUZyb21NYXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0c09uTWFwLnB1c2goamNsdXN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyQ3JlYXRpb25MaXN0LnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAtLWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFtYXJrZXIuX3JlbW92ZUZyb21NYXApXG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInd0ZlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBjbHVzdGVyQ3JlYXRpb25MaXN0Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgIGljbHVzdGVyID0gY2x1c3RlckNyZWF0aW9uTGlzdFtpXSxcbiAgICAgICAgICAgICAgaWRhdGEgPSBpY2x1c3Rlci5kYXRhO1xuICAgICAgICAgIHZhciBpcG9zaXRpb24gPSBpZGF0YS5fbGVhZmxldFBvc2l0aW9uO1xuICAgICAgICAgIHZhciBjcmVhdGlvbk1hcmtlcjtcbiAgICAgICAgICBpZiAoaWNsdXN0ZXIucG9wdWxhdGlvbiA9PT0gMSkge1xuICAgICAgICAgICAgICBjcmVhdGlvbk1hcmtlciA9IHRoaXMuQnVpbGRMZWFmbGV0TWFya2VyKGljbHVzdGVyLmxhc3RNYXJrZXIsIGlwb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjcmVhdGlvbk1hcmtlciA9IHRoaXMuQnVpbGRMZWFmbGV0Q2x1c3RlcihpY2x1c3RlciwgaXBvc2l0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3JlYXRpb25NYXJrZXIuYWRkVG8obWFwKTtcbiAgICAgICAgICBjcmVhdGlvbk1hcmtlci5zZXRPcGFjaXR5KDApO1xuICAgICAgICAgIG9wYWNpdHlVcGRhdGVMaXN0LnB1c2goY3JlYXRpb25NYXJrZXIpO1xuICAgICAgICAgIGlkYXRhLl9sZWFmbGV0TWFya2VyID0gY3JlYXRpb25NYXJrZXI7XG4gICAgICAgICAgY3JlYXRpb25NYXJrZXIuX3pvb21MZXZlbCA9IHpvb207XG4gICAgICAgICAgY3JlYXRpb25NYXJrZXIuX2hhc2hDb2RlID0gaWNsdXN0ZXIuaGFzaENvZGU7XG4gICAgICAgICAgY3JlYXRpb25NYXJrZXIuX3BvcHVsYXRpb24gPSBpY2x1c3Rlci5wb3B1bGF0aW9uO1xuICAgICAgICAgIG5ld09iamVjdHNPbk1hcC5wdXNoKGljbHVzdGVyKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3BhY2l0eVVwZGF0ZUxpc3QubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gb3BhY2l0eVVwZGF0ZUxpc3RbaV07XG4gICAgICAgICAgICAgIGlmIChtLl9pY29uKVxuICAgICAgICAgICAgICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKG0uX2ljb24sIFwicHJ1bmVjbHVzdGVyLWFuaW1cIik7XG4gICAgICAgICAgICAgIGlmIChtLl9zaGFkb3cpXG4gICAgICAgICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3MobS5fc2hhZG93LCBcInBydW5lY2x1c3Rlci1hbmltXCIpO1xuICAgICAgICAgICAgICBtLnNldE9wYWNpdHkoMSk7XG4gICAgICAgICAgfVxuICAgICAgfSwgMSk7XG4gICAgICBpZiAodGhpcy5faGFyZE1vdmUpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gbWFya2Vyc09uTWFwLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICBtYXJrZXIgPSBtYXJrZXJzT25NYXBbaV07XG4gICAgICAgICAgICAgIGlmIChtYXJrZXIuX3JlbW92ZUZyb21NYXApIHtcbiAgICAgICAgICAgICAgICAgIG1hcC5yZW1vdmVMYXllcihtYXJrZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlbW92ZVRpbWVvdXRJZCAhPT0gMCkge1xuICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLl9tYXJrZXJzUmVtb3ZlTGlzdFRpbWVvdXQubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICBtYXAucmVtb3ZlTGF5ZXIodGhpcy5fbWFya2Vyc1JlbW92ZUxpc3RUaW1lb3V0W2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gbWFya2Vyc09uTWFwLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICBtYXJrZXIgPSBtYXJrZXJzT25NYXBbaV07XG4gICAgICAgICAgICAgIGlmIChtYXJrZXIuX3JlbW92ZUZyb21NYXApIHtcbiAgICAgICAgICAgICAgICAgIG1hcmtlci5zZXRPcGFjaXR5KDApO1xuICAgICAgICAgICAgICAgICAgdG9SZW1vdmUucHVzaChtYXJrZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0b1JlbW92ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXAucmVtb3ZlTGF5ZXIodG9SZW1vdmVbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZVRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21hcmtlcnNSZW1vdmVMaXN0VGltZW91dCA9IHRvUmVtb3ZlO1xuICAgICAgfVxuICAgICAgdGhpcy5fb2JqZWN0c09uTWFwID0gbmV3T2JqZWN0c09uTWFwO1xuICAgICAgdGhpcy5faGFyZE1vdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3Jlc2V0SWNvbnMgPSBmYWxzZTtcbiAgfSxcbiAgRml0Qm91bmRzOiBmdW5jdGlvbiAod2l0aEZpbHRlcmVkKSB7XG4gICAgICBpZiAod2l0aEZpbHRlcmVkID09PSB2b2lkIDApIHsgd2l0aEZpbHRlcmVkID0gdHJ1ZTsgfVxuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuQ2x1c3Rlci5Db21wdXRlR2xvYmFsQm91bmRzKHdpdGhGaWx0ZXJlZCk7XG4gICAgICBpZiAoYm91bmRzKSB7XG4gICAgICAgICAgdGhpcy5fbWFwLmZpdEJvdW5kcyhuZXcgTC5MYXRMbmdCb3VuZHMobmV3IEwuTGF0TG5nKGJvdW5kcy5taW5MYXQsIGJvdW5kcy5tYXhMbmcpLCBuZXcgTC5MYXRMbmcoYm91bmRzLm1heExhdCwgYm91bmRzLm1pbkxuZykpKTtcbiAgICAgIH1cbiAgfSxcbiAgR2V0TWFya2VyczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuQ2x1c3Rlci5HZXRNYXJrZXJzKCk7XG4gIH0sXG4gIFJlZHJhd0ljb25zOiBmdW5jdGlvbiAocHJvY2Vzc1ZpZXcpIHtcbiAgICAgIGlmIChwcm9jZXNzVmlldyA9PT0gdm9pZCAwKSB7IHByb2Nlc3NWaWV3ID0gdHJ1ZTsgfVxuICAgICAgdGhpcy5fcmVzZXRJY29ucyA9IHRydWU7XG4gICAgICBpZiAocHJvY2Vzc1ZpZXcpIHtcbiAgICAgICAgICB0aGlzLlByb2Nlc3NWaWV3KCk7XG4gICAgICB9XG4gIH1cbn0pO1xudmFyIFBydW5lQ2x1c3RlckxlYWZsZXRTcGlkZXJmaWVyID0gKEwuTGF5ZXIgPyBMLkxheWVyIDogTC5DbGFzcykuZXh0ZW5kKHtcbiAgXzJQSTogTWF0aC5QSSAqIDIsXG4gIF9jaXJjbGVGb290U2VwYXJhdGlvbjogMjUsXG4gIF9jaXJjbGVTdGFydEFuZ2xlOiBNYXRoLlBJIC8gNixcbiAgX3NwaXJhbEZvb3RTZXBhcmF0aW9uOiAyOCxcbiAgX3NwaXJhbExlbmd0aFN0YXJ0OiAxMSxcbiAgX3NwaXJhbExlbmd0aEZhY3RvcjogNSxcbiAgX3NwaXJhbENvdW50VHJpZ2dlcjogOCxcbiAgc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXI6IDEsXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChjbHVzdGVyKSB7XG4gICAgICB0aGlzLl9jbHVzdGVyID0gY2x1c3RlcjtcbiAgICAgIHRoaXMuX2N1cnJlbnRNYXJrZXJzID0gW107XG4gICAgICB0aGlzLl9tdWx0aUxpbmVzID0gISFMLm11bHRpUG9seWxpbmU7XG4gICAgICB0aGlzLl9saW5lcyA9IHRoaXMuX211bHRpTGluZXMgP1xuICAgICAgICAgIEwubXVsdGlQb2x5bGluZShbXSwgeyB3ZWlnaHQ6IDEuNSwgY29sb3I6ICcjMjIyJyB9KSA6XG4gICAgICAgICAgTC5wb2x5bGluZShbXSwgeyB3ZWlnaHQ6IDEuNSwgY29sb3I6ICcjMjIyJyB9KTtcbiAgfSxcbiAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgIHRoaXMuX21hcC5vbignb3ZlcmxhcHBpbmdtYXJrZXJzJywgdGhpcy5TcGlkZXJmeSwgdGhpcyk7XG4gICAgICB0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5VbnNwaWRlcmZ5LCB0aGlzKTtcbiAgICAgIHRoaXMuX21hcC5vbignem9vbWVuZCcsIHRoaXMuVW5zcGlkZXJmeSwgdGhpcyk7XG4gIH0sXG4gIFNwaWRlcmZ5OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChkYXRhLmNsdXN0ZXIgIT09IHRoaXMuX2NsdXN0ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLlVuc3BpZGVyZnkoKTtcbiAgICAgIHZhciBtYXJrZXJzID0gZGF0YS5tYXJrZXJzLmZpbHRlcihmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgICAgcmV0dXJuICFtYXJrZXIuZmlsdGVyZWQ7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDZW50ZXIgPSBkYXRhLmNlbnRlcjtcbiAgICAgIHZhciBjZW50ZXJQb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoZGF0YS5jZW50ZXIpO1xuICAgICAgdmFyIHBvaW50cztcbiAgICAgIGlmIChtYXJrZXJzLmxlbmd0aCA+PSB0aGlzLl9zcGlyYWxDb3VudFRyaWdnZXIpIHtcbiAgICAgICAgICBwb2ludHMgPSB0aGlzLl9nZW5lcmF0ZVBvaW50c1NwaXJhbChtYXJrZXJzLmxlbmd0aCwgY2VudGVyUG9pbnQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuX211bHRpTGluZXMpIHtcbiAgICAgICAgICAgICAgY2VudGVyUG9pbnQueSArPSAxMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnRzID0gdGhpcy5fZ2VuZXJhdGVQb2ludHNDaXJjbGUobWFya2Vycy5sZW5ndGgsIGNlbnRlclBvaW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2x5bGluZXMgPSBbXTtcbiAgICAgIHZhciBsZWFmbGV0TWFya2VycyA9IFtdO1xuICAgICAgdmFyIHByb2plY3RlZFBvaW50cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzW2ldKTtcbiAgICAgICAgICB2YXIgbSA9IHRoaXMuX2NsdXN0ZXIuQnVpbGRMZWFmbGV0TWFya2VyKG1hcmtlcnNbaV0sIGRhdGEuY2VudGVyKTtcbiAgICAgICAgICBtLnNldFpJbmRleE9mZnNldCg1MDAwKTtcbiAgICAgICAgICBtLnNldE9wYWNpdHkoMCk7XG4gICAgICAgICAgdGhpcy5fY3VycmVudE1hcmtlcnMucHVzaChtKTtcbiAgICAgICAgICB0aGlzLl9tYXAuYWRkTGF5ZXIobSk7XG4gICAgICAgICAgbGVhZmxldE1hcmtlcnMucHVzaChtKTtcbiAgICAgICAgICBwcm9qZWN0ZWRQb2ludHMucHVzaChwb3MpO1xuICAgICAgfVxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgIGxlYWZsZXRNYXJrZXJzW2ldLnNldExhdExuZyhwcm9qZWN0ZWRQb2ludHNbaV0pXG4gICAgICAgICAgICAgICAgICAuc2V0T3BhY2l0eSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgIHZhciBpbnRlcnZhbCA9IDQyLCBkdXJhdGlvbiA9IDI5MDtcbiAgICAgICAgICB2YXIgYW5pbSA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHBvbHlsaW5lcyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgbm93ID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICAgIHZhciBkID0gbm93IC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICBpZiAoZCA+PSBkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoYW5pbSk7XG4gICAgICAgICAgICAgICAgICBzdGVwUmF0aW8gPSAxLjA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RlcFJhdGlvID0gZCAvIGR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBkYXRhLmNlbnRlcjtcbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwID0gcHJvamVjdGVkUG9pbnRzW2ldLCBkaWZmTGF0ID0gcC5sYXQgLSBjZW50ZXIubGF0LCBkaWZmTG5nID0gcC5sbmcgLSBjZW50ZXIubG5nO1xuICAgICAgICAgICAgICAgICAgcG9seWxpbmVzLnB1c2goW2NlbnRlciwgbmV3IEwuTGF0TG5nKGNlbnRlci5sYXQgKyBkaWZmTGF0ICogc3RlcFJhdGlvLCBjZW50ZXIubG5nICsgZGlmZkxuZyAqIHN0ZXBSYXRpbyldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfdGhpcy5fbGluZXMuc2V0TGF0TG5ncyhwb2x5bGluZXMpO1xuICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgIH0sIDEpO1xuICAgICAgdGhpcy5fbGluZXMuc2V0TGF0TG5ncyhwb2x5bGluZXMpO1xuICAgICAgdGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX2xpbmVzKTtcbiAgICAgIGlmIChkYXRhLm1hcmtlcikge1xuICAgICAgICAgIHRoaXMuX2NsdXN0ZXJNYXJrZXIgPSBkYXRhLm1hcmtlci5zZXRPcGFjaXR5KDAuMyk7XG4gICAgICB9XG4gIH0sXG4gIF9nZW5lcmF0ZVBvaW50c0NpcmNsZTogZnVuY3Rpb24gKGNvdW50LCBjZW50ZXJQdCkge1xuICAgICAgdmFyIGNpcmN1bWZlcmVuY2UgPSB0aGlzLnNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyICogdGhpcy5fY2lyY2xlRm9vdFNlcGFyYXRpb24gKiAoMiArIGNvdW50KSwgbGVnTGVuZ3RoID0gY2lyY3VtZmVyZW5jZSAvIHRoaXMuXzJQSSwgYW5nbGVTdGVwID0gdGhpcy5fMlBJIC8gY291bnQsIHJlcyA9IFtdLCBpLCBhbmdsZTtcbiAgICAgIHJlcy5sZW5ndGggPSBjb3VudDtcbiAgICAgIGZvciAoaSA9IGNvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBhbmdsZSA9IHRoaXMuX2NpcmNsZVN0YXJ0QW5nbGUgKyBpICogYW5nbGVTdGVwO1xuICAgICAgICAgIHJlc1tpXSA9IG5ldyBMLlBvaW50KE1hdGgucm91bmQoY2VudGVyUHQueCArIGxlZ0xlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSksIE1hdGgucm91bmQoY2VudGVyUHQueSArIGxlZ0xlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgfSxcbiAgX2dlbmVyYXRlUG9pbnRzU3BpcmFsOiBmdW5jdGlvbiAoY291bnQsIGNlbnRlclB0KSB7XG4gICAgICB2YXIgbGVnTGVuZ3RoID0gdGhpcy5zcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbExlbmd0aFN0YXJ0LCBzZXBhcmF0aW9uID0gdGhpcy5zcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbEZvb3RTZXBhcmF0aW9uLCBsZW5ndGhGYWN0b3IgPSB0aGlzLnNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyICogdGhpcy5fc3BpcmFsTGVuZ3RoRmFjdG9yLCBhbmdsZSA9IDAsIHJlcyA9IFtdLCBpO1xuICAgICAgcmVzLmxlbmd0aCA9IGNvdW50O1xuICAgICAgZm9yIChpID0gY291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGFuZ2xlICs9IHNlcGFyYXRpb24gLyBsZWdMZW5ndGggKyBpICogMC4wMDA1O1xuICAgICAgICAgIHJlc1tpXSA9IG5ldyBMLlBvaW50KE1hdGgucm91bmQoY2VudGVyUHQueCArIGxlZ0xlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSksIE1hdGgucm91bmQoY2VudGVyUHQueSArIGxlZ0xlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSkpO1xuICAgICAgICAgIGxlZ0xlbmd0aCArPSB0aGlzLl8yUEkgKiBsZW5ndGhGYWN0b3IgLyBhbmdsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gIH0sXG4gIFVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2N1cnJlbnRNYXJrZXJzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRNYXJrZXJzW2ldLnNldExhdExuZyh0aGlzLl9jdXJyZW50Q2VudGVyKS5zZXRPcGFjaXR5KDApO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmtlcnMgPSB0aGlzLl9jdXJyZW50TWFya2VycztcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gbWFya2Vycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX21hcC5yZW1vdmVMYXllcihtYXJrZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuICAgICAgdGhpcy5fY3VycmVudE1hcmtlcnMgPSBbXTtcbiAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9saW5lcyk7XG4gICAgICBpZiAodGhpcy5fY2x1c3Rlck1hcmtlcikge1xuICAgICAgICAgIHRoaXMuX2NsdXN0ZXJNYXJrZXIuc2V0T3BhY2l0eSgxKTtcbiAgICAgIH1cbiAgfSxcbiAgb25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgIHRoaXMuVW5zcGlkZXJmeSgpO1xuICAgICAgbWFwLm9mZignb3ZlcmxhcHBpbmdtYXJrZXJzJywgdGhpcy5TcGlkZXJmeSwgdGhpcyk7XG4gICAgICBtYXAub2ZmKCdjbGljaycsIHRoaXMuVW5zcGlkZXJmeSwgdGhpcyk7XG4gICAgICBtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5VbnNwaWRlcmZ5LCB0aGlzKTtcbiAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7UHJ1bmVDbHVzdGVyLCBQcnVuZUNsdXN0ZXJGb3JMZWFmbGV0fVxuIl19
